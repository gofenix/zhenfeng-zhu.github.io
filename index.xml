<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Awesome Fenix</title><link>https://zhenfeng-zhu.github.io/</link><description>Recent content on Awesome Fenix</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Fenix</copyright><lastBuildDate>Sun, 30 Jan 2022 15:26:35 +0800</lastBuildDate><atom:link href="https://zhenfeng-zhu.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>打造文档</title><link>https://zhenfeng-zhu.github.io/post/%E6%89%93%E9%80%A0%E6%96%87%E6%A1%A3/</link><pubDate>Sun, 30 Jan 2022 15:26:35 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E6%89%93%E9%80%A0%E6%96%87%E6%A1%A3/</guid><description>两种文档视角：需求视角和供给视角 需求视角：想想你的受众是谁，了解他们的期望值 管理者 汇报上级 业务整体情况 战略重心和资源投入 面临问题和解决办法 协</description></item><item><title>书单</title><link>https://zhenfeng-zhu.github.io/post/%E4%B9%A6%E5%8D%95/</link><pubDate>Sun, 30 Jan 2022 15:18:30 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E4%B9%A6%E5%8D%95/</guid><description>一、理解自己之生理与心理健康 肥胖代码 正念的奇迹 冥想的原理与实践进阶 二、理解自己之巅峰时刻 跨越不可能 纳瓦尔宝典：财富和幸福指南 巨人的工具书 三、</description></item><item><title>学习上瘾</title><link>https://zhenfeng-zhu.github.io/post/%E5%AD%A6%E4%B9%A0%E4%B8%8A%E7%98%BE/</link><pubDate>Sun, 30 Jan 2022 15:10:35 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E5%AD%A6%E4%B9%A0%E4%B8%8A%E7%98%BE/</guid><description>最近两年，深感越来越多人患上了“毒鸡汤被迫害妄想症”，当别人抛出一个论点后，你下意识的将其归为“鸡汤”、“装逼”、“假正经”，虽然内心一时站</description></item><item><title>如何让自己不忙不卷还有成长</title><link>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B8%8D%E5%BF%99%E4%B8%8D%E5%8D%B7%E8%BF%98%E6%9C%89%E6%88%90%E9%95%BF/</link><pubDate>Sun, 30 Jan 2022 14:39:04 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B8%8D%E5%BF%99%E4%B8%8D%E5%8D%B7%E8%BF%98%E6%9C%89%E6%88%90%E9%95%BF/</guid><description>检查你是否落入了这些坏习惯 1、喜欢干事而不喜欢想事 （突然想起好像是王兴说的一句话，大多数人为了逃避真正的思考，愿意做任何事情。） 2、没搞清服</description></item><item><title>如何增强做事的动机</title><link>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E5%A2%9E%E5%BC%BA%E5%81%9A%E4%BA%8B%E7%9A%84%E5%8A%A8%E6%9C%BA/</link><pubDate>Sun, 30 Jan 2022 14:33:12 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E5%A2%9E%E5%BC%BA%E5%81%9A%E4%BA%8B%E7%9A%84%E5%8A%A8%E6%9C%BA/</guid><description>动机是一种强大的情感激励因素 动机=动力=自驱力=自我驱动力 动机=好奇心+激情+目标+自主性+掌控感。 自主的动机才是真动机 自主性是对追求你的激</description></item><item><title>如何增强掌控感</title><link>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E5%A2%9E%E5%BC%BA%E6%8E%8C%E6%8E%A7%E6%84%9F/</link><pubDate>Sun, 30 Jan 2022 11:56:28 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E5%A2%9E%E5%BC%BA%E6%8E%8C%E6%8E%A7%E6%84%9F/</guid><description>15%的自主时间 人类最喜欢的就是把小胜利叠加在小胜利之上，再叠加在小胜利之上。在神经化学上，这些胜利会产生多巴胺。 要想真正驾驭掌控力作为一种</description></item><item><title>抱怨</title><link>https://zhenfeng-zhu.github.io/post/%E6%8A%B1%E6%80%A8/</link><pubDate>Sun, 30 Jan 2022 11:32:47 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E6%8A%B1%E6%80%A8/</guid><description>对问题或困境的无能为力，对他人有所渴求和寄托，期望他人帮助解决问题。同时，渴望别人读懂自己，亲近自己。 抱怨，其实是“要抱抱”。抱怨还经常伴有</description></item><item><title>嫉妒</title><link>https://zhenfeng-zhu.github.io/post/%E5%AB%89%E5%A6%92/</link><pubDate>Sun, 30 Jan 2022 11:32:43 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E5%AB%89%E5%A6%92/</guid><description>嫉妒是，你有而我没有，让我觉得自己很没有价值。 自我价值感越完善，嫉妒出现的概率越低，也不倾向于通过和他人比较，来填补自己的价值感。如果倾向于</description></item><item><title>愤怒</title><link>https://zhenfeng-zhu.github.io/post/%E6%84%A4%E6%80%92/</link><pubDate>Sun, 30 Jan 2022 11:32:38 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E6%84%A4%E6%80%92/</guid><description>一种具有强烈刺激性的情绪，由刺激事件引发了心理上极度的挫折感，体现在价值感和安全感都丧失了，引发了强烈的不满，进而让人爆发出反抗他人的本能反</description></item><item><title>恐惧</title><link>https://zhenfeng-zhu.github.io/post/%E6%81%90%E6%83%A7/</link><pubDate>Sun, 30 Jan 2022 11:32:32 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E6%81%90%E6%83%A7/</guid><description>恐惧的本质是自我安全感受到了威胁，而理性脑无法解决这种威胁，于是代之以情绪的方法来应对。 恐惧的根源是人的失策或失能，人在面对一种状况时失去了</description></item><item><title>抑郁</title><link>https://zhenfeng-zhu.github.io/post/%E6%8A%91%E9%83%81/</link><pubDate>Sun, 30 Jan 2022 11:28:47 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E6%8A%91%E9%83%81/</guid><description>抑郁情绪是在对现实毫无对策的时候出现的，它在提醒我们当前解决问题的策略是无效的，我们需要寻找另外一种有效的应对策略。 抑郁产生的模式是，我们付</description></item><item><title>焦虑</title><link>https://zhenfeng-zhu.github.io/post/%E7%84%A6%E8%99%91/</link><pubDate>Sun, 30 Jan 2022 11:25:21 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E7%84%A6%E8%99%91/</guid><description>焦虑来自个体努力追求生存，以及维持和肯定自我存在、安全感和价值感的过程，焦虑感是人生中不可避免的问题。 焦虑是我们的大脑对抗潜在危机的积极行为</description></item><item><title>如何更好地理解我们的情绪</title><link>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E7%90%86%E8%A7%A3%E6%88%91%E4%BB%AC%E7%9A%84%E6%83%85%E7%BB%AA/</link><pubDate>Sun, 30 Jan 2022 11:14:39 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E7%90%86%E8%A7%A3%E6%88%91%E4%BB%AC%E7%9A%84%E6%83%85%E7%BB%AA/</guid><description>情绪是来帮我们的，是为我们送信号的内在小孩，如果我们看不见它、不搭理它、压抑它、甚至和它对着干，总有一天它会「吃掉我们」（被情绪反噬）。 情绪</description></item><item><title>感受自己的力量</title><link>https://zhenfeng-zhu.github.io/post/%E6%84%9F%E5%8F%97%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8A%9B%E9%87%8F/</link><pubDate>Sun, 30 Jan 2022 11:10:13 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E6%84%9F%E5%8F%97%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8A%9B%E9%87%8F/</guid><description>萨特说：憎恨的本质就是承认了他人的自由 这句话怎么理解？ 我们羡慕的人，他们自由度太高以至于有合理预期； 我们嫉妒的人，他们只是稍稍压我们一头； 而</description></item><item><title>如何通过“三叶草”模型抢救你的工作状态</title><link>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%B8%89%E5%8F%B6%E8%8D%89%E6%A8%A1%E5%9E%8B%E6%8A%A2%E6%95%91%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81/</link><pubDate>Sun, 30 Jan 2022 10:57:28 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%B8%89%E5%8F%B6%E8%8D%89%E6%A8%A1%E5%9E%8B%E6%8A%A2%E6%95%91%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81/</guid><description>什么是三叶草模型 工作的本质是，通过价值创造完成价值兑现。我们能够进行价值创造的前提是对所从事的工作内容有兴趣，兴趣加上持续的投入，让我们具备</description></item><item><title>成长的本质是潜力兑现的过程</title><link>https://zhenfeng-zhu.github.io/post/what_is_growth/</link><pubDate>Sat, 29 Jan 2022 15:38:05 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/what_is_growth/</guid><description>成长的本质是潜力兑现的过程 任何人都有潜力，潜力有高有低，有大有小。 潜力是很大，每个人都有很大的潜力，只是大部分人还没有达到自己潜力兑现的下限</description></item><item><title>Flutter 地理位置插件使用指南</title><link>https://zhenfeng-zhu.github.io/post/flutter_geolocation/</link><pubDate>Thu, 27 Jan 2022 10:09:20 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/flutter_geolocation/</guid><description>geolocator 是一个 flutter 的地理位置插件，同时支持 Android、iOS、web 和 macos。 安装 1 flutter pub add geolocator 使用方式 定义一个基础的骨架 1 2 3 4 5 6 7 8 9 10 11</description></item><item><title>Flutter WeChat Camera Picker 使用</title><link>https://zhenfeng-zhu.github.io/post/flutter_wechat_camera_picker/</link><pubDate>Tue, 25 Jan 2022 10:36:39 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/flutter_wechat_camera_picker/</guid><description>Flutter WeChat Camera Picker 仿微信资源选择器 的扩展。 基于 camera 实现相机相关功能，photo_manager 实现资源相关内容。 https://pub.flutter-io.cn/packages/wechat_camera_picker/example 引入包 在 pubspec.yaml 中引入依赖 1 wechat_camera_picker: any 代码 demo 1 2 3</description></item><item><title>Flutter 常用工具</title><link>https://zhenfeng-zhu.github.io/post/flutter_tools/</link><pubDate>Mon, 24 Jan 2022 20:31:03 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/flutter_tools/</guid><description>摄像： https://pub.flutter-io.cn/packages/wechat_camera_picker 录音： https://pub.flutter-io.cn/packages/flutter_sound_lite 定位： https://pub.flutter-io.cn/packages/geolocator 很多用起来比原生还简单方便很多，而且还不用写两份代码</description></item><item><title>Flutter 常见问题记录</title><link>https://zhenfeng-zhu.github.io/post/flutters/</link><pubDate>Mon, 24 Jan 2022 10:52:44 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/flutters/</guid><description>第一个问题 Cannot run with sound null safety because dependencies don&amp;rsquo;t support null safety First, you should read through the guide to understand unsound null safety. If you are sure that you want to run your application with unsound null safety, you can use the following command: flutter run &amp;ndash;no-sound-null-safety The &amp;ndash;no-sound-null-safety option is not documented in the article, however, I have not experienced any problems with</description></item><item><title>Farewell 永别了</title><link>https://zhenfeng-zhu.github.io/post/farewell/</link><pubDate>Sat, 15 Jan 2022 21:45:17 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/farewell/</guid><description>永别了 正如 Semisonic 在 90 年代的热门歌曲 &amp;ldquo;Closing Time &amp;ldquo;所告诉我们的那样，每一个新的开始都来自于其他一些开始的结束。恭喜你，高贵的读者，完成了这次 Clojure</description></item><item><title>AppendixB 花哨的 Boot</title><link>https://zhenfeng-zhu.github.io/post/appendixb/</link><pubDate>Sat, 15 Jan 2022 21:41:09 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/appendixb/</guid><description>Boot，花哨的 Clojure 构建框架 Boot 是 Leiningen 的替代品，提供同样的功能。Leiningen 更受欢迎（截至 2015 年夏天），但我个人喜欢用 Boot 工作，因为它更容易扩展</description></item><item><title>AppendixA 用 Leiningen 构建和开发</title><link>https://zhenfeng-zhu.github.io/post/appendixa/</link><pubDate>Sat, 15 Jan 2022 21:39:36 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/appendixa/</guid><description>用 Leiningen 构建和开发 用任何语言编写软件都需要生成工件，即可执行文件或库包，用于部署或共享。它还涉及到管理依赖工件，也称为依赖，以确保它们被加载到你</description></item><item><title>Chapter13 抽象</title><link>https://zhenfeng-zhu.github.io/post/chapter13/</link><pubDate>Sat, 15 Jan 2022 21:29:04 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/chapter13/</guid><description>用 Multimethods、协议和记录创建和扩展抽象概念 花一分钟思考一下，作为大自然的顶级产品之一：人类是多么伟大。作为一个人类，你可以在社</description></item><item><title>Chapter12 与 Java 的互操作</title><link>https://zhenfeng-zhu.github.io/post/chapter12/</link><pubDate>Sat, 15 Jan 2022 20:55:18 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/chapter12/</guid><description>与 JVM 一起工作 在每个 Clojurist 的生命中都会有这么一天，她必须从纯函数和不可变数据结构的庇护所冒险进入野蛮的 Java 大陆。这段艰难的旅程是必要的，因为 Clojure 是在 Java</description></item><item><title>Chapter11 core.async</title><link>https://zhenfeng-zhu.github.io/post/chapter11/</link><pubDate>Sat, 15 Jan 2022 12:56:01 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/chapter11/</guid><description>用 core.async 掌握并发进程 有一天，当你走在大街上时，你会惊讶、好奇，并有点厌恶地发现一台热狗自动贩卖机。你的头皮被有罪的好奇心刺痛，你会忍不住掏出三块</description></item><item><title>Chapter10 形而上学</title><link>https://zhenfeng-zhu.github.io/post/chapter10/</link><pubDate>Sat, 15 Jan 2022 12:42:26 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/chapter10/</guid><description>Clojure Metaphysics: 原子、Refs、Vars 和拥抱僵尸 三个并发性的小妖精都是从同一个邪恶的坑里生出来的：对可变状态的共享访问。你可以在第九章的引用单元讨论中</description></item><item><title>Chapter9 并发的艺术</title><link>https://zhenfeng-zhu.github.io/post/chapter9/</link><pubDate>Sat, 15 Jan 2022 12:30:14 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/chapter9/</guid><description>并发和并行编程的神圣艺术 如果我是一个庄园的主人，而你是我的继承人，我会在你的第 13 个命名日让你坐下来，告诉你：&amp;ldquo;计算的世界正在改变</description></item><item><title>Chapter8 宏</title><link>https://zhenfeng-zhu.github.io/post/chapter8/</link><pubDate>Sat, 15 Jan 2022 12:22:42 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/chapter8/</guid><description>编写宏 当我 18 岁时，我在新墨西哥州圣菲的一家酒店找到了一份夜班审计师的工作，每周工作四个晚上，从晚上 11 点到早上 7 点。经过几个月的这种不眠不休的</description></item><item><title>Chapter7 炼金术</title><link>https://zhenfeng-zhu.github.io/post/chapter7/</link><pubDate>Sat, 15 Jan 2022 12:14:36 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/chapter7/</guid><description>Clojure 炼金术：读取器、求值器和宏 哲学家之石，与生命之药和伟哥一样，是炼金术传说中最著名的标本之一，因其能将铅转化为金而受到追捧。然而，Cloju</description></item><item><title>Chapter6 组织你的项目</title><link>https://zhenfeng-zhu.github.io/post/chapter6/</link><pubDate>Fri, 14 Jan 2022 12:40:41 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/chapter6/</guid><description>组织你的项目：一个图书管理员的故事 在我们每个人心中都住着一个叫 Melvil 的图书管理员，一个以组织艺术为乐的奇异生物。日日夜夜，Melvil 都渴望为你</description></item><item><title>Chapter5 函数式编程</title><link>https://zhenfeng-zhu.github.io/post/chapter5/</link><pubDate>Fri, 14 Jan 2022 10:00:07 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/chapter5/</guid><description>函数式编程 到目前为止，你已经专注于熟悉 Clojure 提供的工具：不可变的数据结构、函数、抽象，等等。在这一章中，你将学习如何思考你的编程任务，以最好的方</description></item><item><title>Chapter4 深入研究核心函数</title><link>https://zhenfeng-zhu.github.io/post/chapter4/</link><pubDate>Thu, 13 Jan 2022 17:39:28 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/chapter4/</guid><description>核心函数的深入研究 如果你像我一样是焦虑的、以青少年为中心的准肥皂剧*《吸血鬼日记》*的超级粉丝，你一定记得主角埃琳娜开始质疑她苍白的、神秘的</description></item><item><title>Chapter3 速成班</title><link>https://zhenfeng-zhu.github.io/post/chapter3/</link><pubDate>Thu, 13 Jan 2022 11:12:19 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/chapter3/</guid><description>做事情：Clojure 速成班 是时候学习如何用 Clojure 真正地做事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的</description></item><item><title>Chapter2 如何使用 Emacs</title><link>https://zhenfeng-zhu.github.io/post/chapter2/</link><pubDate>Thu, 13 Jan 2022 10:43:56 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/chapter2/</guid><description>如何使用 Emacs，一个优秀的 Clojure 编辑器 在你掌握 Clojure 的过程中，你的编辑器将是你最亲密的盟友。我强烈建议使用 Emacs，但你当然也可以使用任何你想</description></item><item><title>Chapter1 构建、运行和 REPL</title><link>https://zhenfeng-zhu.github.io/post/chapter1/</link><pubDate>Thu, 13 Jan 2022 10:26:48 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/chapter1/</guid><description>构建、运行和 REPL 在本章中，你将预先投入少量时间来熟悉建立和运行 Clojure 程序的快速、傻瓜式方法。让一个真正的程序运行起来感觉很好。达到了这个里程碑，你</description></item><item><title>Introduction 简介</title><link>https://zhenfeng-zhu.github.io/post/introduction/</link><pubDate>Thu, 13 Jan 2022 10:11:25 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/introduction/</guid><description>简介 在你的内心深处，你一直都知道你注定要学习 Clojure。 每当你高举着键盘，为一个难以理解的类层次结构而痛苦地哭泣时；每当你晚上躺在床上，</description></item><item><title>Acknowledgments 致谢</title><link>https://zhenfeng-zhu.github.io/post/acknowledgments/</link><pubDate>Thu, 13 Jan 2022 10:06:10 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/acknowledgments/</guid><description>致谢 有很多人帮助我诞生了这个奇怪的婴儿，我对他们的支持感到感激。 首先，感谢我的妻子杰西，她为这本书绘制了插图，使它具有我所希望的视觉特性。也</description></item><item><title>Foreword 前言</title><link>https://zhenfeng-zhu.github.io/post/foreword/</link><pubDate>Thu, 13 Jan 2022 10:04:46 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/foreword/</guid><description>前言 当你阅读这本搞笑的书时，你会在某个时刻经历一个非常严肃的时刻。在了解了一些 Clojure 之后，编程变得更加有趣。这也是你在这本书上的投资，包括金钱和</description></item><item><title>Thrfit 入门</title><link>https://zhenfeng-zhu.github.io/post/thrfit-get-started/</link><pubDate>Thu, 06 Jan 2022 10:41:45 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/thrfit-get-started/</guid><description>本文主要介绍 Thrift 的 IDL 基本语法。 IDL Thrift 采用 IDL（Interface Definition Language）来定义通用的服务接口，然后通过 Thrift 提供的编译器，可以将服务接</description></item><item><title>修复 Vscode Git Cannot Use Api Proposal ScmValidation</title><link>https://zhenfeng-zhu.github.io/post/fix-vscode-git-cannot-use-api-proposal-scmvalidation/</link><pubDate>Thu, 06 Jan 2022 10:29:52 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/fix-vscode-git-cannot-use-api-proposal-scmvalidation/</guid><description>问题表现 某天，我的 vscode 的 git 管理出现了问题。 类似这个样子。 解决方式 1 @builtin @id:vscode.git 直接卸载了。 出现原因 应该是某个公司的插件给我自动装上导致的</description></item><item><title>Gavin Wood: Web3 去中心化技术是维护自由民主的唯一希望</title><link>https://zhenfeng-zhu.github.io/post/what-is-web3/</link><pubDate>Wed, 05 Jan 2022 10:20:39 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/what-is-web3/</guid><description>Gavin Wood 在 2014 年创造了 Web3（最初是 Web 3.0）这个词。当时，他刚开始帮助开发以太坊，这是一种在知名度和市场规模上仅次于比特币的加密货币。如今，他</description></item><item><title>Openfaas Workshop Lab11</title><link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab11/</link><pubDate>Tue, 04 Jan 2022 13:44:15 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab11/</guid><description>Lab 11 - 高级函数 - 使用 HMAC 的信任 前言 用于微服务的传统认证策略与函数的工作原理完全相同。在这个实验室中，我们将讨论使用共享秘密和基于哈希的消息验证</description></item><item><title>Openfaas Workshop Lab10</title><link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab10/</link><pubDate>Tue, 04 Jan 2022 13:44:12 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab10/</guid><description>Lab 10 - 高级函数 - 秘密 在开始本实验室之前，为你的文件创建一个新的文件夹。由于本实验室是建立在先前的实验室基础上的，因此请复制 lab5。 1 2 $ cp</description></item><item><title>Openfaas Workshop Lab9</title><link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab9/</link><pubDate>Tue, 04 Jan 2022 13:44:09 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab9/</guid><description>Lab 9 - 高级函数 - 自动缩放 自动缩放函数的应用 正如文档中描述的那样，OpenFaaS 带有自动扩展函数。在这个实验室中，我们将看看自动扩展是如何运</description></item><item><title>Openfaas Workshop Lab8</title><link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab8/</link><pubDate>Tue, 04 Jan 2022 13:44:05 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab8/</guid><description>Lab 8 - 高级函数 - 超时 在开始这个实验之前，为你的文件创建一个新的文件夹。 1 2 $ mkdir -p lab8 \ &amp;amp;&amp;amp; cd lab8 用read_timeout扩展超时时间 timeou</description></item><item><title>Openfaas Workshop Lab7</title><link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab7/</link><pubDate>Tue, 04 Jan 2022 13:44:02 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab7/</guid><description>实验 7&amp;ndash;异步函数 在开始这个实验之前，为你的文件创建一个新的文件夹。 1 2 $ mkdir -p lab7 \ &amp;amp;&amp;amp; cd lab7 同步与异步地调用一个函数 当你同步调用一个函</description></item><item><title>Openfaas Workshop Lab6</title><link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab6/</link><pubDate>Tue, 04 Jan 2022 13:43:59 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab6/</guid><description>实验 6&amp;ndash;你的函数的 HTML 在开始这个实验之前，为你的文件创建一个新的文件夹。 1 2 $ mkdir -p lab6\ &amp;amp;&amp;amp; cd lab6 从一个函数中生成并返回基本的 HTML 函数可以返</description></item><item><title>Openfaas Workshop Lab5</title><link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab5/</link><pubDate>Tue, 04 Jan 2022 13:43:56 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab5/</guid><description>Lab 5 - 创建一个 GitHub 机器人 在开始这个实验之前，为你的文件创建一个新的文件夹。 1 2 $ mkdir -p lab5\ &amp;amp;&amp;amp; cd lab5 我们将使用 OpenFaaS 的函数来创建一个名为 issue-bot</description></item><item><title>Blockchain 数据结构分析</title><link>https://zhenfeng-zhu.github.io/post/blockchain-schema/</link><pubDate>Tue, 04 Jan 2022 10:04:05 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/blockchain-schema/</guid><description>区块 想要了解区块到底是什么，最简单快捷的方法就是分析它的数据结构，以 bitcoin 种的区块为例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { &amp;#34;hash&amp;#34;:&amp;#34;00000000000000000018b0a6ae560fa33c469b6528bc9e0fb0c669319a186c33&amp;#34;, &amp;#34;confirmations&amp;#34;:1009, &amp;#34;strippedsize&amp;#34;:956228, &amp;#34;size&amp;#34;:1112639, &amp;#34;weight&amp;#34;:3981323,</description></item><item><title>轻服务 nodejs 助力爬虫 web3</title><link>https://zhenfeng-zhu.github.io/post/how-to-crawl-a-web-in-nodejs/</link><pubDate>Mon, 20 Dec 2021 09:58:58 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/how-to-crawl-a-web-in-nodejs/</guid><description>周末的时候，写了一个简单的小项目，用来抓取 web3 的文章，然后存到本地。最后选取了公司对外的轻服务：https://qingfuwu.cn/doc</description></item><item><title>Crystal Roadmap</title><link>https://zhenfeng-zhu.github.io/post/crystal_roadmap/</link><pubDate>Thu, 28 Oct 2021 10:11:41 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/crystal_roadmap/</guid><description>This roadmap defines the things that we want to have in the language and plan to do.
Language Stuff that has to do with the language syntax, semantic and runtime.
Concurrency Finalize multithreading support, so fibers can run on multiple threads.
Windows support Finalize support for Windows platform. The compiler already works, but some stdlib features like concurrency support are still missing. Ongoing efforts on #5430.
Type system review Make a review and possible formalisation of Crystal&amp;rsquo;s type system, with a strong emphasis on generics, type restrictions and the meta-model in general.</description></item><item><title>Crystal 1.2 版本更新说明</title><link>https://zhenfeng-zhu.github.io/post/crystal1.2/</link><pubDate>Sun, 17 Oct 2021 23:08:51 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/crystal1.2/</guid><description>Crystal 1.2.0 发布 我们正在发布一个包含多个错误修复和改进的新版本。下面我们列出了最重要或最有趣的变化，但没有提到几个错误修正。有关详细信息，请访问发行</description></item><item><title>如何理解可观测性</title><link>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/</link><pubDate>Fri, 15 Oct 2021 09:45:38 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/</guid><description>可观测性 可观测性 ≠ 监控 核心不同 监控以运维为核心，通过各项指标来定义整体的运行状态、失败情况。 观测则以开发为核心，除了监控，它还会对系统进行分</description></item><item><title>如何从零开始写一个静态网站生成器</title><link>https://zhenfeng-zhu.github.io/post/how-to-write-a-static-site-generator/</link><pubDate>Fri, 23 Jul 2021 09:33:18 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/how-to-write-a-static-site-generator/</guid><description>我们常见的静态网站生成器有 Hugo、Hexo 等，程序员们经常会使用类似的工具去将自己的播客托管到 github pages。前段时间研究了一下实现的方式，</description></item><item><title>Openfaas Workshop Lab2</title><link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab2/</link><pubDate>Tue, 30 Mar 2021 09:57:01 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab2/</guid><description>实验室 2&amp;ndash;测试东西 在开始这个实验之前，创建一个新的文件夹。 1 2 $ mkdir -p lab2 \ &amp;amp;&amp;amp; cd lab2 使用 UI 门户 现在你可以测试一下 OpenFaaS 的用户界面了。 如果你</description></item><item><title>Openfaas Workshop Lab1b</title><link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab1b/</link><pubDate>Tue, 30 Mar 2021 09:55:20 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab1b/</guid><description>Lab 1 - 用 Kubernetes 设置 OpenFaaS 安装最新的 kubectl 使用下面的说明或官方文档为你的操作系统安装kubectl。 Linux 1 2 3 4 export VER=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt) curl -LO https://storage.googleapis.com/kubernetes-release/release/$VER/bin/linux/amd64/kubectl chmod +x kubectl mv kubectl /usr/local/bin/ MacOS 1 2 3 4 export VER=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)</description></item><item><title>Openfaas Workshop Lab1</title><link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab1/</link><pubDate>Tue, 30 Mar 2021 09:54:25 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab1/</guid><description>Lab 1 - 为 OpenFaaS 做准备 OpenFaaS 需要一个Kubernetes集群来运行。你可以使用一个单节点集群或多节点集群，不管是在你的笔记本电脑上还是在云端。 任何 OpenFaaS 函</description></item><item><title>Openfaas Workshop</title><link>https://zhenfeng-zhu.github.io/post/openfaas-workshop/</link><pubDate>Tue, 30 Mar 2021 09:53:12 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop/</guid><description>openfaas-workshop 这是一个自定进度的研讨会，学习如何使用 OpenFaaS 构建、部署和运行无服务器函数。 在这个工作坊中，你将首先把 OpenFaaS 部署到你的笔记本电脑或使用 Docker for Mac 或 Windows 的远</description></item><item><title>Streaming 101</title><link>https://zhenfeng-zhu.github.io/post/streaming-101/</link><pubDate>Fri, 26 Mar 2021 14:11:29 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/streaming-101/</guid><description>有效的复杂系统总是从简单</description></item><item><title>K3d With Openfaas</title><link>https://zhenfeng-zhu.github.io/post/k3d-with-openfaas/</link><pubDate>Wed, 10 Mar 2021 20:09:11 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/k3d-with-openfaas/</guid><description>openfaas https://github.com/openfaas/workshop/blob/master/lab1b.md 安装 docker 1 brew install homebrew/cask/docker 安装单节点 K8S 1 brew install k3d 配置单节点 K8S 集群 1 2 3 4 5 6 k3d cluster create CLUSTER_NAME k3d kubeconfig merge CLUSTER_NAME --kubeconfig-switch-context kubectl get pods --all-namespaces 安装 arkade 1 curl -SLsf https://dl.get-arkade.dev/ | sudo sh 安装 openfaas 客户端 faas-cli 1 brew install faas-cli 安装 openfaas</description></item><item><title>换一种方式思考</title><link>https://zhenfeng-zhu.github.io/post/%E6%8D%A2%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%80%9D%E8%80%83/</link><pubDate>Sat, 27 Feb 2021 12:16:48 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E6%8D%A2%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%80%9D%E8%80%83/</guid><description>面向对象不是设计代码的唯一方法 函数式编程不一定是复杂和纯数学的 编程的基础不是赋值、if 语句和循环 并发不一定需要锁、信号量、监视器等类似的东西</description></item><item><title>小白都能快速上手的 Vim 配置</title><link>https://zhenfeng-zhu.github.io/post/vim/</link><pubDate>Sat, 20 Feb 2021 09:56:31 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/vim/</guid><description>首先把所有的 vim 相关的都删除 1 2 3 cd rm -rf .vim* 创建自己的.vimrc 1 vim .vimrc 一些基本的设置 在.vimrc 中添加下面的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14</description></item><item><title>Github Action 自动部署 blog</title><link>https://zhenfeng-zhu.github.io/post/hugo-github-action/</link><pubDate>Thu, 18 Feb 2021 13:20:11 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/hugo-github-action/</guid><description>之前我采用的方式是两个 github repo 的方式： 一个叫 hugo-blog，用于存放 blog 的源文件 一个叫 zhenfeng-zhu.github.io，用于存放生</description></item><item><title>编程语言的世界观</title><link>https://zhenfeng-zhu.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%96%E7%95%8C%E8%A7%82/</link><pubDate>Thu, 18 Feb 2021 13:05:31 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%96%E7%95%8C%E8%A7%82/</guid><description>Elixir everything is a process. process are strongly isolated. process creation and destruction is a lightweight operation. message passing is the only way for processes to interact. processes have unique names. if you know the name of a process you can send it a message. processes share no resources. error handling is non-local. processes do what they are supposed to do or fail. Go simple, poetic, pithy don&amp;rsquo;t communicate by</description></item><item><title>如何建立指标体系</title><link>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E6%8C%87%E6%A0%87%E4%BD%93%E7%B3%BB/</link><pubDate>Thu, 18 Feb 2021 12:48:34 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E6%8C%87%E6%A0%87%E4%BD%93%E7%B3%BB/</guid><description>什么是指标体系 指标体系是在业务的不同阶段，分析师牵头与业务方协助，制定一套能从各个维度反映业务状况的待实施框架。 关键点 在业务的前期、中期和后</description></item><item><title>业务代码的成长机会</title><link>https://zhenfeng-zhu.github.io/post/%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E7%9A%84%E6%88%90%E9%95%BF%E6%9C%BA%E4%BC%9A/</link><pubDate>Wed, 17 Feb 2021 17:45:40 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E7%9A%84%E6%88%90%E9%95%BF%E6%9C%BA%E4%BC%9A/</guid><description>对于大部分公司而言，能够写底层代码或者中间件代码的人总是有限的，写业务代码会面临更高的复杂度。这里分三个层次来看其中的机会： 第一个层次，让代</description></item><item><title>unix 哲学</title><link>https://zhenfeng-zhu.github.io/post/unix-philosophy/</link><pubDate>Wed, 17 Feb 2021 16:46:52 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/unix-philosophy/</guid><description>让每个程序都做好一件事。要做一件新的工作，写一个新程序，而不是通过添加“功能”让老程序复杂化。 期待每个程序的输出成为另一个程序的输入。不要将</description></item><item><title>Web 前端性能优化</title><link>https://zhenfeng-zhu.github.io/post/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link><pubDate>Fri, 20 Nov 2020 16:01:49 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid><description>一般来说 web 前端是指网站业务逻辑之前的部分，比如：浏览器加载、网站视图模型、图片服务、CDN 服务等等。web 前端优化主要从如下三个方面入手： 浏</description></item><item><title>大型网站发展历程</title><link>https://zhenfeng-zhu.github.io/post/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/</link><pubDate>Fri, 20 Nov 2020 16:00:59 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/</guid><description>前几天跟一个朋友聊了一些关于网站缓存分布式的一些东西，发现自己的知识还是太过贫瘠。理论+协议，这是现在我亟待加强的。这个周末买了两本关于分布</description></item><item><title>Geth 私链</title><link>https://zhenfeng-zhu.github.io/post/geth-%E7%A7%81%E9%93%BE/</link><pubDate>Fri, 20 Nov 2020 15:59:22 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/geth-%E7%A7%81%E9%93%BE/</guid><description>在上一篇文章《Geth 入门》中，主要讲了开发环境下以太坊 geth 客户端的使用。今天简单说下私链的配置。 genesis.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { &amp;#34;config&amp;#34;: { &amp;#34;chainId&amp;#34;:</description></item><item><title>Geth</title><link>https://zhenfeng-zhu.github.io/post/geth/</link><pubDate>Fri, 20 Nov 2020 10:07:39 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/geth/</guid><description>Geth 简介 go-ethereum go-ethereum 客户端通常被称为 geth，它是个命令行界面，执行在 Go 上实现的完整以太坊节点。通过安装和运行 geth，可以参与到以太坊前台实时网络并</description></item><item><title>hive 常用函数</title><link>https://zhenfeng-zhu.github.io/post/hive%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</link><pubDate>Thu, 16 Apr 2020 17:59:03 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/hive%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</guid><description>json 字符串处理 get_json_object lateral_view explode substr json_tuple get_json_object get_json_object(string json_string, string path) 解析 json 字符串 json_string，返回 path 指定的内容。如果输入的 json 字符串是无效的，那么返回 null。 path 就是 &amp;</description></item><item><title>mysql 的学习</title><link>https://zhenfeng-zhu.github.io/post/mysql%E7%9A%84%E5%AD%A6%E4%B9%A0/</link><pubDate>Thu, 16 Apr 2020 17:34:30 +0800</pubDate><guid>https://zhenfeng-zhu.github.io/post/mysql%E7%9A%84%E5%AD%A6%E4%B9%A0/</guid><description>SQL 条件语句 IF if(exp1, exp2, exp3) exp1 是条件，条件为 true 的话，是 exp2，否则是 exp3 case when 1 2 3 4 5 case列名when条件then结果else其他结果end别名 IFNULL</description></item><item><title>clickhouse</title><link>https://zhenfeng-zhu.github.io/post/clickhouse/</link><pubDate>Sat, 12 Oct 2019 06:48:01 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/clickhouse/</guid><description>ClickHouse ClickHouse 是一个用于联机分析（Online Analytical Processing：OLAP）的列式数据库管理系统(DBMS)。通过使用 OLAP 工具，用户能够从多个角度交</description></item><item><title>每日学习 2</title><link>https://zhenfeng-zhu.github.io/post/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0-2019-09-29/</link><pubDate>Sun, 29 Sep 2019 02:19:03 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0-2019-09-29/</guid><description>https://mubu.com/doc/oHlgG0FSu0</description></item><item><title>每日学习-2019-09-24</title><link>https://zhenfeng-zhu.github.io/post/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0-2019-09-24/</link><pubDate>Sun, 29 Sep 2019 02:17:46 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0-2019-09-24/</guid><description>开言英语 极客时间 编译原理之美 语义分析（下）：如何做上下文相关情况的处理 语义分析的本质，就是针对上下文相关的情况做处理。 引用消解：不同作用域里</description></item><item><title>tmux</title><link>https://zhenfeng-zhu.github.io/post/tmux/</link><pubDate>Wed, 28 Aug 2019 12:03:46 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/tmux/</guid><description>折腾一下 tmux 安装 1 brew install tmux 概念 session：理解为一个会话，持久保存工作状态。 window：可以理解为我们常说的 tab 页。 pane：一个 window 被分成若</description></item><item><title>crystal 开发环境</title><link>https://zhenfeng-zhu.github.io/post/crystal%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Tue, 27 Aug 2019 14:03:12 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/crystal%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>突然搞明白了 crystal 的 vscode 插件的正确使用姿势，记录一下。 安装 crystal 1 brew install crystal 安装 vscode 插件 https://marketplace.visualstudio.com/items?itemName=faustinoaq.crystal-lang 安装 scry scry 是 crystal 的 language server 的 client 工具，在本地安装 scry 就可以做到代码跳转了。 1 2</description></item><item><title>crystal 简介</title><link>https://zhenfeng-zhu.github.io/post/crystal%E7%AE%80%E4%BB%8B/</link><pubDate>Tue, 27 Aug 2019 02:14:18 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/crystal%E7%AE%80%E4%BB%8B/</guid><description>关注 crystal 也有一段时间了，看到多线程的 pr 已经提了，今天简单写一下。 Fast as C, Slick as Ruby 语法 crystal 的语法和 Ruby 比较类似。 1 2 3 4 5 6 7 8 9 10 # A very basic HTTP server require &amp;#34;http/server&amp;#34; server =</description></item><item><title>socket</title><link>https://zhenfeng-zhu.github.io/post/socket/</link><pubDate>Mon, 26 Aug 2019 06:54:14 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/socket/</guid><description>Socket 网络模型 osi 七层模型 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 对应的 tcpip 就是 应用层 dns http 传输层 icmp tcp udp ip 层 ipv4 ipv6 mac 层 arp vlan 物理层 Ethernet 为什么要分层 因为</description></item><item><title>go 进阶</title><link>https://zhenfeng-zhu.github.io/post/go%E8%BF%9B%E9%98%B6/</link><pubDate>Mon, 26 Aug 2019 06:53:32 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/go%E8%BF%9B%E9%98%B6/</guid><description>Diagnostics go 提供了一系列诊断逻辑和性能问题的工具。 profiling 分析 tracing 跟踪 debuging 调试 运行时统计信息和事件 Profiling profiling 信息可以在 go test 或者 net/http/pprof 包的时候使用。 runtime/pprof 包有： cpu 主动消费 cpu 周</description></item><item><title>mysql</title><link>https://zhenfeng-zhu.github.io/post/mysql/</link><pubDate>Sat, 01 Dec 2018 15:54:53 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/mysql/</guid><description>MySQL 基本架构 客户端 server 层 连接器：管理连接，权限验证 查询缓存：命中规则，直接返回结果 8.0 之后全部删除了这个模块 分析器：词法分析，语法分析 优化器：执行</description></item><item><title>graphql</title><link>https://zhenfeng-zhu.github.io/post/graphql/</link><pubDate>Thu, 08 Nov 2018 18:28:13 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/graphql/</guid><description>graphql 经常被认为是聚焦于前端的技术。 核心概念 SDL：schema definition language（模式定义语言） 如： 1 2 3 4 type Person{ name: String! age: Int! } 这个类型有两个字段，</description></item><item><title>go-best-practice</title><link>https://zhenfeng-zhu.github.io/post/go-best-practice/</link><pubDate>Wed, 07 Nov 2018 17:16:07 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/go-best-practice/</guid><description>短变量名称在声明和上次使用之间的距离很短时效果很好。 长变量名称需要证明自己的合理性; 名称越长，需要提供的价值越高。冗长的名称与页面上的重量相</description></item><item><title>kubernetes</title><link>https://zhenfeng-zhu.github.io/post/kubernetes/</link><pubDate>Mon, 08 Oct 2018 15:29:21 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/kubernetes/</guid><description>docker 利用 Linux 的 cgroups 和 namespace，构建一个沙箱运行环境。 docker 镜像 其实就是一个压缩包，这个压缩包是由一个完整的操作系统的所有文件目录构成，包含了</description></item><item><title>watchdog</title><link>https://zhenfeng-zhu.github.io/post/watchdog/</link><pubDate>Thu, 06 Sep 2018 16:23:57 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/watchdog/</guid><description>监视器 监视器提供了一个外部世界和函数之间的非托管的通用接口。它的工作是收集从 API 网关来的 HTTP 请求，然后调用程序。监视器是一个小型的 Golang 服务——下图</description></item><item><title>queue-worker</title><link>https://zhenfeng-zhu.github.io/post/queue-worker/</link><pubDate>Thu, 06 Sep 2018 16:23:12 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/queue-worker/</guid><description>queue-worker 源码分析 异步函数和同步函数 在 OpenFaaS 中同步调用函数时，将会连接到网关，直到函数成功返回才会关闭连接。同步调用是阻塞的。 网关的路由是：/funct</description></item><item><title>区块链学习笔记</title><link>https://zhenfeng-zhu.github.io/post/blockchain/</link><pubDate>Thu, 23 Aug 2018 15:14:02 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/blockchain/</guid><description>本文是阅读http://www.netkiller.cn/blockchain/ch01s10.html 上的一些笔记。 理解区块链的分布式记账</description></item><item><title>谈谈聊天机器人框架的实现原理</title><link>https://zhenfeng-zhu.github.io/post/botbuilder/</link><pubDate>Wed, 22 Aug 2018 19:39:12 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/botbuilder/</guid><description>在这篇文章不考虑人工智能，谈谈我对聊天机器人框架实现机制的理解。 聊天机器人 聊天机器人（Chatterbot）是经由对话或文字进行交谈的计算机</description></item><item><title>基于以太坊的 Parity 联盟链部署</title><link>https://zhenfeng-zhu.github.io/post/parity/</link><pubDate>Wed, 22 Aug 2018 16:51:13 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/parity/</guid><description>公司项目中使用公网上的以太坊私链，交易速度比较慢，于是这几天都在鼓捣基于以太坊的联盟链，parity 是可以构建出一个基于 PoA 共识的私链，而且兼</description></item><item><title>dive-into-redis</title><link>https://zhenfeng-zhu.github.io/post/dive-into-redis/</link><pubDate>Mon, 20 Aug 2018 09:39:08 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/dive-into-redis/</guid><description>redis 持久化， 机制有两种： 快照：全量备份，二进制序列化，存储紧凑 AOF 日志：连续的增量备份，内存数据修改的文本</description></item><item><title>golang 踩坑</title><link>https://zhenfeng-zhu.github.io/post/golang%E8%B8%A9%E5%9D%91/</link><pubDate>Tue, 14 Aug 2018 20:10:55 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/golang%E8%B8%A9%E5%9D%91/</guid><description>一 x509 error when using HTTPS inside a Docker container 因为 docker 中没有 CA 证书。 普通的镜像解决办法 1 2 3 4 5 6 FROM ubuntu:14.04.1 RUN apt-get update RUN apt-get install -y ca-certificates CMD curl https://www.google.com 如果是 alpine 的参考这个： 1 2 3 4 5 6 7 8 9 FROM docker.finogeeks.club/base/alpine MAINTAINER</description></item><item><title>以太坊开发总结</title><link>https://zhenfeng-zhu.github.io/post/eth-tools/</link><pubDate>Fri, 10 Aug 2018 18:57:09 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/eth-tools/</guid><description>最近因公司项目需要，做为一个打杂工程师，操起键盘和笔记本开始了以太坊的踩坑之旅。以太坊的开发比较新，变化也比较多，还好有@cctanfuju</description></item><item><title>以太坊</title><link>https://zhenfeng-zhu.github.io/post/%E4%BB%A5%E5%A4%AA%E5%9D%8A/</link><pubDate>Tue, 07 Aug 2018 20:09:26 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E4%BB%A5%E5%A4%AA%E5%9D%8A/</guid><description>参与了公司的一个项目，上了以太坊，这里简单记录一下踩坑。 首先先把 go 的依赖下载下来： 1 go get -u -v github.com/ethereum/go-ethereum 有时候下载的很慢，可以从 github 上拉下来代码。 账户 以</description></item><item><title>contract</title><link>https://zhenfeng-zhu.github.io/post/contract/</link><pubDate>Fri, 03 Aug 2018 14:32:03 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/contract/</guid><description>类型 Solidity 是静态类型的语言。 值类型 bool int/uint fixed/unfixed address balance 和 transfer send call, callcode 和 delegatecall byte bytes 和 string 十六进制 hex&amp;quot;0012&amp;quot; enum function 引用类型 数组 uint[] 结构体 struct Map mapping(key =&amp;gt; value) 单元和全局变量 以太币的单位 在数字后</description></item><item><title>faas-provider</title><link>https://zhenfeng-zhu.github.io/post/faas-provider/</link><pubDate>Wed, 01 Aug 2018 19:53:23 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/faas-provider/</guid><description>faas-provider 是一个模板，只要实现了这个模板的接口，就可以自定义实现自己的 provider。 faas-provider OpenFaaS 官方提供了两套后台 provider： Docker Swarm Kubernetes 这两者在部署和</description></item><item><title>gateway-reading</title><link>https://zhenfeng-zhu.github.io/post/gateway-reading/</link><pubDate>Wed, 01 Aug 2018 09:15:35 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/gateway-reading/</guid><description>OpenFaaS 的 Gateway 是一个 golang 实现的请求转发的网关，在这个网关服务中，主要有以下几个功能： UI 部署函数 监控 自动伸缩 架构分析 从图中可以发现，当 Gateway 作为一个入口，当</description></item><item><title>NATS streaming</title><link>https://zhenfeng-zhu.github.io/post/nats-streaming/</link><pubDate>Mon, 30 Jul 2018 14:51:26 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/nats-streaming/</guid><description>市面上常见到的和 Nats 功能类似的消息通信系统有： ActiveMQ（Java 编写）、KafKa（Scala 编写）、RabbitMq（Ruby 编写）</description></item><item><title>nats 简介</title><link>https://zhenfeng-zhu.github.io/post/nats/</link><pubDate>Mon, 30 Jul 2018 11:15:39 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/nats/</guid><description>nats 是一个开源的，云原生的消息系统。Apcera，百度，西门子，VMware，HTC 和爱立信等公司都有在使用。 核心基于 EventMachine 开发，原理是基于消息发</description></item><item><title>overview-of-openfaas</title><link>https://zhenfeng-zhu.github.io/post/overview-of-openfaas/</link><pubDate>Thu, 26 Jul 2018 17:41:33 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/overview-of-openfaas/</guid><description>OpenFaaS 概览 无服务器函数变得简单。 函数监视器 你可以通过添加函数监视器 (一个小型的 Golang HTTP 服务)把任何一个 Docker 镜像变成无服务器函数。 函数监视器是允许 HTTP 请求</description></item><item><title>OpenFaaS on Rancher 2.0</title><link>https://zhenfeng-zhu.github.io/post/openfaas-on-rancher/</link><pubDate>Thu, 26 Jul 2018 09:50:46 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/openfaas-on-rancher/</guid><description>这是一篇关于如何在 Rancher 2.0 上创建 OpenFaaS 栈的文章。我假设你已经准备好了 Rancher 2.0 集群，如果没有请按照官方文档创建一个。 下面的视频展示了如何创建 OpenFaaS 栈，并在实际</description></item><item><title>openfaas-workshop-lab4</title><link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab4/</link><pubDate>Mon, 02 Jul 2018 09:32:59 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab4/</guid><description>实验 4&amp;ndash;更深入地使用函数 在开始本实验之前，为你的文件创建一个新的文件夹。由于本实验是建立在早期实验的基础上的，所以请复制 lab3</description></item><item><title>ubuntu-docker-sudo</title><link>https://zhenfeng-zhu.github.io/post/ubuntu-docker-sudo/</link><pubDate>Fri, 29 Jun 2018 13:54:25 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/ubuntu-docker-sudo/</guid><description>1 2 sudo chown &amp;#34;$USER&amp;#34;:&amp;#34;$USER&amp;#34; /home/&amp;#34;$USER&amp;#34;/.docker -R sudo chmod g+rwx &amp;#34;/home/$USER/.docker&amp;#34; -R 1 2 3 4 5 https://api.finochat.com/api/v1/platform/apps/RETAIL/profiles/@custom:finolabs.com.cn/avatar?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmY2lkIjoiQHBjdXN0b20tMTA6Zmlub2xhYnMuY29tLmNuIiwiaXNzIjoieUNkNXVhaWRhWU4zc1pwTTdHU2V5WWVqSGdlN3hSa1EiLCJpYXQiOjE1MzAyNjk5NDh9.UUsO2xw1f8cA6FiG1bNAGyYQh-vh32hKHKSJ2EKZicI http://localhost:3000/api/v1/platform/apps/RETAIL/profiles/@custom:finolabs.com.cn/avatar?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmY2lkIjoiQHBjdXN0b20tMTA6Zmlub2xhYnMuY29tLmNuIiwiaXNzIjoieUNkNXVhaWRhWU4zc1pwTTdHU2V5WWVqSGdlN3hSa1EiLCJpYXQiOjE1MzAyNjk5NDh9.UUsO2xw1f8cA6FiG1bNAGyYQh-vh32hKHKSJ2EKZicI</description></item><item><title>openfaas-workshop-lab3</title><link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab3/</link><pubDate>Thu, 28 Jun 2018 17:29:56 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab3/</guid><description>实验 3&amp;ndash;函数介绍 在开始这个实验之前，为你的文件创建一个新的文件夹。 1 2 $ mkdir -p lab3\`s &amp;amp;&amp;amp; cd lab3 创建一个新的函数 有两种方法来创建一个新的函数</description></item><item><title>译：openfaas-workshop-Lab1</title><link>https://zhenfeng-zhu.github.io/post/workshop-lab1/</link><pubDate>Mon, 25 Jun 2018 18:04:09 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/workshop-lab1/</guid><description>今天大多数公司在开发应用程序并将其部署在服务器上的时候，无论是选择公有云还是私有的数据中心，都需要提前了解究竟需要多少台服务器、多大容量的存</description></item><item><title>openfaas</title><link>https://zhenfeng-zhu.github.io/post/openfaas/</link><pubDate>Sun, 24 Jun 2018 15:43:46 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/openfaas/</guid><description>对于 mac 环境来讲，首先安装新版 docker: 1 brew cask install docker 然后启动 docker。 命令行登陆 docker hub 1 docker login 启动 docker swarm 1 docker swarm init 安装 faas-cli 1 brew install faas-cli clone 下来代码： 1 git clone https://github.com/openfaas/faas 然后执行</description></item><item><title>java-reactive-web</title><link>https://zhenfeng-zhu.github.io/post/java-reactive-web/</link><pubDate>Sat, 23 Jun 2018 15:05:32 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/java-reactive-web/</guid><description>Spring web mvc： 传统 servlet web spring web flux： Reactive web 编程模式： non-blocking 非阻塞 nio：同步？异步？ 并行模型 sync 同步 async 异步 Reactive 概念 Reactive programming： 响应式编程 In</description></item><item><title>kafka</title><link>https://zhenfeng-zhu.github.io/post/kafka/</link><pubDate>Thu, 21 Jun 2018 17:49:46 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/kafka/</guid><description>启动 zookeeper 1 bin/zookeeper-server-start.sh config/zookeeper.properties 启动 kafka 1 bin/kafka-server-start.sh config/server.properties 创建一个主题 1 bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test 1 bin/kafka-topics.sh --list --zookeeper localhost:2181 生产者 1 bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test 消费者 1 bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning kafka connect 1 echo -e &amp;#34;zhisheng\ntian&amp;#34; &amp;gt; test.txt ls 1 2 3 4 5 6 zh</description></item><item><title>译：vertx-kotlin-coroutine</title><link>https://zhenfeng-zhu.github.io/post/vertx-kotlin-coroutine/</link><pubDate>Sat, 02 Jun 2018 16:00:52 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/vertx-kotlin-coroutine/</guid><description>尝试翻译 vertx 的文档。尊重原文，部分使用自己的理解。 Vert.x 的 kotlin 协程提供了 async/await 或者和 go 类似的 channel。这使得你能够以熟悉的顺序风格写垂直代码。 vertx-lang-kotlin-coroutines 集</description></item><item><title>小议 async/await 和 coroutine</title><link>https://zhenfeng-zhu.github.io/post/async/</link><pubDate>Mon, 21 May 2018 19:37:14 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/async/</guid><description>Being happy doesn&amp;rsquo;t mean that everything is perfect. It means that you decided to look beyond the imperfections. 后端编程，涉及最多的就是并发。简单理解就是： 并发是同时管理多个任务去执行，并行是针对多核处理器，同时执行</description></item><item><title>elasticsearch</title><link>https://zhenfeng-zhu.github.io/post/elasticsearch/</link><pubDate>Sun, 20 May 2018 14:17:07 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/elasticsearch/</guid><description>以前没有好好学的东西，现在在工作中慢慢的补回来了。 基础概念 索引 es 是将数据存储在一个或者多个索引（index）中。 索引就像是数据库。 文档 文档是</description></item><item><title>git 常用操作</title><link>https://zhenfeng-zhu.github.io/post/git/</link><pubDate>Mon, 14 May 2018 10:04:02 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/git/</guid><description>整理一下常用的 git 操作，不用再到处找了。 git 放弃本地修改，强制更新 1 2 git fetch --all git reset --hard origin/master git 修改远程仓库地址 1 git remote set-url origin url cherry-pick 当你通过一番挣扎终于搞定一个</description></item><item><title>node 的 cluster</title><link>https://zhenfeng-zhu.github.io/post/node%E7%9A%84cluster/</link><pubDate>Sat, 05 May 2018 15:45:47 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/node%E7%9A%84cluster/</guid><description>我们知道 js 是运行单线程的，也就是说一个 node 进程只能运行在一个 cpu 上。那么如果用 node 来做 web server 的话，就无法享受到多核运算的好处。 一个问题就是： 1 如何榨</description></item><item><title>node 踩坑</title><link>https://zhenfeng-zhu.github.io/post/node%E8%B8%A9%E5%9D%91/</link><pubDate>Sat, 05 May 2018 15:32:59 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/node%E8%B8%A9%E5%9D%91/</guid><description>module 首先第一个就是 es6 的 module。 看到别人写的 1 import { a } from &amp;#34;./module&amp;#34;; 所以自己也想要这么写，但是每次运行的时候都会报错。 1 2 3 4 5 6 7 8 9 // demo2.js export const a =</description></item><item><title>node 学习笔记</title><link>https://zhenfeng-zhu.github.io/post/node-learning/</link><pubDate>Sun, 22 Apr 2018 15:41:21 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/node-learning/</guid><description>写 node 也有一段时间了，整理一下学习笔记，共同进步 什么是 node 首先看一下什么是 node.js Node 是一个服务器端 JavaScript Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境 Node.js 使用了一个事件驱</description></item><item><title>node 的 redis 实战</title><link>https://zhenfeng-zhu.github.io/post/node%E7%9A%84redis%E5%AE%9E%E6%88%98/</link><pubDate>Fri, 13 Apr 2018 10:00:12 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/node%E7%9A%84redis%E5%AE%9E%E6%88%98/</guid><description>Node.js Redis 客户端模块 为了追新，这里我使用的 yarn，毕竟我是 HDD（面向热点编程）编程实践者。 模块安装 1 yarn add redis 模块使用实例 1 2 3 4 5 6 7 8 9 10 11 12</description></item><item><title>谈谈 web 框架</title><link>https://zhenfeng-zhu.github.io/post/%E8%B0%88%E8%B0%88web%E6%A1%86%E6%9E%B6/</link><pubDate>Sun, 08 Apr 2018 16:01:48 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E8%B0%88%E8%B0%88web%E6%A1%86%E6%9E%B6/</guid><description>这篇文章打的标签比较多，也基本涵盖了我所了解的一些知识，归纳总结一下自己对 web 框架的理解。自己了解的也不是很多，也请多多指教。 写程序免不了要做</description></item><item><title>技术栈</title><link>https://zhenfeng-zhu.github.io/post/%E6%8A%80%E6%9C%AF%E6%A0%88/</link><pubDate>Thu, 05 Apr 2018 09:49:06 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E6%8A%80%E6%9C%AF%E6%A0%88/</guid><description>创业公司真的比较锻炼人，接触了很多的东西，视野开阔了，但是在某些时候自己疲于奔命，每个东西都是接触了一点点就被赶鸭子上架开始开发了。 技术栈 Docker</description></item><item><title>同步一个 fork</title><link>https://zhenfeng-zhu.github.io/post/%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA-fork/</link><pubDate>Wed, 04 Apr 2018 16:01:31 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA-fork/</guid><description>具体方法 Configuring a remote for a fork 给 fork 配置一个 remote 主要使用 git remote -v 查看远程状态。 1 2 3 git remote -v # origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) # origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) 添加一个将被同步给 fork 远程的上游仓库 1 git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git 再次</description></item><item><title>Go 语言体会</title><link>https://zhenfeng-zhu.github.io/post/go%E8%AF%AD%E8%A8%80%E4%BD%93%E4%BC%9A/</link><pubDate>Wed, 04 Apr 2018 13:48:57 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/go%E8%AF%AD%E8%A8%80%E4%BD%93%E4%BC%9A/</guid><description>最近公司要统一技术栈，在 kotlin 和 go 之间选。我心里是比较倾向 go 的，主要有如下几点体会。 语言简单，上手快。 gorotuine 易发布 垃圾回收 约定大于配置 我最早听说协程</description></item><item><title>关于时间管理</title><link>https://zhenfeng-zhu.github.io/post/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</link><pubDate>Sun, 25 Mar 2018 20:28:42 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</guid><description>主动管理时间，敢于说不。 有目标向前看，没目标向钱看。</description></item><item><title>一致性哈希算法</title><link>https://zhenfeng-zhu.github.io/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 24 Mar 2018 19:03:58 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</guid><description>当我们在做数据库分库分表或者做分布式缓存的时候，不可避免的都会遇到一个问题： 如何将数据均匀的分散到各个节点中，并且尽量的在加减节点的时能使受</description></item><item><title>Spring Boot 启动原理分析</title><link>https://zhenfeng-zhu.github.io/post/spring-boot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link><pubDate>Sat, 24 Mar 2018 19:03:22 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/spring-boot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid><description>Spring Boot 启动原理分析 我们在开发 spring boot 应用的时候，一般会遇到如下的启动类： 1 2 3 4 5 6 @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 从这段代码可以看出，注解@Spr</description></item><item><title>Spring Data Jpa 实战</title><link>https://zhenfeng-zhu.github.io/post/spring-data-jpa%E5%AE%9E%E6%88%98/</link><pubDate>Sat, 24 Mar 2018 19:02:48 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/spring-data-jpa%E5%AE%9E%E6%88%98/</guid><description>为了解决抽象各个 Java 实体基本的“增删改查”操作，我们通常会以泛型的方式封装一个模板 Dao 来进行抽象简化，但是这样依然不是很方便，我们需要针对每个实</description></item><item><title>spring boot 多数据源配置</title><link>https://zhenfeng-zhu.github.io/post/spring-boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 24 Mar 2018 19:01:37 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/spring-boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/</guid><description>spring boot 多数据源配置 在单数据源的情况下，Spring Boot 的配置非常简单，只需要在 application.properties 文件中配置连接参数即可。但是往往随着业务量发展，我们通常会进行数</description></item><item><title>spring boot 连接 redis</title><link>https://zhenfeng-zhu.github.io/post/spring-boot%E8%BF%9E%E6%8E%A5redis/</link><pubDate>Sat, 24 Mar 2018 19:00:48 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/spring-boot%E8%BF%9E%E6%8E%A5redis/</guid><description>Spring-data-redis为 spring-data 模块中对 redis 的支持部分，简称为“SDR”，提供了基于 jedis 客户端 API 的高度封装以及与 spring 容器的整合， jedis 客户端在编</description></item><item><title>最终一致性的实现手段</title><link>https://zhenfeng-zhu.github.io/post/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%AE%B5/</link><pubDate>Sat, 24 Mar 2018 18:59:55 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%AE%B5/</guid><description>最终一致性的实现手段 实现最终一致性有三种手段：可靠事件模式、业务补偿模式和 TCC 模式 1 可靠事件模式 可靠事件模式属于事件驱动架构，当某件重要的事情</description></item><item><title>Reactive 微服务</title><link>https://zhenfeng-zhu.github.io/post/reactive%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link><pubDate>Sat, 24 Mar 2018 17:57:58 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/reactive%E5%BE%AE%E6%9C%8D%E5%8A%A1/</guid><description>Reactive 微服务 分布式系统构建起来很困难，因为它们容易出问题，运行缓慢，并且被 CAP 和 FLP 理论所限制。换句话说，它们的构建和运维都特别复杂。为了解决这个问</description></item><item><title>Guice 快速入门</title><link>https://zhenfeng-zhu.github.io/post/guice%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link><pubDate>Sat, 24 Mar 2018 17:57:15 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/guice%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid><description>Guice 快速入门 接手的新项目主要是使用 kotlin+vert.x 来写的，使用 gradle 构建，依赖注入框架使用了 guice。这段时间都是在熟悉代码的过程，恶补一些知识。 guice 是谷歌推出</description></item><item><title>kotlin 快速入门</title><link>https://zhenfeng-zhu.github.io/post/kotlin%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link><pubDate>Sat, 24 Mar 2018 17:56:45 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/kotlin%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid><description>快速浏览一下 Kotlin 的语法。 基本语法 包定义和引用 在源文件头部： 1 2 3 package my.demo import java.util.* 方法定义 带有方法体，并且返回确定类型数据的定义方式，例如接受 Int 类型的参</description></item><item><title>RxJava2 快速入门</title><link>https://zhenfeng-zhu.github.io/post/rxjava2%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link><pubDate>Sat, 24 Mar 2018 17:55:56 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/rxjava2%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid><description>RxJava2 快速入门 引入依赖 1 compile &amp;#39;io.reactivex.rxjava2:rxjava:2.0.1&amp;#39; 写法 简单版本 1 2 3 4 5 6 7 8 9 10 private static void helloSimple() { Consumer&amp;lt;String&amp;gt; consumer = new Consumer&amp;lt;String&amp;gt;() { @Override public void accept(String s) throws Exception { System.out.println(&amp;#34;consumer accept is &amp;#34; + s); } }; Observable.just(&amp;#34;hello world&amp;#34;).subscribe(consumer); } 复杂版本 1 2 3 4 5 6 7 8</description></item><item><title>领域实体类</title><link>https://zhenfeng-zhu.github.io/post/%E9%A2%86%E5%9F%9F%E5%AE%9E%E4%BD%93%E7%B1%BB/</link><pubDate>Sat, 24 Mar 2018 17:53:42 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/%E9%A2%86%E5%9F%9F%E5%AE%9E%E4%BD%93%E7%B1%BB/</guid><description>在看项目代码的时候，发现了 entity 包和 dto 包，里面都是只保存数据的类，仔细查了资料，才发现 java 对于只保存数据的类有好几个分类。 pojo 类：这是普通的 java 类，具</description></item><item><title>docker</title><link>https://zhenfeng-zhu.github.io/post/docker/</link><pubDate>Sat, 24 Mar 2018 17:42:58 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/docker/</guid><description>docker 常用命令 docker 获取镜像 docker pull 新建并启动 docker run 列出镜像 docker image ls docker images 删除虚悬镜像 docker image prune 删除本地镜像 docker iamge rm 查看应用信息 docker logs dockerfile 一般步骤 在一个目录里，新建一个</description></item><item><title>express</title><link>https://zhenfeng-zhu.github.io/post/express/</link><pubDate>Sat, 24 Mar 2018 17:41:01 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/express/</guid><description>Express 快速入门 安装 1 2 3 npm init npm install --save express hello world 1 2 3 4 5 6 7 8 9 10 var express = require(&amp;#39;express&amp;#39;); var app = express(); app.get(&amp;#39;/&amp;#39;, function (req, res) { res.send(&amp;#39;Hello World!&amp;#39;); }); app.listen(3000, function () { console.log(&amp;#39;Example app listening on port 3000!&amp;#39;); }); 执行命令运行应用程序 1 node app.js 然后</description></item><item><title>碎碎念</title><link>https://zhenfeng-zhu.github.io/post/a-month-in-finogeeks/</link><pubDate>Sat, 24 Mar 2018 15:55:58 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/a-month-in-finogeeks/</guid><description>一直没有机会写 2017 的年终总结，想到去年写的新的一年的计划，好像自己都没有按照计划来做，而且写的计划也不知道写到哪里去了。 站在现在的时间点去审视</description></item><item><title>Java 内存模型和线程</title><link>https://zhenfeng-zhu.github.io/post/java-memory-thread/</link><pubDate>Thu, 22 Mar 2018 19:16:37 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/java-memory-thread/</guid><description>java 内存模型和线程 并发不一定依赖多线程，但是在 java 里面谈论并发，大多与线程脱不开关系。 线程是大多是面试都会问到的问题。我们都知道，线程是比进程更</description></item><item><title>aws.md</title><link>https://zhenfeng-zhu.github.io/post/aws-md/</link><pubDate>Thu, 22 Mar 2018 14:04:09 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/post/aws-md/</guid><description>一些基础概念 EC2 云服务器，可以理解成虚拟机，新建一个实例，就是新建一个虚拟机并安装操作系统（Linux 或者 windows）。 VPC Virtual Private Cloud。</description></item><item><title>About Me</title><link>https://zhenfeng-zhu.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/about/</guid><description>软件工程师 编程小语种爱好者，精通各种语言的hello world，目前沉迷Clojure、elixir Get Started工程师，止步于大量框架和</description></item><item><title>Search</title><link>https://zhenfeng-zhu.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zhenfeng-zhu.github.io/search/</guid><description/></item></channel></rss>