<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="用 Multimethods、协议和记录创建和扩展抽象概念 花一分钟思考一下，作为大自然的顶级产品之一：人类是多么伟大。作为一个人类，你可以在社交媒体上闲聊，玩龙与地下城，戴帽子。也许更重要的是，你可以用抽象的概念来思考和交流。
抽象思考的能力确实是人类最好的特征之一。它可以让你规避你的认知极限，将不同的细节捆绑在一起，形成一个整齐的概念包，让你可以在工作记忆中持有。你不需要去想 &amp;ldquo;可挤压的红球鼻子装饰 &amp;ldquo;这种笨重的想法，而只需要 &amp;ldquo;小丑鼻子 &amp;ldquo;这个概念。
在 Clojure 中，一个抽象是一个操作的集合，而数据类型实现抽象。例如，seq 抽象由 &amp;ldquo;first &amp;ldquo;和 &amp;ldquo;rest &amp;ldquo;等操作组成，而 Vector 数据类型是该抽象的实现；它对所有 seq 操作做出响应。像[:seltzer :water]这样的特定 Vector 是该数据类型的*实例。
编程语言越是让你以抽象的方式思考和写作，你的生产力就越高。例如，如果你知道一个数据结构是 seq 抽象的一个实例，你就可以立即调用一个大的知识网，了解哪些函数可以与数据结构一起工作。因此，你会花时间去实际使用这个数据结构，而不是不断地去查找关于它如何工作的文档。同样地，如果你扩展一个数据结构，使其与 seq 抽象一起工作，你就可以在上面使用大量的 seq 函数库。
在第四章中，你了解到 Clojure 是以抽象的方式编写的。这很强大，因为在 Clojure 中，你可以专注于你可以用数据结构实际做的事情，而不用担心实现的细枝末节。本章向你介绍了创建和实现你自己的抽象的世界。你将学习 Multimethods、协议和记录的基础知识。
多态 我们在 Clojure 中实现抽象的主要方式是将一个操作名称与一个以上的算法联系起来。这种技术被称为多态。例如，在列表上执行 &amp;ldquo;conj &amp;ldquo;的算法与 Vector 的算法不同，但我们把它们统一在同一个名字下，以表明它们实现了同一个概念，即向这个数据结构添加一个元素。
因为 Clojure 的许多数据类型都依赖于 Java 的标准库，所以本章中使用了一点 Java。例如，Clojure 的字符串只是 Java 的字符串，是 Java 类java.lang.String的实例。要在 Java 中定义你自己的数据类型，你要使用类。Clojure 提供了额外的类型结构。 记录和类型。本书只涉及记录。
在我们学习记录之前，让我们看看 Multimethods，这是我们定义多态行为的第一个工具。
Multimethods Multimethods为你提供了一种直接的、灵活的方法，将多态引入你的代码中。使用 Multimethods，你可以通过定义一个调度函数将一个名字与多个实现联系起来，该函数产生调度值，用来决定使用哪个方法。调度函数就像餐厅里的主人。主人会问你一些问题，比如 &amp;ldquo;你有预订吗？&amp;ldquo;和 &amp;ldquo;聚会人数？&amp;quot;，然后给你安排相应的座位。同样，当你调用一个 Multimethods 时，调度函数将询问参数，并将它们发送到正确的方法，正如这个例子所显示的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  (ns were-creatures) ➊ (defmulti full-moon-behavior (fn [were-creature] (:were-type were-creature))) ➋ (defmethod full-moon-behavior :wolf [were-creature] (str (:name were-creature) &amp;#34; will howl and murder&amp;#34;)) ➌ (defmethod full-moon-behavior :simmons [were-creature] (str (:name were-creature) &amp;#34; will encourage people and sweat to the oldies&amp;#34;)) (full-moon-behavior {:were-type :wolf ➍ :name &amp;#34;Rachel from next door&amp;#34;}) ; =&amp;gt; &amp;#34;Rachel from next door will howl and murder&amp;#34; (full-moon-behavior {:name &amp;#34;Andy the baker&amp;#34; ➎ :were-type :simmons}) ; =&amp;gt; &amp;#34;Andy the baker will encourage people and sweat to the oldies&amp;#34;   这个 Multimethods 显示了你如何定义不同种类的狼人生物的满月行为。大家都知道狼人变成了狼，到处嚎叫着杀人。一种不太知名的狼人，即狼-西蒙斯，变成理查德-西蒙斯，烫着头发，到处跑，鼓励人们做最好的自己，为老人们流汗。你不想被这两种生物咬到，否则你就会变成它们。"><title>Chapter13 抽象</title><link rel=canonical href=https://example.com/p/chapter13-%E6%8A%BD%E8%B1%A1/><link rel=stylesheet href=/scss/style.min.b80bf249ce4a22cf55e8d7340a0b37a2f2c10f54f3a9a49cb94b694a2eb0bbea.css><meta property="og:title" content="Chapter13 抽象"><meta property="og:description" content="用 Multimethods、协议和记录创建和扩展抽象概念 花一分钟思考一下，作为大自然的顶级产品之一：人类是多么伟大。作为一个人类，你可以在社交媒体上闲聊，玩龙与地下城，戴帽子。也许更重要的是，你可以用抽象的概念来思考和交流。
抽象思考的能力确实是人类最好的特征之一。它可以让你规避你的认知极限，将不同的细节捆绑在一起，形成一个整齐的概念包，让你可以在工作记忆中持有。你不需要去想 &amp;ldquo;可挤压的红球鼻子装饰 &amp;ldquo;这种笨重的想法，而只需要 &amp;ldquo;小丑鼻子 &amp;ldquo;这个概念。
在 Clojure 中，一个抽象是一个操作的集合，而数据类型实现抽象。例如，seq 抽象由 &amp;ldquo;first &amp;ldquo;和 &amp;ldquo;rest &amp;ldquo;等操作组成，而 Vector 数据类型是该抽象的实现；它对所有 seq 操作做出响应。像[:seltzer :water]这样的特定 Vector 是该数据类型的*实例。
编程语言越是让你以抽象的方式思考和写作，你的生产力就越高。例如，如果你知道一个数据结构是 seq 抽象的一个实例，你就可以立即调用一个大的知识网，了解哪些函数可以与数据结构一起工作。因此，你会花时间去实际使用这个数据结构，而不是不断地去查找关于它如何工作的文档。同样地，如果你扩展一个数据结构，使其与 seq 抽象一起工作，你就可以在上面使用大量的 seq 函数库。
在第四章中，你了解到 Clojure 是以抽象的方式编写的。这很强大，因为在 Clojure 中，你可以专注于你可以用数据结构实际做的事情，而不用担心实现的细枝末节。本章向你介绍了创建和实现你自己的抽象的世界。你将学习 Multimethods、协议和记录的基础知识。
多态 我们在 Clojure 中实现抽象的主要方式是将一个操作名称与一个以上的算法联系起来。这种技术被称为多态。例如，在列表上执行 &amp;ldquo;conj &amp;ldquo;的算法与 Vector 的算法不同，但我们把它们统一在同一个名字下，以表明它们实现了同一个概念，即向这个数据结构添加一个元素。
因为 Clojure 的许多数据类型都依赖于 Java 的标准库，所以本章中使用了一点 Java。例如，Clojure 的字符串只是 Java 的字符串，是 Java 类java.lang.String的实例。要在 Java 中定义你自己的数据类型，你要使用类。Clojure 提供了额外的类型结构。 记录和类型。本书只涉及记录。
在我们学习记录之前，让我们看看 Multimethods，这是我们定义多态行为的第一个工具。
Multimethods Multimethods为你提供了一种直接的、灵活的方法，将多态引入你的代码中。使用 Multimethods，你可以通过定义一个调度函数将一个名字与多个实现联系起来，该函数产生调度值，用来决定使用哪个方法。调度函数就像餐厅里的主人。主人会问你一些问题，比如 &amp;ldquo;你有预订吗？&amp;ldquo;和 &amp;ldquo;聚会人数？&amp;quot;，然后给你安排相应的座位。同样，当你调用一个 Multimethods 时，调度函数将询问参数，并将它们发送到正确的方法，正如这个例子所显示的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  (ns were-creatures) ➊ (defmulti full-moon-behavior (fn [were-creature] (:were-type were-creature))) ➋ (defmethod full-moon-behavior :wolf [were-creature] (str (:name were-creature) &amp;#34; will howl and murder&amp;#34;)) ➌ (defmethod full-moon-behavior :simmons [were-creature] (str (:name were-creature) &amp;#34; will encourage people and sweat to the oldies&amp;#34;)) (full-moon-behavior {:were-type :wolf ➍ :name &amp;#34;Rachel from next door&amp;#34;}) ; =&amp;gt; &amp;#34;Rachel from next door will howl and murder&amp;#34; (full-moon-behavior {:name &amp;#34;Andy the baker&amp;#34; ➎ :were-type :simmons}) ; =&amp;gt; &amp;#34;Andy the baker will encourage people and sweat to the oldies&amp;#34;   这个 Multimethods 显示了你如何定义不同种类的狼人生物的满月行为。大家都知道狼人变成了狼，到处嚎叫着杀人。一种不太知名的狼人，即狼-西蒙斯，变成理查德-西蒙斯，烫着头发，到处跑，鼓励人们做最好的自己，为老人们流汗。你不想被这两种生物咬到，否则你就会变成它们。"><meta property="og:url" content="https://example.com/p/chapter13-%E6%8A%BD%E8%B1%A1/"><meta property="og:site_name" content="演示站点"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="clojure"><meta property="article:published_time" content="2022-01-15T21:29:04+08:00"><meta property="article:modified_time" content="2022-01-15T21:29:04+08:00"><meta name=twitter:title content="Chapter13 抽象"><meta name=twitter:description content="用 Multimethods、协议和记录创建和扩展抽象概念 花一分钟思考一下，作为大自然的顶级产品之一：人类是多么伟大。作为一个人类，你可以在社交媒体上闲聊，玩龙与地下城，戴帽子。也许更重要的是，你可以用抽象的概念来思考和交流。
抽象思考的能力确实是人类最好的特征之一。它可以让你规避你的认知极限，将不同的细节捆绑在一起，形成一个整齐的概念包，让你可以在工作记忆中持有。你不需要去想 &amp;ldquo;可挤压的红球鼻子装饰 &amp;ldquo;这种笨重的想法，而只需要 &amp;ldquo;小丑鼻子 &amp;ldquo;这个概念。
在 Clojure 中，一个抽象是一个操作的集合，而数据类型实现抽象。例如，seq 抽象由 &amp;ldquo;first &amp;ldquo;和 &amp;ldquo;rest &amp;ldquo;等操作组成，而 Vector 数据类型是该抽象的实现；它对所有 seq 操作做出响应。像[:seltzer :water]这样的特定 Vector 是该数据类型的*实例。
编程语言越是让你以抽象的方式思考和写作，你的生产力就越高。例如，如果你知道一个数据结构是 seq 抽象的一个实例，你就可以立即调用一个大的知识网，了解哪些函数可以与数据结构一起工作。因此，你会花时间去实际使用这个数据结构，而不是不断地去查找关于它如何工作的文档。同样地，如果你扩展一个数据结构，使其与 seq 抽象一起工作，你就可以在上面使用大量的 seq 函数库。
在第四章中，你了解到 Clojure 是以抽象的方式编写的。这很强大，因为在 Clojure 中，你可以专注于你可以用数据结构实际做的事情，而不用担心实现的细枝末节。本章向你介绍了创建和实现你自己的抽象的世界。你将学习 Multimethods、协议和记录的基础知识。
多态 我们在 Clojure 中实现抽象的主要方式是将一个操作名称与一个以上的算法联系起来。这种技术被称为多态。例如，在列表上执行 &amp;ldquo;conj &amp;ldquo;的算法与 Vector 的算法不同，但我们把它们统一在同一个名字下，以表明它们实现了同一个概念，即向这个数据结构添加一个元素。
因为 Clojure 的许多数据类型都依赖于 Java 的标准库，所以本章中使用了一点 Java。例如，Clojure 的字符串只是 Java 的字符串，是 Java 类java.lang.String的实例。要在 Java 中定义你自己的数据类型，你要使用类。Clojure 提供了额外的类型结构。 记录和类型。本书只涉及记录。
在我们学习记录之前，让我们看看 Multimethods，这是我们定义多态行为的第一个工具。
Multimethods Multimethods为你提供了一种直接的、灵活的方法，将多态引入你的代码中。使用 Multimethods，你可以通过定义一个调度函数将一个名字与多个实现联系起来，该函数产生调度值，用来决定使用哪个方法。调度函数就像餐厅里的主人。主人会问你一些问题，比如 &amp;ldquo;你有预订吗？&amp;ldquo;和 &amp;ldquo;聚会人数？&amp;quot;，然后给你安排相应的座位。同样，当你调用一个 Multimethods 时，调度函数将询问参数，并将它们发送到正确的方法，正如这个例子所显示的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  (ns were-creatures) ➊ (defmulti full-moon-behavior (fn [were-creature] (:were-type were-creature))) ➋ (defmethod full-moon-behavior :wolf [were-creature] (str (:name were-creature) &amp;#34; will howl and murder&amp;#34;)) ➌ (defmethod full-moon-behavior :simmons [were-creature] (str (:name were-creature) &amp;#34; will encourage people and sweat to the oldies&amp;#34;)) (full-moon-behavior {:were-type :wolf ➍ :name &amp;#34;Rachel from next door&amp;#34;}) ; =&amp;gt; &amp;#34;Rachel from next door will howl and murder&amp;#34; (full-moon-behavior {:name &amp;#34;Andy the baker&amp;#34; ➎ :were-type :simmons}) ; =&amp;gt; &amp;#34;Andy the baker will encourage people and sweat to the oldies&amp;#34;   这个 Multimethods 显示了你如何定义不同种类的狼人生物的满月行为。大家都知道狼人变成了狼，到处嚎叫着杀人。一种不太知名的狼人，即狼-西蒙斯，变成理查德-西蒙斯，烫着头发，到处跑，鼓励人们做最好的自己，为老人们流汗。你不想被这两种生物咬到，否则你就会变成它们。"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_huda2458f72ce188392d75c5d51cd8e24e_373_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>演示站点</a></h1><h2 class=site-description>软件工程师 编程小语种爱好者，精通各种语言的hello world，目前沉迷Clojure、elixir Get Started工程师，止步于大量框架和包的readme 后端开发工程师，偶尔写一些前端，伪全栈 也是一名数据工程师，朝着SQL Boy进化</h2></div></header><ol class=social-menu><li><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank title=GitHub><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><div class=menu-bottom-section><li id=i18n-switch><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg><select name=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://example.com/en/>English</option><option value=https://example.com/ selected>中文</option><option value=https://example.com/ar/>عربي</option></select></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></div></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/p/chapter13-%E6%8A%BD%E8%B1%A1/>Chapter13 抽象</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Jan 15, 2022</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 5 分钟</time></div></footer></div></header><section class=article-content><h1 id=用-multimethods协议和记录创建和扩展抽象概念>用 Multimethods、协议和记录创建和扩展抽象概念</h1><p>花一分钟思考一下，作为大自然的顶级产品之一：人类是多么伟大。作为一个人类，你可以在社交媒体上闲聊，玩龙与地下城，戴帽子。也许更重要的是，你可以用抽象的概念来思考和交流。</p><p>抽象思考的能力确实是人类最好的特征之一。它可以让你规避你的认知极限，将不同的细节捆绑在一起，形成一个整齐的概念包，让你可以在工作记忆中持有。你不需要去想 &ldquo;可挤压的红球鼻子装饰 &ldquo;这种笨重的想法，而只需要 &ldquo;小丑鼻子 &ldquo;这个概念。</p><p>在 Clojure 中，一个<em>抽象</em>是一个操作的集合，而<em>数据类型</em>实现抽象。例如，seq 抽象由 &ldquo;first &ldquo;和 &ldquo;rest &ldquo;等操作组成，而 Vector 数据类型是该抽象的实现；它对所有 seq 操作做出响应。像<code>[:seltzer :water]</code>这样的特定 Vector 是该数据类型的*实例。</p><p>编程语言越是让你以抽象的方式思考和写作，你的生产力就越高。例如，如果你知道一个数据结构是 seq 抽象的一个实例，你就可以立即调用一个大的知识网，了解哪些函数可以与数据结构一起工作。因此，你会花时间去实际使用这个数据结构，而不是不断地去查找关于它如何工作的文档。同样地，如果你扩展一个数据结构，使其与 seq 抽象一起工作，你就可以在上面使用大量的 seq 函数库。</p><p>在第四章中，你了解到 Clojure 是以抽象的方式编写的。这很强大，因为在 Clojure 中，你可以专注于你可以用数据结构实际做的事情，而不用担心实现的细枝末节。本章向你介绍了创建和实现你自己的抽象的世界。你将学习 Multimethods、协议和记录的基础知识。</p><h2 id=多态>多态</h2><p>我们在 Clojure 中实现抽象的主要方式是将一个操作名称与一个以上的算法联系起来。这种技术被称为<em>多态</em>。例如，在列表上执行 &ldquo;conj &ldquo;的算法与 Vector 的算法不同，但我们把它们统一在同一个名字下，以表明它们实现了同一个概念，即<em>向</em>这个数据结构添加一个元素。</p><p>因为 Clojure 的许多数据类型都依赖于 Java 的标准库，所以本章中使用了一点 Java。例如，Clojure 的字符串只是 Java 的字符串，是 Java 类<code>java.lang.String</code>的实例。要在 Java 中定义你自己的数据类型，你要使用类。Clojure 提供了额外的类型结构。 <em>记录</em>和<em>类型</em>。本书只涉及记录。</p><p>在我们学习记录之前，让我们看看 Multimethods，这是我们定义多态行为的第一个工具。</p><h3 id=multimethods>Multimethods</h3><p><em>Multimethods</em>为你提供了一种直接的、灵活的方法，将多态引入你的代码中。使用 Multimethods，你可以通过定义一个<em>调度函数</em>将一个名字与多个实现联系起来，该函数产生<em>调度值</em>，用来决定使用哪个<em>方法</em>。调度函数就像餐厅里的主人。主人会问你一些问题，比如 &ldquo;你有预订吗？&ldquo;和 &ldquo;聚会人数？"，然后给你安排相应的座位。同样，当你调用一个 Multimethods 时，调度函数将询问参数，并将它们发送到正确的方法，正如这个例子所显示的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(ns were-creatures)
</span></span><span class=line><span class=cl>➊ (defmulti full-moon-behavior (fn [were-creature] (:were-type were-creature)))
</span></span><span class=line><span class=cl>➋ (defmethod full-moon-behavior :wolf
</span></span><span class=line><span class=cl>  [were-creature]
</span></span><span class=line><span class=cl>  (str (:name were-creature) &#34; will howl and murder&#34;))
</span></span><span class=line><span class=cl>➌ (defmethod full-moon-behavior :simmons
</span></span><span class=line><span class=cl>  [were-creature]
</span></span><span class=line><span class=cl>  (str (:name were-creature) &#34; will encourage people and sweat to the oldies&#34;))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(full-moon-behavior {:were-type :wolf
</span></span><span class=line><span class=cl>➍                      :name &#34;Rachel from next door&#34;})
</span></span><span class=line><span class=cl>; =&gt; &#34;Rachel from next door will howl and murder&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(full-moon-behavior {:name &#34;Andy the baker&#34;
</span></span><span class=line><span class=cl>➎                      :were-type :simmons})
</span></span><span class=line><span class=cl>; =&gt; &#34;Andy the baker will encourage people and sweat to the oldies&#34;
</span></span></code></pre></td></tr></table></div></div><p>这个 Multimethods 显示了你如何定义不同种类的狼人生物的满月行为。大家都知道狼人变成了狼，到处嚎叫着杀人。一种不太知名的狼人，即狼-西蒙斯，变成理查德-西蒙斯，烫着头发，到处跑，鼓励人们做最好的自己，为老人们流汗。你不想被这两种生物咬到，否则你就会变成它们。</p><p><img src=https://www.braveclojure.com/assets/images/cftbat/multimethods-records-protocols/weresimmons.png loading=lazy></p><p>我们在➊处创建 Multimethods。这告诉 Clojure，&ldquo;嘿，创建一个名为<code>full-moon-behavior'的新Multimethods。每当有人调用</code>full-moon-behavior<code>时，在参数上运行调度函数</code>(fn [were-creature] (:were-type were-creature))`。使用该函数的结果，也就是调度值，来决定使用哪个具体方法！&rdquo;</p><p>接下来，我们定义了两个方法，一个是当调度函数返回的值是➋的<code>:wolf</code>时，另一个是当它是➌的<code>:simmons</code>时。方法定义看起来很像函数定义，但主要的区别是，方法名称后面紧跟着<em>dispatch 值</em>。 <code>:wolf</code>和<code>:simmons</code>都是<em>dispatch 值</em>。这与调度*值不同，后者是调度函数的返回值。完整的调度序列是这样的。</p><ol><li>形式<code>(full-moon-behavior {:wer-type :wolf :name "Rachel from next door"})</code>被求值。</li><li>运行<code>full-moon-behavior</code>的调度函数，返回<code>:wolf</code>作为调度值。</li><li>Clojure 将调度值<code>:wolf</code>与为<code>full-moon-behavior</code>定义的所有方法的调度值相比较。这些调度值是<code>:wolf</code>和<code>:simmons</code>。</li><li>因为调度值<code>:wolf</code>等于调度值<code>:wolf</code>，所以<code>:wolf</code>的算法运行。</li></ol><p>不要让术语把你绊倒! 主要的想法是，调度函数返回一些值，这个值被用来决定使用哪个方法定义。</p><p>回到我们的例子! 接下来我们调用该方法两次。在➍处，调度函数返回值&rdquo;:wolf&rdquo;，并使用相应的方法，通知你 &ldquo;隔壁的 Rachel 将嚎叫并杀人&rdquo;。在➏，该函数的行为类似，只是<code>:simmons</code>是调度值。</p><p>你可以定义一个以<code>nil</code>为调度值的方法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(defmethod full-moon-behavior nil
</span></span><span class=line><span class=cl>  [were-creature]
</span></span><span class=line><span class=cl>  (str (:name were-creature) &#34; will stay at home and eat ice cream&#34;))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(full-moon-behavior {:were-type nil
</span></span><span class=line><span class=cl>                     :name &#34;Martin the nurse&#34;})
</span></span><span class=line><span class=cl>; =&gt; &#34;Martin the nurse will stay at home and eat ice cream&#34;
</span></span></code></pre></td></tr></table></div></div><p>当你这次调用<code>full-moon-behavior</code>时，你给它的参数<code>:wer-type</code>是<code>nil</code>，所以对应于<code>nil</code>的方法被求值，你被告知`&ldquo;护士 Martin 将呆在家里吃冰淇淋&rdquo;。</p><p>你也可以通过指定<code>:default</code>作为调度值，定义一个默认方法，在没有其他方法匹配的情况下使用。在这个例子中，给出的参数的<code>:were-type</code>与之前定义的方法都不匹配，所以使用了默认方法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(defmethod full-moon-behavior :default
</span></span><span class=line><span class=cl>  [were-creature]
</span></span><span class=line><span class=cl>  (str (:name were-creature) &#34; will stay up all night fantasy footballing&#34;))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(full-moon-behavior {:were-type :office-worker
</span></span><span class=line><span class=cl>                     :name &#34;Jimmy from sales&#34;})
</span></span><span class=line><span class=cl>; =&gt; &#34;Jimmy from sales will stay up all night fantasy footballing&#34;
</span></span></code></pre></td></tr></table></div></div><p>Multimethods 的一个很酷的地方是，你可以随时添加新的方法。如果你发布了一个包括<code>wer-creatures</code>命名空间的库，其他人可以继续扩展 Multimethods 来处理新的派发值。这个例子显示，你创建了自己的随机命名空间并包括了<code>wer-creatures</code>命名空间，然后为<code>full-moon-behavior</code>Multimethods 定义了另一个方法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(ns random-namespace
</span></span><span class=line><span class=cl>  (:require [were-creatures]))
</span></span><span class=line><span class=cl>(defmethod were-creatures/full-moon-behavior :bill-murray
</span></span><span class=line><span class=cl>  [were-creature]
</span></span><span class=line><span class=cl>  (str (:name were-creature) &#34; will be the most likeable celebrity&#34;))
</span></span><span class=line><span class=cl>(were-creatures/full-moon-behavior {:name &#34;Laura the intern&#34; 
</span></span><span class=line><span class=cl>                                    :were-type :bill-murray})
</span></span><span class=line><span class=cl>; =&gt; &#34;Laura the intern will be the most likeable celebrity&#34;
</span></span></code></pre></td></tr></table></div></div><p>你的调度函数可以使用它的任何或所有参数返回任意的值。下一个例子定义了一个 Multimethods，它接收两个参数，并返回一个包含每个参数类型的 Vector。它还定义了该方法的一个实现，当每个参数都是字符串时，该方法将被调用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(ns user)
</span></span><span class=line><span class=cl>(defmulti types (fn [x y] [(class x) (class y)]))
</span></span><span class=line><span class=cl>(defmethod types [java.lang.String java.lang.String]
</span></span><span class=line><span class=cl>  [x y]
</span></span><span class=line><span class=cl>  &#34;Two strings!&#34;)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(types &#34;String 1&#34; &#34;String 2&#34;)
</span></span><span class=line><span class=cl>; =&gt; &#34;Two strings!&#34;
</span></span></code></pre></td></tr></table></div></div><p>顺便说一下，这就是为什么它们被称为<em>multi</em>methods：它们允许对多个参数进行调度。我没有经常使用这个功能，但我可以看到它被用于角色扮演游戏中，根据法师的主要魔法学校和他的魔法专长来编写方法。无论如何，有它而不需要它总比需要它而没有它好。</p><p>注意 Multimethods 也允许分层调度。Clojure 可以让你建立自定义的层次结构，我不会介绍这些，但你可以通过阅读<a class=link href=http://clojure.org/multimethods/ target=_blank rel=noopener>http://clojure.org/multimethods/</a> 的文档来了解它们。</p><h3 id=协议>协议</h3><p>在大约 93.58%的情况下，你会希望根据参数的类型来调度方法。例如，<code>count</code>需要对 Vector 使用不同的方法，而不是对 map 或 list 使用不同的方法。尽管可以用 Multimethods 进行类型调度，但<em>协议</em>是为类型调度而优化的。它们比 Multimethods 更有效，而且 Clojure 让你很容易简洁地指定协议的实现。</p><p>Multimethods 只是一个多态的操作，而协议是一个<em>集合</em>的一个或多个多态操作。协议操作被称为方法，就像 Multimethods 操作一样。与 Multimethods 不同的是，Multimethods 对调度函数返回的任意值进行调度，而协议方法是根据第一个参数的类型进行调度，如本例所示。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(ns data-psychology)
</span></span><span class=line><span class=cl>➊(defprotocol ➋Psychodynamics
</span></span><span class=line><span class=cl>  ➌&#34;Plumb the inner depths of your data types&#34;
</span></span><span class=line><span class=cl>  ➍(thoughts [x] &#34;The data type&#39;s innermost thoughts&#34;)
</span></span><span class=line><span class=cl>  ➎(feelings-about [x] [x y] &#34;Feelings about self or other&#34;))
</span></span></code></pre></td></tr></table></div></div><p>首先，在➊有<code>defprotocol</code>。这需要一个名字，<code>Psychodynamics</code> ➋，和一个可选的文件串，<code>"探究你的数据类型的内部深度"</code>➌。接下来是方法签名。一个<em>方法签名</em>由一个名称、一个参数说明和一个可选的文档串组成。第一个方法签名被命名为<code>thoughts</code>➍，只能接受一个参数。第二个名为<code>feelings-about</code>➎，可以接受一个或两个参数。协议有一个限制：方法不能有其余参数。所以像下面这样的行是不允许的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(feels-about [x] [x &amp; others])
</span></span></code></pre></td></tr></table></div></div><p>通过定义一个协议，你在定义一个抽象，但你还没有定义如何实现这个抽象。这就像你为行为保留了名字（在这个例子中，你保留了<code>思想</code>和<code>感觉-关于</code>），但你还没有定义具体的行为。如果你要求值<code>(thoughts "blorb")</code>，你会得到一个异常，内容是：&ldquo;没有为 java.lang.String 类找到方法的实现：protocol: data-psychology/psychodynamics 的 thoughts。&rdquo; 协议是根据第一个参数的类型分配的，所以当你调用<code>(thoughts "blorb")</code>时，Clojure 试图为字符串查找<code>thoughts</code>方法的实现，但失败了。</p><p>你可以通过<em>扩展</em>字符串数据类型来<em>实现</em><code>Psychodynamics</code>协议来解决这一遗憾。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>➊ (extend-type java.lang.String
</span></span><span class=line><span class=cl>➋   Psychodynamics
</span></span><span class=line><span class=cl>➌   (thoughts [x] (str x &#34; thinks, &#39;Truly, the character defines the data type&#39;&#34;)
</span></span><span class=line><span class=cl>➍   (feelings-about
</span></span><span class=line><span class=cl>    ([x] (str x &#34; is longing for a simpler way of life&#34;))
</span></span><span class=line><span class=cl>    ([x y] (str x &#34; is envious of &#34; y &#34;&#39;s simpler way of life&#34;))))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(thoughts &#34;blorb&#34;)
</span></span><span class=line><span class=cl>➎ ; =&gt; &#34;blorb thinks, &#39;Truly, the character defines the data type&#39;&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(feelings-about &#34;schmorb&#34;)
</span></span><span class=line><span class=cl>; =&gt; &#34;schmorb is longing for a simpler way of life&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(feelings-about &#34;schmorb&#34; 2)
</span></span><span class=line><span class=cl>; =&gt; &#34;schmorb is envious of 2&#39;s simpler way of life&#34;
</span></span></code></pre></td></tr></table></div></div><p><code>extend-type</code>后面是你想扩展的类或类型的名称和你想让它支持的协议&ndash;在这个例子中，你在➊处指定了类<code>java.lang.String</code>和你想让它支持的协议<code>Psychodynamics</code>，在➋。之后，你在➌为 &ldquo;thoughts &ldquo;方法和➍为 &ldquo;feelings-about &ldquo;方法提供一个实现。如果你要扩展一个类型来实现一个协议，你必须实现协议中的每一个方法，否则 Clojure 会抛出一个异常。在这种情况下，你不能只实现<code>思想'或只实现</code>感觉&rsquo;；你必须同时实现这两种方法。</p><p>注意，这些方法的实现不像 Multimethods 那样以<code>defmethod</code>开头。事实上，它们看起来类似于函数定义，只是没有<code>defn'。要定义一个方法的实现，你要写一个以方法名称开头的表格，像</code>thoughts&rsquo;，然后提供一个参数 Vector 和方法的主体。这些方法也允许重载，就像函数一样，你定义多重性的方法实现与多重性的函数类似。你可以在➍的 &ldquo;feelings-about &ldquo;实现中看到这一点。</p><p>在你扩展了<code>java.lang.String</code>类型以实现<code>Psychodynamics</code>协议后，Clojure 知道如何调度调用<code>(thoughts "blorb")</code>，你会在➎得到字符串`&ldquo;blorb thinks, &lsquo;Truly, the character defines the data type&rsquo;"。</p><p>如果你想提供一个默认的实现，就像你对 multimethods 所做的那样呢？要做到这一点，你可以扩展<code>java.lang.Object</code>。这样做是因为 Java（也就是 Clojure）中的每个类型都是<code>java.lang.Object</code>的后代。如果这不是很有意义（也许是因为你不熟悉面向对象的编程），不要担心，只要知道它是有效的。下面是你如何使用这个技术为<code>Psychodynamics</code>协议提供一个默认实现。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(extend-type java.lang.Object
</span></span><span class=line><span class=cl>  Psychodynamics
</span></span><span class=line><span class=cl>  (thoughts [x] &#34;Maybe the Internet is just a vector for toxoplasmosis&#34;)
</span></span><span class=line><span class=cl>  (feelings-about
</span></span><span class=line><span class=cl>    ([x] &#34;meh&#34;)
</span></span><span class=line><span class=cl>    ([x y] (str &#34;meh about &#34; y))))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(thoughts 3)
</span></span><span class=line><span class=cl>; =&gt; &#34;Maybe the Internet is just a vector for toxoplasmosis&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(feelings-about 3)
</span></span><span class=line><span class=cl>; =&gt; &#34;meh&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(feelings-about 3 &#34;blorb&#34;)
</span></span><span class=line><span class=cl>; =&gt; &#34;meh about blorb&#34;
</span></span></code></pre></td></tr></table></div></div><p>因为我们还没有为数字定义一个<code>心理动力学'的实现，Clojure将对</code>思想&rsquo;和<code>感觉-关于'的调用分派给为</code>java.lang.Object&rsquo;定义的实现。</p><p>你可以使用<code>extend-protocol'来代替多次调用</code>extend-type&rsquo;来扩展多个类型，它可以让你一次为多个类型定义协议实现。下面是你如何定义前面的协议实现。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(extend-protocol Psychodynamics
</span></span><span class=line><span class=cl>  java.lang.String
</span></span><span class=line><span class=cl>  (thoughts [x] &#34;Truly, the character defines the data type&#34;)
</span></span><span class=line><span class=cl>  (feelings-about
</span></span><span class=line><span class=cl>    ([x] &#34;longing for a simpler way of life&#34;)
</span></span><span class=line><span class=cl>    ([x y] (str &#34;envious of &#34; y &#34;&#39;s simpler way of life&#34;)))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  java.lang.Object
</span></span><span class=line><span class=cl>  (thoughts [x] &#34;Maybe the Internet is just a vector for toxoplasmosis&#34;)
</span></span><span class=line><span class=cl>  (feelings-about
</span></span><span class=line><span class=cl>    ([x] &#34;meh&#34;)
</span></span><span class=line><span class=cl>    ([x y] (str &#34;meh about &#34; y))))
</span></span></code></pre></td></tr></table></div></div><p>你可能会发现这个技术比使用<code>extend-type</code>更方便。然后，你也可能不觉得。<code>extend-type</code>让你感觉如何？<code>extend-protocol</code>怎么样？来坐在这个沙发上，告诉我这一切。</p><p>值得注意的是，一个协议的方法 &ldquo;属于 &ldquo;它们所定义的命名空间。在这些例子中，&ldquo;心理动力学 &ldquo;方法的完全限定名称是 &ldquo;数据-心理学/想法 &ldquo;和 &ldquo;数据-心理学/感觉-关于&rdquo;。如果你有面向对象的背景，这可能看起来很奇怪，因为方法属于 OOP 中的数据类型。但不要吓坏了! 这只是 Clojure 赋予抽象优先权的另一种方式。这个事实的一个后果是，如果你想让两个不同的协议包括具有相同名称的方法，你需要把协议放在不同的命名空间中。</p><h2 id=记录>记录</h2><p>Clojure 允许你创建<em>records</em>，它是自定义的、类似 Map 的数据类型。它们类似于 Map，因为它们将键和值联系起来，你可以像使用 Map 一样查询它们的值，而且它们像 Map 一样是不可改变的。它们的不同之处在于，你为记录指定*字段。字段是数据的槽；使用它们就像指定一个数据结构应该有哪些键。记录也与 Map 不同，你可以扩展它们来实现协议。</p><p>要创建一个记录，你可以使用<code>defrecord</code>来指定它的名字和字段。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(ns were-records)
</span></span><span class=line><span class=cl>(defrecord WereWolf [name title])
</span></span></code></pre></td></tr></table></div></div><p>这个记录的名字是<code>WereWolf</code>，它的两个字段是<code>name</code>和<code>title</code>。你可以通过三种方式创建这个记录的实例。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>➊ (WereWolf. &#34;David&#34; &#34;London Tourist&#34;)
</span></span><span class=line><span class=cl>; =&gt; #were_records.WereWolf{:name &#34;David&#34;, :title &#34;London Tourist&#34;}.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>➋ (-&gt;WereWolf &#34;Jacob&#34; &#34;Lead Shirt Discarder&#34;)
</span></span><span class=line><span class=cl>; =&gt; #were_records.WereWolf{:name &#34;Jacob&#34;, :title &#34;Lead Shirt Discarder&#34;}。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>➌ (map-&gt;WereWolf {:name &#34;Lucian&#34; :title &#34;CEO of Melodrama&#34;})
</span></span><span class=line><span class=cl>; =&gt; #were_records.WereWolf{:name &#34;Lucian&#34;, :title &#34;CEO of Melodrama&#34;}.
</span></span></code></pre></td></tr></table></div></div><p>在➊，我们以创建 Java 对象的方式创建一个实例，使用类实例化的互操作调用。(<em>Interop</em>指的是在 Clojure 中与本地 Java 结构交互的能力)。请注意，参数必须遵循与字段定义相同的顺序。这样做的原因是，记录实际上是被掩盖的 Java 类。</p><p>➋的实例看起来与➊的实例几乎相同，但关键的区别在于<code>->WereWolf</code>是一个函数。当你创建一条记录时，工厂函数<code>-></code>RecordName 和<code>map-></code>RecordName 会自动创建。在➌，<code>map->WereWolf</code>接收一个 map 作为参数，其关键字与记录类型的字段相对应，并返回一个记录。</p><p>如果你想使用其他命名空间的记录类型，你必须导入它，就像你在第 12 章中对 Java 类所做的那样。请注意将命名空间中的所有破折号替换为下划线。这个简单的例子显示了如何在另一个命名空间导入<code>WereWolf</code>记录类型。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(ns monster-mash
</span></span><span class=line><span class=cl>  (:import [were_records WereWolf])
</span></span><span class=line><span class=cl>(WereWolf. &#34;David&#34; &#34;London Tourist&#34;)
</span></span><span class=line><span class=cl>; =&gt; #were_records.WereWolf{:name &#34;David&#34;, :title &#34;London Tourist&#34;}
</span></span></code></pre></td></tr></table></div></div><p>注意，<code>were_records</code>有一个下划线，而不是破折号。</p><p>你可以用查询 Map 值的方式查询记录值，也可以使用 Java 字段访问互操作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(def jacob (-&gt;WereWolf &#34;Jacob&#34; &#34;Lead Shirt Discarder&#34;)
</span></span><span class=line><span class=cl>➊ (.name jacob) 
</span></span><span class=line><span class=cl>; =&gt; &#34;Jacob&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>➋ (:name jacob) 
</span></span><span class=line><span class=cl>; =&gt; &#34;Jacob&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>➌ (get jacob :name) 
</span></span><span class=line><span class=cl>;=&gt; &#34;Jacob&#34;
</span></span></code></pre></td></tr></table></div></div><p>第一个例子<code>(.name jacob)</code>在➊，使用了 Java 互操作，➋和➌的例子访问<code>:name</code>的方式与使用 map 相同。</p><p>当测试相等时，Clojure 将检查所有字段是否相等，以及两个比较体是否具有相同的类型。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>➊ (= jacob (-&gt;WereWolf &#34;Jacob&#34; &#34;Lead Shirt Discarder&#34;))
</span></span><span class=line><span class=cl>; =&gt; true
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>➋ (= jacob (WereWolf. &#34;David&#34; &#34;London Tourist&#34;))
</span></span><span class=line><span class=cl>; =&gt; false
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>➌ (= jacob {:name &#34;Jacob&#34; :title &#34;Lead Shirt Discarder&#34;})
</span></span><span class=line><span class=cl>; =&gt; false
</span></span></code></pre></td></tr></table></div></div><p>➊处的测试返回<code>true</code>，因为<code>jacob'和新创建的记录是同一类型，并且它们的字段是相等的。➋处的测试返回 "false"，因为字段不相等。最后在➌处的测试返回 "false"，因为两个比较对象的类型不一样。</code>jacob&rsquo;是一个`WereWolf&rsquo;记录，而另一个参数是一个 Map。</p><p>任何你能在 Map 上使用的函数，你也能在记录上使用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(assoc jacob :title &#34;Lead Third Wheel&#34;)
</span></span><span class=line><span class=cl>; =&gt; #were_records.WereWolf{:name &#34;Jacob&#34;, :title &#34;Lead Third Wheel&#34;}。
</span></span></code></pre></td></tr></table></div></div><p>然而，如果你<code>dissoc</code>一个字段，结果的类型将是一个普通的&rsquo;Clojure map；它将不会有与原始记录相同的数据类型。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(dissoc jacob :title)
</span></span><span class=line><span class=cl>; =&gt; {:name &#34;Jacob&#34;} &lt;- that&#39;s not a were_records.WereWolf
</span></span></code></pre></td></tr></table></div></div><p>这至少有两个原因：第一，访问 Map 值比访问记录值要慢，所以如果你要建立一个高性能的程序，就要注意了。第二，当你创建一个新的记录类型时，你可以扩展它来实现一个协议，类似于你之前使用<code>extend-type</code>扩展一个类型。如果你<code>dissoc</code>一个记录，然后试图在结果上调用一个协议方法，记录的协议方法就不会被调用。</p><p>下面是你在定义记录时如何扩展一个协议。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>➊ (defprotocol WereCreature
</span></span><span class=line><span class=cl>➋   (full-moon-behavior [x]))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>➌ (defrecord WereWolf [name title]
</span></span><span class=line><span class=cl>  WereCreature
</span></span><span class=line><span class=cl>  (full-moon-behavior [x]
</span></span><span class=line><span class=cl>    (str name &#34; will howl and murder&#34;)))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(full-moon-behavior (map-&gt;WereWolf {:name &#34;Lucian&#34; :title &#34;CEO of Melodrama&#34;}))
</span></span><span class=line><span class=cl>; =&gt; &#34;Lucian will howl and murder&#34;
</span></span></code></pre></td></tr></table></div></div><p>我们创建了一个新的协议，<code>WereCreature</code> ➊，有一个方法，<code>full-moon-behavior</code> ➋。在➌，<code>defrecord</code>为<code>WereWolf</code>实现了<code>WereCreature</code>。在<code>full-moon-behavior</code>实现中最有趣的部分是你可以访问<code>name</code>。你还可以访问<code>title'和任何其他可能为你的记录定义的字段。你也可以使用</code>extend-type<code>和</code>extend-protocol`来扩展记录。</p><p>你什么时候应该使用记录，什么时候应该使用 Map？一般来说，如果你发现自己在创建 Map 时反复使用相同的字段，你应该考虑使用记录。这告诉你，这组数据代表了你的应用程序领域的信息，如果你提供一个基于你试图建模的概念的名称，你的代码将更好地传达其目的。不仅如此，记录访问比 Map 访问更有表现力，所以你的程序会变得更有效率一些。最后，如果你想使用协议，你就需要创建一个记录。</p><h2 id=进一步研究>进一步研究</h2><p>Clojure 提供了其他的工具来处理抽象和数据类型。这些工具，我认为是高级的，包括<code>deftype</code>，<code>reify</code>，和<code>proxy</code>。如果你有兴趣了解更多，请查看*<a class=link href=http://clojure.org/reference/datatypes/ target=_blank rel=noopener>http://clojure.org/datatypes/</a>*上关于数据类型的文档。</p><h2 id=总结>总结</h2><p>Clojure 的设计原则之一就是要写到抽象。在本章中，你学到了如何使用 Multimethods 和原型来定义你自己的抽象概念。这些结构提供了多态，允许同一个操作根据它的参数有不同的表现。你还学会了如何用<code>defrecord</code>创建和使用自己的关联数据类型，以及如何扩展记录来实现协议。</p><p>当我刚开始学习 Clojure 时，我对使用 Multimethods、协议和记录感到很害羞。然而，它们在 Clojure 库中经常被使用，所以了解它们的工作原理是很好的。一旦你掌握了它们，它们会帮助你写出更干净的代码。</p><h2 id=练习>练习</h2><ol><li>扩展<code>full-moon-behavior</code>Multimethods，为你自己的 were-creature 类型添加行为。</li><li>创建一个<code>WereSimmons</code>记录类型，然后扩展<code>WereCreature</code>协议。</li><li>创建你自己的协议，然后使用<code>extend-type</code>和<code>extend-protocol</code>来扩展它。</li><li>创建一个角色扮演游戏，使用多重调度来实现行为。</li></ol></section><footer class=article-footer><section class=article-tags><a href=/tags/clojure/>clojure</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><div class=disqus-container><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{DISQUS&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
1993 -
2022 演示站点</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.10.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#多态>多态</a><ol><li><a href=#multimethods>Multimethods</a></li><li><a href=#协议>协议</a></li></ol></li><li><a href=#记录>记录</a></li><li><a href=#进一步研究>进一步研究</a></li><li><a href=#总结>总结</a></li><li><a href=#练习>练习</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>