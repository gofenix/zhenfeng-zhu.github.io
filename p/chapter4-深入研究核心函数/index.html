<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="核心函数的深入研究 如果你像我一样是焦虑的、以青少年为中心的准肥皂剧*《吸血鬼日记》*的超级粉丝，你一定记得主角埃琳娜开始质疑她苍白的、神秘的暗恋者的行为的那一集。&amp;ldquo;为什么当我的膝盖被刮伤时，他立刻消失得无影无踪？&amp;ldquo;和 &amp;ldquo;为什么当我的手指被划破时，他的脸变成了一个怪异的死亡面具？&amp;ldquo;等等。
如果你已经开始把玩 Clojure 的核心函数，你可能也会问自己类似的问题。&amp;ldquo;为什么map会返回一个列表，而我给它的是一个 Vector？&amp;ldquo;和 &amp;ldquo;为什么reduce会把我的 map 当成一个 Vector？&amp;ldquo;等等。(不过，有了 Clojure，你至少可以免于思考作为一个 17 岁孩子的深刻的存在恐惧，直到永远）。
在这一章中，你将了解到 Clojure 的深邃、黑暗、嗜血、超自然的cough，我的意思是，在这一章中，你将了解到 Clojure 的抽象的基本概念以及序列和集合的抽象。你还会了解到疯狂的序列。这将为你提供所需的基础，使你能够阅读你以前没有使用过的函数的文档，并理解当你试着使用它们时发生了什么。
接下来，你将获得更多关于你最需要使用的函数的经验。你将学习如何用函数map、reduce、into、conj、concat、some、filter、take、drop、sort、sort-by和identity来处理列表、Vector、Map 和 Set。你还将学习如何用apply、partial和complement创建新的函数。所有这些信息将帮助你了解如何以 Clojure 的方式做事，它将为你编写自己的代码以及阅读和学习他人的项目打下坚实的基础。
最后，你将学会如何解析和查询 CSV 中的吸血鬼数据，以确定在你的家乡潜伏着哪些诺斯费拉图。
从编程到抽象 为了理解从编程到抽象，让我们把 Clojure 与一种没有考虑到这个原则的语言进行比较。Emacs Lisp（elisp）。在 elisp 中，你可以使用mapcar函数来导出一个新的列表，这与你在 Clojure 中使用map的方式相似。然而，如果你想在 elisp 中 Map 一个哈希 Map（类似于 Clojure 的 map 数据结构），你需要使用maphash函数，而在 Clojure 中你仍然可以只使用map。换句话说，elisp 使用两个不同的、针对数据结构的函数来实现map操作，而 Clojure 只使用一个。你也可以在 Clojure 中对 map 调用reduce，而 elisp 并没有提供一个函数来减少散列 map。
原因是 Clojure 在序列抽象方面定义了map和reduce函数，而不是在具体的数据结构方面。只要数据结构响应核心序列操作（函数first、rest和cons，我们稍后会仔细研究），它就能与map、reduce以及其他大量的序列函数免费工作。这就是 Clojurists 所说的抽象编程，也是 Clojure 哲学的一个核心原则。
我认为抽象是操作的命名集合。如果你能在一个对象上执行一个抽象的所有操作，那么这个对象就是该抽象的一个实例。我甚至在编程之外也是这样想的。例如，电池抽象包括 &amp;ldquo;将导电介质连接到其阳极和阴极 &amp;ldquo;的操作，而该操作的输出是电流。电池是用锂还是用土豆做的并不重要。只要它对定义电池的一系列操作做出反应，它就是一个电池。
同样地，map并不关心列表、Vector、Set 和 Map 是如何实现的。它只关心它是否能对它们进行序列操作。让我们看看map是如何在序列抽象中定义的，这样你就能理解一般的抽象编程。"><title>Chapter4 深入研究核心函数</title><link rel=canonical href=https://example.com/p/chapter4-%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0/><link rel=stylesheet href=/scss/style.min.b80bf249ce4a22cf55e8d7340a0b37a2f2c10f54f3a9a49cb94b694a2eb0bbea.css><meta property="og:title" content="Chapter4 深入研究核心函数"><meta property="og:description" content="核心函数的深入研究 如果你像我一样是焦虑的、以青少年为中心的准肥皂剧*《吸血鬼日记》*的超级粉丝，你一定记得主角埃琳娜开始质疑她苍白的、神秘的暗恋者的行为的那一集。&amp;ldquo;为什么当我的膝盖被刮伤时，他立刻消失得无影无踪？&amp;ldquo;和 &amp;ldquo;为什么当我的手指被划破时，他的脸变成了一个怪异的死亡面具？&amp;ldquo;等等。
如果你已经开始把玩 Clojure 的核心函数，你可能也会问自己类似的问题。&amp;ldquo;为什么map会返回一个列表，而我给它的是一个 Vector？&amp;ldquo;和 &amp;ldquo;为什么reduce会把我的 map 当成一个 Vector？&amp;ldquo;等等。(不过，有了 Clojure，你至少可以免于思考作为一个 17 岁孩子的深刻的存在恐惧，直到永远）。
在这一章中，你将了解到 Clojure 的深邃、黑暗、嗜血、超自然的cough，我的意思是，在这一章中，你将了解到 Clojure 的抽象的基本概念以及序列和集合的抽象。你还会了解到疯狂的序列。这将为你提供所需的基础，使你能够阅读你以前没有使用过的函数的文档，并理解当你试着使用它们时发生了什么。
接下来，你将获得更多关于你最需要使用的函数的经验。你将学习如何用函数map、reduce、into、conj、concat、some、filter、take、drop、sort、sort-by和identity来处理列表、Vector、Map 和 Set。你还将学习如何用apply、partial和complement创建新的函数。所有这些信息将帮助你了解如何以 Clojure 的方式做事，它将为你编写自己的代码以及阅读和学习他人的项目打下坚实的基础。
最后，你将学会如何解析和查询 CSV 中的吸血鬼数据，以确定在你的家乡潜伏着哪些诺斯费拉图。
从编程到抽象 为了理解从编程到抽象，让我们把 Clojure 与一种没有考虑到这个原则的语言进行比较。Emacs Lisp（elisp）。在 elisp 中，你可以使用mapcar函数来导出一个新的列表，这与你在 Clojure 中使用map的方式相似。然而，如果你想在 elisp 中 Map 一个哈希 Map（类似于 Clojure 的 map 数据结构），你需要使用maphash函数，而在 Clojure 中你仍然可以只使用map。换句话说，elisp 使用两个不同的、针对数据结构的函数来实现map操作，而 Clojure 只使用一个。你也可以在 Clojure 中对 map 调用reduce，而 elisp 并没有提供一个函数来减少散列 map。
原因是 Clojure 在序列抽象方面定义了map和reduce函数，而不是在具体的数据结构方面。只要数据结构响应核心序列操作（函数first、rest和cons，我们稍后会仔细研究），它就能与map、reduce以及其他大量的序列函数免费工作。这就是 Clojurists 所说的抽象编程，也是 Clojure 哲学的一个核心原则。
我认为抽象是操作的命名集合。如果你能在一个对象上执行一个抽象的所有操作，那么这个对象就是该抽象的一个实例。我甚至在编程之外也是这样想的。例如，电池抽象包括 &amp;ldquo;将导电介质连接到其阳极和阴极 &amp;ldquo;的操作，而该操作的输出是电流。电池是用锂还是用土豆做的并不重要。只要它对定义电池的一系列操作做出反应，它就是一个电池。
同样地，map并不关心列表、Vector、Set 和 Map 是如何实现的。它只关心它是否能对它们进行序列操作。让我们看看map是如何在序列抽象中定义的，这样你就能理解一般的抽象编程。"><meta property="og:url" content="https://example.com/p/chapter4-%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0/"><meta property="og:site_name" content="演示站点"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="clojure"><meta property="article:published_time" content="2022-01-13T17:39:28+08:00"><meta property="article:modified_time" content="2022-01-13T17:39:28+08:00"><meta name=twitter:title content="Chapter4 深入研究核心函数"><meta name=twitter:description content="核心函数的深入研究 如果你像我一样是焦虑的、以青少年为中心的准肥皂剧*《吸血鬼日记》*的超级粉丝，你一定记得主角埃琳娜开始质疑她苍白的、神秘的暗恋者的行为的那一集。&amp;ldquo;为什么当我的膝盖被刮伤时，他立刻消失得无影无踪？&amp;ldquo;和 &amp;ldquo;为什么当我的手指被划破时，他的脸变成了一个怪异的死亡面具？&amp;ldquo;等等。
如果你已经开始把玩 Clojure 的核心函数，你可能也会问自己类似的问题。&amp;ldquo;为什么map会返回一个列表，而我给它的是一个 Vector？&amp;ldquo;和 &amp;ldquo;为什么reduce会把我的 map 当成一个 Vector？&amp;ldquo;等等。(不过，有了 Clojure，你至少可以免于思考作为一个 17 岁孩子的深刻的存在恐惧，直到永远）。
在这一章中，你将了解到 Clojure 的深邃、黑暗、嗜血、超自然的cough，我的意思是，在这一章中，你将了解到 Clojure 的抽象的基本概念以及序列和集合的抽象。你还会了解到疯狂的序列。这将为你提供所需的基础，使你能够阅读你以前没有使用过的函数的文档，并理解当你试着使用它们时发生了什么。
接下来，你将获得更多关于你最需要使用的函数的经验。你将学习如何用函数map、reduce、into、conj、concat、some、filter、take、drop、sort、sort-by和identity来处理列表、Vector、Map 和 Set。你还将学习如何用apply、partial和complement创建新的函数。所有这些信息将帮助你了解如何以 Clojure 的方式做事，它将为你编写自己的代码以及阅读和学习他人的项目打下坚实的基础。
最后，你将学会如何解析和查询 CSV 中的吸血鬼数据，以确定在你的家乡潜伏着哪些诺斯费拉图。
从编程到抽象 为了理解从编程到抽象，让我们把 Clojure 与一种没有考虑到这个原则的语言进行比较。Emacs Lisp（elisp）。在 elisp 中，你可以使用mapcar函数来导出一个新的列表，这与你在 Clojure 中使用map的方式相似。然而，如果你想在 elisp 中 Map 一个哈希 Map（类似于 Clojure 的 map 数据结构），你需要使用maphash函数，而在 Clojure 中你仍然可以只使用map。换句话说，elisp 使用两个不同的、针对数据结构的函数来实现map操作，而 Clojure 只使用一个。你也可以在 Clojure 中对 map 调用reduce，而 elisp 并没有提供一个函数来减少散列 map。
原因是 Clojure 在序列抽象方面定义了map和reduce函数，而不是在具体的数据结构方面。只要数据结构响应核心序列操作（函数first、rest和cons，我们稍后会仔细研究），它就能与map、reduce以及其他大量的序列函数免费工作。这就是 Clojurists 所说的抽象编程，也是 Clojure 哲学的一个核心原则。
我认为抽象是操作的命名集合。如果你能在一个对象上执行一个抽象的所有操作，那么这个对象就是该抽象的一个实例。我甚至在编程之外也是这样想的。例如，电池抽象包括 &amp;ldquo;将导电介质连接到其阳极和阴极 &amp;ldquo;的操作，而该操作的输出是电流。电池是用锂还是用土豆做的并不重要。只要它对定义电池的一系列操作做出反应，它就是一个电池。
同样地，map并不关心列表、Vector、Set 和 Map 是如何实现的。它只关心它是否能对它们进行序列操作。让我们看看map是如何在序列抽象中定义的，这样你就能理解一般的抽象编程。"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_huda2458f72ce188392d75c5d51cd8e24e_373_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>演示站点</a></h1><h2 class=site-description>软件工程师 编程小语种爱好者，精通各种语言的hello world，目前沉迷Clojure、elixir Get Started工程师，止步于大量框架和包的readme 后端开发工程师，偶尔写一些前端，伪全栈 也是一名数据工程师，朝着SQL Boy进化</h2></div></header><ol class=social-menu><li><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank title=GitHub><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><div class=menu-bottom-section><li id=i18n-switch><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg><select name=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://example.com/en/>English</option><option value=https://example.com/ selected>中文</option><option value=https://example.com/ar/>عربي</option></select></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></div></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/p/chapter4-%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0/>Chapter4 深入研究核心函数</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Jan 13, 2022</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 14 分钟</time></div></footer></div></header><section class=article-content><h1 id=核心函数的深入研究>核心函数的深入研究</h1><p>如果你像我一样是焦虑的、以青少年为中心的准肥皂剧*《吸血鬼日记》*的超级粉丝，你一定记得主角埃琳娜开始质疑她苍白的、神秘的暗恋者的行为的那一集。&ldquo;为什么当我的膝盖被刮伤时，他立刻消失得无影无踪？&ldquo;和 &ldquo;为什么当我的手指被划破时，他的脸变成了一个怪异的死亡面具？&ldquo;等等。</p><p>如果你已经开始把玩 Clojure 的核心函数，你可能也会问自己类似的问题。&ldquo;为什么<code>map</code>会返回一个列表，而我给它的是一个 Vector？&ldquo;和 &ldquo;为什么<code>reduce</code>会把我的 map 当成一个 Vector？&ldquo;等等。(不过，有了 Clojure，你至少可以免于思考作为一个 17 岁孩子的深刻的存在恐惧，直到永远）。</p><p>在这一章中，你将了解到 Clojure 的深邃、黑暗、嗜血、超自然的<em>cough</em>，我的意思是，在这一章中，你将了解到 Clojure 的<em>抽象的基本概念以及序列和集合的抽象</em>。你还会了解到<em>疯狂的序列</em>。这将为你提供所需的基础，使你能够阅读你以前没有使用过的函数的文档，并理解当你试着使用它们时发生了什么。</p><p><img src=https://www.braveclojure.com/assets/images/cftbat/core-functions-in-depth/sparkly.png loading=lazy alt=img></p><p>接下来，你将获得更多关于你最需要使用的函数的经验。你将学习如何用函数<code>map</code>、<code>reduce</code>、<code>into</code>、<code>conj</code>、<code>concat</code>、<code>some</code>、<code>filter</code>、<code>take</code>、<code>drop</code>、<code>sort</code>、<code>sort-by</code>和<code>identity</code>来处理列表、Vector、Map 和 Set。你还将学习如何用<code>apply</code>、<code>partial</code>和<code>complement</code>创建新的函数。所有这些信息将帮助你了解如何以 Clojure 的方式做事，它将为你编写自己的代码以及阅读和学习他人的项目打下坚实的基础。</p><p>最后，你将学会如何解析和查询 CSV 中的吸血鬼数据，以确定在你的家乡潜伏着哪些诺斯费拉图。</p><h2 id=从编程到抽象>从编程到抽象</h2><p>为了理解从编程到抽象，让我们把 Clojure 与一种没有考虑到这个原则的语言进行比较。Emacs Lisp（elisp）。在 elisp 中，你可以使用<code>mapcar</code>函数来导出一个新的列表，这与你在 Clojure 中使用<code>map</code>的方式相似。然而，如果你想在 elisp 中 Map 一个哈希 Map（类似于 Clojure 的 map 数据结构），你需要使用<code>maphash</code>函数，而在 Clojure 中你仍然可以只使用<code>map</code>。换句话说，elisp 使用两个不同的、针对数据结构的函数来实现<em>map</em>操作，而 Clojure 只使用一个。你也可以在 Clojure 中对 map 调用<code>reduce</code>，而 elisp 并没有提供一个函数来减少散列 map。</p><p>原因是 Clojure 在<em>序列抽象</em>方面定义了<code>map</code>和<code>reduce</code>函数，而不是在具体的数据结构方面。只要数据结构响应核心序列操作（函数<code>first</code>、<code>rest</code>和<code>cons</code>，我们稍后会仔细研究），它就能与<code>map</code>、<code>reduce</code>以及其他大量的序列函数免费工作。这就是 Clojurists 所说的抽象编程，也是 Clojure 哲学的一个核心原则。</p><p>我认为抽象是操作的命名集合。如果你能在一个对象上执行一个抽象的所有操作，那么这个对象就是该抽象的一个实例。我甚至在编程之外也是这样想的。例如，<em>电池</em>抽象包括 &ldquo;将导电介质连接到其阳极和阴极 &ldquo;的操作，而该操作的输出是<em>电流</em>。电池是用锂还是用土豆做的并不重要。只要它对定义<em>电池</em>的一系列操作做出反应，它就是一个电池。</p><p>同样地，<code>map</code>并不关心列表、Vector、Set 和 Map 是如何实现的。它只关心它是否能对它们进行序列操作。让我们看看<code>map</code>是如何在序列抽象中定义的，这样你就能理解一般的抽象编程。</p><h3 id=把列表vectorset-和-map-当作序列对待>把列表、Vector、Set 和 Map 当作序列对待</h3><p>如果你把<code>map</code>操作独立于任何编程语言，甚至是编程，它的基本行为是用一个函数<em>ƒ</em>从现有的序列<em>x</em>导出一个新的序列<em>y</em>，这样 y1 = ƒ(x1), y2 = ƒ(x2), . . . yn = ƒ(xn)。图 4-1 说明了你如何将应用于序列的 Map 可视化。</p><p>! <a class=link href=https://www.braveclojure.com/assets/images/cftbat/core-functions-in-depth/mapping.png target=_blank rel=noopener>img</a></p><p>图 4-1：Map 的可视化</p><p>术语<em>序列</em>在这里指的是以线性顺序组织的元素集合，而不是无序集合或节点之间没有前后关系的图。图 4-2 显示了你如何将一个序列可视化，与上述其他两个集合形成对比。</p><p><img src=https://www.braveclojure.com/assets/images/cftbat/core-functions-in-depth/collections.png loading=lazy alt=img></p><p>图 4-2：序列和非序列集合</p><p>在这个关于 Map 和序列的描述中，没有提到列表、Vector 或其他具体的数据结构。Clojure 的设计是让我们尽可能地用这种抽象的术语来思考和编程，它通过用数据结构的抽象来实现函数。在这个例子中，<code>map</code>是根据序列抽象来定义的。在对话中，你会说<code>map</code>、<code>reduce</code>和其他序列函数<em>取一个序列</em>或甚至<em>取一个 seq</em>。事实上，Clojurists 通常使用<em>seq</em>而不是<em>sequence</em>，使用<em>seq 函数</em>和<em>seq 库</em>等术语来指代执行顺序操作的函数。无论你使用<em>sequence</em>还是<em>seq</em>，你都表明有关的数据结构将被视为一个序列，在这种情况下，它实际上是什么最真实的心态并不重要。</p><p>如果核心序列函数 &ldquo;first&rdquo;、&ldquo;rest &ldquo;和 &ldquo;cons &ldquo;在一个数据结构上工作，你可以说这个数据结构<em>实现了</em>序列的抽象。列表、Vector、Set 和 Map 都实现了序列抽象，所以它们都可以用<code>map</code>，如图所示。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(defn titleize
</span></span><span class=line><span class=cl>  [topic]
</span></span><span class=line><span class=cl>  (str topic &#34; for the Brave and True&#34;))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(map titleize [&#34;Hamsters&#34; &#34;Ragnarok&#34;])
</span></span><span class=line><span class=cl>; =&gt; (&#34;Hamsters for the Brave and True&#34; &#34;Ragnarok for the Brave and True&#34;)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(map titleize &#39;(&#34;Empathy&#34; &#34;Decorating&#34;))
</span></span><span class=line><span class=cl>; =&gt; (&#34;Empathy for the Brave and True&#34; &#34;Decorating for the Brave and True&#34;)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(map titleize #{&#34;Elbows&#34; &#34;Soap Carving&#34;})
</span></span><span class=line><span class=cl>; =&gt; (&#34;Elbows for the Brave and True&#34; &#34;Soap Carving for the Brave and True&#34;)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(map #(titleize (second %)) {:uncomfortable-thing &#34;Winking&#34;})
</span></span><span class=line><span class=cl>; =&gt; (&#34;Winking for the Brave and True&#34;)
</span></span></code></pre></td></tr></table></div></div><p>前两个例子表明<code>map</code>对 Vector 和列表的工作方式是相同的。第三个例子显示<code>map</code>可以与未排序的集合一起工作。在第四个例子中，你必须在匿名函数的参数上调用<code>second</code>，然后再将其标题化，因为参数是一个 map。我将很快解释原因，但首先让我们看看定义序列抽象的三个函数。</p><h3 id=first-rest-and-cons>first, rest, and cons</h3><p><img src=https://www.braveclojure.com/assets/images/cftbat/core-functions-in-depth/hamster.png loading=lazy alt=img></p><p>在这一节中，我们将快速迂回到 JavaScript 中，实现一个链表和三个核心函数。<code>first</code>,<code>rest</code>, 和<code>cons</code>。在这三个核心函数实现之后，我将展示如何用它们来构建<code>map</code>。</p><p>重点是要理解 Clojure 中的 seq 抽象和链接列表的具体实现之间的区别。如何实现一个特定的数据结构并不重要：当涉及到在一个数据结构上使用 seq 函数时，Clojure 所问的是 &ldquo;我可以<code>first</code>、<code>rest</code>和<code>cons</code>吗？&rdquo; 如果答案是肯定的，你就可以在该数据结构上使用 seq 库。</p><p>在一个链接列表中，节点是以线性顺序链接的。下面是你如何在 JavaScript 中创建一个。在这个片段中，<code>next</code>是空的，因为它是列表中的最后一个节点。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>var node3 = {
</span></span><span class=line><span class=cl>  value: &#34;last&#34;,
</span></span><span class=line><span class=cl>  next: null
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><p>在这个代码中，<code>node2</code>的<code>next</code>指向<code>node3</code>，而<code>node1</code>的<code>next</code>指向<code>node2</code>；这就是 &ldquo;链表 &ldquo;中的 &ldquo;链接&rdquo;。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>var node2 = {
</span></span><span class=line><span class=cl>  value: &#34;middle&#34;,
</span></span><span class=line><span class=cl>  next: node3
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var node1 = {
</span></span><span class=line><span class=cl>  value: &#34;first&#34;,
</span></span><span class=line><span class=cl>  next: node2
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><p>从图形上看，你可以如图 4-3 所示表示这个列表。</p><p><img src=https://www.braveclojure.com/assets/images/cftbat/core-functions-in-depth/linked-list.png loading=lazy alt=img></p><p>图 4-3: 一个链接列表</p><p>你可以在一个链表上执行三个核心函数。<code>first</code>, <code>rest</code>, 和<code>cons</code>. <code>first</code>返回请求的节点的值，<code>rest</code>返回请求的节点之后的剩余值，<code>cons</code>在列表的开头添加一个具有给定值的新节点。在这些实现之后，你可以在它们之上实现<code>map</code>、<code>reduce</code>、<code>filter</code>和其他 seq 函数。</p><p>下面的代码显示了我们如何用我们的 JavaScript 例子实现和使用<code>first</code>、<code>rest</code>和<code>cons</code>，以及如何使用它们来返回特定的节点并导出一个新的列表。请注意，<code>first</code>和<code>rest</code>的参数被命名为<em>node</em>。这可能会让人感到困惑，因为你可能会说：&ldquo;我不是在获取一个<em>列表</em>的第一个元素吗？&rdquo; 好吧，你一次对列表中的元素进行操作，是一个节点一个节点地操作</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>var first = function(node) {
</span></span><span class=line><span class=cl>  return node.value;
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var rest = function(node) {
</span></span><span class=line><span class=cl>  return node.next;
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var cons = function(newValue, node) {
</span></span><span class=line><span class=cl>  return {
</span></span><span class=line><span class=cl>    value: newValue,
</span></span><span class=line><span class=cl>    next: node
</span></span><span class=line><span class=cl>  };
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>first(node1);
</span></span><span class=line><span class=cl>// =&gt; &#34;first&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>first(rest(node1));
</span></span><span class=line><span class=cl>// =&gt; &#34;middle&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>first(rest(rest(node1)));
</span></span><span class=line><span class=cl>// =&gt; &#34;last&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var node0 = cons(&#34;new first&#34;, node1);
</span></span><span class=line><span class=cl>first(node0);
</span></span><span class=line><span class=cl>// =&gt; &#34;new first&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>first(rest(node0));
</span></span><span class=line><span class=cl>// =&gt; &#34;first&#34;
</span></span></code></pre></td></tr></table></div></div><p>如前所述，你可以用<code>first</code>、<code>rest</code>和<code>cons</code>来实现<code>map</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>var map = function (list, transform) {
</span></span><span class=line><span class=cl>  if (list === null) {
</span></span><span class=line><span class=cl>    return null;
</span></span><span class=line><span class=cl>  } else {
</span></span><span class=line><span class=cl>    return cons(transform(first(list)), map(rest(list), transform));
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>这个函数转换了 list 的第一个元素，然后在 list 的其余部分再次调用自己，直到到达结尾（一个空值）。让我们看看它的运行情况 在这个例子中，你对以 <code>node1</code> 开始的列表进行 Map，返回一个新的列表，字符串 <code>" mapped!"</code> 被附加到每个节点的值上。然后你用<code>first</code>来返回第一个节点的值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>first(
</span></span><span class=line><span class=cl>  map(node1, function (val) { return val + &#34; mapped!&#34;})
</span></span><span class=line><span class=cl>);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// =&gt; &#34;first mapped!&#34;
</span></span></code></pre></td></tr></table></div></div><p>这里有件很酷的事：因为<code>map</code>是完全用<code>cons</code>、<code>first</code>和<code>rest</code>实现的，你实际上可以把任何数据结构传给它，只要<code>cons</code>、<code>first</code>和<code>rest</code>对该数据结构起作用，它就能工作。</p><p>下面是它们对一个数组的作用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>var first = function (array) {
</span></span><span class=line><span class=cl>  return array[0];
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var rest = function (array) {
</span></span><span class=line><span class=cl>  var sliced = array.slice(1, array.length);
</span></span><span class=line><span class=cl>  if (sliced.length == 0) {
</span></span><span class=line><span class=cl>    return null;
</span></span><span class=line><span class=cl>  } else {
</span></span><span class=line><span class=cl>    return sliced;
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var cons = function (newValue, array) {
</span></span><span class=line><span class=cl>  return [newValue].concat(array);
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>var list = [&#34;Transylvania&#34;, &#34;Forks, WA&#34;];
</span></span><span class=line><span class=cl>map(list, function (val) { return val + &#34; mapped!&#34;})
</span></span><span class=line><span class=cl>// =&gt; [&#34;Transylvania mapped!&#34;, &#34;Forks, WA mapped!&#34;]
</span></span></code></pre></td></tr></table></div></div><p>这个代码片段用 JavaScript 的数组函数定义了<code>first</code>、<code>rest</code>和<code>cons</code>。同时，<code>map</code>继续引用名为<code>first</code>、<code>rest</code>和<code>cons</code>的函数，所以现在它在<code>array</code>上工作。所以，如果你能实现<code>first</code>、<code>rest</code>和<code>cons</code>，你就能免费得到<code>map</code>和前面提到的大量其他函数。</p><h3 id=通过中间层抽象>通过中间层抽象</h3><p>在这一点上，你可能会反对我只是在踢皮球，因为我们仍然面临着像<code>first</code>这样的函数如何能够与不同的数据结构一起工作的问题。Clojure 使用两种形式的指示来实现这一目标。在编程中，<em>中间层</em>是一个通用术语，指的是一种语言所采用的机制，这样一个名字可以有多种相关的含义。在这个例子中，&ldquo;first &ldquo;这个名字有多种数据结构的含义。方向性是使抽象化成为可能的原因。</p><p><em>多态</em>是 Clojure 提供中间层的一种方式。我不想在细节上迷失方向，但基本上，多态函数根据提供的参数类型分配给不同的函数体。(这与多态函数根据你提供的参数数量派发到不同的函数体并无太大区别）。</p><p>注意 Clojure 有两种结构来定义多态分发：主机平台的接口结构和平台独立的协议。但在你刚开始的时候，没有必要了解这些东西是如何工作的。我将在第 13 章介绍协议。</p><p>当涉及到序列时，Clojure 也通过做一种轻量级的类型转换来创造中间层，产生一种数据结构，与抽象的函数一起工作。每当 Clojure 期望一个序列&ndash;例如，当你调用<code>map</code>、<code>first</code>、<code>rest</code>或<code>cons</code>时，它就会调用相关数据结构上的<code>seq</code>函数，以获得一个允许<code>first</code>、<code>rest</code>和<code>cons</code>的数据结构。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(seq &#39;(1 2 3))
</span></span><span class=line><span class=cl>; =&gt; (1 2 3)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(seq [1 2 3])
</span></span><span class=line><span class=cl>; =&gt; (1 2 3)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(seq #{1 2 3})
</span></span><span class=line><span class=cl>; =&gt; (1 2 3)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(seq {:name &#34;Bill Compton&#34; :occupation &#34;Dead mopey guy&#34;})
</span></span><span class=line><span class=cl>; =&gt; ([:name &#34;Bill Compton&#34;] [:occupation &#34;Dead mopey guy&#34;])
</span></span></code></pre></td></tr></table></div></div><p>这里有两个值得注意的细节。首先，<code>seq</code>总是返回一个看起来像列表的值；你会把这个值称为<em>sequence</em>或<em>seq</em>。第二，Map 的 seq 由两个元素的键值 Vector 组成。这就是为什么<code>map</code>把你的 Map 当作 Vector 列表的原因! 你可以在 &ldquo;Bill Compton &ldquo;的例子中看到这一点。我想特别指出这个例子，因为它可能是令人惊讶和困惑的。在我刚开始使用 Clojure 的时候就是这样。了解这些底层机制将使你不至于像试图保留人性的男性吸血鬼那样，经常表现出挫折感和普遍的拖沓感。</p><p>你可以通过使用<code>into</code>将 seq 转换回 Map，将结果粘到一个空的 Map 中（后面你会仔细看<code>into</code>）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(into {} (seq {:a 1 :b 2 :c 3})
</span></span><span class=line><span class=cl>; =&gt; {:a 1, :c 3, :b 2}
</span></span></code></pre></td></tr></table></div></div><p>所以，Clojure 的序列函数在其参数上使用<code>seq</code>。序列函数是根据序列抽象定义的，使用<code>first</code>、<code>rest</code>和<code>cons</code>。只要一个数据结构实现了序列抽象，它就可以使用广泛的 seq 库，其中包括诸如<code>reduce</code>、<code>filter</code>、<code>distinct</code>、<code>group-by</code>等超级明星函数。</p><p>这里的启示是，把注意力集中在我们能对一个数据结构做什么，并尽可能地忽略它的实现，是非常有力的。实现本身并不重要。它们只是达到目的的一种手段。一般来说，抽象编程可以让你在不同的数据结构上使用函数库，不管这些数据结构是如何实现的。</p><h2 id=seq-函数的例子>Seq 函数的例子</h2><p>Clojure 的 seq 库中有很多有用的函数，你会经常用到。现在你已经对 Clojure 的序列抽象有了更深的了解，让我们来详细看看这些函数。如果你是 Lisp 和函数式编程的新手，这些例子将是令人惊讶和愉快的。</p><h3 id=map>Map</h3><p>你现在已经看过很多<code>map</code>的例子了，但是这一节展示了<code>map</code>做了两个新的任务：把多个集合作为参数，以及把一个函数集合作为参数。它还强调了一个常见的<code>map</code>模式：使用关键字作为 Map 函数。</p><p>到目前为止，你只看到了<code>map</code>在一个集合上操作的例子。在下面的代码中，这个集合是 Vector<code>[1 2 3]</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(map inc [1 2 3])
</span></span><span class=line><span class=cl>; =&gt; (2 3 4)
</span></span></code></pre></td></tr></table></div></div><p>然而，你也可以给<code>map</code>多个集合。下面是一个简单的例子来说明这个方法的作用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(map str [&#34;a&#34; &#34;b&#34; &#34;c&#34;] [&#34;A&#34; &#34;B&#34; &#34;C&#34;] )
</span></span><span class=line><span class=cl>; =&gt; (&#34;aA&#34; &#34;bB&#34; &#34;cC&#34;)
</span></span></code></pre></td></tr></table></div></div><p>这就好像<code>map</code>做了以下的事情。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(list (str &#34;a&#34; &#34;A&#34;) (str &#34;b&#34; &#34;B&#34;) (str &#34;c&#34; &#34;C&#34;))
</span></span></code></pre></td></tr></table></div></div><p><img src=https://www.braveclojure.com/assets/images/cftbat/core-functions-in-depth/vampire-diary.png loading=lazy alt=img></p><p>当你传递给<code>map</code>多个集合时，第一个集合的元素（<code>["a" "b" "c"]</code>）将作为 Map 函数（<code>str</code>）的第一个参数传递，第二个集合的元素（<code>["A" "B" "C"</code>）将作为第二个参数传递，以此类推。只要确保你的 Map 函数可以接受的参数数量与你传递给<code>map</code>的集合数量相等。</p><p>下面的例子显示了如果你是一个试图抑制人类消费的吸血鬼，你可以如何使用这种能力。你有两个 Vector，一个代表人类摄入的升数，另一个代表过去四天的小动物摄入量。<code>unify-diet-data</code> 函数获取人类和动物的单日数据，并将两者统一为一张 Map。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(def human-consumption   [8.1 7.3 6.6 5.0])
</span></span><span class=line><span class=cl>(def critter-consumption [0.0 0.2 0.3 1.1])
</span></span><span class=line><span class=cl>(defn unify-diet-data
</span></span><span class=line><span class=cl>  [human critter]
</span></span><span class=line><span class=cl>  {:human human
</span></span><span class=line><span class=cl>   :critter critter})
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(map unify-diet-data human-consumption critter-consumption)
</span></span><span class=line><span class=cl>; =&gt; ({:human 8.1, :critter 0.0}
</span></span><span class=line><span class=cl>      {:human 7.3, :critter 0.2}
</span></span><span class=line><span class=cl>      {:human 6.6, :critter 0.3}
</span></span><span class=line><span class=cl>      {:human 5.0, :critter 1.1})
</span></span></code></pre></td></tr></table></div></div><p>好样的，把人裁掉了!</p><p>你可以用<code>map</code>做的另一件有趣的事是把一个函数集合传给它。如果你想对不同的数字集合进行一系列的计算，你可以使用这个方法，就像这样。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(def sum #(reduce + %))
</span></span><span class=line><span class=cl>(def avg #(/ (sum %) (count %)))
</span></span><span class=line><span class=cl>(defn stats
</span></span><span class=line><span class=cl>  [numbers]
</span></span><span class=line><span class=cl>  (map #(% numbers) [sum count avg]))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(stats [3 4 10])
</span></span><span class=line><span class=cl>; =&gt; (17 3 17/3)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(stats [80 1 44 13 6])
</span></span><span class=line><span class=cl>; =&gt; (144 5 144/5)
</span></span></code></pre></td></tr></table></div></div><p>在这个例子中，<code>stats</code>函数遍历了一个函数的 Vector，将每个函数应用于<code>numbers</code>。</p><p>此外，Clojurists 经常使用<code>map</code>从 map 数据结构的集合中检索与一个关键词相关的值。因为关键字可以作为函数使用，你可以简洁地做到这一点。下面是一个例子。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(def identities
</span></span><span class=line><span class=cl>  [{:alias &#34;Batman&#34; :real &#34;Bruce Wayne&#34;}
</span></span><span class=line><span class=cl>   {:alias &#34;Spider-Man&#34; :real &#34;Peter Parker&#34;}
</span></span><span class=line><span class=cl>   {:alias &#34;Santa&#34; :real &#34;Your mom&#34;}
</span></span><span class=line><span class=cl>   {:alias &#34;Easter Bunny&#34; :real &#34;Your dad&#34;}])
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(map :real identities)
</span></span><span class=line><span class=cl>; =&gt; (&#34;Bruce Wayne&#34; &#34;Peter Parker&#34; &#34;Your mom&#34; &#34;Your dad&#34;)
</span></span></code></pre></td></tr></table></div></div><p>(如果你是五岁，那么我深表歉意）。</p><h3 id=reduce>reduce</h3><p>第 3 章展示了<code>reduce</code>如何处理序列中的每个元素来生成一个结果。本节展示了其他一些可能不经常使用的使用方法。</p><p>第一种用法是转换一个 Map 的值，产生一个新的 Map，其键值相同，但数值更新。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(reduce (fn [new-map [key val]]
</span></span><span class=line><span class=cl>          (assoc new-map key (inc val)))
</span></span><span class=line><span class=cl>        {}
</span></span><span class=line><span class=cl>        {:max 30 :min 10})
</span></span><span class=line><span class=cl>; =&gt; {:max 31, :min 11}
</span></span></code></pre></td></tr></table></div></div><p>在这个例子中，<code>reduce</code>将参数<code>{:max 30 :min 10}</code>视为一个 Vector 序列，如<code>([:max 30] [:min 10])</code>。然后，它从一个空 Map（第二个参数）开始，用第一个参数，一个匿名函数来建立它。就像<code>reduce</code>这样做：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(assoc (assoc {} :max (inc 30))
</span></span><span class=line><span class=cl>       :min (inc 10))
</span></span></code></pre></td></tr></table></div></div><p>函数<code>assoc</code>需要三个参数：一个 Map，一个键，和一个值。它通过<em>关联</em>给定的键和给定的值，从你给它的 Map 中派生出一个新的 Map。例如，<code>(assoc {:a 1} :b 2)</code>将返回<code>{:a 1 :b 2}</code>。</p><p><code>reduce</code> 的另一个用途是根据键值从 Map 中过滤出来。在下面的例子中，匿名函数检查一个键值对的值是否大于 4，如果不是，那么这个键值对就被过滤掉了。在 Map<code>{:human 4.1 :critter 3.9}</code>中，3.9 小于 4，所以<code>:critter</code>键和它的 3.9 值被过滤掉了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(reduce (fn [new-map [key val]]
</span></span><span class=line><span class=cl>          (if (&gt; val 4)
</span></span><span class=line><span class=cl>            (assoc new-map key val)
</span></span><span class=line><span class=cl>            new-map))
</span></span><span class=line><span class=cl>        {}
</span></span><span class=line><span class=cl>        {:human 4.1
</span></span><span class=line><span class=cl>         :critter 3.9})
</span></span><span class=line><span class=cl>; =&gt; {:human 4.1}
</span></span></code></pre></td></tr></table></div></div><p>这里的启示是，<code>reduce</code>是一个比最初看起来更灵活的函数。每当你想从一个序列中得到一个新的值时，<code>reduce</code>通常能够满足你的需要。如果你想做一个真正能让你的头发倒竖的练习，试着用<code>reduce</code>实现<code>map</code>，然后在本章后面的内容中对<code>filter</code>和<code>some</code>做同样的练习。</p><h3 id=take-drop-take-while-and-drop-while>take, drop, take-while, and drop-while</h3><p><code>take</code>和<code>drop</code>都接受两个参数：一个数字和一个序列。<code>take</code>返回序列的前 n 个元素，而<code>drop</code>返回除去前 n 个元素的序列。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(take 3 [1 2 3 4 5 6 7 8 9 10])
</span></span><span class=line><span class=cl>; =&gt; (1 2 3)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(drop 3 [1 2 3 4 5 6 7 8 9 10])
</span></span><span class=line><span class=cl>; =&gt; (4 5 6 7 8 9 10)
</span></span></code></pre></td></tr></table></div></div><p>它们的表亲<code>take-while</code>和<code>drop-while</code>更有趣一些。每一个都需要一个<em>谓词函数</em>（一个其返回值为真或假的函数）来决定它何时应该停止取舍。例如，假设你有一个 Vector，代表你 &ldquo;食物 &ldquo;日记中的条目。每个条目都有月份和日期，以及你吃了什么。为了保留空间，我们将只包括几个条目。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(def food-journal
</span></span><span class=line><span class=cl>  [{:month 1 :day 1 :human 5.3 :critter 2.3}
</span></span><span class=line><span class=cl>   {:month 1 :day 2 :human 5.1 :critter 2.0}
</span></span><span class=line><span class=cl>   {:month 2 :day 1 :human 4.9 :critter 2.1}
</span></span><span class=line><span class=cl>   {:month 2 :day 2 :human 5.0 :critter 2.5}
</span></span><span class=line><span class=cl>   {:month 3 :day 1 :human 4.2 :critter 3.3}
</span></span><span class=line><span class=cl>   {:month 3 :day 2 :human 4.0 :critter 3.8}
</span></span><span class=line><span class=cl>   {:month 4 :day 1 :human 3.7 :critter 3.9}
</span></span><span class=line><span class=cl>   {:month 4 :day 2 :human 3.7 :critter 3.6}])
</span></span></code></pre></td></tr></table></div></div><p>使用<code>take-while</code>，你可以只检索一月和二月的数据。<code>take-while</code>遍历给定的序列（在本例中是<code>food-journal</code>），对每个元素应用谓词函数。</p><p>这个例子使用匿名函数<code>#(&lt; (:month %) 3)</code>来测试日记条目的月份是否超出范围。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(take-while #(&lt; (:month %) 3) food-journal)
</span></span><span class=line><span class=cl>; =&gt; ({:month 1 :day 1 :human 5.3 :critter 2.3}
</span></span><span class=line><span class=cl>      {:month 1 :day 2 :human 5.1 :critter 2.0}
</span></span><span class=line><span class=cl>      {:month 2 :day 1 :human 4.9 :critter 2.1}
</span></span><span class=line><span class=cl>      {:month 2 :day 2 :human 5.0 :critter 2.5})
</span></span></code></pre></td></tr></table></div></div><p>当<code>take-while</code>到达第一个 March 条目时，匿名函数返回<code>false</code>，而<code>take-while</code>返回它在这之前测试的每个元素的序列。</p><p>同样的想法也适用于<code>drop-while</code>，只是它一直在丢弃元素，直到有一个测试为真。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(drop-while #(&lt; (:month %) 3) food-journal)
</span></span><span class=line><span class=cl>; =&gt; ({:month 3 :day 1 :human 4.2 :critter 3.3}
</span></span><span class=line><span class=cl>      {:month 3 :day 2 :human 4.0 :critter 3.8}
</span></span><span class=line><span class=cl>      {:month 4 :day 1 :human 3.7 :critter 3.9}
</span></span><span class=line><span class=cl>      {:month 4 :day 2 :human 3.7 :critter 3.6})
</span></span></code></pre></td></tr></table></div></div><p>通过同时使用<code>take-while</code>和<code>drop-while</code>，你可以只获得 2 月和 3 月的数据。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(take-while #(&lt; (:month %) 4)
</span></span><span class=line><span class=cl>            (drop-while #(&lt; (:month %) 2) food-journal))
</span></span><span class=line><span class=cl>; =&gt; ({:month 2 :day 1 :human 4.9 :critter 2.1}
</span></span><span class=line><span class=cl>      {:month 2 :day 2 :human 5.0 :critter 2.5}
</span></span><span class=line><span class=cl>      {:month 3 :day 1 :human 4.2 :critter 3.3}
</span></span><span class=line><span class=cl>      {:month 3 :day 2 :human 4.0 :critter 3.8})
</span></span></code></pre></td></tr></table></div></div><p>这个例子使用 &ldquo;drop-while &ldquo;去掉 1 月份的条目，然后对结果使用 &ldquo;take-while &ldquo;继续取条目，直到到达 4 月份的第一个条目。</p><h3 id=filter-和-some>Filter 和 Some</h3><p>使用<code>filter</code>来返回一个序列中对一个谓词函数为真的所有元素。这里是人类消费少于 5 升的日记条目：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(filter #(&lt; (:human %) 5) food-journal)
</span></span><span class=line><span class=cl>; =&gt; ({:month 2 :day 1 :human 4.9 :critter 2.1}
</span></span><span class=line><span class=cl>      {:month 3 :day 1 :human 4.2 :critter 3.3}
</span></span><span class=line><span class=cl>      {:month 3 :day 2 :human 4.0 :critter 3.8}
</span></span><span class=line><span class=cl>      {:month 4 :day 1 :human 3.7 :critter 3.9}
</span></span><span class=line><span class=cl>      {:month 4 :day 2 :human 3.7 :critter 3.6})
</span></span></code></pre></td></tr></table></div></div><p>你可能想知道为什么我们不在前面的 &ldquo;take-while &ldquo;和 &ldquo;drop-while &ldquo;例子中使用<code>filter</code>。事实上，<code>filter</code>也可以用于此。这里我们要抓取 1 月和 2 月的数据，就像在<code>take-while</code>例子中一样。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(filter #(&lt; (:month %) 3) food-journal)
</span></span><span class=line><span class=cl>; =&gt; ({:month 1 :day 1 :human 5.3 :critter 2.3}
</span></span><span class=line><span class=cl>      {:month 1 :day 2 :human 5.1 :critter 2.0}
</span></span><span class=line><span class=cl>      {:month 2 :day 1 :human 4.9 :critter 2.1}
</span></span><span class=line><span class=cl>      {:month 2 :day 2 :human 5.0 :critter 2.5})
</span></span></code></pre></td></tr></table></div></div><p>这种用法完全没有问题，但是<code>filter</code>最终会处理你的所有数据，这并不总是必要的。因为食物日记已经按日期排序，我们知道<code>take-while</code>会返回我们想要的数据，而不需要检查任何我们不需要的数据。因此，<code>take-while</code>可以更有效率。</p><p>通常情况下，你想知道一个集合是否包含对一个谓词函数测试为真的任何值。<code>some</code>函数就是这样做的，它返回由一个谓词函数返回的第一个真值（任何不是<code>false</code>或<code>nil</code>的值）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(some #(&gt; (:critter %) 5) food-journal)
</span></span><span class=line><span class=cl>; =&gt; nil
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(some #(&gt; (:critter %) 3) food-journal)
</span></span><span class=line><span class=cl>; =&gt; true
</span></span></code></pre></td></tr></table></div></div><p>你没有任何食物日记条目显示你从小动物来源中消耗了超过 5 升的食物，但是你至少有一条显示你消耗了超过 3 升的食物。请注意，第二个例子中的返回值是<code>true</code>，而不是产生真值的实际条目。原因是匿名函数<code>#(> (:critter %) 3)</code>返回<code>true</code>或<code>false</code>。下面是你如何返回该条目。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(some #(and (&gt; (:critter %) 3) %) food-journal)
</span></span><span class=line><span class=cl>; =&gt; {:month 3 :day 1 :human 4.2 :critter 3.3}。
</span></span></code></pre></td></tr></table></div></div><p>这里，一个稍有不同的匿名函数使用<code>and</code>首先检查条件<code>(> (:critter %) 3)</code>是否为真，然后在条件确实为真时返回条目。</p><h3 id=sort-and-sort-by>sort and sort-by</h3><p>你可以用<code>sort</code>将元素按升序排序。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(sort [3 1 2])
</span></span><span class=line><span class=cl>; =&gt; (1 2 3)
</span></span></code></pre></td></tr></table></div></div><p>如果你的排序需求更复杂，你可以使用<code>sort-by</code>，它允许你将一个函数（有时称为<em>键函数</em>）应用于一个序列的元素，并使用它返回的值来决定排序顺序。在下面的例子中，取自*<a class=link href=http://clojuredocs.org/ target=_blank rel=noopener>http://clojuredocs.org/</a>*，<code>count</code>是关键函数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(sort-by count [&#34;aaa&#34; &#34;c&#34; &#34;bb&#34;] )
</span></span><span class=line><span class=cl>; =&gt; (&#34;c&#34; &#34;bb&#34; &#34;aaa&#34;)
</span></span></code></pre></td></tr></table></div></div><p>如果你使用<code>sort</code>进行排序，元素将按字母顺序进行排序，返回<code>("aaa" "bb" "c")</code>。相反，结果是<code>("c" "bb" "aaa")</code>，因为你是按<code>count</code>排序，而<code>"c "的计数是1，</code>&ldquo;bb &ldquo;是 2，`&ldquo;aaa &ldquo;是 3。</p><h3 id=concat>Concat</h3><p>最后, <code>concat</code>简单地将一个序列的成员附加到另一个序列的末尾:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(concat [1 2] [3 4])
</span></span><span class=line><span class=cl>; =&gt; (1 2 3 4)
</span></span></code></pre></td></tr></table></div></div><h2 id=惰性序列>惰性序列</h2><p>正如你之前看到的，<code>map</code>首先在你传递给它的集合上调用<code>seq</code>。但这并不是故事的全部。许多函数，包括<code>map</code>和<code>filter</code>，都返回一个<em>惰性序列</em>。惰性序列 是一个 seq，它的成员在你试图访问它们时才被计算。计算一个 seq 的成员被称为<em>实现</em>seq。将计算推迟到需要的时候，可以使你的程序更有效率，而且它还有一个令人惊讶的好处，就是允许你构建无穷的序列。</p><h3 id=演示惰性序列的效率>演示惰性序列的效率</h3><p>为了看到惰性序列的作用，假装你是一个现代任务组的成员，其目的是为了识别吸血鬼。你的情报人员告诉你，在你的城市里只有一个活跃的吸血鬼，而且他们已经帮助你把嫌疑人的名单缩小到一百万人。你的老板给了你一份一百万个社会安全号码的名单，并喊道：&ldquo;搞定它，麦克菲斯维奇！&rdquo;</p><p>值得庆幸的是，你拥有一台 Vampmatic 3000 计算机，这是用于识别吸血鬼的最先进的设备。由于这种猎杀吸血鬼的技术的源代码是专有的，我把它存根出来，模拟执行这项任务所需的时间。这里是一个吸血鬼数据库的子集。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(def vampire-database
</span></span><span class=line><span class=cl>  {0 {:makes-blood-puns? false, :has-pulse? true  :name &#34;McFishwich&#34;}
</span></span><span class=line><span class=cl>   1 {:makes-blood-puns? false, :has-pulse? true  :name &#34;McMackson&#34;}
</span></span><span class=line><span class=cl>   2 {:makes-blood-puns? true,  :has-pulse? false :name &#34;Damon Salvatore&#34;}
</span></span><span class=line><span class=cl>   3 {:makes-blood-puns? true,  :has-pulse? true  :name &#34;Mickey Mouse&#34;}})
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(defn vampire-related-details
</span></span><span class=line><span class=cl>  [social-security-number]
</span></span><span class=line><span class=cl>  (Thread/sleep 1000)
</span></span><span class=line><span class=cl>  (get vampire-database social-security-number))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(defn vampire?
</span></span><span class=line><span class=cl>  [record]
</span></span><span class=line><span class=cl>  (and (:makes-blood-puns? record)
</span></span><span class=line><span class=cl>       (not (:has-pulse? record))
</span></span><span class=line><span class=cl>       record))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(defn identify-vampire
</span></span><span class=line><span class=cl>  [social-security-numbers]
</span></span><span class=line><span class=cl>  (first (filter vampire?
</span></span><span class=line><span class=cl>                 (map vampire-related-details social-security-numbers))))
</span></span></code></pre></td></tr></table></div></div><p>你有一个函数，<code>vampire-related-details</code>，它需要一秒钟从数据库中查找一个条目。接下来，你有一个函数，<code>vampire?</code>，如果它通过了吸血鬼测试，就返回一条记录；否则，就返回<code>false</code>。最后，<code>identify-vampire</code>将社会安全号码 Map 到数据库记录，然后返回第一条表明有吸血鬼的记录。</p><p>为了显示运行这些函数需要多少时间，你可以使用<code>time</code>操作。当你使用<code>time</code>时，你的代码的行为与你不使用<code>time</code>时完全一样，但有一个例外：会打印出一份经过时间的报告。下面是一个例子。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(time (vampire-related-details 0))
</span></span><span class=line><span class=cl>; =&gt; &#34;Elapsed time: 1001.042 msecs&#34;
</span></span><span class=line><span class=cl>; =&gt; {:name &#34;McFishwich&#34;, :makes-blood-puns? false, :has-pulse? true}
</span></span></code></pre></td></tr></table></div></div><p>第一个打印行报告了给定操作所花费的时间&ndash;本例是 1,001.042 毫秒。第二行是返回值，在本例中是你的数据库记录。返回值与没有使用<code>time</code>的情况下完全相同。</p><p>一个不笨的<code>map</code>的实现首先要对<code>social-security-numbers</code>的每个成员应用<code>vampire-</code>related-details<code>，然后再把结果传给</code>filter`。因为你有一百万个嫌疑人，这将需要一百万秒，也就是 12 天，到那时你的一半城市都会死掉！"。当然，如果结果是唯一的吸血鬼是记录中的最后一个嫌疑人，用懒人版本还是会花那么多时间，但至少有一个很好的机会，它不会。</p><p>因为<code>map</code>是惰性的，在你试图访问 Map 的元素之前，它实际上并没有将<code>吸血鬼相关的细节</code>应用于社会安全号码。事实上，<code>map</code>几乎立刻就会返回一个值。</p><p>第一个打印行报告了给定操作所花费的时间&ndash;本例中是 1,001.042 毫秒。第二行是返回值，在这个例子中是你的数据库记录。返回值与没有使用<code>time</code>的情况下完全相同。</p><p>一个不笨的<code>map</code>的实现首先要对<code>social-security-numbers</code>的每个成员应用<code>vampire-</code>related-details<code>，然后再把结果传给</code>filter`。因为你有一百万个嫌疑人，这将需要一百万秒，也就是 12 天，到那时你的一半城市都会死掉！"。当然，如果结果是唯一的吸血鬼是记录中的最后一个嫌疑人，用懒人版本还是会花那么多时间，但至少有一个很好的机会，它不会。</p><p>因为<code>map</code>是惰性的，在你试图访问 Map 的元素之前，它实际上并没有将<code>吸血鬼相关的细节</code>应用于社会安全号码。事实上，<code>map</code>几乎马上就会返回一个值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(time (def mapped-details (map vampire-related-details (range 0 1000000))))
</span></span><span class=line><span class=cl>; =&gt; &#34;Elapsed time: 0.049 msecs&#34;
</span></span><span class=line><span class=cl>; =&gt; #&#39;user/mapped-details
</span></span></code></pre></td></tr></table></div></div><p>在这个例子中，<code>range</code>返回一个由 0 到 999,999 的整数组成的惰性序列。然后，<code>map</code>返回一个与名称<code>mapped-details</code>相关的惰性序列。因为<code>map</code>实际上没有对<code>range</code>返回的任何元素应用<code>vampire-related-details</code>，整个操作几乎没有花费任何时间，当然，少于 12 天。</p><p>你可以认为懒人序列是由两部分组成的：一个关于如何实现序列元素的配方和到目前为止已经实现的元素。当你使用<code>map</code>时，它返回的懒人序列不包括任何已实现的元素，但它确实有生成其元素的配方。每当你试图访问一个未实现的元素时，懒人序列将使用它的配方来生成所请求的元素。</p><p>在前面的例子中，<code>mapped-details</code>是未实现的。一旦你试图访问<code>mapped-details</code>的一个成员，它将使用它的配方来生成你所请求的元素，你将产生每秒钟的数据库查询费用。</p><p>在这个例子中，<code>range</code>返回一个由 0 到 999,999 的整数组成的惰性序列。然后，<code>map</code>返回一个与<code>mapped-details</code>名称相关的惰性序列。因为<code>map</code>实际上没有对<code>range</code>返回的任何元素应用<code>vampire-related-details</code>，整个操作几乎没有花费任何时间，当然，少于 12 天。</p><p>你可以认为懒人序列由两部分组成：一个关于如何实现序列元素的配方和到目前为止已经实现的元素。当你使用<code>map</code>时，它返回的惰性序列不包括任何已实现的元素，但它确实有生成其元素的配方。每当你试图访问一个未实现的元素时，懒人序列将使用它的配方来生成所请求的元素。</p><p>在前面的例子中，<code>mapped-details</code>是未实现的。一旦你试图访问<code>mapped-details</code>的一个成员，它将使用它的配方来生成你所请求的元素，你将产生每秒钟的数据库查询费用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(time (first mapped-details))
</span></span><span class=line><span class=cl>; =&gt; &#34;Elapsed time: 32030.767 msecs&#34;
</span></span><span class=line><span class=cl>; =&gt; {:name &#34;McFishwich&#34;, :makes-blood-puns? false, :has-pulse? true}
</span></span></code></pre></td></tr></table></div></div><p>这个操作花了大约 32 秒。这比一百万秒好得多，但还是比我们预期的多了 31 秒。毕竟，你只是试图访问第一个元素，所以它应该只花一秒钟。</p><p>花了 32 秒的原因是 Clojure<em>chunks</em>它的惰性序列，这只是意味着每当 Clojure 要实现一个元素时，它也会预先实现一些下一个元素的实现。在这个例子中，你只想要<code>mapped-details</code>的第一个元素，但 Clojure 继续前进，也准备了后面的 31 个元素。Clojure 这样做是因为它几乎总是能带来更好的性能。</p><p>值得庆幸的是，惰性的 seq 元素只需要实现一次。再次访问<code>mapped-details</code>的第一个元素几乎不需要时间。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(time (first mapped-details))
</span></span><span class=line><span class=cl>; =&gt; &#34;Elapsed time: 0.022 msecs&#34;
</span></span><span class=line><span class=cl>; =&gt; {:name &#34;McFishwich&#34;, :makes-blood-puns? false, :has-pulse? true}
</span></span></code></pre></td></tr></table></div></div><p>有了这些新发现的知识，你就可以有效地挖掘吸血鬼数据库，找到带獠牙的罪魁祸首。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(time (identify-vampire (range 0 1000000)))
</span></span><span class=line><span class=cl>&#34;Elapsed time: 32019.912 msecs&#34;
</span></span><span class=line><span class=cl>; =&gt; {:name &#34;Damon Salvatore&#34;, :makes-blood-puns? true, :has-pulse? false}
</span></span></code></pre></td></tr></table></div></div><p>哦！这就是为什么达蒙会做出那些令人毛骨悚然的双关语的原因。</p><h3 id=无穷序列>无穷序列</h3><p>惰性序列 给你的一个很酷、很有用的能力是构建无穷序列的能力。到目前为止，你只处理过从 Vector 或列表中生成的惰性序列，这些序列是终止的。然而，Clojure 自带了一些函数来创建无穷序列。创建无穷序列的一个简单方法是使用<code>repeat</code>，它创建一个序列，其每个成员都是你传递的参数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(concat (take 8 (repeat &#34;na&#34;)) [&#34;Batman!&#34;])
</span></span><span class=line><span class=cl>; =&gt; (&#34;na&#34; &#34;na&#34; &#34;na&#34; &#34;na&#34; &#34;na&#34; &#34;na&#34; &#34;na&#34; &#34;na&#34; &#34;Batman!&#34;)
</span></span></code></pre></td></tr></table></div></div><p>在这种情况下，你创建了一个无穷的序列，其中每个元素都是字符串 &ldquo;na&rdquo;，然后用它来构建一个可能引起或不引起怀旧情绪的序列。</p><p>你也可以使用<code>repeatedly</code>，它将调用提供的函数来生成序列中的每个元素。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(take 3 (repeatedly (fn [] (rand-int 10))))
</span></span><span class=line><span class=cl>; =&gt; (1 4 0)
</span></span></code></pre></td></tr></table></div></div><p>这里，由<code>repeatedly</code>返回的惰性序列通过调用匿名函数<code>(fn [] (rand-int 10))</code>生成每个新元素，该函数返回一个 0 到 9 之间的随机整数。如果你在你的 REPL 中运行这个，你的结果很可能与此不同。</p><p>惰性序列 的配方不需要指定一个端点。像<code>first</code>和<code>take</code>这样的函数实现了惰性序列，它们没有办法知道序列的下一步是什么，如果序列一直提供元素，那么它们就会一直取走它们。如果你构建你自己的无穷序列，你就可以看到这一点。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(defn even-numbers
</span></span><span class=line><span class=cl>  ([] (even-numbers 0))
</span></span><span class=line><span class=cl>  ([n] (cons n (lazy-seq (even-numbers (+ n 2))))))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(take 10 (even-numbers))
</span></span><span class=line><span class=cl>; =&gt; (0 2 4 6 8 10 12 14 16 18)
</span></span></code></pre></td></tr></table></div></div><p>这个例子有点令人费解，因为它使用了递归。记住<code>cons</code>返回一个新的列表，并将一个元素追加到给定的列表中，会有所帮助。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(cons 0 &#39;(2 4 6))
</span></span><span class=line><span class=cl>; =&gt; (0 2 4 6)
</span></span></code></pre></td></tr></table></div></div><p>(顺便说一下，Lisp 程序员在使用<code>cons</code>函数时称它为<em>consing</em>)。</p><p>在 &ldquo;偶数 &ldquo;中，你是在对一个惰性列表进行 consing，其中包括一个关于下一个元素的配方（一个函数）（而不是对一个完全实现的列表进行 consing）。</p><p>这就涵盖了惰性序列! 现在你知道了关于序列抽象的所有知识，我们可以转向集合抽象了。</p><h2 id=集合抽象>集合抽象</h2><p>集合的抽象与序列的抽象密切相关。所有 Clojure 的核心数据结构&ndash;Vector、Map、列表和集合&ndash;都参与了这两个抽象。</p><p>序列抽象是关于对成员的单独操作，而集合抽象是关于数据结构的整体。例如，集合函数 <code>count</code>, <code>empty?</code>, 和 <code>every?</code> 不是关于任何单独的元素；它们是关于整体的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(empty?[])
</span></span><span class=line><span class=cl>; =&gt; true
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(empty? [&#34;no!&#34;])
</span></span><span class=line><span class=cl>; =&gt; false
</span></span></code></pre></td></tr></table></div></div><p>实际上，你很少会有意识的说：&ldquo;好的，自己！"。你现在是在和整个集合一起工作。从集合抽象的角度来考虑！&rdquo; 尽管如此，了解这些作为你所使用的函数和数据结构基础的概念还是很有用的。</p><p>现在我们来研究两个常见的集合函数&ndash;<code>into</code>和<code>conj</code>，它们的相似性可能会让人有点困惑。</p><h3 id=into>into</h3><p>最重要的集合函数之一是<code>into</code>。正如你现在所知，许多 seq 函数返回一个 seq，而不是原始数据结构。你可能想把返回值转换成原始值, <code>into</code>让你做到这一点:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(map identity {:sunlight-reaction &#34;Glitter!&#34;})
</span></span><span class=line><span class=cl>; =&gt; ([:sunlight-reaction &#34;Glitter!&#34;])
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(into {} (map identity {:sunlight-reaction &#34;Glitter!&#34;}))
</span></span><span class=line><span class=cl>; =&gt; {:sunlight-reaction &#34;Glitter!&#34;}.
</span></span></code></pre></td></tr></table></div></div><p>在这里，<code>map</code>函数在得到一个 map 数据结构后返回一个顺序数据结构，并将 seq 转换回 map。</p><p>这也适用于其他数据结构。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(map identity [:garlic :sesame-oil :fried-eggs])
</span></span><span class=line><span class=cl>; =&gt; (:garlic :sesame-oil :fried-eggs)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(into [] (map identity [:garlic :sesame-oil :fried-eggs]))
</span></span><span class=line><span class=cl>; =&gt; [:garlic :sesame-oil :fried-eggs]
</span></span></code></pre></td></tr></table></div></div><p>这里，在第一行，<code>map</code>返回一个序列，我们在第二行使用<code>into</code>将结果转换为一个 Vector。</p><p>在下面的例子中，我们从一个有两个相同条目的 Vector 开始，<code>map</code>把它转换为一个列表，然后我们用<code>into</code>把值粘到一个集合中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(map identity [:garlic-clove :garlic-clove])
</span></span><span class=line><span class=cl>; =&gt; (:garlic-clove :garlic-clove)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(into #{} (map identity [:garlic-clove :garlic-clove]))
</span></span><span class=line><span class=cl>; =&gt; #{:garlic-clove}
</span></span></code></pre></td></tr></table></div></div><p>因为集合只包含唯一的值，所以集合中最终只有一个值。</p><p><code>into</code>的第一个参数不一定是空的。这里，第一个例子显示了如何使用<code>into</code>向 Map 添加元素，第二个例子显示了如何向 Vector 添加元素。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(into {:favorite-emotion &#34;gloomy&#34;} [[:sunlight-reaction &#34;Glitter!&#34;]])
</span></span><span class=line><span class=cl>; =&gt; {:favorite-emotion &#34;gloomy&#34; :sunlight-reaction &#34;Glitter!&#34;}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(into [&#34;cherry&#34;] &#39;(&#34;pine&#34; &#34;spruce&#34;))
</span></span><span class=line><span class=cl>; =&gt; [&#34;cherry&#34; &#34;pine&#34; &#34;spruce&#34;]
</span></span></code></pre></td></tr></table></div></div><p>当然，两个参数也可以是同一类型。在下一个例子中，两个参数都是 Map，而之前所有的例子都有不同类型的参数。它的工作原理和你所期望的一样，返回一个新的 Map，将第二个 Map 的元素添加到第一个 Map 中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(into {:favorite-animal &#34;kitty&#34;} {:least-favorite-smell &#34;dog&#34;
</span></span><span class=line><span class=cl>                                  :relationship-with-teenager &#34;creepy&#34;})
</span></span><span class=line><span class=cl>; =&gt; {:favorite-animal &#34;kitty&#34;
</span></span><span class=line><span class=cl>      :relationship-with-teenager &#34;creepy&#34;
</span></span><span class=line><span class=cl>      :least-favorite-smell &#34;dog&#34;}
</span></span></code></pre></td></tr></table></div></div><p>如果<code>into</code>在求职面试中被要求描述它的优势，它会说：&ldquo;我很擅长处理两个集合，并将第二个集合中的所有元素添加到第一个集合中。&rdquo;</p><h3 id=conj>conj</h3><p><code>conj</code>也是向一个集合添加元素，但它的方式略有不同。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(conj [0] [1])
</span></span><span class=line><span class=cl>; =&gt; [0 [1]]
</span></span></code></pre></td></tr></table></div></div><p>呜呜呜! 看起来它把整个 Vector<code>[1]</code>添加到<code>[0]</code>。与<code>into</code>比较。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(into [0] [1])
</span></span><span class=line><span class=cl>; =&gt; [0 1]
</span></span></code></pre></td></tr></table></div></div><p>下面是我们如何用<code>conj</code>做同样的事情。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(conj [0] 1)
</span></span><span class=line><span class=cl>; =&gt; [0 1]
</span></span></code></pre></td></tr></table></div></div><p>注意，数字 1 是作为标量（单数，非集合）值传递的，而<code>into</code>的第二个参数必须是一个集合。</p><p>你可以提供尽可能多的元素与<code>conj</code>一起添加，你也可以添加到其他集合中，如 map。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(conj [0] 1 2 3 4)
</span></span><span class=line><span class=cl>; =&gt; [0 1 2 3 4]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(conj {:time &#34;midnight&#34;} [:place &#34;ye olde cemetarium&#34;])
</span></span><span class=line><span class=cl>; =&gt; {:place &#34;ye olde cemetarium&#34; :time &#34;midnight&#34;}
</span></span></code></pre></td></tr></table></div></div><p><code>conj</code>和<code>into</code>如此相似，你甚至可以用<code>into</code>来定义<code>conj</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(defn my-conj
</span></span><span class=line><span class=cl>  [target &amp; additions]
</span></span><span class=line><span class=cl>  (into target additions))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(my-conj [0] 1 2 3)
</span></span><span class=line><span class=cl>; =&gt; [0 1 2 3]
</span></span></code></pre></td></tr></table></div></div><h2 id=功能函数>功能函数</h2><p>学习利用 Clojure 的接受函数作为参数和返回函数作为值的能力是非常有趣的，即使它需要一些适应。</p><p>Clojure 的两个函数，<code>apply</code>和<code>partial</code>，可能看起来特别奇怪，因为它们都<em>接受</em>和<em>返回</em>函数。让我们来解开它们的疑惑。</p><h3 id=apply>Apply</h3><p><code>apply</code> 会展开一个序列，所以它可以被传递给一个期望有其余参数的函数。例如，<code>max</code>接受任何数量的参数，并返回所有参数中最大的一个。这里是你如何找到最大的数字。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(max 0 1 2)
</span></span><span class=line><span class=cl>; =&gt; 2
</span></span></code></pre></td></tr></table></div></div><p>但如果你想找到一个 Vector 的最大元素，怎么办？你不能只把 Vector 传给<code>max</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(max [0 1 2])
</span></span><span class=line><span class=cl>; =&gt; [0 1 2]
</span></span></code></pre></td></tr></table></div></div><p>这不会返回 Vector 中最大的元素，因为<code>max</code>返回所有传递给它的参数中最大的，在这种情况下，你只是传递给它一个包含所有你想比较的数字的 Vector，而不是把数字作为单独的参数传递进去。<code>apply</code>是这种情况的完美选择。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(apply max [0 1 2])
</span></span><span class=line><span class=cl>; =&gt; 2
</span></span></code></pre></td></tr></table></div></div><p>通过使用<code>apply</code>，就像你调用<code>(max 0 1 2)</code>一样。你经常会像这样使用<code>apply</code>，对一个集合的元素进行分解，使它们作为单独的参数被传递给一个函数。</p><p>还记得我们之前是如何用 &ldquo;into &ldquo;来定义 &ldquo;conj &ldquo;的吗？那么，我们也可以通过使用<code>apply</code>在<code>conj</code>的基础上定义<code>into</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(defn my-into
</span></span><span class=line><span class=cl>  [target additions]
</span></span><span class=line><span class=cl>  (apply conj target additions))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(my-into [0] [1 2 3])
</span></span><span class=line><span class=cl>; =&gt; [0 1 2 3]
</span></span></code></pre></td></tr></table></div></div><p>对<code>my-into</code>的调用相当于调用<code>(conj [0] 1 2 3)</code>。</p><h3 id=partial>Partial</h3><p><code>partial</code>接收一个函数和任意数量的参数。然后它返回一个新的函数。当你调用返回的函数时，它用你提供的原参数和新参数一起调用原函数。</p><p>这里有一个例子。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(def add10 (partial + 10))
</span></span><span class=line><span class=cl>(add10 3) 
</span></span><span class=line><span class=cl>; =&gt; 13
</span></span><span class=line><span class=cl>(add10 5) 
</span></span><span class=line><span class=cl>; =&gt; 15
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(def add-missing-elements
</span></span><span class=line><span class=cl>  (partial conj [&#34;water&#34; &#34;earth&#34; &#34;air&#34;]))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(add-missing-elements &#34;unobtainium&#34; &#34;adamantium&#34;)
</span></span><span class=line><span class=cl>; =&gt; [&#34;water&#34; &#34;earth&#34; &#34;air&#34; &#34;unobtainium&#34; &#34;adamantium&#34;]
</span></span></code></pre></td></tr></table></div></div><p>所以当你调用<code>add10</code>时，它会调用原始函数和参数<code>（+ 10）</code>，并附加你调用<code>add10</code>的任何参数。为了帮助澄清<code>partial</code>的工作原理，下面演示了如何定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(defn my-partial
</span></span><span class=line><span class=cl>  [partialized-fn &amp; args]
</span></span><span class=line><span class=cl>  (fn [&amp; more-args]
</span></span><span class=line><span class=cl>    (apply partialized-fn (into args more-args))))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(def add20 (my-partial + 20))
</span></span><span class=line><span class=cl>(add20 3) 
</span></span><span class=line><span class=cl>; =&gt; 23
</span></span></code></pre></td></tr></table></div></div><p>在这个例子中，<code>add20</code>的值是由<code>my-partial</code>返回的匿名函数。这个匿名函数是这样定义的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(fn [&amp; more-args]
</span></span><span class=line><span class=cl>  (apply + (into [20] more-args)))
</span></span></code></pre></td></tr></table></div></div><p>一般来说，当你发现你在许多不同的情况下重复相同的函数和参数组合时，你会想使用 partial。这个玩具例子显示了你如何使用<code>partial</code>来专门化一个记录器，创建一个<code>warn</code>函数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(defn lousy-logger
</span></span><span class=line><span class=cl>  [log-level message]
</span></span><span class=line><span class=cl>  (condp = log-level
</span></span><span class=line><span class=cl>    :warn (clojure.string/lower-case message)
</span></span><span class=line><span class=cl>    :emergency (clojure.string/upper-case message)))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(def warn (partial lousy-logger :warn))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(warn &#34;Red light ahead&#34;)
</span></span><span class=line><span class=cl>; =&gt; &#34;red light ahead&#34;
</span></span></code></pre></td></tr></table></div></div><p>在这里调用<code>(warning "Red light ahead")</code>与调用<code>(lousy-logger :warning "Red light ahead")</code>是相同的。</p><h3 id=complement>Complement</h3><p>早些时候，你创建了<code>识别吸血鬼</code>函数，以便在一百万人中找到一个吸血鬼。如果你想创建一个函数来寻找所有的人类呢？也许你想给他们发送感谢卡，因为他们没有成为不死的掠夺者。这里是你可以做的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(defn identify-humans
</span></span><span class=line><span class=cl>  [social-security-numbers]
</span></span><span class=line><span class=cl>  (filter #(not (vampire? %))
</span></span><span class=line><span class=cl>          (map vampire-related-details social-security-numbers)))
</span></span></code></pre></td></tr></table></div></div><p>看看<code>filter</code>的第一个参数，<code>#(not (vampire? %))</code>。想要得到一个布尔函数的<em>complement</em>（否定）是很常见的，所以有一个函数，<code>complement</code>，用于此。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(def not-vampire? (complement vampire?))
</span></span><span class=line><span class=cl>(defn identify-humans
</span></span><span class=line><span class=cl>  [social-security-numbers]
</span></span><span class=line><span class=cl>  (filter not-vampire?
</span></span><span class=line><span class=cl>          (map vampire-related-details social-security-numbers)))
</span></span></code></pre></td></tr></table></div></div><p>下面是你如何实现 &ldquo;complement"的方法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(defn my-complement
</span></span><span class=line><span class=cl>  [fun]
</span></span><span class=line><span class=cl>  (fn [&amp; args]
</span></span><span class=line><span class=cl>    (not (apply fun args))))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(def my-pos? (complement neg?))
</span></span><span class=line><span class=cl>(my-pos? 1)  
</span></span><span class=line><span class=cl>; =&gt; true
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(my-pos? -1) 
</span></span><span class=line><span class=cl>; =&gt; false
</span></span></code></pre></td></tr></table></div></div><p>正如你所看到的，<code>complement</code>是一个不起眼的函数。它只做一件小事，而且做得很好。<code>complement</code>使创建一个<code>不吸血</code>的函数变得微不足道，而且任何阅读代码的人都能理解代码的意图。</p><p>这不会为你提供数兆字节的数据的 MapReduce 或类似的东西，但它确实证明了高阶函数的力量。它们允许你以一种在某些语言中不可能实现的方式建立起实用函数库。总的来说，这些实用函数使你的生活变得更加轻松。</p><h2 id=为华盛顿州福克斯警察局fwpd编写一个复杂的吸血鬼数据分析程序>为华盛顿州福克斯警察局（FWPD）编写一个复杂的吸血鬼数据分析程序</h2><p>为了把所有的事情联系起来，让我们为华盛顿州福克斯警察局（FWPD）编写一个复杂的吸血鬼数据分析程序的雏形。</p><p>FWPD 有一个花哨的新数据库技术，叫做<em>CSV</em> <em>（逗号-**分隔的</em>值）<em>。你的工作是解析这个最先进的 CSV，并分析它是否有潜在的吸血鬼。我们将通过过滤每个嫌疑人的</em>闪光指数*来做到这一点，这是一个由某个少女开发的对嫌疑人的吸血鬼性的 0-10 预测。继续并为你的工具创建一个新的 Leiningen 项目。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>lein new app fwpd
</span></span></code></pre></td></tr></table></div></div><p>在新的<em>fwpd</em>目录下，创建一个名为<em>suspects.csv</em>的文件，输入如下内容。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Edward Cullen,10
</span></span><span class=line><span class=cl>Bella Swan,0
</span></span><span class=line><span class=cl>Charlie Swan,0
</span></span><span class=line><span class=cl>Jacob Black,3
</span></span><span class=line><span class=cl>Carlisle Cullen,6
</span></span></code></pre></td></tr></table></div></div><p>现在是时候通过建立<em>fwpd/src/fwpd/core.clj</em>文件来弄脏你的手了。我建议你启动一个新的 REPL 会话，这样你就可以边走边试。在 Emacs 中，你可以通过打开<em>fwpd/**src/fwpd/core.clj</em>并运行<strong>M-x</strong> cider-restart 来实现。一旦 REPL 启动，删除<em>core.clj</em>的内容，然后加入以下内容。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(ns fwpd.core)
</span></span><span class=line><span class=cl>(def filename &#34;suspects.csv&#34;)
</span></span></code></pre></td></tr></table></div></div><p>第一行建立了命名空间，第二行只是使你创建的 CSV 更容易被引用。你可以通过编译你的文件（Emacs 中的<strong>C-c C-k</strong>）并运行以下程序，在你的 REPL 中做一个快速的理智检查。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(slurp filename)
</span></span><span class=line><span class=cl>; =&gt; &#34;Edward Cullen,10\nBella Swan,0\nCharlie Swan,0\nJacob Black, 3\nCarlisle Cullen, 6&#34;
</span></span></code></pre></td></tr></table></div></div><p>如果<code>slurp</code>函数没有返回前面的字符串，试着在<em>core.clj</em>打开的情况下重新启动你的 REPL 会话。</p><p>接下来，在<em>core.clj</em>中添加这个内容。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>➊ (def vamp-keys [:name :glitter-index])
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>➋ (defn str-&gt;int
</span></span><span class=line><span class=cl>  [str]
</span></span><span class=line><span class=cl>  (Integer. str))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>➌ (def conversions {:name identity
</span></span><span class=line><span class=cl>                  :glitter-index str-&gt;int})
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>➍ (defn convert
</span></span><span class=line><span class=cl>  [vamp-key value]
</span></span><span class=line><span class=cl>  ((get conversions vamp-key) value))
</span></span></code></pre></td></tr></table></div></div><p>最终，你会得到一串看起来像<code>{:name "Edward Cullen" :glitter-index 10}</code>的 Map，前面的定义可以帮助你达到目的。首先，<code>vamp-keys</code>➊是一个键的 Vector，你很快会用它来创建吸血鬼 Map。接下来，函数<code>str->int</code>➋将一个字符串转换为一个整数。Map<code>conversions</code>➌将一个转换函数与每个吸血鬼键相关联。你根本不需要转换名字，所以它的转换函数是<code>identity</code>，它只是返回传递给它的参数。熠熠生辉的索引被转换为一个整数，所以它的转换函数是<code>str->int</code>。最后，<code>convert</code>函数➍接收一个 vamp 键和一个值，并返回转换后的值。下面是一个例子。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(convert :glitter-index &#34;3&#34;)
</span></span><span class=line><span class=cl>; =&gt; 3
</span></span></code></pre></td></tr></table></div></div><p>现在把这个添加到你的文件中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(defn parse
</span></span><span class=line><span class=cl>  &#34;Convert a CSV into rows of columns&#34;
</span></span><span class=line><span class=cl>  [string]
</span></span><span class=line><span class=cl>  (map #(clojure.string/split % #&#34;,&#34;)
</span></span><span class=line><span class=cl>       (clojure.string/split string #&#34;\n&#34;)))
</span></span></code></pre></td></tr></table></div></div><p><code>parse</code>函数接收一个字符串，首先在换行符上进行分割，创建一个字符串的序列。接下来，它对字符串序列进行 Map，在逗号字符上分割每一个字符串。试着在你的 CSV 上运行<code>parse</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(parse (slurp filename))
</span></span><span class=line><span class=cl>; =&gt; ([&#34;Edward Cullen&#34; &#34;10&#34;] [&#34;Bella Swan&#34; &#34;0&#34;] [&#34;Charlie Swan&#34; &#34;0&#34;]
</span></span><span class=line><span class=cl>      [&#34;Jacob Black&#34; &#34;3&#34;] [&#34;Carlisle Cullen&#34; &#34;6&#34;])
</span></span></code></pre></td></tr></table></div></div><p>接下来的代码将 Vector 序列与你的吸血鬼钥匙结合起来，创建 Map。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(defn mapify
</span></span><span class=line><span class=cl>  &#34;Return a seq of maps like {:name \&#34;Edward Cullen\&#34; :glitter-index 10}&#34;
</span></span><span class=line><span class=cl>  [rows]
</span></span><span class=line><span class=cl>  (map (fn [unmapped-row]
</span></span><span class=line><span class=cl>         (reduce (fn [row-map [vamp-key value]]
</span></span><span class=line><span class=cl>                   (assoc row-map vamp-key (convert vamp-key value)))
</span></span><span class=line><span class=cl>                 {}
</span></span><span class=line><span class=cl>                 (map vector vamp-keys unmapped-row)))
</span></span><span class=line><span class=cl>       rows))
</span></span></code></pre></td></tr></table></div></div><p>在这个函数中，<code>map</code>通过使用<code>reduce</code>将每一行 Vector 如<code>["Bella Swan" 0]</code>转化为一个 Map，其方式与上面&rdquo;<code>reduce</code>&ldquo;中的第一个例子相似。首先，<code>map</code>创建一个键值对序列，如<code>([:name "Bella Swan"] [:glitter-index 0])</code>。然后，&ldquo;reduce &ldquo;通过将一个 vamp 键和一个转换后的 vamp 值关联到 &ldquo;row-map &ldquo;来建立一个 Map。下面是第一行的 Map。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(first (mapify (parse (slurp filename))))
</span></span><span class=line><span class=cl>; =&gt; {:glitter-index 10, :name &#34;Edward Cullen&#34; }
</span></span></code></pre></td></tr></table></div></div><p>最后，添加这个<code>glitter-filter</code>函数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(defn glitter-filter
</span></span><span class=line><span class=cl>  [minimum-glitter records]
</span></span><span class=line><span class=cl>  (filter #(&gt;= (:glitter-index %) minimum-glitter) records))
</span></span></code></pre></td></tr></table></div></div><p>这需要完全 Map 的吸血鬼记录，并过滤掉那些<code>:glitter-index</code>小于所提供的<code>minimum-glitter</code>的记录。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(glitter-filter 3 (mapify (parse (slurp filename))))
</span></span><span class=line><span class=cl>({:name &#34;Edward Cullen&#34;, :glitter-index 10}
</span></span><span class=line><span class=cl> {:name &#34;Jacob Black&#34;, :glitter-index 3}
</span></span><span class=line><span class=cl> {:name &#34;Carlisle Cullen&#34;, :glitter-index 6})
</span></span></code></pre></td></tr></table></div></div><p>Et voilà! 你现在离实现你的梦想又近了一步，即成为一名猎杀超自然生物的义务警员。你最好去围捕那些粗略的人物!</p><h2 id=总结>总结</h2><p>在本章中，你了解到 Clojure 强调对抽象的编程。序列抽象处理的是对序列中各个元素的操作，而 seq 函数通常将其参数转换为 seq，并返回一个惰性的 seq。惰性求值通过将计算推迟到需要时再进行，从而提高性能。你所学到的另一个抽象，即集合抽象，处理的是整个数据结构。最后，你学到的最重要的东西是，你不应该相信那些在阳光下闪光的人。</p><h2 id=练习>练习</h2><p>你现在拥有的吸血鬼分析程序已经领先于市场上的任何其他程序几十年了。但你怎样才能使它变得更好呢？我建议尝试以下几点。</p><ol><li>把你的闪光过滤器的结果变成一个名字的列表。</li><li>写一个函数，<code>append</code>，它将把一个新的嫌疑人追加到你的嫌疑人列表中。</li><li>写一个函数，<code>validate</code>，它将在你<code>append</code>时检查<code>:name</code>和<code>:glitter-index</code>是否存在。<code>validate</code>函数应该接受两个参数：一个类似于<code>conversions</code>的验证函数的关键词 Map，以及要验证的记录。</li><li>编写一个函数，将你的 Map 列表转换为 CSV 字符串。你需要使用<code>clojure.string/join</code>函数。</li></ol><p>祝你好运，McFishwich!</p></section><footer class=article-footer><section class=article-tags><a href=/tags/clojure/>clojure</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><div class=disqus-container><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{DISQUS&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
1993 -
2022 演示站点</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.10.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#从编程到抽象>从编程到抽象</a><ol><li><a href=#把列表vectorset-和-map-当作序列对待>把列表、Vector、Set 和 Map 当作序列对待</a></li><li><a href=#first-rest-and-cons>first, rest, and cons</a></li><li><a href=#通过中间层抽象>通过中间层抽象</a></li></ol></li><li><a href=#seq-函数的例子>Seq 函数的例子</a><ol><li><a href=#map>Map</a></li><li><a href=#reduce>reduce</a></li><li><a href=#take-drop-take-while-and-drop-while>take, drop, take-while, and drop-while</a></li><li><a href=#filter-和-some>Filter 和 Some</a></li><li><a href=#sort-and-sort-by>sort and sort-by</a></li><li><a href=#concat>Concat</a></li></ol></li><li><a href=#惰性序列>惰性序列</a><ol><li><a href=#演示惰性序列的效率>演示惰性序列的效率</a></li><li><a href=#无穷序列>无穷序列</a></li></ol></li><li><a href=#集合抽象>集合抽象</a><ol><li><a href=#into>into</a></li><li><a href=#conj>conj</a></li></ol></li><li><a href=#功能函数>功能函数</a><ol><li><a href=#apply>Apply</a></li><li><a href=#partial>Partial</a></li><li><a href=#complement>Complement</a></li></ol></li><li><a href=#为华盛顿州福克斯警察局fwpd编写一个复杂的吸血鬼数据分析程序>为华盛顿州福克斯警察局（FWPD）编写一个复杂的吸血鬼数据分析程序</a></li><li><a href=#总结>总结</a></li><li><a href=#练习>练习</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>