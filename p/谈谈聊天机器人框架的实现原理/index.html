<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="在这篇文章不考虑人工智能，谈谈我对聊天机器人框架实现机制的理解。
聊天机器人  聊天机器人（Chatterbot）是经由对话或文字进行交谈的计算机程序[1]。能够模拟人类对话，通过图灵测试。
 我们可以看到现有的 IM 工具上已经有了很多机器人，其实聊天机器人不只是单纯的和用户进行聊天，他其实还可以做很多事情，例如根据用户输入的一些话，可以帮用户订餐。另外在运维领域，也出现了 chatops，通过和机器人聊天，进行运维操作。
机器人开发框架 作为聊天机器人开发者，面对如此多的 IM 工具和 SDK，常会感到无所适从。Bot 开发框架就是对聊天机器人开发过程中的人工内容做抽象化处理。简单地解释，机器人开发框架就是用来制造机器人并定义其行为。
然而尽管很多机器人框架宣称「代码一旦写好可部署到任何地方」，但是还会是出现为每一个 IM 工具开发一个单独的聊天机器人。而一个良好的机器人框架主要包含开发 SDK，连接器和模拟器等。
使用机器人框架其实并不适合初学者学习聊天机器人开发。它们尝试自动化太多工作，对初学者掩盖了基础机制。
实现方式  webhook 事件回调 FSM 状态机 workflow 工作流  最简单的机器人是没有上下文的语义理解的一问一答，仅仅是对用户的对话进行响应，这种就可以采用 webhook 的方式进行开发。不需要采用什么开发框架。
那么对于多轮对话的时候，就需要进行一定的对话管理。由此引入了 FSM 状态机。
可能有人不是很懂有限状态机，这里做一下简单说明。
 有限状态机在现实生活中其实随处可见，伸缩式圆珠笔其实就是一个有限状态机（两种状态互相转换）。
有限状态机，缩写为 FSM，又称为有限状态自动机，简称状态机。是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。
可以总结为：f(state, action) =&amp;gt; state’
也就是说，这个函数采用当前的状态和一次行动（即更改状态的方法），之后将该行动应用于这种状态并返回新的状态。
可以认为状态机是图灵完备的。
 我们可以将对话看做是在有限状态内跳转的过程，每个状态都有对应的动作和回复，如果能从开始节点顺利的流转到终止节点，任务就完成了。
我们可以将对话的过程，分为一个个的状态，然后使用 DSL 来实现一个 FSM，对于开发者来讲，我们只需要关注一个个状态函数即可。
特点是：
 人为定义对话流程 完全有系统主导，系统问用户答 答非所问的情况直接忽略 建模简单，能清晰明了的把交互匹配到模型 难以扩展，很容易变的复杂 适用于简单的任务，难以处理复杂问题 缺少灵活性，表达能力有限，输入有限，对话结构和流转路径有限  示例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  const {startWith, when, goto, stay, stop} = botkit."><title>谈谈聊天机器人框架的实现原理</title><link rel=canonical href=https://example.com/p/%E8%B0%88%E8%B0%88%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/><link rel=stylesheet href=/scss/style.min.b80bf249ce4a22cf55e8d7340a0b37a2f2c10f54f3a9a49cb94b694a2eb0bbea.css><meta property="og:title" content="谈谈聊天机器人框架的实现原理"><meta property="og:description" content="在这篇文章不考虑人工智能，谈谈我对聊天机器人框架实现机制的理解。
聊天机器人  聊天机器人（Chatterbot）是经由对话或文字进行交谈的计算机程序[1]。能够模拟人类对话，通过图灵测试。
 我们可以看到现有的 IM 工具上已经有了很多机器人，其实聊天机器人不只是单纯的和用户进行聊天，他其实还可以做很多事情，例如根据用户输入的一些话，可以帮用户订餐。另外在运维领域，也出现了 chatops，通过和机器人聊天，进行运维操作。
机器人开发框架 作为聊天机器人开发者，面对如此多的 IM 工具和 SDK，常会感到无所适从。Bot 开发框架就是对聊天机器人开发过程中的人工内容做抽象化处理。简单地解释，机器人开发框架就是用来制造机器人并定义其行为。
然而尽管很多机器人框架宣称「代码一旦写好可部署到任何地方」，但是还会是出现为每一个 IM 工具开发一个单独的聊天机器人。而一个良好的机器人框架主要包含开发 SDK，连接器和模拟器等。
使用机器人框架其实并不适合初学者学习聊天机器人开发。它们尝试自动化太多工作，对初学者掩盖了基础机制。
实现方式  webhook 事件回调 FSM 状态机 workflow 工作流  最简单的机器人是没有上下文的语义理解的一问一答，仅仅是对用户的对话进行响应，这种就可以采用 webhook 的方式进行开发。不需要采用什么开发框架。
那么对于多轮对话的时候，就需要进行一定的对话管理。由此引入了 FSM 状态机。
可能有人不是很懂有限状态机，这里做一下简单说明。
 有限状态机在现实生活中其实随处可见，伸缩式圆珠笔其实就是一个有限状态机（两种状态互相转换）。
有限状态机，缩写为 FSM，又称为有限状态自动机，简称状态机。是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。
可以总结为：f(state, action) =&amp;gt; state’
也就是说，这个函数采用当前的状态和一次行动（即更改状态的方法），之后将该行动应用于这种状态并返回新的状态。
可以认为状态机是图灵完备的。
 我们可以将对话看做是在有限状态内跳转的过程，每个状态都有对应的动作和回复，如果能从开始节点顺利的流转到终止节点，任务就完成了。
我们可以将对话的过程，分为一个个的状态，然后使用 DSL 来实现一个 FSM，对于开发者来讲，我们只需要关注一个个状态函数即可。
特点是：
 人为定义对话流程 完全有系统主导，系统问用户答 答非所问的情况直接忽略 建模简单，能清晰明了的把交互匹配到模型 难以扩展，很容易变的复杂 适用于简单的任务，难以处理复杂问题 缺少灵活性，表达能力有限，输入有限，对话结构和流转路径有限  示例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  const {startWith, when, goto, stay, stop} = botkit."><meta property="og:url" content="https://example.com/p/%E8%B0%88%E8%B0%88%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"><meta property="og:site_name" content="演示站点"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:published_time" content="2018-08-22T19:39:12+00:00"><meta property="article:modified_time" content="2018-08-22T19:39:12+00:00"><meta name=twitter:title content="谈谈聊天机器人框架的实现原理"><meta name=twitter:description content="在这篇文章不考虑人工智能，谈谈我对聊天机器人框架实现机制的理解。
聊天机器人  聊天机器人（Chatterbot）是经由对话或文字进行交谈的计算机程序[1]。能够模拟人类对话，通过图灵测试。
 我们可以看到现有的 IM 工具上已经有了很多机器人，其实聊天机器人不只是单纯的和用户进行聊天，他其实还可以做很多事情，例如根据用户输入的一些话，可以帮用户订餐。另外在运维领域，也出现了 chatops，通过和机器人聊天，进行运维操作。
机器人开发框架 作为聊天机器人开发者，面对如此多的 IM 工具和 SDK，常会感到无所适从。Bot 开发框架就是对聊天机器人开发过程中的人工内容做抽象化处理。简单地解释，机器人开发框架就是用来制造机器人并定义其行为。
然而尽管很多机器人框架宣称「代码一旦写好可部署到任何地方」，但是还会是出现为每一个 IM 工具开发一个单独的聊天机器人。而一个良好的机器人框架主要包含开发 SDK，连接器和模拟器等。
使用机器人框架其实并不适合初学者学习聊天机器人开发。它们尝试自动化太多工作，对初学者掩盖了基础机制。
实现方式  webhook 事件回调 FSM 状态机 workflow 工作流  最简单的机器人是没有上下文的语义理解的一问一答，仅仅是对用户的对话进行响应，这种就可以采用 webhook 的方式进行开发。不需要采用什么开发框架。
那么对于多轮对话的时候，就需要进行一定的对话管理。由此引入了 FSM 状态机。
可能有人不是很懂有限状态机，这里做一下简单说明。
 有限状态机在现实生活中其实随处可见，伸缩式圆珠笔其实就是一个有限状态机（两种状态互相转换）。
有限状态机，缩写为 FSM，又称为有限状态自动机，简称状态机。是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。
可以总结为：f(state, action) =&amp;gt; state’
也就是说，这个函数采用当前的状态和一次行动（即更改状态的方法），之后将该行动应用于这种状态并返回新的状态。
可以认为状态机是图灵完备的。
 我们可以将对话看做是在有限状态内跳转的过程，每个状态都有对应的动作和回复，如果能从开始节点顺利的流转到终止节点，任务就完成了。
我们可以将对话的过程，分为一个个的状态，然后使用 DSL 来实现一个 FSM，对于开发者来讲，我们只需要关注一个个状态函数即可。
特点是：
 人为定义对话流程 完全有系统主导，系统问用户答 答非所问的情况直接忽略 建模简单，能清晰明了的把交互匹配到模型 难以扩展，很容易变的复杂 适用于简单的任务，难以处理复杂问题 缺少灵活性，表达能力有限，输入有限，对话结构和流转路径有限  示例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  const {startWith, when, goto, stay, stop} = botkit."></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_huda2458f72ce188392d75c5d51cd8e24e_373_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>演示站点</a></h1><h2 class=site-description>软件工程师 编程小语种爱好者，精通各种语言的hello world，目前沉迷Clojure、elixir Get Started工程师，止步于大量框架和包的readme 后端开发工程师，偶尔写一些前端，伪全栈 也是一名数据工程师，朝着SQL Boy进化</h2></div></header><ol class=social-menu><li><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank title=GitHub><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><div class=menu-bottom-section><li id=i18n-switch><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg><select name=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://example.com/en/>English</option><option value=https://example.com/ selected>中文</option><option value=https://example.com/ar/>عربي</option></select></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></div></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/p/%E8%B0%88%E8%B0%88%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/>谈谈聊天机器人框架的实现原理</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Aug 22, 2018</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 4 分钟</time></div></footer></div></header><section class=article-content><p>在这篇文章不考虑人工智能，谈谈我对聊天机器人框架实现机制的理解。</p><h2 id=聊天机器人>聊天机器人</h2><blockquote><p><strong>聊天机器人</strong>（Chatterbot）是经由对话或文字进行交谈的计算机程序[<a class=link href=https://zh.wikipedia.org/wiki/%E8%81%8A%E5%A4%A9%E6%A9%9F%E5%99%A8%E4%BA%BA#cite_note-target-1 target=_blank rel=noopener>1]</a>。能够模拟人类对话，通过<a class=link href=https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%B5%8B%E8%AF%95 target=_blank rel=noopener>图灵测试</a>。</p></blockquote><p>我们可以看到现有的 IM 工具上已经有了很多机器人，其实聊天机器人不只是单纯的和用户进行聊天，他其实还可以做很多事情，例如根据用户输入的一些话，可以帮用户订餐。另外在运维领域，也出现了 chatops，通过和机器人聊天，进行运维操作。</p><h2 id=机器人开发框架>机器人开发框架</h2><p>作为聊天机器人开发者，面对如此多的 IM 工具和 SDK，常会感到无所适从。Bot 开发框架就是对聊天机器人开发过程中的人工内容做抽象化处理。简单地解释，机器人开发框架就是用来制造机器人并定义其行为。</p><p>然而尽管很多机器人框架宣称「代码一旦写好可部署到任何地方」，但是还会是出现为每一个 IM 工具开发一个单独的聊天机器人。而一个良好的机器人框架主要包含开发 SDK，连接器和模拟器等。</p><p>使用机器人框架其实并不适合初学者学习聊天机器人开发。它们尝试自动化太多工作，对初学者掩盖了基础机制。</p><h2 id=实现方式>实现方式</h2><ul><li>webhook 事件回调</li><li>FSM 状态机</li><li>workflow 工作流</li></ul><p>最简单的机器人是没有上下文的语义理解的一问一答，仅仅是对用户的对话进行响应，这种就可以采用 webhook 的方式进行开发。不需要采用什么开发框架。</p><p>那么对于多轮对话的时候，就需要进行一定的对话管理。由此引入了 FSM 状态机。</p><p>可能有人不是很懂有限状态机，这里做一下简单说明。</p><blockquote><p>有限状态机在现实生活中其实随处可见，伸缩式圆珠笔其实就是一个有限状态机（两种状态互相转换）。</p><p>有限状态机，缩写为 FSM，又称为有限状态自动机，简称状态机。是表示有限个<a class=link href=https://zh.wikipedia.org/wiki/%E7%8A%B6%E6%80%81 target=_blank rel=noopener>状态</a>以及在这些状态之间的转移和动作等行为的<a class=link href=https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B target=_blank rel=noopener>数学模型</a>。</p><p>可以总结为：f(state, action) => state’</p><p>也就是说，这个函数采用当前的状态和一次行动（即更改状态的方法），之后将该行动应用于这种状态并返回新的状态。</p><p>可以认为状态机是图灵完备的。</p></blockquote><p>我们可以将对话看做是在有限状态内跳转的过程，每个状态都有对应的动作和回复，如果能从开始节点顺利的流转到终止节点，任务就完成了。</p><p>我们可以将对话的过程，分为一个个的状态，然后使用 DSL 来实现一个 FSM，对于开发者来讲，我们只需要关注一个个状态函数即可。</p><p>特点是：</p><ul><li>人为定义对话流程</li><li>完全有系统主导，系统问用户答</li><li>答非所问的情况直接忽略</li><li>建模简单，能清晰明了的把交互匹配到模型</li><li>难以扩展，很容易变的复杂</li><li>适用于简单的任务，难以处理复杂问题</li><li>缺少灵活性，表达能力有限，输入有限，对话结构和流转路径有限</li></ul><p>示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>const {startWith, when, goto, stay, stop} = botkit.DSL(fsm);
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>startWith(MyStates.IDLE, {counter: 0});
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>when(MyStates.IDLE)(async (sender, content, data) =&gt; {
</span></span><span class=line><span class=cl>           
</span></span><span class=line><span class=cl>});
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>when(MyStates.UI)((sender, content, data) =&gt; {
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>});
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>when(MyStates.STEP1)((sender, content, data) =&gt; {
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>});
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>when(MyStates.STEP2)((sender, content, data) =&gt; {
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>});
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>when(MyStates.DONE)((sender, content, data) =&gt; {
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>});
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>when(MyStates.EMPTY)((sender, content, data) =&gt; {
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>});
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>when(MyStates.LOOP)((sender, content, data) =&gt; {
</span></span><span class=line><span class=cl>           
</span></span><span class=line><span class=cl>});
</span></span></code></pre></td></tr></table></div></div><p>从示例中可以发现，基于 fsm 的机器人框架需要使用类似 DSL 领域特定语言一样的描述语言，定义各种各样的状态，每一个状态都有触发点。当满足某个状态条件时，进入该状态，执行该状态的逻辑。这种基于状态机的机器人框架，对于简单的场景比较容易写，但是如果是遇到了复杂的场景，比如多轮对话中还附带上下文信息，就会写起来非常复杂。</p><p>于是引入了基于工作流的 chatbot 框架。其实工作流是对 fsm 的一种简化封装，本质上来讲，工作流能做到的，fsm 状态机也能做到，而且 fsm 状态机或许能拆的更细，但是工作流的一个个 function，或者是 function 的集合 dialog，可以互相组合，开发起来更符合大部分人的直觉。</p><ul><li><p>routing dialog</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>// hotels.js
</span></span><span class=line><span class=cl>module.exports = [
</span></span><span class=line><span class=cl>    // Destination
</span></span><span class=line><span class=cl>    function (session) {
</span></span><span class=line><span class=cl>        session.send(&#39;Welcome to the Hotels finder!&#39;);
</span></span><span class=line><span class=cl>        builder.Prompts.text(session, &#39;Please enter your destination&#39;);
</span></span><span class=line><span class=cl>    },
</span></span><span class=line><span class=cl>    function (session, results, next) {
</span></span><span class=line><span class=cl>        session.dialogData.destination = results.response;
</span></span><span class=line><span class=cl>        session.send(&#39;Looking for hotels in %s&#39;, results.response); 
</span></span><span class=line><span class=cl>        next();
</span></span><span class=line><span class=cl>    },
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>];
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// app.js
</span></span><span class=line><span class=cl>var bot = new builder.UniversalBot(connector, [
</span></span><span class=line><span class=cl>    function (session) {
</span></span><span class=line><span class=cl>        // ...
</span></span><span class=line><span class=cl>    },
</span></span><span class=line><span class=cl>    // ...
</span></span><span class=line><span class=cl>]);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>bot.dialog(&#39;hotels&#39;, require(&#39;./hotels&#39;));
</span></span><span class=line><span class=cl>bot.dialog(&#39;flights&#39;, require(&#39;./flights&#39;));
</span></span></code></pre></td></tr></table></div></div><p>通过 routing dialog，我们可以实现 dialog 的复用。</p></li><li><p>waterfall dialog</p><p>一个瀑布流的 dialog，可以让我们在一个 dialog 中像流一样完成一系列的动作。就像 fsm 的多种状态的集合。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>[
</span></span><span class=line><span class=cl>    // Destination
</span></span><span class=line><span class=cl>    function (session) {
</span></span><span class=line><span class=cl>        session.send(&#39;Welcome to the Hotels finder!&#39;);
</span></span><span class=line><span class=cl>        builder.Prompts.text(session, &#39;Please enter your destination&#39;);
</span></span><span class=line><span class=cl>    },
</span></span><span class=line><span class=cl>    function (session, results, next) {
</span></span><span class=line><span class=cl>        session.dialogData.destination = results.response;
</span></span><span class=line><span class=cl>        session.send(&#39;Looking for hotels in %s&#39;, results.response); 
</span></span><span class=line><span class=cl>        next();
</span></span><span class=line><span class=cl>    },
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    function (session) {
</span></span><span class=line><span class=cl>        var destination = session.dialogData.destination;
</span></span><span class=line><span class=cl>        var checkIn = new Date(session.dialogData.checkIn);
</span></span><span class=line><span class=cl>        var checkOut = checkIn.addDays(session.dialogData.nights);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        session.send(
</span></span><span class=line><span class=cl>            &#39;Ok. Searching for Hotels in %s from %d/%d to %d/%d...&#39;,
</span></span><span class=line><span class=cl>            destination,
</span></span><span class=line><span class=cl>            checkIn.getMonth() + 1, checkIn.getDate(),
</span></span><span class=line><span class=cl>            checkOut.getMonth() + 1, checkOut.getDate());
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        // Async search
</span></span><span class=line><span class=cl>        Store
</span></span><span class=line><span class=cl>            .searchHotels(destination, checkIn, checkOut)
</span></span><span class=line><span class=cl>            .then(function (hotels) {
</span></span><span class=line><span class=cl>                // Results
</span></span><span class=line><span class=cl>                session.send(&#39;I found in total %d hotels for your dates:&#39;, hotels.length);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                var message = new builder.Message()
</span></span><span class=line><span class=cl>                    .attachmentLayout(builder.AttachmentLayout.carousel)
</span></span><span class=line><span class=cl>                    .attachments(hotels.map(hotelAsAttachment));
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                session.send(message);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                // End
</span></span><span class=line><span class=cl>                session.endDialog();
</span></span><span class=line><span class=cl>            });
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>]
</span></span></code></pre></td></tr></table></div></div></li><li><p>state</p><p>在一个 dialog 上下文中共享的数据，或者在多个 dialog 中共享的数据。对于微软的 botbuilder 来讲，他们提供了如下几个 API：</p><div class=table-wrapper><table><thead><tr><th>Field</th><th>Use Cases</th></tr></thead><tbody><tr><td>userData</td><td>Stores information globally for the user across all conversations.</td></tr><tr><td>conversationData</td><td>Stores information globally for a single conversation. This data is visible to everyone within the conversation so care should be used to what’s stored there. It’s disabled by default and needs to be enabled using the bots <a class=link href=https://docs.botframework.com/en-us/node/builder/chat-reference/interfaces/_botbuilder_d_.iuniversalbotsettings.html#persistconversationdata target=_blank rel=noopener><code>persistConversationData</code></a> setting.</td></tr><tr><td>privateConversationData</td><td>Stores information globally for a single conversation but its private data for the current user. This data spans all dialogs so it’s useful for storing temporary state that you want cleaned up when the conversation ends.</td></tr><tr><td>dialogData</td><td>Persists information for a single dialog instance. This is essential for storing temporary information in between the steps of a waterfall.</td></tr></tbody></table></div></li></ul><h2 id=conversation-ui>Conversation UI</h2><p>对话式 UI（Conversation UI，下文简称 CUI）。</p><p>CUI 到底是什么？很好理解，我们日常跟人聊天的微信、短信界面就是。由一条条消息组成，按时间先后展示出来，就可以看作 CUI。</p><p>chatbot 在与用户交流时，不单单是只有文字，还会需要用户进行互动，这时候就是 CUI 的用武之地了。我们可以和移动端进行约定，对一些特定的消息格式进行渲染，这样就可以做出按钮，列表等。</p><h2 id=bot-service>Bot Service</h2><p>作为一个机器人框架，开发完成之后，还需要和 telegram，Facebook messenger，slack 等 IM 平台进行对接，如果要开发者一个个对接的话，将会特别麻烦。作为 chatbot 开发框架的一部分，bot service 的工作就是对接 IM 平台。</p><h2 id=bot-builder-源码阅读>Bot Builder 源码阅读</h2><p>微软的 botbuilder-js 出到了 V4 版本，在新版本的机器人框架有着很大的变动，相比于 V3 目录结构变化了，而且机器人编写流程也有了一定的差异。</p><p>项目结构</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>├── botbuilder
</span></span><span class=line><span class=cl>├── botbuilder-ai
</span></span><span class=line><span class=cl>├── botbuilder-azure
</span></span><span class=line><span class=cl>├── botbuilder-core
</span></span><span class=line><span class=cl>├── botbuilder-dialogs
</span></span><span class=line><span class=cl>├── botframework-config
</span></span><span class=line><span class=cl>├── botframework-connector
</span></span><span class=line><span class=cl>├── botframework-schema
</span></span></code></pre></td></tr></table></div></div><p>目录结构更加的组件化。</p><p>如果我们不使用微软的服务，那么 botbuilder-ai 和 botbuilder-azure 其实不重要。</p><h3 id=botbuilder>botbuilder</h3><p>botbuilder 是框架的入口，在这个 package 中做的事情比较简单：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./botFrameworkAdapter&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./fileTranscriptStore&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;../../botbuilder-core/lib&#39;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>导出 botbuilder-core 和继承了 botAdapter 的子类 botFrameworkAdapter。</p><p>fileTranscriptStore 是存储每个 activity 的 transcript 到文件中，Transcript 是人和 bot 的对话动作的日志。</p><p>如果我们要定制自己的 bot 动作，其实就可以继承 botAdapter，然后对接自己的 IM 等等。botAdapter 也是 botbuilder-core 中的，所以 botbuilder-core 是核心，只要读懂了 botbuilder-core，就可以说是理解了微软的机器人框架。</p><h3 id=botbuilder-core>botbuilder-core</h3><p>看 botbuilder-core，也从 index.ts 开始。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;../../botframework-schema/lib&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./autoSaveStateMiddleware&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./botAdapter&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./botState&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./botStatePropertyAccessor&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./botStateSet&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./browserStorage&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./cardFactory&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./conversationState&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./memoryStorage&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./memoryTranscriptStore&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./messageFactory&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./middlewareSet&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./privateConversationState&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./propertyManager&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./recognizerResult&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./showTypingMiddleware&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./storage&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./testAdapter&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./transcriptLogger&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./turnContext&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=o>*</span> <span class=kr>from</span> <span class=s1>&#39;./userState&#39;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>这里引入了一个 botframework-schema，通过名字可以看出来，这就是一个类型定义的包，主要是机器人 Activity 的 Schema。Activity 是人和 bot 所做的会话的程序级别的表示，该 schema 中包含了文本协议、多媒体和非内容动作（如社交互动和打字指示符）的规定。</p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><div class=disqus-container><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{DISQUS&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
1993 -
2022 演示站点</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.10.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#聊天机器人>聊天机器人</a></li><li><a href=#机器人开发框架>机器人开发框架</a></li><li><a href=#实现方式>实现方式</a></li><li><a href=#conversation-ui>Conversation UI</a></li><li><a href=#bot-service>Bot Service</a></li><li><a href=#bot-builder-源码阅读>Bot Builder 源码阅读</a><ol><li><a href=#botbuilder>botbuilder</a></li><li><a href=#botbuilder-core>botbuilder-core</a></li></ol></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>