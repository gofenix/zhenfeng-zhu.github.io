<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Chapter6 整理你的项目：一个图书管理员的故事 | Awesome Fenix</title>
<meta name=keywords content="clojure">
<meta name=description content="整理你的项目：一个图书管理员的故事 在我们每个人心中都住着一个叫 Melvil 的图书管理员，一个以组织艺术为乐的奇异生物。日日夜夜，Melvil 都渴望为你的代码库带来秩序。幸运的是，Clojure 提供了一套工具，专门用来帮助这个侏儒与混乱的力量不断斗争。
这些工具通过将相关的函数和数据分组来帮助你组织你的代码。它们还可以防止名称冲突，这样你就不会意外地覆盖别人的代码，反之亦然。在这个充满悬念和神秘的故事中，请和我一起学习如何使用这些工具，并解决一生中的抢劫案吧 在这个传奇故事的最后，你将了解以下内容。
  `def&rsquo;是做什么的
  什么是命名空间以及如何使用它们
  命名空间和文件系统之间的关系
  如何使用refer、alias、require、use和ns。
  如何使用文件系统来组织 Clojure 项目
  我先来介绍一下 Clojure 的组织系统，它的工作原理很像一个库。Melvil 兴奋地颤抖着!
你的项目是一个库 现实世界中的图书馆存储对象的集合，如书籍、杂志和 DVD。他们使用寻址系统，所以当你得到一个物体的地址时，你可以导航到物理空间并检索到该物体。
当然，没有人能够直接知道一本书或 DVD 的地址是什么。这就是为什么图书馆要记录一个物体的标题和它的地址之间的联系，并提供工具来搜索这些记录。在计算机之前的旧时代，图书馆提供卡片目录，即装满纸质卡片的柜子，其中包含每本书的标题、作者、&ldquo;地址&rdquo;（杜威十进制或国会图书馆编号）和其他信息。
例如，要找到《达芬奇密码》，你可以翻阅书名目录（按书名排序的卡片），直到你找到正确的卡片。在那张卡片上，你会看到地址813.54（如果它使用杜威十进制系统），浏览图书馆，找到达芬奇密码所在的书架，并参与你一生中的文学和/或仇恨阅读冒险。
在 Clojure 中想象一个类似的设置是很有用的。我认为 Clojure 是将对象（如数据结构和函数）存储在一组巨大的编号架上。没有人能够直接知道一个对象被存储在哪个架子上。相反，我们给 Clojure 一个标识符，它用来检索该对象。
为了使之成功，Clojure 必须维护我们的标识符和货架地址之间的关联。它通过使用namespaces来做到这一点。命名空间包含了人类友好的符号和书架地址的引用之间的映射，被称为vars，很像卡片目录。
从技术上讲，命名空间是 &ldquo;clojure.lang.Namespace &ldquo;类型的对象，你可以与它们互动，就像你可以与 Clojure 数据结构互动一样。例如，你可以用*ns*来引用当前的命名空间，你可以用(ns-name *ns*)来获得其名称。
(ns-name *ns*) ; => user 例如，当你启动 REPL 时，你在user命名空间中（正如你在这里看到的）。提示符显示当前名称空间，使用user=>。
当前名字空间的概念意味着你可以有多个名字空间，事实上 Clojure 允许你创建任意多的名字空间（尽管从技术上讲，你可以创建的名字数量可能有一个上限）。在 Clojure 程序中，你总是在个命名空间中。
至于符号，你一直在使用它们，甚至没有意识到。例如，当你写(map inc [1 2])时，map和inc都是符号。符号是 Clojure 中的数据类型，我将在下一章中彻底解释它们。现在，你需要知道的是，当你给 Clojure 一个像map这样的符号时，它会在当前命名空间中找到相应的 var，得到一个架子上的地址，并为你从那个架子上检索一个对象&ndash;在这里，就是map所指的那个函数。如果你想只使用符号本身，而不是它所指的东西，你必须引用它。引述任何 Clojure 的形式告诉 Clojure 不要评估它，而是把它当作数据。接下来的几个例子显示了当你引用一个表单时会发生什么。">
<meta name=author content="Fenix">
<link rel=canonical href=https://zhenfeng-zhu.github.io/posts/chapter6/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zhenfeng-zhu.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://zhenfeng-zhu.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://zhenfeng-zhu.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://zhenfeng-zhu.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://zhenfeng-zhu.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-216295420-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Chapter6 整理你的项目：一个图书管理员的故事">
<meta property="og:description" content="整理你的项目：一个图书管理员的故事 在我们每个人心中都住着一个叫 Melvil 的图书管理员，一个以组织艺术为乐的奇异生物。日日夜夜，Melvil 都渴望为你的代码库带来秩序。幸运的是，Clojure 提供了一套工具，专门用来帮助这个侏儒与混乱的力量不断斗争。
这些工具通过将相关的函数和数据分组来帮助你组织你的代码。它们还可以防止名称冲突，这样你就不会意外地覆盖别人的代码，反之亦然。在这个充满悬念和神秘的故事中，请和我一起学习如何使用这些工具，并解决一生中的抢劫案吧 在这个传奇故事的最后，你将了解以下内容。
  `def&rsquo;是做什么的
  什么是命名空间以及如何使用它们
  命名空间和文件系统之间的关系
  如何使用refer、alias、require、use和ns。
  如何使用文件系统来组织 Clojure 项目
  我先来介绍一下 Clojure 的组织系统，它的工作原理很像一个库。Melvil 兴奋地颤抖着!
你的项目是一个库 现实世界中的图书馆存储对象的集合，如书籍、杂志和 DVD。他们使用寻址系统，所以当你得到一个物体的地址时，你可以导航到物理空间并检索到该物体。
当然，没有人能够直接知道一本书或 DVD 的地址是什么。这就是为什么图书馆要记录一个物体的标题和它的地址之间的联系，并提供工具来搜索这些记录。在计算机之前的旧时代，图书馆提供卡片目录，即装满纸质卡片的柜子，其中包含每本书的标题、作者、&ldquo;地址&rdquo;（杜威十进制或国会图书馆编号）和其他信息。
例如，要找到《达芬奇密码》，你可以翻阅书名目录（按书名排序的卡片），直到你找到正确的卡片。在那张卡片上，你会看到地址813.54（如果它使用杜威十进制系统），浏览图书馆，找到达芬奇密码所在的书架，并参与你一生中的文学和/或仇恨阅读冒险。
在 Clojure 中想象一个类似的设置是很有用的。我认为 Clojure 是将对象（如数据结构和函数）存储在一组巨大的编号架上。没有人能够直接知道一个对象被存储在哪个架子上。相反，我们给 Clojure 一个标识符，它用来检索该对象。
为了使之成功，Clojure 必须维护我们的标识符和货架地址之间的关联。它通过使用namespaces来做到这一点。命名空间包含了人类友好的符号和书架地址的引用之间的映射，被称为vars，很像卡片目录。
从技术上讲，命名空间是 &ldquo;clojure.lang.Namespace &ldquo;类型的对象，你可以与它们互动，就像你可以与 Clojure 数据结构互动一样。例如，你可以用*ns*来引用当前的命名空间，你可以用(ns-name *ns*)来获得其名称。
(ns-name *ns*) ; => user 例如，当你启动 REPL 时，你在user命名空间中（正如你在这里看到的）。提示符显示当前名称空间，使用user=>。
当前名字空间的概念意味着你可以有多个名字空间，事实上 Clojure 允许你创建任意多的名字空间（尽管从技术上讲，你可以创建的名字数量可能有一个上限）。在 Clojure 程序中，你总是在个命名空间中。
至于符号，你一直在使用它们，甚至没有意识到。例如，当你写(map inc [1 2])时，map和inc都是符号。符号是 Clojure 中的数据类型，我将在下一章中彻底解释它们。现在，你需要知道的是，当你给 Clojure 一个像map这样的符号时，它会在当前命名空间中找到相应的 var，得到一个架子上的地址，并为你从那个架子上检索一个对象&ndash;在这里，就是map所指的那个函数。如果你想只使用符号本身，而不是它所指的东西，你必须引用它。引述任何 Clojure 的形式告诉 Clojure 不要评估它，而是把它当作数据。接下来的几个例子显示了当你引用一个表单时会发生什么。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhenfeng-zhu.github.io/posts/chapter6/">
<meta property="og:image" content="https://zhenfeng-zhu.github.io/posts/chapter6/https:/raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201131821608.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-14T12:40:41+08:00">
<meta property="article:modified_time" content="2022-01-14T12:40:41+08:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhenfeng-zhu.github.io/posts/chapter6/https:/raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201131821608.png">
<meta name=twitter:title content="Chapter6 整理你的项目：一个图书管理员的故事">
<meta name=twitter:description content="整理你的项目：一个图书管理员的故事 在我们每个人心中都住着一个叫 Melvil 的图书管理员，一个以组织艺术为乐的奇异生物。日日夜夜，Melvil 都渴望为你的代码库带来秩序。幸运的是，Clojure 提供了一套工具，专门用来帮助这个侏儒与混乱的力量不断斗争。
这些工具通过将相关的函数和数据分组来帮助你组织你的代码。它们还可以防止名称冲突，这样你就不会意外地覆盖别人的代码，反之亦然。在这个充满悬念和神秘的故事中，请和我一起学习如何使用这些工具，并解决一生中的抢劫案吧 在这个传奇故事的最后，你将了解以下内容。
  `def&rsquo;是做什么的
  什么是命名空间以及如何使用它们
  命名空间和文件系统之间的关系
  如何使用refer、alias、require、use和ns。
  如何使用文件系统来组织 Clojure 项目
  我先来介绍一下 Clojure 的组织系统，它的工作原理很像一个库。Melvil 兴奋地颤抖着!
你的项目是一个库 现实世界中的图书馆存储对象的集合，如书籍、杂志和 DVD。他们使用寻址系统，所以当你得到一个物体的地址时，你可以导航到物理空间并检索到该物体。
当然，没有人能够直接知道一本书或 DVD 的地址是什么。这就是为什么图书馆要记录一个物体的标题和它的地址之间的联系，并提供工具来搜索这些记录。在计算机之前的旧时代，图书馆提供卡片目录，即装满纸质卡片的柜子，其中包含每本书的标题、作者、&ldquo;地址&rdquo;（杜威十进制或国会图书馆编号）和其他信息。
例如，要找到《达芬奇密码》，你可以翻阅书名目录（按书名排序的卡片），直到你找到正确的卡片。在那张卡片上，你会看到地址813.54（如果它使用杜威十进制系统），浏览图书馆，找到达芬奇密码所在的书架，并参与你一生中的文学和/或仇恨阅读冒险。
在 Clojure 中想象一个类似的设置是很有用的。我认为 Clojure 是将对象（如数据结构和函数）存储在一组巨大的编号架上。没有人能够直接知道一个对象被存储在哪个架子上。相反，我们给 Clojure 一个标识符，它用来检索该对象。
为了使之成功，Clojure 必须维护我们的标识符和货架地址之间的关联。它通过使用namespaces来做到这一点。命名空间包含了人类友好的符号和书架地址的引用之间的映射，被称为vars，很像卡片目录。
从技术上讲，命名空间是 &ldquo;clojure.lang.Namespace &ldquo;类型的对象，你可以与它们互动，就像你可以与 Clojure 数据结构互动一样。例如，你可以用*ns*来引用当前的命名空间，你可以用(ns-name *ns*)来获得其名称。
(ns-name *ns*) ; => user 例如，当你启动 REPL 时，你在user命名空间中（正如你在这里看到的）。提示符显示当前名称空间，使用user=>。
当前名字空间的概念意味着你可以有多个名字空间，事实上 Clojure 允许你创建任意多的名字空间（尽管从技术上讲，你可以创建的名字数量可能有一个上限）。在 Clojure 程序中，你总是在个命名空间中。
至于符号，你一直在使用它们，甚至没有意识到。例如，当你写(map inc [1 2])时，map和inc都是符号。符号是 Clojure 中的数据类型，我将在下一章中彻底解释它们。现在，你需要知道的是，当你给 Clojure 一个像map这样的符号时，它会在当前命名空间中找到相应的 var，得到一个架子上的地址，并为你从那个架子上检索一个对象&ndash;在这里，就是map所指的那个函数。如果你想只使用符号本身，而不是它所指的东西，你必须引用它。引述任何 Clojure 的形式告诉 Clojure 不要评估它，而是把它当作数据。接下来的几个例子显示了当你引用一个表单时会发生什么。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://zhenfeng-zhu.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Chapter6 整理你的项目：一个图书管理员的故事","item":"https://zhenfeng-zhu.github.io/posts/chapter6/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Chapter6 整理你的项目：一个图书管理员的故事","name":"Chapter6 整理你的项目：一个图书管理员的故事","description":"整理你的项目：一个图书管理员的故事 在我们每个人心中都住着一个叫 Melvil 的图书管理员，一个以组织艺术为乐的奇异生物。日日夜夜，Melvil 都渴望为你的代码库带来秩序。幸运的是，Clojure 提供了一套工具，专门用来帮助这个侏儒与混乱的力量不断斗争。\n这些工具通过将相关的函数和数据分组来帮助你组织你的代码。它们还可以防止名称冲突，这样你就不会意外地覆盖别人的代码，反之亦然。在这个充满悬念和神秘的故事中，请和我一起学习如何使用这些工具，并解决一生中的抢劫案吧 在这个传奇故事的最后，你将了解以下内容。\n  `def\u0026rsquo;是做什么的\n  什么是命名空间以及如何使用它们\n  命名空间和文件系统之间的关系\n  如何使用refer、alias、require、use和ns。\n  如何使用文件系统来组织 Clojure 项目\n  我先来介绍一下 Clojure 的组织系统，它的工作原理很像一个库。Melvil 兴奋地颤抖着!\n你的项目是一个库 现实世界中的图书馆存储对象的集合，如书籍、杂志和 DVD。他们使用寻址系统，所以当你得到一个物体的地址时，你可以导航到物理空间并检索到该物体。\n当然，没有人能够直接知道一本书或 DVD 的地址是什么。这就是为什么图书馆要记录一个物体的标题和它的地址之间的联系，并提供工具来搜索这些记录。在计算机之前的旧时代，图书馆提供卡片目录，即装满纸质卡片的柜子，其中包含每本书的标题、作者、\u0026ldquo;地址\u0026rdquo;（杜威十进制或国会图书馆编号）和其他信息。\n例如，要找到《达芬奇密码》，你可以翻阅书名目录（按书名排序的卡片），直到你找到正确的卡片。在那张卡片上，你会看到地址813.54（如果它使用杜威十进制系统），浏览图书馆，找到达芬奇密码所在的书架，并参与你一生中的文学和/或仇恨阅读冒险。\n在 Clojure 中想象一个类似的设置是很有用的。我认为 Clojure 是将对象（如数据结构和函数）存储在一组巨大的编号架上。没有人能够直接知道一个对象被存储在哪个架子上。相反，我们给 Clojure 一个标识符，它用来检索该对象。\n为了使之成功，Clojure 必须维护我们的标识符和货架地址之间的关联。它通过使用namespaces来做到这一点。命名空间包含了人类友好的符号和书架地址的引用之间的映射，被称为vars，很像卡片目录。\n从技术上讲，命名空间是 \u0026ldquo;clojure.lang.Namespace \u0026ldquo;类型的对象，你可以与它们互动，就像你可以与 Clojure 数据结构互动一样。例如，你可以用*ns*来引用当前的命名空间，你可以用(ns-name *ns*)来获得其名称。\n(ns-name *ns*) ; =\u0026gt; user 例如，当你启动 REPL 时，你在user命名空间中（正如你在这里看到的）。提示符显示当前名称空间，使用user=\u0026gt;。\n当前名字空间的概念意味着你可以有多个名字空间，事实上 Clojure 允许你创建任意多的名字空间（尽管从技术上讲，你可以创建的名字数量可能有一个上限）。在 Clojure 程序中，你总是在个命名空间中。\n至于符号，你一直在使用它们，甚至没有意识到。例如，当你写(map inc [1 2])时，map和inc都是符号。符号是 Clojure 中的数据类型，我将在下一章中彻底解释它们。现在，你需要知道的是，当你给 Clojure 一个像map这样的符号时，它会在当前命名空间中找到相应的 var，得到一个架子上的地址，并为你从那个架子上检索一个对象\u0026ndash;在这里，就是map所指的那个函数。如果你想只使用符号本身，而不是它所指的东西，你必须引用它。引述任何 Clojure 的形式告诉 Clojure 不要评估它，而是把它当作数据。接下来的几个例子显示了当你引用一个表单时会发生什么。","keywords":["clojure"],"articleBody":"整理你的项目：一个图书管理员的故事 在我们每个人心中都住着一个叫 Melvil 的图书管理员，一个以组织艺术为乐的奇异生物。日日夜夜，Melvil 都渴望为你的代码库带来秩序。幸运的是，Clojure 提供了一套工具，专门用来帮助这个侏儒与混乱的力量不断斗争。\n这些工具通过将相关的函数和数据分组来帮助你组织你的代码。它们还可以防止名称冲突，这样你就不会意外地覆盖别人的代码，反之亦然。在这个充满悬念和神秘的故事中，请和我一起学习如何使用这些工具，并解决一生中的抢劫案吧 在这个传奇故事的最后，你将了解以下内容。\n  `def’是做什么的\n  什么是命名空间以及如何使用它们\n  命名空间和文件系统之间的关系\n  如何使用refer、alias、require、use和ns。\n  如何使用文件系统来组织 Clojure 项目\n  我先来介绍一下 Clojure 的组织系统，它的工作原理很像一个库。Melvil 兴奋地颤抖着!\n你的项目是一个库 现实世界中的图书馆存储对象的集合，如书籍、杂志和 DVD。他们使用寻址系统，所以当你得到一个物体的地址时，你可以导航到物理空间并检索到该物体。\n当然，没有人能够直接知道一本书或 DVD 的地址是什么。这就是为什么图书馆要记录一个物体的标题和它的地址之间的联系，并提供工具来搜索这些记录。在计算机之前的旧时代，图书馆提供卡片目录，即装满纸质卡片的柜子，其中包含每本书的标题、作者、“地址”（杜威十进制或国会图书馆编号）和其他信息。\n例如，要找到《达芬奇密码》，你可以翻阅书名目录（按书名排序的卡片），直到你找到正确的卡片。在那张卡片上，你会看到地址813.54（如果它使用杜威十进制系统），浏览图书馆，找到达芬奇密码所在的书架，并参与你一生中的文学和/或仇恨阅读冒险。\n在 Clojure 中想象一个类似的设置是很有用的。我认为 Clojure 是将对象（如数据结构和函数）存储在一组巨大的编号架上。没有人能够直接知道一个对象被存储在哪个架子上。相反，我们给 Clojure 一个标识符，它用来检索该对象。\n为了使之成功，Clojure 必须维护我们的标识符和货架地址之间的关联。它通过使用namespaces来做到这一点。命名空间包含了人类友好的符号和书架地址的引用之间的映射，被称为vars，很像卡片目录。\n从技术上讲，命名空间是 “clojure.lang.Namespace “类型的对象，你可以与它们互动，就像你可以与 Clojure 数据结构互动一样。例如，你可以用*ns*来引用当前的命名空间，你可以用(ns-name *ns*)来获得其名称。\n(ns-name *ns*) ; = user 例如，当你启动 REPL 时，你在user命名空间中（正如你在这里看到的）。提示符显示当前名称空间，使用user=。\n当前名字空间的概念意味着你可以有多个名字空间，事实上 Clojure 允许你创建任意多的名字空间（尽管从技术上讲，你可以创建的名字数量可能有一个上限）。在 Clojure 程序中，你总是在个命名空间中。\n至于符号，你一直在使用它们，甚至没有意识到。例如，当你写(map inc [1 2])时，map和inc都是符号。符号是 Clojure 中的数据类型，我将在下一章中彻底解释它们。现在，你需要知道的是，当你给 Clojure 一个像map这样的符号时，它会在当前命名空间中找到相应的 var，得到一个架子上的地址，并为你从那个架子上检索一个对象–在这里，就是map所指的那个函数。如果你想只使用符号本身，而不是它所指的东西，你必须引用它。引述任何 Clojure 的形式告诉 Clojure 不要评估它，而是把它当作数据。接下来的几个例子显示了当你引用一个表单时会发生什么。\n➊ inc ; = #➋ 'inc ; = inc ➌ (map inc [1 2]) ; = (2 3) ➍ '(map inc [1 2]) ; = (map inc [1 2]) 当你在 REPL 中评估 inc 在 ➊ 处时，它会打印出 inc 所指的函数的文本表述。接下来，你在➋引用inc，所以结果是符号inc。然后，你在➌处评估一个熟悉的map应用程序，得到一个熟悉的结果。之后，你在➍处引用整个列表数据结构，结果是一个未评估的列表，包括map符号、inc符号和一个向量。\n现在你知道了 Clojure 的组织系统，让我们来看看如何使用它。\n用 def 存储对象 Clojure 中用于存储对象的主要工具是def。其他的工具，如defn，都是使用def。下面是一个 def 的应用实例。\n(def great-books [\"East of Eden\" \"The Glass Bead Game\"]) ; = #'user/great-books great-books ; = [\"East of Eden\" \"The Glass Bead Game\"] 这段代码告诉 Clojure。\n 用great-books和 var 之间的关联更新当前命名空间的地图。 找到一个空闲的存储架。 将[《伊甸园之东》《玻璃珠游戏》]存放在架子上。 将书架的地址写在 var 上。 5.返回 var（在这个例子中，`#‘user/great-books’）。  这个过程被称为interning一个 var。 你可以使用`ns-interns’与命名空间的符号到内含变量的映射进行交互。下面是你如何获得一个内部变量的映射。\n(ns-interns *ns*) ; = {great-books #'user/great-books}. 你可以使用`get’函数来获取一个特定的 var。\n(get (ns-interns *ns*) ' great-books) ; = #'user/great-books 通过评估(ns-map ns),你也可以得到命名空间在给定一个符号时用来查找 var 的完整地图。(ns-map *ns*)给你一个非常大的地图，我不会在这里打印，但可以试试\n#'user/great-books'是var的*读者形式。 我将在第七章解释更多关于读者形式。现在，只需知道你可以使用#‘‘来抓取与后面的符号对应的 var；#'user/great-books'让你在user’命名空间中使用与符号great-books'相关的var。我们可以deref’变量来获得它们所指向的对象。\n(deref #'user/great-books) ; = [\"East of Eden\" \"The Glass Bead Game\"] 这就像告诉 Clojure，“从 var 中获取书架号，去那个书架号，抓住上面的东西，然后给我！”\n但是通常情况下，你只需要使用符号。\ngreat-books ; = [\"East of Eden\" \"The Glass Bead Game\"] 这就像告诉 Clojure，“检索与 great-books 相关的 var，然后取消那个坏的杰克逊”。\n到目前为止还不错，对吗？好吧，请做好准备，因为这个田园诗般的组织天堂即将被颠覆 用同样的符号再次调用def。\n(def great-books [\"The Power of Bees\" \"Journey to Upstairs\"]) great-books ; = [\"The Power of Bees\" \"Journey to Upstairs\"] var 已经更新了新的矢量的地址。这就像你在卡片目录中的卡片上的地址用了白笔，然后写了一个新地址。其结果是，你不能再要求 Clojure 找到第一个向量。这被称为名称碰撞。混乱! 无政府状态!\n你可能在其他编程语言中经历过这种情况。JavaScript 在这方面是臭名昭著的，它也发生在 Ruby 中。这是个问题，因为你可能无意中覆盖了你自己的代码，而且你也不能保证第三方库不会覆盖你的代码。Melvil 惊恐地退缩了! 幸运的是，Clojure 允许你创建任意多的命名空间，这样你就可以避免这些碰撞。\n创建和切换到命名空间 Clojure 有三种创建命名空间的工具：函数create-ns，函数in-ns，以及宏ns。你将在你的 Clojure 文件中主要使用ns宏，但我将推迟几页来解释它，因为它结合了许多工具，而且在我讨论其他工具之后，它更容易理解。\ncreate-ns接收一个符号，如果它不存在，就用这个名字创建一个命名空间，并返回这个命名空间。\nuser= (create-ns 'cheese.taxonomy) ; = #你可以使用返回的名字空间作为函数调用的参数。\nuser= (ns-name (create-ns 'cheese.taxonomy)) ; = cheese-taxonomy 在实践中，你可能永远不会在你的代码中使用create-ns，因为创建一个命名空间而不移入它并不是非常有用。使用in-ns更常见，因为如果命名空间不存在，它会创建命名空间，并**切换到它，如清单 6-1 所示。\nuser= (in-ns 'cheese.analysis) ; = # 6-1. 使用 in-ns 创建一个命名空间并切换到该空间  注意你的 REPL 提示符现在是cheese.analysis，表明你确实在你刚刚创建的新命名空间中。现在当你使用def时，它将在cheese.analysis命名空间中存储命名对象。\n但是如果你想使用其他命名空间的函数和数据怎么办？要做到这一点，你可以使用一个完全合格的符号。一般的形式是 namespace/name。\ncheese.analysis= (in-ns 'cheese.taxonomy) cheese.taxonomy= (def cheddars [\"mild\" \"medium\" \"strong\" \"sharp\" \"extra sharp\"]) cheese.taxonomy= (in-ns 'cheese.analysis) cheese.analysis= cheddars ; = Exception: Unable to resolve symbol: cheddars in this context 这创建了一个新的命名空间，cheese.taxonomy，在该命名空间中定义了cheddars，然后切换回cheese.analysis命名空间。如果你试图在cheese.analysis中引用cheese.taxonomy命名空间的cheddars，你会得到一个异常，但是使用完全合格的符号可以。\ncheese.analysis= cheese.taxonomy/cheddars ; = [\"mild\" \"medium\" \"strong\" \"sharp\" \"extra sharp\"] 输入这些完全合格的符号很快就会成为一种困扰。 比如说，我是一个极不耐烦的学者，专门研究符号学-au-fromage，或者研究与奶酪有关的符号。\n突然间，可能发生的最糟糕的事情发生了！在全世界范围内，神圣的和有可能发生的事情都发生了。在世界各地，神圣的、具有历史意义的奶酪都失踪了。威斯康星州的标准切达干酪：不见了! 图坦卡蒙的大奶酪罐：被偷了! 都灵奶酪：被骗取的奶酪所取代! 这有可能使世界因某种原因而陷入完全的混乱! 自然，作为一个杰出的奶酪研究者，我有责任解开这个谜团。与此同时，我正被光明会、共济会和足部族追捕！因为我是一名学者，所以我必须为他们提供帮助。\n因为我是一个学者，我试图用我知道的最好的方式来解决这个谜团–去图书馆研究这个狗屎。我可靠的助手 Clojure 陪着我。当我们从一个名字空间到另一个名字空间忙忙碌碌时，我喊着让 Clojure 把一个又一个东西交给我。\n但 Clojure 有点笨，很难弄清楚我指的是什么。在user命名空间中，我大声说：\"join! 给我join'！\"--我嘴里的唾沫星子飞了出来。\"RuntimeException: Unable to resolve symbol: join,\" Clojure抱怨着回应。\"看在布里的份上，把clojure.string/join`交给我吧！” 我反驳道，Clojure 尽职尽责地把我要找的函数交给我。\n我的声音变得沙哑了。我需要一些方法来告诉 Clojure 要给我什么对象，而不必每次都使用完全合格的符号。\n幸运的是，Clojure 提供了 “refer “和 “alias “工具，让我可以更简洁地对它吼叫。\n引用 refer使你能够精细地控制你如何引用其他命名空间的对象。启动一个新的 REPL 会话并尝试以下操作。请记住，在 REPL 中这样玩命名空间是可以的，但你不希望你的 Clojure 文件看起来像这样；正确的文件结构方式在“真正的项目组织 “第 133 页中涉及。\nuser= (in-ns 'cheese.taxonomy) cheese.taxonomy= (def cheddars [\"mild\" \"medium\" \"strong\" \"sharp\" \"extra sharp\"]) cheese.taxonomy= (def bries [\"Wisconsin\" \"Somerset\" \"Brie de Meaux\" \"Brie de Melun\"]) cheese.taxonomy= (in-ns 'cheese.analysis) cheese.analysis= (clojure.core/refer 'cheese.taxonomy) cheese.analysis= bries ; = [\"Wisconsin\" \"Somerset\" \"Brie de Meaux\" \"Brie de Melun\"] cheese.analysis= cheddars ; = [\"mild\" \"medium\" \"strong\" \"sharp\" \"extra sharp\"] 这段代码创建了一个 “cheese.taxonomy “命名空间和其中的两个向量。 cheddars和bries。然后它创建并移动到一个新的命名空间，称为cheese.analysis。用命名空间的符号调用refer可以让你引用相应的命名空间的对象，而不需要使用完全限定的符号。它通过更新当前命名空间的符号/对象映射来实现这一目的。你可以看到像这样的新条目。\ncheese.analysis= (clojure.core/get (clojure.core/ns-map clojure.core/*ns*) 'bries) ; = #'cheese.taxonomy/bries cheese.analysis= (clojure.core/get (clojure.core/ns-map clojure.core/*ns*) 'cheddars) ; = #'cheese.taxonomy/cheddars 这就好像 Clojure\n 在cheese.taxonomy命名空间上调用ns-interns。 将其与当前命名空间的ns-map合并。 将结果作为当前命名空间的新的`ns-map’。  当你调用refer时，你也可以把过滤器:only, :exclude, 和:rename传递给它。正如名字所暗示的，:only和:exclude限制了哪些符号/变量映射被合并到当前命名空间的ns-map。 :rename允许你使用不同的符号来表示被合并的变量。如果我们将前面的例子修改为使用:only，会发生以下情况。\ncheese.analysis= (clojure.core/refer 'cheese.taxonomy :only ['bries]) cheese.analysis= bries ; = [\"Wisconsin\" \"Somerset\" \"Brie de Meaux\" \"Brie de Melun\"] cheese.analysis= cheddars ; = RuntimeException: 无法解决符号：cheddars 下面是:exclude的操作。\ncheese.analysis= (clojure.core/refer 'cheese.taxonomy :only ['bries]) cheese.analysis= bries ; = [\"Wisconsin\" \"Somerset\" \"Brie de Meaux\" \"Brie de Melun\"] cheese.analysis= cheddars ; = RuntimeException: Unable to resolve symbol: cheddars 最后，一个:rename的例子。\ncheese.analysis= (clojure.core/refer 'cheese.taxonomy :rename {'bries 'yummy-bries}) cheese.analysis= bries ; = RuntimeException: Unable to resolve symbol: bries cheese.analysis= yummy-bries ; = [\"Wisconsin\" \"Somerset\" \"Brie de Meaux\" \"Brie de Melun\"] 注意，在这些最后的例子中，我们必须使用clojure.core中所有对象的完全合格名称，如clojure.core/ns-map和clojure.core/refer。我们不需要在user命名空间中这样做。这是因为 REPL 在user命名空间中自动引用clojure.core。当你创建一个新的命名空间时，你可以通过评估(clojure.core/refer-clojure)来简化你的生活；这将引用 clojure.core 命名空间，从现在起我将使用它。在例子中你不会看到clojure.core/refer，而只会看到refer。\n另一件需要注意的事情是，你可以完全自由地组织你的函数和数据，跨越命名空间。这让你可以合理地将相关的函数和数据归入同一命名空间。\n有时你可能希望一个函数只对同一命名空间内的其他函数有效。Clojure 允许你使用defn-来定义私有的函数。\n(in-ns 'cheese.analysis) ;; Notice the dash after \"defn\" (defn- private-function \"Just an example function that does nothing\" []) 如果你试图从其他命名空间调用这个函数或引用它，Clojure 将抛出一个异常。你可以在评估➊和➋的代码时看到这一点。\ncheese.analysis= (in-ns 'cheese.taxonomy) cheese.taxonomy= (clojure.core/refer-clojure) ➊ cheese.taxonomy= (cheese.analysis/private-function) ➋ cheese.taxonomy= (refer 'cheese.analysis :only ['private-function]) 正如你所看到的，即使你明确地 “引用 “这个函数，你也不能使用其他命名空间的函数，因为你把它变成了私有的。(如果你想狡猾一点，你仍然可以使用神秘的语法`@#‘some/private-var’来访问私有变量，但你很少想这样做)。\nalias 与refer相比，alias相对简单。它所做的只是让你缩短一个命名空间的名称，以便使用完全合格的符号。\ncheese.analysis= (clojure.core/alias 'taxonomy 'cheese.taxonomy) cheese.analysis= taxonomy/bries ; = [\"Wisconsin\" \"Somerset\" \"Brie de Meaux\" \"Brie de Melun\"] 这段代码让我们使用来自cheese.taxonomy命名空间的调用符号，并使用较短的别名taxonomy。\nrefer和alias是你引用当前命名空间以外的对象的两个基本工具! 它们是 REPL 开发的好帮手。\n然而，你不可能在 REPL 中创建整个程序。在下一节中，我将介绍你需要知道的一切，以组织一个真正的项目，使源代码在文件系统中生存。\n真正的项目组织 现在我已经介绍了 Clojure 组织系统的构建模块，我将向你展示如何在实际项目中使用它们。我将讨论文件路径和命名空间名称之间的关系，解释如何用require和use加载文件，并展示如何使用ns来设置一个命名空间。\n文件路径和命名空间名称之间的关系 为了一石二鸟（或者用一颗种子喂养两只鸟，这取决于你是多么的嬉皮士），我将介绍更多关于命名空间的内容，同时我们将通过绘制国际奶酪大盗的抢劫地点来抓捕这个讨厌的大盗。运行以下程序。\nlein new app the-divine-cheese-code 这应该创建一个目录结构，看起来像这样。\n| .gitignore | doc | | intro.md | project.clj | README.md | resources | src | | the_divine_cheese_code | | | core.clj | test | | the_divine_cheese_code | | | core_test.clj 现在，打开src/the_divine_cheese_code/core.clj。你应该在第一行看到这个。\n(ns the-divine-cheese-code.core (:gen-class)) ns是在 Clojure 中创建和管理命名空间的主要方式。我很快就会对它进行全面的解释。不过现在，只需知道这一行与我们在清单 6-1 中使用的in-ns函数非常相似。如果一个命名空间不存在，它就创建一个命名空间，然后切换到它。我在第 12 章也详细介绍了(:gen-class)。\n命名空间的名字是the-divine-cheese-code.core。在 Clojure 中，命名空间的名称和声明命名空间的文件路径之间有一个一对一的映射，根据以下约定。\n 当你用lein创建一个目录时（就像你在这里做的那样），源代码的根默认为src。 名称空间中的破折号对应于文件系统中的下划线。所以the-divine-cheese-code在文件系统中被映射为the_divine_cheese_code。 命名空间名称中的句号（.）前面的成分对应于一个目录。例如，由于the-divine-cheese-code.core是命名空间的名称，the_divine_cheese_code是一个目录。 命名空间的最后一个组成部分对应于扩展名为*.clj的文件；core被映射到core.clj*。  你的项目将有一个命名空间，the-divine-cheese-code.visualization.svg。现在继续为它创建文件。\nmkdir src/the_divine_cheese_code/visualization touch src/the_divine_cheese_code/visualization/svg.clj 注意，文件系统的路径遵循这些惯例。有了命名空间和文件系统之间的关系，我们来看看require和use。\n要求和使用命名空间 在the-divine-cheese-code.core命名空间的代码将使用the-divine-cheese-code.visualization.svg命名空间的函数来创建 SVG 标记。为了使用svg的函数，core将不得不要求它。但首先，让我们在svg.clj*中添加一些代码。让它看起来像这样（你以后会添加更多）。\n(ns the-divine-cheese-code.visualization.svg) (defn latlng-point \"Convert lat/lng map to comma-separated string\" [latlng] (str (:lat latlng) \",\" (:lng latlng))) (defn points [locations] (clojure.string/join \" \" (map latlng-point locations))) 这定义了两个函数，latlng-point和points，你将用它们来把一串经纬度坐标转换成一串点。 要使用core.clj文件中的这段代码，你必须require它。require接收一个指定命名空间的符号，并确保该命名空间存在并准备使用；在这种情况下，当你调用(require 'the-divine-cheese-code.visualization.svg)，Clojure读取并评估相应的文件。通过评估该文件，它创建了the-divine-cheese-code.visualization.svg命名空间，并在该命名空间中定义了函数latlng-point和points`。即使文件svg.clj在你的项目目录中，Clojure 在运行你的项目时也不会自动评估它；你必须明确告诉 Clojure 你想使用它。\n在要求命名空间之后，你可以参考它，这样你就不必使用完全合格的名称来引用函数。继续要求the-divine-cheese-code.visualization.svg，并添加heists序列，使core.clj与列表相符。\n(ns the-divine-cheese-code.core) ;; Ensure that the SVG code is evaluated (require 'the-divine-cheese-code.visualization.svg) ;; Refer the namespace so that you don't have to use the ;; fully qualified name to reference svg functions (refer 'the-divine-cheese-code.visualization.svg) (def heists [{:location \"Cologne, Germany\" :cheese-name \"Archbishop Hildebold's Cheese Pretzel\" :lat 50.95 :lng 6.97} {:location \"Zurich, Switzerland\" :cheese-name \"The Standard Emmental\" :lat 47.37 :lng 8.55} {:location \"Marseille, France\" :cheese-name \"Le Fromage de Cosquer\" :lat 43.30 :lng 5.37} {:location \"Zurich, Switzerland\" :cheese-name \"The Lesser Emmental\" :lat 47.37 :lng 8.55} {:location \"Vatican City\" :cheese-name \"The Cheese of Turin\" :lat 41.90 :lng 12.45}]) (defn -main [\u0026 args] (println (points heists))) 现在你有一连串的 heist 位置可以使用，你可以使用visualization.svg命名空间的函数。main函数只是将points函数应用于heists。如果你用lein run运行该项目，你应该看到这个。\n50.95,6.97 47.37,8.55 43.3,5.37 47.37,8.55 41.9,12.45 万岁! 你离抓到那个偷窃发酵乳的人又近了一步! 使用require成功加载了the-divine-cheese-code.visualization.svg以供使用。\nrequire的细节实际上有点复杂，但为了实用，你可以认为require是告诉 Clojure 以下内容。\n 如果你已经用这个符号（the-divine-cheese-code.visualization.svg）调用了require，则不做任何事情。 否则，使用“文件路径和命名空间名称之间的关系 “第 133 页中描述的规则找到与该符号对应的文件。在这种情况下，Clojure 找到src/the_divine_cheese_code/visualization/svg.clj。  读取并评估该文件的内容。Clojure 希望该文件声明一个与它的路径相对应的命名空间（我们的文件就是如此）。\nrequire也可以让你在需要一个命名空间时使用:as或alias来别名它。这样。\n(require '[the-divine-cheese-code.visualization.svg :as svg] ) 相当于这样。\n(require 'the-divine-cheese-code.visualization.svg) (alias 'svg 'the-divine-cheese-code.visualization.svg) 现在你可以使用别名的命名空间了。\n(svg/points heists) ; = \"50.95,6.97 47.37,8.55 43.3,5.37 47.37,8.55 41.9,12.45\" Clojure 提供了另一种捷径。函数use不需要单独调用require和refer，而是同时调用。在生产代码中使用use是不可取的，但当你在 REPL 中做实验，想快速获得一些函数时，它就很方便。例如，这个。\n(require 'the-divine-cheese-code.visualization.svg) (refer 'the-divine-cheese-code.visualization.svg) 相当于这样。\n(use 'the-divine-cheese-code.visualization.svg) 你可以用use来别名一个命名空间，就像你可以用require一样。这样。\n(require 'the-divine-cheese-code.visualization.svg) (refer 'the-divine-cheese-code.visualization.svg) (alias 'svg 'the-divine-cheese-code.visualization.svg) 相当于清单 6-2 中的代码，其中也显示了函数调用中使用的别名空间。\n(use '[the-divine-cheese-code.visualization.svg :as svg]) (= svg/points points) ; = true (= svg/latlng-point latlng-point) ; = true  6-2. 有时，既使用又别名一个命名空间是很方便的。  在这里用use别名命名空间似乎是多余的，因为use已经引用了命名空间（这让你可以简单地调用points而不是svg/points）。但在某些情况下，这很方便，因为use和refer有相同的选项（:only, :exclude, :as, 和:rename）。当你跳过引用一个符号时，你可能想用use来别名一个命名空间。你可以这样使用。\n(require 'the-divine-cheese-code.visualization.svg) (refer 'the-divine-cheese-code.visualization.svg :as :only ['point]) 或者你可以使用清单 6-3 中的use形式（其中还包括如何调用函数的例子）。\n(use '[the-divine-cheese-code.visualization.svg :as svg :only [points]]) (refer 'the-divine-cheese-code.visualization.svg :as :only ['points]) (= svg/points points) ; = true ;; We can use the alias to reach latlng-point svg/latlng-point ; This doesn't throw an exception ;; But we can't use the bare name latlng-point ; This does throw an exception!  在你使用一个命名空间后将其别名化，可以让你参考你排除的符号。  如果你在 REPL 中尝试清单 6-3，并且latlng-point没有抛出一个异常，这是因为你在清单 6-2 中引用了latlng-point。你需要重新启动你的 REPL 会话，使代码表现得如清单 6-3 所示。\n这里的启示是，require和use加载文件，并可选择alias或refer其命名空间。当你写 Clojure 程序和阅读别人写的代码时，你可能会遇到更多的require'和use’的写法，这时，阅读 Clojure 的 API 文档（http://clojure.org/libs/）来了解发生了什么是有意义的。然而，到目前为止，你所学到的关于require和use的内容应该能满足你 95.3%的需求。\n＃＃＃NS 宏 现在是时候看看ns宏了。到目前为止所涉及的工具–in-ns, refer, alias, require, 和 use–最常在你使用 REPL 时使用。在你的源代码文件中，你通常会使用ns宏，因为它允许你简洁地使用迄今为止描述的工具，并提供其他有用的功能。在本节中，你将了解一个ns调用如何结合require、use、in-ns、alias和refer。\nns做的一个有用的任务是默认引用clojure.core命名空间。这就是为什么你可以从the-divine-cheese-code.core中调用println，而不使用完全限定的名称clojure.core/println。\n你可以用:refer-clojure来控制从clojure-core引用的内容，它的选项与refer相同。\n(ns the-divine-cheese-code.core (:refer-clojure :exclude [println]) 如果你在divine_cheese_code.core.clj的开头调用这个，会破坏你的代码，迫使你在-main'函数中使用clojure.core/println’。\n在ns中，(:refer-clojure)`的形式被称为reference。这对你来说可能看起来很奇怪。这个引用是一个函数调用？一个宏？它是什么？你将在第 7 章中了解更多关于底层机器的知识。现在，你只需要了解每个引用如何映射到函数调用。例如，前面的代码就相当于这样。\n(in-ns 'the-divine-cheese-code.core) (refer 'clojure.core :exclude ['println]) 在 “ns “中，有六种可能的引用。\n (:refer-clojure). “(:require)\"。 (:use) (:import) (:load) (:gen-class)。  (:import)和(:gen-class)将在第 12 章介绍。我将不介绍(:load)，因为它很少被使用。\n(:require)的工作方式很像require函数。例如，这样。\n(ns the-divine-cheese-code.core (:require the-divine-cheese-code.visualization.svg)) 相当于这样。\n(in-ns 'the-divine-cheese-code.core) (require 'the-divine-cheese-code.visualization.svg) 注意，在 “ns “形式中（与 “in-ns “函数调用不同），你不需要用”‘‘来引用你的符号。在 “ns “中，你从来不需要引用符号。\n你也可以alias一个你在ns内require的库，就像你调用函数时一样。这样。\n(ns the-divine-cheese-code.core (:require [the-divine-cheese-code.visualization.svg :as svg]) 相当于这样。\n(in-ns 'the-divine-cheese-code.core) (require ['the-divine-cheese-code.visualization.svg :as 'svg]) 你可以在一个(:require)引用中要求多个库，如下所示。 这样。\n(ns the-divine-cheese-code.core (:require [the-divine-cheese-code.visualization.svg :as svg]) [clojure.java.browse :as browse])) 相当于这样。\n(in-ns 'the-divine-cheese-code.core) (require ['the-divine-cheese-code.visualization.svg :as 'svg]) (require ['clojure.java.browse :as 'browse]) 然而，(:require)引用和require函数之间的一个区别是，引用也允许你引用名字。这一点。\n(ns the-divine-cheese-code.core (:require [the-divine-cheese-code.visualization.svg :refer [point])) 相当于这样。\n(in-ns 'the-divine-cheese-code.core) (require 'the-divine-cheese-code.visualization.svg) (refer 'the-divine-cheese-code.visualization.svg :only ['point]) 你也可以引用所有的符号（注意:all关键字）。\n(ns the-divine-cheese-code.core (:require [the-divine-cheese-code.visualization.svg :refer :all])) 这就相当于这样做了。\n(in-ns 'the-divine-cheese-code.core) (require 'the-divine-cheese-code.visualization.svg) (refer 'the-divine-cheese-code.visualization.svg) 这是要求代码、别名命名空间和引用符号的首选方式。建议你不要使用(:use)，但由于你很可能会遇到它，所以知道它是如何工作的很好。你知道该怎么做。这个。\n(ns the-divine-cheese-code.core (:use clojure.java.browse)) 这样做。\n(in-ns 'the-divine-cheese-code.core) (use 'clojure.java.browse) 而这一点。\n(ns the-divine-cheese-code.core (:use [clojure.java browse io]) 这样做。\n(in-ns 'the-divine-cheese-code.core) (use 'clojure.java.browse) (use 'clojure.java.io) 注意，当你在:use后面加上一个矢量时，它把第一个符号作为base，然后用后面的每个符号调用use。\n哦，我的天哪，就是这样! 现在你可以像专家一样使用ns了! 你需要这样做，该死的，因为那个voleur des fromages（他们可能在法语中这样说）仍然在肆意妄为。还记得他/她吗？\n∮∮抓小偷\n我们不能让这个掠夺帕尔马干酪的人带着更多的干酪离开！是时候完成根据坐标画线的工作了。现在是时候根据盗窃案的坐标来完成画线了！这肯定会发现一些问题。这肯定会发现一些问题!\n使用每个抢劫案的纬度坐标，你将在一个 SVG 图像中连接这些点。但是，如果你用给定的坐标画线，结果看起来就不对了，原因有二。首先，纬度坐标是由南向北上升的，而 SVG 的 Y 坐标是由上向下上升的。换句话说，你需要翻转坐标，否则绘图就会颠倒过来。\n第二，绘图会非常小。为了解决这个问题，你将通过平移和缩放来放大它。这就像把一张看起来像图 6-1a 的图变成图 6-1b。\n图 6-1：通过翻转、平移和缩放纬度坐标来制作一张 SVG 图片。\n说实话，这些都是完全随意的，它已经与代码组织没有直接关系了，但是它很有趣，我想你会有一个很好的时间来浏览这些代码的 使你的svg.clj文件与清单 6-4 一致。\n(ns the-divine-cheese-code.visualization.svg (:require [clojure.string :as s]) (:refer-clojure :exclude [min max]) ➊ （defn comparator-over-maps [比较-fn ks］ (fn [maps] ➋ (zipmap ks ➌ (map (fn [k] (apply comparison-fn (map k maps))) ks)))) ➍ (def min (comparator-over-maps clojure.core/min [:lat :lng]) (def max (comparator-over-maps clojure.core/max [:lat :lng]))  6-3. 构建地图比较函数  你在➊处定义了comparator-over-maps函数。这可能是最棘手的部分，所以请忍受一下。 comparator-over-maps是一个返回一个函数的函数。返回的函数使用所提供的比较函数comparison-fn对参数ks提供的键值进行比较。\n你使用comparator-over-map来构造min和max函数➍，你将用它们来寻找我们图形的左上角和右下角。下面是`min’的操作。\n(min [{:a 1 :b 3} {:a 5 :b 0}] ) ; = {:a 1 :b 0} 当你调用min时，它调用zipmap，它接受两个参数，都是 seq，并返回一个新的 map。第一个序列的元素成为键，第二个序列的元素成为值。\n(zipmap [:a :b] [1 2]) ; = {:a 1 :b 2}。 在 ，zipmap的第一个参数是ks，所以ks的元素将是返回地图的键。第二个参数是在➌的地图调用的结果。那个地图调用实际上是在进行比较。\n最后，在➍，你使用comparator-over-maps来创建比较函数。如果你把图纸看作是刻在一个矩形里，那么min是矩形中最接近（0，0）的角，max是离它最远的角。\n下面是代码的下一部分。\n (defn translate-to-00 [locations] (let [mincoords (min locations)] (map #(merge-with - % mincoords) locations))) (defn scale [width height locations] (let [maxcoords (max locations) ratio {:lat (/ height (:lat maxcoords)) :lng (/ width (:lng maxcoords))}] (map #(merge-with * % ratio) locations))) translate-to-00，定义在 ，工作原理是找到我们位置的min'，然后从每个位置减去这个值。它使用merge-with`，其工作原理如下。\n(merge-with - {:lat 50 :lng 10} {:lat 5 :lng 5}) ; = {:lat 45 :lng 5} 然后我们定义函数scale，它将每个点乘以最大经纬度与所需高度和宽度之间的比率。\n下面是svg.clj的其余代码。\n(defn latlng-point \"Convert lat/lng map to comma-separated string\" [latlng] (str (:lat latlng) \",\" (:lng latlng))) (defn points \"Given a seq of lat/lng maps, return string of points joined by space\" [locations] (s/join \" \" (map latlng-point locations))) (defn line [points] (str \"\")) (defn transform \"Just chains other functions\" [width height locations] (- locations translate-to-00 (scale width height))) (defn xml \"svg 'template', which also flips the coordinate system\" [width height locations] (str \"\" ;; These two  tags change the coordinate system so that ;; 0,0 is in the lower-left corner, instead of SVG's default ;; upper-left corner \"\" \"\" (- (transform width height locations) points line) \"\" \"\")) 这里的函数非常简单明了。它们只是接收{:lat x :lng y}地图，并对其进行转换，以便创建一个 SVG。latlng-point返回一个字符串，可用于在 SVG 标记中定义一个点。points将lat/lng地图的序列转换为一个以空格分隔的点的字符串。 line返回连接所有给定空间分隔的点字符串的 SVG 标记。 transform接收一个位置序列，将它们翻译成从(0, 0)开始的点，并将它们缩放到给定的宽度和高度。最后，xml产生标记，用 SVG 显示给定的位置。\n有了svg.clj的所有代码，现在让core.clj看起来像这样。\n(ns the-divine-cheese-code.core (:require [clojure.java.browse :as browse] [the-divine-cheese-code.visualization.svg :refer [xml]]) (:gen-class)) (def heists [{:location \"Cologne, Germany\" :cheese-name \"Archbishop Hildebold's Cheese Pretzel\" :lat 50.95 :lng 6.97} {:location \"Zurich, Switzerland\" :cheese-name \"The Standard Emmental\" :lat 47.37 :lng 8.55} {:location \"Marseille, France\" :cheese-name \"Le Fromage de Cosquer\" :lat 43.30 :lng 5.37} {:location \"Zurich, Switzerland\" :cheese-name \"The Lesser Emmental\" :lat 47.37 :lng 8.55} {:location \"Vatican City\" :cheese-name \"The Cheese of Turin\" :lat 41.90 :lng 12.45}]) (defn url [filename] (str \"file:///\" (System/getProperty \"user.dir\") \"/\" filename)) (defn template [contents] (str \"polyline { fill:none; stroke:#5881d8; stroke-width:3}\" contents)) (defn -main [\u0026 args] (let [filename \"map.html\"] (- heists (xml 50 100) template (spit filename)) (browse/browse-url (url filename)))) 这里没有太复杂的事情发生。在 “main “中，你使用 “xml “和 “template “函数建立绘图，用 “spit “将绘图写入一个文件，然后用 “browse/browse-url “打开它。你现在应该试试! 运行lein run，你会看到类似图 6-2 的东西。\n图 6-2: 抢劫模式的最终 SVG!\n等一下 ……这看起来很像 ……这看起来很像一个 lambda。Clojure 的标志是一个 lambda . ……哦，我的天啊! Clojure，一直以来都是你!\n总结 在本章中你学到了很多东西。在这一点上，你应该拥有所有你需要的工具来开始组织你的项目。你现在知道命名空间组织了符号和 vars 之间的映射，vars 是对 Clojure 对象（数据结构、函数等）的引用。 def存储一个对象，并用符号和指向该对象的 var 之间的映射来更新当前命名空间。你可以用defn-创建私有函数。\nClojure 允许你用create-ns创建命名空间，但通常使用in-ns更有用，它也会切换到命名空间。你可能只在 REPL 中使用这些函数。当你在 REPL 中时，你总是在当前命名空间中。当你在文件中而不是在 REPL 中定义名字空间时，你应该使用 ns 宏，名字空间和它在文件系统中的路径之间是一对一的关系。\n你可以通过使用完全限定的名称来引用其他命名空间中的对象，如cheese.taxonomy/cheddars。 refer可以让你使用其他命名空间的名字，而不需要完全限定它们，alias可以让你在写出完全限定的名字时，使用一个更短的名字来命名空间。\nrequire和use确保一个名字空间的存在并准备好被使用，并且可以选择让你refer和alias相应的名字空间。你应该使用ns在你的源文件中调用require和use。*Clojure ns syntax cheat-sheet - GitHub*是使用ns的所有变化的一个很好的参考。\n最后，也是最重要的一点，做一个俗气的人并不容易。\n","wordCount":"1581","inLanguage":"en","image":"https://zhenfeng-zhu.github.io/posts/chapter6/https:/raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201131821608.png","datePublished":"2022-01-14T12:40:41+08:00","dateModified":"2022-01-14T12:40:41+08:00","author":{"@type":"Person","name":"Fenix"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhenfeng-zhu.github.io/posts/chapter6/"},"publisher":{"@type":"Organization","name":"Awesome Fenix","logo":{"@type":"ImageObject","url":"https://zhenfeng-zhu.github.io/favicon.ico"}}}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8502076734034112" crossorigin=anonymous></script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhenfeng-zhu.github.io accesskey=h title="Awesome Fenix (Alt + H)">Awesome Fenix</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://zhenfeng-zhu.github.io/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/about title=About>
<span>About</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/search/ title=🔍>
<span>🔍</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://zhenfeng-zhu.github.io>Home</a>&nbsp;»&nbsp;<a href=https://zhenfeng-zhu.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Chapter6 整理你的项目：一个图书管理员的故事
</h1>
<div class=post-meta><span title="2022-01-14 12:40:41 +0800 +0800">January 14, 2022</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Fenix&nbsp;|&nbsp;<a href=https://github.com/zhenfeng-zhu/zhenfeng-zhu.github.io/tree/main/content/posts/Chapter6.md rel="noopener noreferrer" target=_blank>修改本文章</a>
</div>
</header>
<figure class=entry-cover><img loading=lazy src=https://raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201131821608.png alt>
<p></p>
</figure><div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e6%95%b4%e7%90%86%e4%bd%a0%e7%9a%84%e9%a1%b9%e7%9b%ae%e4%b8%80%e4%b8%aa%e5%9b%be%e4%b9%a6%e7%ae%a1%e7%90%86%e5%91%98%e7%9a%84%e6%95%85%e4%ba%8b aria-label=整理你的项目：一个图书管理员的故事>整理你的项目：一个图书管理员的故事</a><ul>
<li>
<a href=#%e4%bd%a0%e7%9a%84%e9%a1%b9%e7%9b%ae%e6%98%af%e4%b8%80%e4%b8%aa%e5%ba%93 aria-label=你的项目是一个库>你的项目是一个库</a></li>
<li>
<a href=#%e7%94%a8-def-%e5%ad%98%e5%82%a8%e5%af%b9%e8%b1%a1 aria-label="用 def 存储对象">用 def 存储对象</a></li>
<li>
<a href=#%e5%88%9b%e5%bb%ba%e5%92%8c%e5%88%87%e6%8d%a2%e5%88%b0%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4 aria-label=创建和切换到命名空间>创建和切换到命名空间</a><ul>
<li>
<a href=#%e5%bc%95%e7%94%a8 aria-label=引用>引用</a></li>
<li>
<a href=#alias aria-label=alias>alias</a></li></ul>
</li>
<li>
<a href=#%e7%9c%9f%e6%ad%a3%e7%9a%84%e9%a1%b9%e7%9b%ae%e7%bb%84%e7%bb%87 aria-label=真正的项目组织>真正的项目组织</a><ul>
<li>
<a href=#%e6%96%87%e4%bb%b6%e8%b7%af%e5%be%84%e5%92%8c%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4%e5%90%8d%e7%a7%b0%e4%b9%8b%e9%97%b4%e7%9a%84%e5%85%b3%e7%b3%bb aria-label=文件路径和命名空间名称之间的关系>文件路径和命名空间名称之间的关系</a></li>
<li>
<a href=#%e8%a6%81%e6%b1%82%e5%92%8c%e4%bd%bf%e7%94%a8%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4 aria-label=要求和使用命名空间>要求和使用命名空间</a></li>
<li>
<a href=#ns-%e5%ae%8f aria-label="＃＃＃NS 宏">＃＃＃NS 宏</a></li></ul>
</li>
<li>
<a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=整理你的项目一个图书管理员的故事>整理你的项目：一个图书管理员的故事<a hidden class=anchor aria-hidden=true href=#整理你的项目一个图书管理员的故事>#</a></h1>
<p>在我们每个人心中都住着一个叫 Melvil 的图书管理员，一个以组织艺术为乐的奇异生物。日日夜夜，Melvil 都渴望为你的代码库带来秩序。幸运的是，Clojure 提供了一套工具，专门用来帮助这个侏儒与混乱的力量不断斗争。</p>
<p>这些工具通过将相关的函数和数据分组来帮助你组织你的代码。它们还可以防止名称冲突，这样你就不会意外地覆盖别人的代码，反之亦然。在这个充满悬念和神秘的故事中，请和我一起学习如何使用这些工具，并解决一生中的抢劫案吧 在这个传奇故事的最后，你将了解以下内容。</p>
<ul>
<li>
<p>`def&rsquo;是做什么的</p>
</li>
<li>
<p>什么是命名空间以及如何使用它们</p>
</li>
<li>
<p>命名空间和文件系统之间的关系</p>
</li>
<li>
<p>如何使用<code>refer</code>、<code>alias</code>、<code>require</code>、<code>use</code>和<code>ns</code>。</p>
</li>
<li>
<p>如何使用文件系统来组织 Clojure 项目</p>
</li>
</ul>
<p>我先来介绍一下 Clojure 的组织系统，它的工作原理很像一个库。Melvil 兴奋地颤抖着!</p>
<h2 id=你的项目是一个库>你的项目是一个库<a hidden class=anchor aria-hidden=true href=#你的项目是一个库>#</a></h2>
<p>现实世界中的图书馆存储对象的集合，如书籍、杂志和 DVD。他们使用寻址系统，所以当你得到一个物体的地址时，你可以导航到物理空间并检索到该物体。</p>
<p>当然，没有人能够直接知道一本书或 DVD 的地址是什么。这就是为什么图书馆要记录一个物体的标题和它的地址之间的联系，并提供工具来搜索这些记录。在计算机之前的旧时代，图书馆提供卡片目录，即装满纸质卡片的柜子，其中包含每本书的标题、作者、&ldquo;地址&rdquo;（杜威十进制或国会图书馆编号）和其他信息。</p>
<p>例如，要找到《达芬奇密码》，你可以翻阅书名目录（按书名排序的卡片），直到你找到正确的卡片。在那张卡片上，你会看到地址<em>813.54</em>（如果它使用杜威十进制系统），浏览图书馆，找到<em>达芬奇密码</em>所在的书架，并参与你一生中的文学和/或仇恨阅读冒险。</p>
<p>在 Clojure 中想象一个类似的设置是很有用的。我认为 Clojure 是将对象（如数据结构和函数）存储在一组巨大的编号架上。没有人能够直接知道一个对象被存储在哪个架子上。相反，我们给 Clojure 一个标识符，它用来检索该对象。</p>
<p>为了使之成功，Clojure 必须维护我们的标识符和货架地址之间的关联。它通过使用<em>namespaces</em>来做到这一点。命名空间包含了人类友好的<em>符号</em>和书架地址的引用之间的映射，被称为<em>vars</em>，很像卡片目录。</p>
<p>从技术上讲，命名空间是 &ldquo;clojure.lang.Namespace &ldquo;类型的对象，你可以与它们互动，就像你可以与 Clojure 数据结构互动一样。例如，你可以用<code>*ns*</code>来引用当前的命名空间，你可以用<code>(ns-name *ns*)</code>来获得其名称。</p>
<pre tabindex=0><code>(ns-name *ns*)
; =&gt; user
</code></pre><p>例如，当你启动 REPL 时，你在<code>user</code>命名空间中（正如你在这里看到的）。提示符显示当前名称空间，使用<code>user=></code>。</p>
<p>当前名字空间的概念意味着你可以有多个名字空间，事实上 Clojure 允许你创建任意多的名字空间（尽管从技术上讲，你可以创建的名字数量可能有一个上限）。在 Clojure 程序中，你总是<em>在</em>个命名空间中。</p>
<p>至于符号，你一直在使用它们，甚至没有意识到。例如，当你写<code>(map inc [1 2])</code>时，<code>map</code>和<code>inc</code>都是符号。符号是 Clojure 中的数据类型，我将在下一章中彻底解释它们。现在，你需要知道的是，当你给 Clojure 一个像<code>map</code>这样的符号时，它会在当前命名空间中找到相应的 var，得到一个架子上的地址，并为你从那个架子上检索一个对象&ndash;在这里，就是<code>map</code>所指的那个函数。如果你想只使用符号本身，而不是它所指的东西，你必须引用它。引述任何 Clojure 的形式告诉 Clojure 不要评估它，而是把它当作数据。接下来的几个例子显示了当你引用一个表单时会发生什么。</p>
<pre tabindex=0><code>➊ inc
; =&gt; #&lt;core$inc clojure.core$inc@30132014&gt;

➋ 'inc
; =&gt; inc

➌ (map inc [1 2])
; =&gt; (2 3)

➍ '(map inc [1 2])
; =&gt; (map inc [1 2])
</code></pre><p>当你在 REPL 中评估 <code>inc</code> 在 ➊ 处时，它会打印出 <code>inc</code> 所指的函数的文本表述。接下来，你在➋引用<code>inc</code>，所以结果是符号<code>inc</code>。然后，你在➌处评估一个熟悉的<code>map</code>应用程序，得到一个熟悉的结果。之后，你在➍处引用整个列表数据结构，结果是一个未评估的列表，包括<code>map</code>符号、<code>inc</code>符号和一个向量。</p>
<p>现在你知道了 Clojure 的组织系统，让我们来看看如何使用它。</p>
<h2 id=用-def-存储对象>用 def 存储对象<a hidden class=anchor aria-hidden=true href=#用-def-存储对象>#</a></h2>
<p>Clojure 中用于存储对象的主要工具是<code>def</code>。其他的工具，如<code>defn</code>，都是使用<code>def</code>。下面是一个 def 的应用实例。</p>
<pre tabindex=0><code>(def great-books [&quot;East of Eden&quot; &quot;The Glass Bead Game&quot;])
; =&gt; #'user/great-books

great-books
; =&gt; [&quot;East of Eden&quot; &quot;The Glass Bead Game&quot;]
</code></pre><p>这段代码告诉 Clojure。</p>
<ol>
<li>用<code>great-books</code>和 var 之间的关联更新当前命名空间的地图。</li>
<li>找到一个空闲的存储架。</li>
<li>将<code>[《伊甸园之东》《玻璃珠游戏》]</code>存放在架子上。</li>
<li>将书架的地址写在 var 上。</li>
<li>5.返回 var（在这个例子中，`#&lsquo;user/great-books&rsquo;）。</li>
</ol>
<p>这个过程被称为<em>interning</em>一个 var。 你可以使用`ns-interns&rsquo;与命名空间的符号到内含变量的映射进行交互。下面是你如何获得一个内部变量的映射。</p>
<pre tabindex=0><code>(ns-interns *ns*)
; =&gt; {great-books #'user/great-books}.
</code></pre><p>你可以使用`get&rsquo;函数来获取一个特定的 var。</p>
<pre tabindex=0><code>(get (ns-interns *ns*) ' great-books)
; =&gt; #'user/great-books
</code></pre><p>通过评估<code>(</code>ns-map <em>ns</em>)<code>,</code>你也可以得到命名空间在给定一个符号时用来查找 var 的完整地图。<code>(ns-map *ns*)</code>给你一个非常大的地图，我不会在这里打印，但可以试试</p>
<p><code>#'user/great-books'是var的*读者形式。 我将在第七章解释更多关于读者形式。现在，只需知道你可以使用</code>#&lsquo;&lsquo;来抓取与后面的符号对应的 var；<code>#'user/great-books'让你在</code>user&rsquo;命名空间中使用与符号<code>great-books'相关的var。我们可以</code>deref&rsquo;变量来获得它们所指向的对象。</p>
<pre tabindex=0><code>(deref #'user/great-books)
; =&gt; [&quot;East of Eden&quot; &quot;The Glass Bead Game&quot;]
</code></pre><p>这就像告诉 Clojure，&ldquo;从 var 中获取书架号，去那个书架号，抓住上面的东西，然后给我！&rdquo;</p>
<p>但是通常情况下，你只需要使用符号。</p>
<pre tabindex=0><code>great-books
; =&gt; [&quot;East of Eden&quot; &quot;The Glass Bead Game&quot;]
</code></pre><p>这就像告诉 Clojure，&ldquo;检索与 great-books 相关的 var，然后取消那个坏的杰克逊&rdquo;。</p>
<p>到目前为止还不错，对吗？好吧，请做好准备，因为这个田园诗般的组织天堂即将被颠覆 用同样的符号再次调用<code>def</code>。</p>
<pre tabindex=0><code>(def great-books [&quot;The Power of Bees&quot; &quot;Journey to Upstairs&quot;])
great-books
; =&gt; [&quot;The Power of Bees&quot; &quot;Journey to Upstairs&quot;]
</code></pre><p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/organization/bee-power.png alt=img>
</p>
<p>var 已经更新了新的矢量的地址。这就像你在卡片目录中的卡片上的地址用了白笔，然后写了一个新地址。其结果是，你不能再要求 Clojure 找到第一个向量。这被称为<em>名称碰撞</em>。混乱! 无政府状态!</p>
<p>你可能在其他编程语言中经历过这种情况。JavaScript 在这方面是臭名昭著的，它也发生在 Ruby 中。这是个问题，因为你可能无意中覆盖了你自己的代码，而且你也不能保证第三方库不会覆盖你的代码。Melvil 惊恐地退缩了! 幸运的是，Clojure 允许你创建任意多的命名空间，这样你就可以避免这些碰撞。</p>
<h2 id=创建和切换到命名空间>创建和切换到命名空间<a hidden class=anchor aria-hidden=true href=#创建和切换到命名空间>#</a></h2>
<p>Clojure 有三种创建命名空间的工具：函数<code>create-ns</code>，函数<code>in-ns</code>，以及宏<code>ns</code>。你将在你的 Clojure 文件中主要使用<code>ns</code>宏，但我将推迟几页来解释它，因为它结合了许多工具，而且在我讨论其他工具之后，它更容易理解。</p>
<p><code>create-ns</code>接收一个符号，如果它不存在，就用这个名字创建一个命名空间，并返回这个命名空间。</p>
<pre tabindex=0><code>user=&gt; (create-ns 'cheese.taxonomy)
; =&gt; #&lt;Namespace cheese.taxonomy&gt;
</code></pre><p>你可以使用返回的名字空间作为函数调用的参数。</p>
<pre tabindex=0><code>user=&gt; (ns-name (create-ns 'cheese.taxonomy))
; =&gt; cheese-taxonomy
</code></pre><p>在实践中，你可能永远不会在你的代码中使用<code>create-ns</code>，因为创建一个命名空间而不移入它并不是非常有用。使用<code>in-ns</code>更常见，因为如果命名空间不存在，它会创建命名空间，并**切换到它，如清单 6-1 所示。</p>
<pre tabindex=0><code>user=&gt; (in-ns 'cheese.analysis)
; =&gt; #&lt;Namespace cheese.analysis&gt;
</code></pre><ol>
<li>6-1. 使用 in-ns 创建一个命名空间并切换到该空间</li>
</ol>
<p>注意你的 REPL 提示符现在是<code>cheese.analysis></code>，表明你确实在你刚刚创建的新命名空间中。现在当你使用<code>def</code>时，它将在<code>cheese.analysis</code>命名空间中存储命名对象。</p>
<p>但是如果你想使用其他命名空间的函数和数据怎么办？要做到这一点，你可以使用一个<em>完全合格的</em>符号。一般的形式是 namespace<code>/</code>name。</p>
<pre tabindex=0><code>cheese.analysis=&gt; (in-ns 'cheese.taxonomy)
cheese.taxonomy=&gt; (def cheddars [&quot;mild&quot; &quot;medium&quot; &quot;strong&quot; &quot;sharp&quot; &quot;extra sharp&quot;])
cheese.taxonomy=&gt; (in-ns 'cheese.analysis)

cheese.analysis=&gt; cheddars
; =&gt; Exception: Unable to resolve symbol: cheddars in this context
</code></pre><p>这创建了一个新的命名空间，<code>cheese.taxonomy</code>，在该命名空间中定义了<code>cheddars</code>，然后切换回<code>cheese.analysis</code>命名空间。如果你试图在<code>cheese.analysis</code>中引用<code>cheese.taxonomy</code>命名空间的<code>cheddars</code>，你会得到一个异常，但是使用完全合格的符号可以。</p>
<pre tabindex=0><code>cheese.analysis=&gt; cheese.taxonomy/cheddars
; =&gt; [&quot;mild&quot; &quot;medium&quot; &quot;strong&quot; &quot;sharp&quot; &quot;extra sharp&quot;]
</code></pre><p>输入这些完全合格的符号很快就会成为一种困扰。 比如说，我是一个极不耐烦的学者，专门研究符号学-au-fromage，或者研究与奶酪有关的符号。</p>
<p>突然间，可能发生的最糟糕的事情发生了！在全世界范围内，神圣的和有可能发生的事情都发生了。在世界各地，神圣的、具有历史意义的奶酪都失踪了。威斯康星州的标准切达干酪：不见了! 图坦卡蒙的大奶酪罐：被偷了! 都灵奶酪：被骗取的奶酪所取代! 这有可能使世界因某种原因而陷入完全的混乱! 自然，作为一个杰出的奶酪研究者，我有责任解开这个谜团。与此同时，我正被光明会、共济会和足部族追捕！因为我是一名学者，所以我必须为他们提供帮助。</p>
<p>因为我是一个学者，我试图用我知道的最好的方式来解决这个谜团&ndash;去图书馆研究这个狗屎。我可靠的助手 Clojure 陪着我。当我们从一个名字空间到另一个名字空间忙忙碌碌时，我喊着让 Clojure 把一个又一个东西交给我。</p>
<p>但 Clojure 有点笨，很难弄清楚我指的是什么。在<code>user</code>命名空间中，我大声说："<code>join</code>! 给我<code>join'！"--我嘴里的唾沫星子飞了出来。"</code>RuntimeException: Unable to resolve symbol: join<code>," Clojure抱怨着回应。"看在布里的份上，把</code>clojure.string/join`交给我吧！&rdquo; 我反驳道，Clojure 尽职尽责地把我要找的函数交给我。</p>
<p>我的声音变得沙哑了。我需要一些方法来告诉 Clojure 要给我什么对象，而不必每次都使用完全合格的符号。</p>
<p>幸运的是，Clojure 提供了 &ldquo;refer &ldquo;和 &ldquo;alias &ldquo;工具，让我可以更简洁地对它吼叫。</p>
<h3 id=引用>引用<a hidden class=anchor aria-hidden=true href=#引用>#</a></h3>
<p><code>refer</code>使你能够精细地控制你如何引用其他命名空间的对象。启动一个新的 REPL 会话并尝试以下操作。请记住，在 REPL 中这样玩命名空间是可以的，但你不希望你的 Clojure 文件看起来像这样；正确的文件结构方式在<a href=https://www.braveclojure.com/organization/#Anchor>&ldquo;真正的项目组织 &ldquo;第 133 页</a>中涉及。</p>
<pre tabindex=0><code>user=&gt; (in-ns 'cheese.taxonomy)
cheese.taxonomy=&gt; (def cheddars [&quot;mild&quot; &quot;medium&quot; &quot;strong&quot; &quot;sharp&quot; &quot;extra sharp&quot;])
cheese.taxonomy=&gt; (def bries [&quot;Wisconsin&quot; &quot;Somerset&quot; &quot;Brie de Meaux&quot; &quot;Brie de Melun&quot;])
cheese.taxonomy=&gt; (in-ns 'cheese.analysis)
cheese.analysis=&gt; (clojure.core/refer 'cheese.taxonomy)
cheese.analysis=&gt; bries
; =&gt; [&quot;Wisconsin&quot; &quot;Somerset&quot; &quot;Brie de Meaux&quot; &quot;Brie de Melun&quot;]

cheese.analysis=&gt; cheddars
; =&gt; [&quot;mild&quot; &quot;medium&quot; &quot;strong&quot; &quot;sharp&quot; &quot;extra sharp&quot;]
</code></pre><p>这段代码创建了一个 &ldquo;cheese.taxonomy &ldquo;命名空间和其中的两个向量。 <code>cheddars</code>和<code>bries</code>。然后它创建并移动到一个新的命名空间，称为<code>cheese.analysis</code>。用命名空间的符号调用<code>refer</code>可以让你引用相应的命名空间的对象，而不需要使用完全限定的符号。它通过更新当前命名空间的符号/对象映射来实现这一目的。你可以看到像这样的新条目。</p>
<pre tabindex=0><code>cheese.analysis=&gt; (clojure.core/get (clojure.core/ns-map clojure.core/*ns*) 'bries)
; =&gt; #'cheese.taxonomy/bries

cheese.analysis=&gt; (clojure.core/get (clojure.core/ns-map clojure.core/*ns*) 'cheddars)
; =&gt; #'cheese.taxonomy/cheddars
</code></pre><p>这就好像 Clojure</p>
<ol>
<li>在<code>cheese.taxonomy</code>命名空间上调用<code>ns-interns</code>。</li>
<li>将其与当前命名空间的<code>ns-map</code>合并。</li>
<li>将结果作为当前命名空间的新的`ns-map&rsquo;。</li>
</ol>
<p>当你调用<code>refer</code>时，你也可以把过滤器<code>:only</code>, <code>:exclude</code>, 和<code>:rename</code>传递给它。正如名字所暗示的，<code>:only</code>和<code>:exclude</code>限制了哪些符号/变量映射被合并到当前命名空间的<code>ns-map</code>。 <code>:rename</code>允许你使用不同的符号来表示被合并的变量。如果我们将前面的例子修改为使用<code>:only</code>，会发生以下情况。</p>
<pre tabindex=0><code>cheese.analysis=&gt; (clojure.core/refer 'cheese.taxonomy :only ['bries])
cheese.analysis=&gt; bries
; =&gt; [&quot;Wisconsin&quot; &quot;Somerset&quot; &quot;Brie de Meaux&quot; &quot;Brie de Melun&quot;]
cheese.analysis=&gt; cheddars 
; =&gt; RuntimeException: 无法解决符号：cheddars
</code></pre><p>下面是<code>:exclude</code>的操作。</p>
<pre tabindex=0><code>cheese.analysis=&gt; (clojure.core/refer 'cheese.taxonomy :only ['bries])
cheese.analysis=&gt; bries
; =&gt; [&quot;Wisconsin&quot; &quot;Somerset&quot; &quot;Brie de Meaux&quot; &quot;Brie de Melun&quot;]
cheese.analysis=&gt; cheddars 
; =&gt; RuntimeException: Unable to resolve symbol: cheddars
</code></pre><p>最后，一个<code>:rename</code>的例子。</p>
<pre tabindex=0><code>cheese.analysis=&gt; (clojure.core/refer 'cheese.taxonomy :rename {'bries 'yummy-bries})
cheese.analysis=&gt; bries
; =&gt; RuntimeException: Unable to resolve symbol: bries
cheese.analysis=&gt; yummy-bries
; =&gt; [&quot;Wisconsin&quot; &quot;Somerset&quot; &quot;Brie de Meaux&quot; &quot;Brie de Melun&quot;]
</code></pre><p>注意，在这些最后的例子中，我们必须使用<code>clojure.core</code>中所有对象的完全合格名称，如<code>clojure.core/ns-map</code>和<code>clojure.core/refer</code>。我们不需要在<code>user</code>命名空间中这样做。这是因为 REPL 在<code>user</code>命名空间中自动引用<code>clojure.core</code>。当你创建一个新的命名空间时，你可以通过评估<code>(clojure.core/refer-clojure)</code>来简化你的生活；这将引用 clojure.core 命名空间，从现在起我将使用它。在例子中你不会看到<code>clojure.core/refer</code>，而只会看到<code>refer</code>。</p>
<p>另一件需要注意的事情是，你可以完全自由地组织你的函数和数据，跨越命名空间。这让你可以合理地将相关的函数和数据归入同一命名空间。</p>
<p>有时你可能希望一个函数只对同一命名空间内的其他函数有效。Clojure 允许你使用<code>defn-</code>来定义<em>私有</em>的函数。</p>
<pre tabindex=0><code>(in-ns 'cheese.analysis)
;; Notice the dash after &quot;defn&quot;
(defn- private-function
  &quot;Just an example function that does nothing&quot;
  [])
</code></pre><p>如果你试图从其他命名空间调用这个函数或引用它，Clojure 将抛出一个异常。你可以在评估➊和➋的代码时看到这一点。</p>
<pre tabindex=0><code>cheese.analysis=&gt; (in-ns 'cheese.taxonomy)
cheese.taxonomy=&gt; (clojure.core/refer-clojure)
➊ cheese.taxonomy=&gt; (cheese.analysis/private-function)
➋ cheese.taxonomy=&gt; (refer 'cheese.analysis :only ['private-function])
</code></pre><p>正如你所看到的，即使你明确地 &ldquo;引用 &ldquo;这个函数，你也不能使用其他命名空间的函数，因为你把它变成了私有的。(如果你想狡猾一点，你仍然可以使用神秘的语法`@#&lsquo;some/private-var&rsquo;来访问私有变量，但你很少想这样做)。</p>
<h3 id=alias>alias<a hidden class=anchor aria-hidden=true href=#alias>#</a></h3>
<p>与<code>refer</code>相比，<code>alias</code>相对简单。它所做的只是让你缩短一个命名空间的名称，以便使用完全合格的符号。</p>
<pre tabindex=0><code>cheese.analysis=&gt; (clojure.core/alias 'taxonomy 'cheese.taxonomy)
cheese.analysis=&gt; taxonomy/bries
; =&gt; [&quot;Wisconsin&quot; &quot;Somerset&quot; &quot;Brie de Meaux&quot; &quot;Brie de Melun&quot;]
</code></pre><p>这段代码让我们使用来自<code>cheese.taxonomy</code>命名空间的调用符号，并使用较短的别名<code>taxonomy</code>。</p>
<p><code>refer</code>和<code>alias</code>是你引用当前命名空间以外的对象的两个基本工具! 它们是 REPL 开发的好帮手。</p>
<p>然而，你不可能在 REPL 中创建整个程序。在下一节中，我将介绍你需要知道的一切，以组织一个真正的项目，使源代码在文件系统中生存。</p>
<h2 id=真正的项目组织>真正的项目组织<a hidden class=anchor aria-hidden=true href=#真正的项目组织>#</a></h2>
<p>现在我已经介绍了 Clojure 组织系统的构建模块，我将向你展示如何在实际项目中使用它们。我将讨论文件路径和命名空间名称之间的关系，解释如何用<code>require</code>和<code>use</code>加载文件，并展示如何使用<code>ns</code>来设置一个命名空间。</p>
<h3 id=文件路径和命名空间名称之间的关系>文件路径和命名空间名称之间的关系<a hidden class=anchor aria-hidden=true href=#文件路径和命名空间名称之间的关系>#</a></h3>
<p>为了一石二鸟（或者用一颗种子喂养两只鸟，这取决于你是多么的嬉皮士），我将介绍更多关于命名空间的内容，同时我们将通过绘制国际奶酪大盗的抢劫地点来抓捕这个讨厌的大盗。运行以下程序。</p>
<pre tabindex=0><code>lein new app the-divine-cheese-code
</code></pre><p>这应该创建一个目录结构，看起来像这样。</p>
<pre tabindex=0><code>| .gitignore
| doc
| | intro.md
| project.clj
| README.md
| resources
| src
| | the_divine_cheese_code
| | | core.clj
| test
| | the_divine_cheese_code
| | | core_test.clj
</code></pre><p>现在，打开<em>src/the_divine_cheese_code/core.clj</em>。你应该在第一行看到这个。</p>
<pre tabindex=0><code>(ns the-divine-cheese-code.core
  (:gen-class))
</code></pre><p><code>ns</code>是在 Clojure 中创建和管理命名空间的主要方式。我很快就会对它进行全面的解释。不过现在，只需知道这一行与我们在清单 6-1 中使用的<code>in-ns</code>函数非常相似。如果一个命名空间不存在，它就创建一个命名空间，然后切换到它。我在第 12 章也详细介绍了<code>(:gen-class)</code>。</p>
<p>命名空间的名字是<code>the-divine-cheese-code.core</code>。在 Clojure 中，命名空间的名称和声明命名空间的文件路径之间有一个一对一的映射，根据以下约定。</p>
<ul>
<li>当你用<code>lein</code>创建一个目录时（就像你在这里做的那样），源代码的根默认为<em>src</em>。</li>
<li>名称空间中的破折号对应于文件系统中的下划线。所以<code>the-divine-cheese-code</code>在文件系统中被映射为<em>the_divine_cheese_code</em>。</li>
<li>命名空间名称中的句号（<code>.</code>）前面的成分对应于一个目录。例如，由于<code>the-divine-cheese-code.core</code>是命名空间的名称，<em>the_divine_cheese_code</em>是一个目录。</li>
<li>命名空间的最后一个组成部分对应于扩展名为*.clj<em>的文件；<code>core</code>被映射到</em>core.clj*。</li>
</ul>
<p>你的项目将有一个命名空间，<code>the-divine-cheese-code.visualization.svg</code>。现在继续为它创建文件。</p>
<pre tabindex=0><code>mkdir src/the_divine_cheese_code/visualization
touch src/the_divine_cheese_code/visualization/svg.clj
</code></pre><p>注意，文件系统的路径遵循这些惯例。有了命名空间和文件系统之间的关系，我们来看看<code>require</code>和<code>use</code>。</p>
<h3 id=要求和使用命名空间>要求和使用命名空间<a hidden class=anchor aria-hidden=true href=#要求和使用命名空间>#</a></h3>
<p>在<code>the-divine-cheese-code.core</code>命名空间的代码将使用<code>the-divine-cheese-code.visualization.svg</code>命名空间的函数来创建 SVG 标记。为了使用<code>svg</code>的函数，<code>core</code>将不得不<em>要求它。但首先，让我们在</em>svg.clj*中添加一些代码。让它看起来像这样（你以后会添加更多）。</p>
<pre tabindex=0><code>(ns the-divine-cheese-code.visualization.svg)

(defn latlng-&gt;point
  &quot;Convert lat/lng map to comma-separated string&quot; 
  [latlng]
  (str (:lat latlng) &quot;,&quot; (:lng latlng)))

(defn points
  [locations]
  (clojure.string/join &quot; &quot; (map latlng-&gt;point locations)))
</code></pre><p>这定义了两个函数，<code>latlng->point</code>和<code>points</code>，你将用它们来把一串经纬度坐标转换成一串点。 要使用<em>core.clj</em>文件中的这段代码，你必须<code>require</code>它。<code>require</code>接收一个指定命名空间的符号，并确保该命名空间存在并准备使用；在这种情况下，当你调用<code>(require 'the-divine-cheese</code>-code.visualization.svg)<code>，Clojure读取并评估相应的文件。通过评估该文件，它创建了</code>the-divine-cheese-code.visualization.svg<code>命名空间，并在该命名空间中定义了函数</code>latlng->point<code>和</code>points`。即使文件<em>svg.clj</em>在你的项目目录中，Clojure 在运行你的项目时也不会自动评估它；你必须明确告诉 Clojure 你想使用它。</p>
<p>在要求命名空间之后，你可以<em>参考</em>它，这样你就不必使用完全合格的名称来引用函数。继续要求<code>the-divine-cheese-code.visualization.svg</code>，并添加<code>heists</code>序列，使<em>core.clj</em>与列表相符。</p>
<pre tabindex=0><code>(ns the-divine-cheese-code.core)
;; Ensure that the SVG code is evaluated
(require 'the-divine-cheese-code.visualization.svg)
;; Refer the namespace so that you don't have to use the 
;; fully qualified name to reference svg functions
(refer 'the-divine-cheese-code.visualization.svg)

(def heists [{:location &quot;Cologne, Germany&quot;
              :cheese-name &quot;Archbishop Hildebold's Cheese Pretzel&quot;
              :lat 50.95
              :lng 6.97}
             {:location &quot;Zurich, Switzerland&quot;
              :cheese-name &quot;The Standard Emmental&quot;
              :lat 47.37
              :lng 8.55}
             {:location &quot;Marseille, France&quot;
              :cheese-name &quot;Le Fromage de Cosquer&quot;
              :lat 43.30
              :lng 5.37}
             {:location &quot;Zurich, Switzerland&quot;
              :cheese-name &quot;The Lesser Emmental&quot;
              :lat 47.37
              :lng 8.55}
             {:location &quot;Vatican City&quot;
              :cheese-name &quot;The Cheese of Turin&quot;
              :lat 41.90
              :lng 12.45}])

(defn -main
  [&amp; args]
  (println (points heists)))
</code></pre><p>现在你有一连串的 heist 位置可以使用，你可以使用<code>visualization.svg</code>命名空间的函数。<code>main</code>函数只是将<code>points</code>函数应用于<code>heists</code>。如果你用<code>lein run</code>运行该项目，你应该看到这个。</p>
<pre tabindex=0><code>50.95,6.97 47.37,8.55 43.3,5.37 47.37,8.55 41.9,12.45
</code></pre><p>万岁! 你离抓到那个偷窃发酵乳的人又近了一步! 使用<code>require</code>成功加载了<code>the-divine-cheese-code.visualization.svg</code>以供使用。</p>
<p><code>require</code>的细节实际上有点复杂，但为了实用，你可以认为<code>require</code>是告诉 Clojure 以下内容。</p>
<ol>
<li>如果你已经用这个符号（<code>the-divine-cheese-code.visualization.svg</code>）调用了<code>require</code>，则不做任何事情。</li>
<li>否则，使用<a href=https://www.braveclojure.com/organization/#Anchor-3>&ldquo;文件路径和命名空间名称之间的关系 &ldquo;第 133 页</a>中描述的规则找到与该符号对应的文件。在这种情况下，Clojure 找到<code>src/the_divine_cheese_code/visualization/svg.clj</code>。</li>
</ol>
<p>读取并评估该文件的内容。Clojure 希望该文件声明一个与它的路径相对应的命名空间（我们的文件就是如此）。</p>
<p><code>require</code>也可以让你在需要一个命名空间时使用<code>:as</code>或<code>alias</code>来别名它。这样。</p>
<pre tabindex=0><code>(require '[the-divine-cheese-code.visualization.svg :as svg] )
</code></pre><p>相当于这样。</p>
<pre tabindex=0><code>(require 'the-divine-cheese-code.visualization.svg)
(alias 'svg 'the-divine-cheese-code.visualization.svg)
</code></pre><p>现在你可以使用别名的命名空间了。</p>
<pre tabindex=0><code>(svg/points heists)
; =&gt; &quot;50.95,6.97 47.37,8.55 43.3,5.37 47.37,8.55 41.9,12.45&quot;
</code></pre><p>Clojure 提供了另一种捷径。函数<code>use</code>不需要单独调用<code>require</code>和<code>refer</code>，而是同时调用。在生产代码中使用<code>use</code>是不可取的，但当你在 REPL 中做实验，想快速获得一些函数时，它就很方便。例如，这个。</p>
<pre tabindex=0><code>(require 'the-divine-cheese-code.visualization.svg)
(refer 'the-divine-cheese-code.visualization.svg)
</code></pre><p>相当于这样。</p>
<pre tabindex=0><code>(use 'the-divine-cheese-code.visualization.svg)
</code></pre><p>你可以用<code>use</code>来别名一个命名空间，就像你可以用<code>require</code>一样。这样。</p>
<pre tabindex=0><code>(require 'the-divine-cheese-code.visualization.svg)
(refer 'the-divine-cheese-code.visualization.svg)
(alias 'svg 'the-divine-cheese-code.visualization.svg)
</code></pre><p>相当于清单 6-2 中的代码，其中也显示了函数调用中使用的别名空间。</p>
<pre tabindex=0><code>(use '[the-divine-cheese-code.visualization.svg :as svg])
(= svg/points points)
; =&gt; true

(= svg/latlng-&gt;point latlng-&gt;point)
; =&gt; true
</code></pre><ol>
<li>6-2. 有时，既使用又别名一个命名空间是很方便的。</li>
</ol>
<p>在这里用<code>use</code>别名命名空间似乎是多余的，因为<code>use</code>已经引用了命名空间（这让你可以简单地调用<code>points</code>而不是<code>svg/points</code>）。但在某些情况下，这很方便，因为<code>use</code>和<code>refer</code>有相同的选项（<code>:only</code>, <code>:exclude</code>, <code>:as</code>, 和<code>:rename</code>）。当你跳过引用一个符号时，你可能想用<code>use</code>来别名一个命名空间。你可以这样使用。</p>
<pre tabindex=0><code>(require 'the-divine-cheese-code.visualization.svg)
(refer 'the-divine-cheese-code.visualization.svg :as :only ['point])
</code></pre><p>或者你可以使用清单 6-3 中的<code>use</code>形式（其中还包括如何调用函数的例子）。</p>
<pre tabindex=0><code>(use '[the-divine-cheese-code.visualization.svg :as svg :only [points]])
(refer 'the-divine-cheese-code.visualization.svg :as :only ['points])
(= svg/points points)
; =&gt; true

;; We can use the alias to reach latlng-&gt;point
svg/latlng-&gt;point
; This doesn't throw an exception

;; But we can't use the bare name
latlng-&gt;point
; This does throw an exception!
</code></pre><ol>
<li>在你使用一个命名空间后将其别名化，可以让你参考你排除的符号。</li>
</ol>
<p>如果你在 REPL 中尝试清单 6-3，并且<code>latlng->point</code>没有抛出一个异常，这是因为你在清单 6-2 中引用了<code>latlng->point</code>。你需要重新启动你的 REPL 会话，使代码表现得如清单 6-3 所示。</p>
<p>这里的启示是，<code>require</code>和<code>use</code>加载文件，并可选择<code>alias</code>或<code>refer</code>其命名空间。当你写 Clojure 程序和阅读别人写的代码时，你可能会遇到更多的<code>require'和</code>use&rsquo;的写法，这时，阅读 Clojure 的 API 文档（<em><a href=http://clojure.org/libs/>http://clojure.org/libs/</a></em>）来了解发生了什么是有意义的。然而，到目前为止，你所学到的关于<code>require</code>和<code>use</code>的内容应该能满足你 95.3%的需求。</p>
<h3 id=ns-宏>＃＃＃NS 宏<a hidden class=anchor aria-hidden=true href=#ns-宏>#</a></h3>
<p>现在是时候看看<code>ns</code>宏了。到目前为止所涉及的工具&ndash;<code>in-ns</code>, <code>refer</code>, <code>alias</code>, <code>require</code>, 和 <code>use</code>&ndash;最常在你使用 REPL 时使用。在你的源代码文件中，你通常会使用<code>ns</code>宏，因为它允许你简洁地使用迄今为止描述的工具，并提供其他有用的功能。在本节中，你将了解一个<code>ns</code>调用如何结合<code>require</code>、<code>use</code>、<code>in-ns</code>、<code>alias</code>和<code>refer</code>。</p>
<p><code>ns</code>做的一个有用的任务是默认引用<code>clojure.core</code>命名空间。这就是为什么你可以从<code>the-divine-cheese-code.core</code>中调用<code>println</code>，而不使用完全限定的名称<code>clojure.core/println</code>。</p>
<p>你可以用<code>:refer-clojure</code>来控制从<code>clojure-core</code>引用的内容，它的选项与<code>refer</code>相同。</p>
<pre tabindex=0><code>(ns the-divine-cheese-code.core
  (:refer-clojure :exclude [println])
</code></pre><p>如果你在<em>divine_cheese_code.core.clj</em>的开头调用这个，会破坏你的代码，迫使你在<code>-main'函数中使用</code>clojure.core/println&rsquo;。</p>
<p>在<code>ns</code>中，<code>(:</code>refer-clojure)`的形式被称为<em>reference</em>。这对你来说可能看起来很奇怪。这个引用是一个函数调用？一个宏？它是什么？你将在第 7 章中了解更多关于底层机器的知识。现在，你只需要了解每个引用如何映射到函数调用。例如，前面的代码就相当于这样。</p>
<pre tabindex=0><code>(in-ns 'the-divine-cheese-code.core)
(refer 'clojure.core :exclude ['println])
</code></pre><p>在 &ldquo;ns &ldquo;中，有六种可能的引用。</p>
<ul>
<li><code>(:refer-clojure)</code>.</li>
<li>&ldquo;(:require)"。</li>
<li><code>(:use)</code></li>
<li><code>(:import)</code></li>
<li><code>(:load)</code></li>
<li><code>(:gen-class)</code>。</li>
</ul>
<p><code>(:import)</code>和<code>(:gen-class)</code>将在第 12 章介绍。我将不介绍<code>(:load)</code>，因为它很少被使用。</p>
<p><code>(:require)</code>的工作方式很像<code>require</code>函数。例如，这样。</p>
<pre tabindex=0><code>(ns the-divine-cheese-code.core
  (:require the-divine-cheese-code.visualization.svg))
</code></pre><p>相当于这样。</p>
<pre tabindex=0><code>(in-ns 'the-divine-cheese-code.core)
(require 'the-divine-cheese-code.visualization.svg)
</code></pre><p>注意，在 &ldquo;ns &ldquo;形式中（与 &ldquo;in-ns &ldquo;函数调用不同），你不需要用&rdquo;&lsquo;&lsquo;来引用你的符号。在 &ldquo;ns &ldquo;中，你从来不需要引用符号。</p>
<p>你也可以<code>alias</code>一个你在<code>ns</code>内<code>require</code>的库，就像你调用函数时一样。这样。</p>
<pre tabindex=0><code>(ns the-divine-cheese-code.core
  (:require [the-divine-cheese-code.visualization.svg :as svg])
</code></pre><p>相当于这样。</p>
<pre tabindex=0><code>(in-ns 'the-divine-cheese-code.core)
(require ['the-divine-cheese-code.visualization.svg :as 'svg])
</code></pre><p>你可以在一个<code>(:require)</code>引用中要求多个库，如下所示。 这样。</p>
<pre tabindex=0><code>(ns the-divine-cheese-code.core
  (:require [the-divine-cheese-code.visualization.svg :as svg])
            [clojure.java.browse :as browse]))
</code></pre><p>相当于这样。</p>
<pre tabindex=0><code>(in-ns 'the-divine-cheese-code.core)
(require ['the-divine-cheese-code.visualization.svg :as 'svg])
(require ['clojure.java.browse :as 'browse])
</code></pre><p>然而，<code>(:require)</code>引用和<code>require</code>函数之间的一个区别是，引用也允许你引用名字。这一点。</p>
<pre tabindex=0><code>(ns the-divine-cheese-code.core
  (:require [the-divine-cheese-code.visualization.svg :refer [point]))
</code></pre><p>相当于这样。</p>
<pre tabindex=0><code>(in-ns 'the-divine-cheese-code.core)
(require 'the-divine-cheese-code.visualization.svg)
(refer 'the-divine-cheese-code.visualization.svg :only ['point])
</code></pre><p>你也可以引用所有的符号（注意<code>:all</code>关键字）。</p>
<pre tabindex=0><code>(ns the-divine-cheese-code.core
  (:require [the-divine-cheese-code.visualization.svg :refer :all]))
</code></pre><p>这就相当于这样做了。</p>
<pre tabindex=0><code>(in-ns 'the-divine-cheese-code.core)
(require 'the-divine-cheese-code.visualization.svg)
(refer 'the-divine-cheese-code.visualization.svg)
</code></pre><p>这是要求代码、别名命名空间和引用符号的首选方式。建议你不要使用<code>(:use)</code>，但由于你很可能会遇到它，所以知道它是如何工作的很好。你知道该怎么做。这个。</p>
<pre tabindex=0><code>(ns the-divine-cheese-code.core
  (:use clojure.java.browse))
</code></pre><p>这样做。</p>
<pre tabindex=0><code>(in-ns 'the-divine-cheese-code.core)
(use 'clojure.java.browse)
</code></pre><p>而这一点。</p>
<pre tabindex=0><code>(ns the-divine-cheese-code.core
  (:use [clojure.java browse io])
</code></pre><p>这样做。</p>
<pre tabindex=0><code>(in-ns 'the-divine-cheese-code.core)
(use 'clojure.java.browse)
(use 'clojure.java.io)
</code></pre><p>注意，当你在<code>:use</code>后面加上一个矢量时，它把第一个符号作为<em>base</em>，然后用后面的每个符号调用<code>use</code>。</p>
<p>哦，我的天哪，就是这样! 现在你可以像专家一样使用<code>ns</code>了! 你需要这样做，该死的，因为那个<em>voleur des fromages</em>（他们可能在法语中这样说）仍然在肆意妄为。还记得他/她吗？</p>
<p>∮∮抓小偷</p>
<p>我们不能让这个掠夺帕尔马干酪的人带着更多的干酪离开！是时候完成根据坐标画线的工作了。现在是时候根据盗窃案的坐标来完成画线了！这肯定会发现一些问题。这肯定会发现一些问题!</p>
<p>使用每个抢劫案的纬度坐标，你将在一个 SVG 图像中连接这些点。但是，如果你用给定的坐标画线，结果看起来就不对了，原因有二。首先，纬度坐标是由南向北上升的，而 SVG 的 Y 坐标是由上向下上升的。换句话说，你需要翻转坐标，否则绘图就会颠倒过来。</p>
<p>第二，绘图会非常小。为了解决这个问题，你将通过平移和缩放来放大它。这就像把一张看起来像图 6-1a 的图变成图 6-1b。</p>
<p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/organization/svg-before.png alt>
<img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/organization/svg-after.png alt>
</p>
<p>图 6-1：通过翻转、平移和缩放纬度坐标来制作一张 SVG 图片。</p>
<p>说实话，这些都是完全随意的，它已经与代码组织没有直接关系了，但是它很有趣，我想你会有一个很好的时间来浏览这些代码的 使你的<em>svg.clj</em>文件与清单 6-4 一致。</p>
<pre tabindex=0><code>(ns the-divine-cheese-code.visualization.svg
  (:require [clojure.string :as s])
  (:refer-clojure :exclude [min max])

➊ （defn comparator-over-maps
  [比较-fn ks］
  (fn [maps]
➋ (zipmap ks
➌ (map (fn [k] (apply comparison-fn (map k maps)))
                 ks))))

➍ (def min (comparator-over-maps clojure.core/min [:lat :lng])
(def max (comparator-over-maps clojure.core/max [:lat :lng]))
</code></pre><ol>
<li>6-3. 构建地图比较函数</li>
</ol>
<p>你在➊处定义了<code>comparator-over-maps</code>函数。这可能是最棘手的部分，所以请忍受一下。 <code>comparator-over-maps</code>是一个返回一个函数的函数。返回的函数使用所提供的比较函数<code>comparison-fn</code>对参数<code>ks</code>提供的键值进行比较。</p>
<p>你使用<code>comparator-over-map</code>来构造<code>min</code>和<code>max</code>函数➍，你将用它们来寻找我们图形的左上角和右下角。下面是`min&rsquo;的操作。</p>
<pre tabindex=0><code>(min [{:a 1 :b 3} {:a 5 :b 0}] )
; =&gt; {:a 1 :b 0}
</code></pre><p>当你调用<code>min</code>时，它调用<code>zipmap</code>，它接受两个参数，都是 seq，并返回一个新的 map。第一个序列的元素成为键，第二个序列的元素成为值。</p>
<pre tabindex=0><code>(zipmap [:a :b] [1 2])
; =&gt; {:a 1 :b 2}。
</code></pre><p>在 ，<code>zipmap</code>的第一个参数是<code>ks</code>，所以<code>ks</code>的元素将是返回地图的键。第二个参数是在➌的地图调用的结果。那个地图调用实际上是在进行比较。</p>
<p>最后，在➍，你使用<code>comparator-over-maps</code>来创建比较函数。如果你把图纸看作是刻在一个矩形里，那么<code>min</code>是矩形中最接近（0，0）的角，<code>max</code>是离它最远的角。</p>
<p>下面是代码的下一部分。</p>
<pre tabindex=0><code> (defn translate-to-00
  [locations]
  (let [mincoords (min locations)]
    (map #(merge-with - % mincoords) locations)))

 (defn scale
  [width height locations]
  (let [maxcoords (max locations)
        ratio {:lat (/ height (:lat maxcoords))
               :lng (/ width (:lng maxcoords))}]
    (map #(merge-with * % ratio) locations)))
</code></pre><p><code>translate-to-00</code>，定义在 ，工作原理是找到我们位置的<code>min'，然后从每个位置减去这个值。它使用</code>merge-with`，其工作原理如下。</p>
<pre tabindex=0><code>(merge-with - {:lat 50 :lng 10} {:lat 5 :lng 5})
; =&gt; {:lat 45 :lng 5}
</code></pre><p>然后我们定义函数<code>scale</code>，它将每个点乘以最大经纬度与所需高度和宽度之间的比率。</p>
<p>下面是<em>svg.clj</em>的其余代码。</p>
<pre tabindex=0><code>(defn latlng-&gt;point
  &quot;Convert lat/lng map to comma-separated string&quot; 
  [latlng]
  (str (:lat latlng) &quot;,&quot; (:lng latlng)))

(defn points
  &quot;Given a seq of lat/lng maps, return string of points joined by space&quot;
  [locations]
  (s/join &quot; &quot; (map latlng-&gt;point locations)))

(defn line
  [points]
  (str &quot;&lt;polyline points=\&quot;&quot; points &quot;\&quot; /&gt;&quot;))

(defn transform
  &quot;Just chains other functions&quot;
  [width height locations]
  (-&gt;&gt; locations
       translate-to-00
       (scale width height)))

(defn xml
  &quot;svg 'template', which also flips the coordinate system&quot;
  [width height locations]
  (str &quot;&lt;svg height=\&quot;&quot; height &quot;\&quot; width=\&quot;&quot; width &quot;\&quot;&gt;&quot;
       ;; These two &lt;g&gt; tags change the coordinate system so that
       ;; 0,0 is in the lower-left corner, instead of SVG's default
       ;; upper-left corner
       &quot;&lt;g transform=\&quot;translate(0,&quot; height &quot;)\&quot;&gt;&quot;
       &quot;&lt;g transform=\&quot;rotate(-90)\&quot;&gt;&quot;
       (-&gt; (transform width height locations)
           points
           line)
       &quot;&lt;/g&gt;&lt;/g&gt;&quot;
       &quot;&lt;/svg&gt;&quot;))
</code></pre><p>这里的函数非常简单明了。它们只是接收<code>{:lat x :lng y}</code>地图，并对其进行转换，以便创建一个 SVG。<code>latlng->point</code>返回一个字符串，可用于在 SVG 标记中定义一个点。<code>points</code>将<code>lat</code>/<code>lng</code>地图的序列转换为一个以空格分隔的点的字符串。 <code>line</code>返回连接所有给定空间分隔的点字符串的 SVG 标记。 <code>transform</code>接收一个位置序列，将它们翻译成从(0, 0)开始的点，并将它们缩放到给定的宽度和高度。最后，<code>xml</code>产生标记，用 SVG 显示给定的位置。</p>
<p>有了<em>svg.clj</em>的所有代码，现在让<em>core.clj</em>看起来像这样。</p>
<pre tabindex=0><code>(ns the-divine-cheese-code.core
  (:require [clojure.java.browse :as browse]
            [the-divine-cheese-code.visualization.svg :refer [xml]])
  (:gen-class))

(def heists [{:location &quot;Cologne, Germany&quot;
              :cheese-name &quot;Archbishop Hildebold's Cheese Pretzel&quot;
              :lat 50.95
              :lng 6.97}
             {:location &quot;Zurich, Switzerland&quot;
              :cheese-name &quot;The Standard Emmental&quot;
              :lat 47.37
              :lng 8.55}
             {:location &quot;Marseille, France&quot;
              :cheese-name &quot;Le Fromage de Cosquer&quot;
              :lat 43.30
              :lng 5.37}
             {:location &quot;Zurich, Switzerland&quot;
              :cheese-name &quot;The Lesser Emmental&quot;
              :lat 47.37
              :lng 8.55}
             {:location &quot;Vatican City&quot;
              :cheese-name &quot;The Cheese of Turin&quot;
              :lat 41.90
              :lng 12.45}])

(defn url
  [filename]
  (str &quot;file:///&quot;
       (System/getProperty &quot;user.dir&quot;)
       &quot;/&quot;
       filename))

(defn template
  [contents]
  (str &quot;&lt;style&gt;polyline { fill:none; stroke:#5881d8; stroke-width:3}&lt;/style&gt;&quot;
       contents))

(defn -main
  [&amp; args]
  (let [filename &quot;map.html&quot;]
    (-&gt;&gt; heists
         (xml 50 100)
         template
         (spit filename))
    (browse/browse-url (url filename))))
</code></pre><p>这里没有太复杂的事情发生。在 &ldquo;main &ldquo;中，你使用 &ldquo;xml &ldquo;和 &ldquo;template &ldquo;函数建立绘图，用 &ldquo;spit &ldquo;将绘图写入一个文件，然后用 &ldquo;browse/browse-url &ldquo;打开它。你现在应该试试! 运行<code>lein run</code>，你会看到类似图 6-2 的东西。</p>
<p>图 6-2: 抢劫模式的最终 SVG!</p>
<p>等一下 ……这看起来很像 ……这看起来很像一个 lambda。Clojure 的标志是一个 lambda . ……哦，我的天啊! Clojure，一直以来都是你!</p>
<h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2>
<p>在本章中你学到了很多东西。在这一点上，你应该拥有所有你需要的工具来开始组织你的项目。你现在知道命名空间组织了符号和 vars 之间的映射，vars 是对 Clojure 对象（数据结构、函数等）的引用。 <code>def</code>存储一个对象，并用符号和指向该对象的 var 之间的映射来更新当前命名空间。你可以用<code>defn-</code>创建私有函数。</p>
<p>Clojure 允许你用<code>create-ns</code>创建命名空间，但通常使用<code>in-ns</code>更有用，它也会切换到命名空间。你可能只在 REPL 中使用这些函数。当你在 REPL 中时，你总是<em>在</em>当前命名空间中。当你在文件中而不是在 REPL 中定义名字空间时，你应该使用 <code>ns</code> 宏，名字空间和它在文件系统中的路径之间是一对一的关系。</p>
<p>你可以通过使用完全限定的名称来引用其他命名空间中的对象，如<code>cheese.taxonomy/cheddars</code>。 <code>refer</code>可以让你使用其他命名空间的名字，而不需要完全限定它们，<code>alias</code>可以让你在写出完全限定的名字时，使用一个更短的名字来命名空间。</p>
<p><code>require</code>和<code>use</code>确保一个名字空间的存在并准备好被使用，并且可以选择让你<code>refer</code>和<code>alias</code>相应的名字空间。你应该使用<code>ns</code>在你的源文件中调用<code>require</code>和<code>use</code>。*<a href=https://gist.github.com/ghoseb/287710/>Clojure ns syntax cheat-sheet - GitHub</a>*是使用<code>ns</code>的所有变化的一个很好的参考。</p>
<p>最后，也是最重要的一点，做一个俗气的人并不容易。</p>
<p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/organization/cheese.png alt>
</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://zhenfeng-zhu.github.io/tags/clojure/>clojure</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://zhenfeng-zhu.github.io/posts/chapter7/>
<span class=title>« Prev Page</span>
<br>
<span>Chapter7 Clojure 炼金术。阅读、评估和宏</span>
</a>
<a class=next href=https://zhenfeng-zhu.github.io/posts/chapter5/>
<span class=title>Next Page »</span>
<br>
<span>Chapter5 函数式编程</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter6 整理你的项目：一个图书管理员的故事 on twitter" href="https://twitter.com/intent/tweet/?text=Chapter6%20%e6%95%b4%e7%90%86%e4%bd%a0%e7%9a%84%e9%a1%b9%e7%9b%ae%ef%bc%9a%e4%b8%80%e4%b8%aa%e5%9b%be%e4%b9%a6%e7%ae%a1%e7%90%86%e5%91%98%e7%9a%84%e6%95%85%e4%ba%8b&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter6%2f&hashtags=clojure"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter6 整理你的项目：一个图书管理员的故事 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter6%2f&title=Chapter6%20%e6%95%b4%e7%90%86%e4%bd%a0%e7%9a%84%e9%a1%b9%e7%9b%ae%ef%bc%9a%e4%b8%80%e4%b8%aa%e5%9b%be%e4%b9%a6%e7%ae%a1%e7%90%86%e5%91%98%e7%9a%84%e6%95%85%e4%ba%8b&summary=Chapter6%20%e6%95%b4%e7%90%86%e4%bd%a0%e7%9a%84%e9%a1%b9%e7%9b%ae%ef%bc%9a%e4%b8%80%e4%b8%aa%e5%9b%be%e4%b9%a6%e7%ae%a1%e7%90%86%e5%91%98%e7%9a%84%e6%95%85%e4%ba%8b&source=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter6%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter6 整理你的项目：一个图书管理员的故事 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter6%2f&title=Chapter6%20%e6%95%b4%e7%90%86%e4%bd%a0%e7%9a%84%e9%a1%b9%e7%9b%ae%ef%bc%9a%e4%b8%80%e4%b8%aa%e5%9b%be%e4%b9%a6%e7%ae%a1%e7%90%86%e5%91%98%e7%9a%84%e6%95%85%e4%ba%8b"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter6 整理你的项目：一个图书管理员的故事 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter6%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter6 整理你的项目：一个图书管理员的故事 on whatsapp" href="https://api.whatsapp.com/send?text=Chapter6%20%e6%95%b4%e7%90%86%e4%bd%a0%e7%9a%84%e9%a1%b9%e7%9b%ae%ef%bc%9a%e4%b8%80%e4%b8%aa%e5%9b%be%e4%b9%a6%e7%ae%a1%e7%90%86%e5%91%98%e7%9a%84%e6%95%85%e4%ba%8b%20-%20https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter6%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter6 整理你的项目：一个图书管理员的故事 on telegram" href="https://telegram.me/share/url?text=Chapter6%20%e6%95%b4%e7%90%86%e4%bd%a0%e7%9a%84%e9%a1%b9%e7%9b%ae%ef%bc%9a%e4%b8%80%e4%b8%aa%e5%9b%be%e4%b9%a6%e7%ae%a1%e7%90%86%e5%91%98%e7%9a%84%e6%95%85%e4%ba%8b&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter6%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer><script src=https://utteranc.es/client.js repo=zhenfeng-zhu/zhenfeng-zhu.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://zhenfeng-zhu.github.io>Awesome Fenix</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>