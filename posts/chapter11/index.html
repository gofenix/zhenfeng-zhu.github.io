<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Chapter11 core.async | Awesome Fenix</title>
<meta name=keywords content="clojure">
<meta name=description content="用 core.async 掌握并发进程 有一天，当你走在大街上时，你会惊讶、好奇，并有点厌恶地发现一台热狗自动贩卖机。你的头皮被有罪的好奇心刺痛，你会忍不住掏出三块钱，看看这个装置是否真的能工作。在 &ldquo;咔嚓 &ldquo;一声接受了你的钱后，它弹出了一个新鲜的热狗，包括面包和所有的东西。
自动售货机表现出简单的行为：当它收到钱时，它会放出一个热狗，然后为下一次购买做准备。当它的热狗用完时，它就会停止。我们周围的热狗自动售货机以不同的面貌出现，它们是独立的实体，同时对世界上的事件作出反应。你最喜欢的咖啡店的浓缩咖啡机，你小时候喜欢的宠物仓鼠&ndash;所有的东西都可以被分解成一组行为，这些行为遵循一般的形式 &ldquo;当x发生时，做y&#34;。甚至我们写的程序也只是美化的热狗贩卖机，每一个都是独立的进程，等待着下一个事件的发生，无论是击键、超时，还是套接字上的数据到达。
Clojure 的 core.async 库允许你在一个程序中创建多个独立进程。 本章描述了思考这种编程风格的有用模型，以及你在实际编写代码时需要了解的实际细节。你将学习如何使用通道在由 go 块和thread创建的独立进程之间进行通信；了解一些关于 Clojure 如何通过停放和阻塞有效地管理线程；如何使用alts!!；以及一种更直接的创建队列的方法。最后，你将学习如何用进程管道来踢回调的屁股。
进程的入门 core.async 的核心是*进程，一个并发运行的逻辑单元，对事件做出反应。进程对应于我们对现实世界的心理模型：实体之间的互动和响应是独立的，没有某种中央控制机制的牵制。你把钱放进机器里，就会有一个热狗出来，所有这些都不需要光照派或老大哥来策划整个事情。这与你迄今为止一直在探索的并发性观点不同，在那里，你定义的任务要么只是控制主线程的扩展（例如，用pmap实现数据并行），要么是你没有兴趣与之交流的任务（如用future创建的一次性任务）。
把自动售货机看成是一个进程可能很奇怪：自动售货机是名词和事物，而进程是动词和行为。为了获得正确的思维方式，可以尝试将现实世界的物体定义为其事件驱动的行为的总和。当一粒种子被浇水时，它就会发芽；当母亲看着她的新生儿时，她就会感受到爱；而当你观看《星战》第一集时，你会充满愤怒和绝望。如果你想变得超级哲学，可以考虑是否有可能将每个事物的本质定义为它所识别的事件的集合，以及它如何做出反应。现实是否只是热狗售卖机的组成？
总之，我说得够多了! 让我们通过创建一些简单的过程，从理论上走向具体。首先，用 &ldquo;lein new app playsync &ldquo;创建一个新的 Leiningen 项目，名为playsync。然后，打开project.clj文件，将 core.async 添加到:dependenciesVector 中，使其内容如下。
[[org.clojure/clojure &#34;1.9.0&#34;] [org.clojure/core.async &#34;0.1.346.0-17112a-alpha&#34;]] 注意 自从我写完这篇文章后，core.async 的版本有可能有所进步。关于最新的版本，请查看 core.async 的 GitHub 项目页面。但为了这些练习的目的，请使用这里列出的版本。
接下来，打开src/playsync/core.clj，使其看起来像这样。
(ns playsync.core (:require [clojure.core.async :as a :refer [>! <! >!! <!! go chan buffer close! thread alts! alts!! timeout]])) 现在，当你在 REPL 中打开它时，你将拥有最常用的 core.async 函数供你使用。很好! 在创建像热狗售卖机那样复杂和革命性的东西之前，先创建一个进程，简单地打印它收到的消息。">
<meta name=author content="Fenix">
<link rel=canonical href=https://zhenfeng-zhu.github.io/posts/chapter11/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zhenfeng-zhu.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://zhenfeng-zhu.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://zhenfeng-zhu.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://zhenfeng-zhu.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://zhenfeng-zhu.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-216295420-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Chapter11 core.async">
<meta property="og:description" content="用 core.async 掌握并发进程 有一天，当你走在大街上时，你会惊讶、好奇，并有点厌恶地发现一台热狗自动贩卖机。你的头皮被有罪的好奇心刺痛，你会忍不住掏出三块钱，看看这个装置是否真的能工作。在 &ldquo;咔嚓 &ldquo;一声接受了你的钱后，它弹出了一个新鲜的热狗，包括面包和所有的东西。
自动售货机表现出简单的行为：当它收到钱时，它会放出一个热狗，然后为下一次购买做准备。当它的热狗用完时，它就会停止。我们周围的热狗自动售货机以不同的面貌出现，它们是独立的实体，同时对世界上的事件作出反应。你最喜欢的咖啡店的浓缩咖啡机，你小时候喜欢的宠物仓鼠&ndash;所有的东西都可以被分解成一组行为，这些行为遵循一般的形式 &ldquo;当x发生时，做y&#34;。甚至我们写的程序也只是美化的热狗贩卖机，每一个都是独立的进程，等待着下一个事件的发生，无论是击键、超时，还是套接字上的数据到达。
Clojure 的 core.async 库允许你在一个程序中创建多个独立进程。 本章描述了思考这种编程风格的有用模型，以及你在实际编写代码时需要了解的实际细节。你将学习如何使用通道在由 go 块和thread创建的独立进程之间进行通信；了解一些关于 Clojure 如何通过停放和阻塞有效地管理线程；如何使用alts!!；以及一种更直接的创建队列的方法。最后，你将学习如何用进程管道来踢回调的屁股。
进程的入门 core.async 的核心是*进程，一个并发运行的逻辑单元，对事件做出反应。进程对应于我们对现实世界的心理模型：实体之间的互动和响应是独立的，没有某种中央控制机制的牵制。你把钱放进机器里，就会有一个热狗出来，所有这些都不需要光照派或老大哥来策划整个事情。这与你迄今为止一直在探索的并发性观点不同，在那里，你定义的任务要么只是控制主线程的扩展（例如，用pmap实现数据并行），要么是你没有兴趣与之交流的任务（如用future创建的一次性任务）。
把自动售货机看成是一个进程可能很奇怪：自动售货机是名词和事物，而进程是动词和行为。为了获得正确的思维方式，可以尝试将现实世界的物体定义为其事件驱动的行为的总和。当一粒种子被浇水时，它就会发芽；当母亲看着她的新生儿时，她就会感受到爱；而当你观看《星战》第一集时，你会充满愤怒和绝望。如果你想变得超级哲学，可以考虑是否有可能将每个事物的本质定义为它所识别的事件的集合，以及它如何做出反应。现实是否只是热狗售卖机的组成？
总之，我说得够多了! 让我们通过创建一些简单的过程，从理论上走向具体。首先，用 &ldquo;lein new app playsync &ldquo;创建一个新的 Leiningen 项目，名为playsync。然后，打开project.clj文件，将 core.async 添加到:dependenciesVector 中，使其内容如下。
[[org.clojure/clojure &#34;1.9.0&#34;] [org.clojure/core.async &#34;0.1.346.0-17112a-alpha&#34;]] 注意 自从我写完这篇文章后，core.async 的版本有可能有所进步。关于最新的版本，请查看 core.async 的 GitHub 项目页面。但为了这些练习的目的，请使用这里列出的版本。
接下来，打开src/playsync/core.clj，使其看起来像这样。
(ns playsync.core (:require [clojure.core.async :as a :refer [>! <! >!! <!! go chan buffer close! thread alts! alts!! timeout]])) 现在，当你在 REPL 中打开它时，你将拥有最常用的 core.async 函数供你使用。很好! 在创建像热狗售卖机那样复杂和革命性的东西之前，先创建一个进程，简单地打印它收到的消息。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhenfeng-zhu.github.io/posts/chapter11/">
<meta property="og:image" content="https://zhenfeng-zhu.github.io/posts/chapter11/https:/raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201152206174.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-15T12:56:01+08:00">
<meta property="article:modified_time" content="2022-01-15T12:56:01+08:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhenfeng-zhu.github.io/posts/chapter11/https:/raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201152206174.png">
<meta name=twitter:title content="Chapter11 core.async">
<meta name=twitter:description content="用 core.async 掌握并发进程 有一天，当你走在大街上时，你会惊讶、好奇，并有点厌恶地发现一台热狗自动贩卖机。你的头皮被有罪的好奇心刺痛，你会忍不住掏出三块钱，看看这个装置是否真的能工作。在 &ldquo;咔嚓 &ldquo;一声接受了你的钱后，它弹出了一个新鲜的热狗，包括面包和所有的东西。
自动售货机表现出简单的行为：当它收到钱时，它会放出一个热狗，然后为下一次购买做准备。当它的热狗用完时，它就会停止。我们周围的热狗自动售货机以不同的面貌出现，它们是独立的实体，同时对世界上的事件作出反应。你最喜欢的咖啡店的浓缩咖啡机，你小时候喜欢的宠物仓鼠&ndash;所有的东西都可以被分解成一组行为，这些行为遵循一般的形式 &ldquo;当x发生时，做y&#34;。甚至我们写的程序也只是美化的热狗贩卖机，每一个都是独立的进程，等待着下一个事件的发生，无论是击键、超时，还是套接字上的数据到达。
Clojure 的 core.async 库允许你在一个程序中创建多个独立进程。 本章描述了思考这种编程风格的有用模型，以及你在实际编写代码时需要了解的实际细节。你将学习如何使用通道在由 go 块和thread创建的独立进程之间进行通信；了解一些关于 Clojure 如何通过停放和阻塞有效地管理线程；如何使用alts!!；以及一种更直接的创建队列的方法。最后，你将学习如何用进程管道来踢回调的屁股。
进程的入门 core.async 的核心是*进程，一个并发运行的逻辑单元，对事件做出反应。进程对应于我们对现实世界的心理模型：实体之间的互动和响应是独立的，没有某种中央控制机制的牵制。你把钱放进机器里，就会有一个热狗出来，所有这些都不需要光照派或老大哥来策划整个事情。这与你迄今为止一直在探索的并发性观点不同，在那里，你定义的任务要么只是控制主线程的扩展（例如，用pmap实现数据并行），要么是你没有兴趣与之交流的任务（如用future创建的一次性任务）。
把自动售货机看成是一个进程可能很奇怪：自动售货机是名词和事物，而进程是动词和行为。为了获得正确的思维方式，可以尝试将现实世界的物体定义为其事件驱动的行为的总和。当一粒种子被浇水时，它就会发芽；当母亲看着她的新生儿时，她就会感受到爱；而当你观看《星战》第一集时，你会充满愤怒和绝望。如果你想变得超级哲学，可以考虑是否有可能将每个事物的本质定义为它所识别的事件的集合，以及它如何做出反应。现实是否只是热狗售卖机的组成？
总之，我说得够多了! 让我们通过创建一些简单的过程，从理论上走向具体。首先，用 &ldquo;lein new app playsync &ldquo;创建一个新的 Leiningen 项目，名为playsync。然后，打开project.clj文件，将 core.async 添加到:dependenciesVector 中，使其内容如下。
[[org.clojure/clojure &#34;1.9.0&#34;] [org.clojure/core.async &#34;0.1.346.0-17112a-alpha&#34;]] 注意 自从我写完这篇文章后，core.async 的版本有可能有所进步。关于最新的版本，请查看 core.async 的 GitHub 项目页面。但为了这些练习的目的，请使用这里列出的版本。
接下来，打开src/playsync/core.clj，使其看起来像这样。
(ns playsync.core (:require [clojure.core.async :as a :refer [>! <! >!! <!! go chan buffer close! thread alts! alts!! timeout]])) 现在，当你在 REPL 中打开它时，你将拥有最常用的 core.async 函数供你使用。很好! 在创建像热狗售卖机那样复杂和革命性的东西之前，先创建一个进程，简单地打印它收到的消息。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://zhenfeng-zhu.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Chapter11 core.async","item":"https://zhenfeng-zhu.github.io/posts/chapter11/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Chapter11 core.async","name":"Chapter11 core.async","description":"用 core.async 掌握并发进程 有一天，当你走在大街上时，你会惊讶、好奇，并有点厌恶地发现一台热狗自动贩卖机。你的头皮被有罪的好奇心刺痛，你会忍不住掏出三块钱，看看这个装置是否真的能工作。在 \u0026ldquo;咔嚓 \u0026ldquo;一声接受了你的钱后，它弹出了一个新鲜的热狗，包括面包和所有的东西。\n自动售货机表现出简单的行为：当它收到钱时，它会放出一个热狗，然后为下一次购买做准备。当它的热狗用完时，它就会停止。我们周围的热狗自动售货机以不同的面貌出现，它们是独立的实体，同时对世界上的事件作出反应。你最喜欢的咖啡店的浓缩咖啡机，你小时候喜欢的宠物仓鼠\u0026ndash;所有的东西都可以被分解成一组行为，这些行为遵循一般的形式 \u0026ldquo;当x发生时，做y\u0026quot;。甚至我们写的程序也只是美化的热狗贩卖机，每一个都是独立的进程，等待着下一个事件的发生，无论是击键、超时，还是套接字上的数据到达。\nClojure 的 core.async 库允许你在一个程序中创建多个独立进程。 本章描述了思考这种编程风格的有用模型，以及你在实际编写代码时需要了解的实际细节。你将学习如何使用通道在由 go 块和thread创建的独立进程之间进行通信；了解一些关于 Clojure 如何通过停放和阻塞有效地管理线程；如何使用alts!!；以及一种更直接的创建队列的方法。最后，你将学习如何用进程管道来踢回调的屁股。\n进程的入门 core.async 的核心是*进程，一个并发运行的逻辑单元，对事件做出反应。进程对应于我们对现实世界的心理模型：实体之间的互动和响应是独立的，没有某种中央控制机制的牵制。你把钱放进机器里，就会有一个热狗出来，所有这些都不需要光照派或老大哥来策划整个事情。这与你迄今为止一直在探索的并发性观点不同，在那里，你定义的任务要么只是控制主线程的扩展（例如，用pmap实现数据并行），要么是你没有兴趣与之交流的任务（如用future创建的一次性任务）。\n把自动售货机看成是一个进程可能很奇怪：自动售货机是名词和事物，而进程是动词和行为。为了获得正确的思维方式，可以尝试将现实世界的物体定义为其事件驱动的行为的总和。当一粒种子被浇水时，它就会发芽；当母亲看着她的新生儿时，她就会感受到爱；而当你观看《星战》第一集时，你会充满愤怒和绝望。如果你想变得超级哲学，可以考虑是否有可能将每个事物的本质定义为它所识别的事件的集合，以及它如何做出反应。现实是否只是热狗售卖机的组成？\n总之，我说得够多了! 让我们通过创建一些简单的过程，从理论上走向具体。首先，用 \u0026ldquo;lein new app playsync \u0026ldquo;创建一个新的 Leiningen 项目，名为playsync。然后，打开project.clj文件，将 core.async 添加到:dependenciesVector 中，使其内容如下。\n[[org.clojure/clojure \u0026quot;1.9.0\u0026quot;] [org.clojure/core.async \u0026quot;0.1.346.0-17112a-alpha\u0026quot;]] 注意 自从我写完这篇文章后，core.async 的版本有可能有所进步。关于最新的版本，请查看 core.async 的 GitHub 项目页面。但为了这些练习的目的，请使用这里列出的版本。\n接下来，打开src/playsync/core.clj，使其看起来像这样。\n(ns playsync.core (:require [clojure.core.async :as a :refer [\u0026gt;! \u0026lt;! \u0026gt;!! \u0026lt;!! go chan buffer close! thread alts! alts!! timeout]])) 现在，当你在 REPL 中打开它时，你将拥有最常用的 core.async 函数供你使用。很好! 在创建像热狗售卖机那样复杂和革命性的东西之前，先创建一个进程，简单地打印它收到的消息。","keywords":["clojure"],"articleBody":"用 core.async 掌握并发进程 有一天，当你走在大街上时，你会惊讶、好奇，并有点厌恶地发现一台热狗自动贩卖机。你的头皮被有罪的好奇心刺痛，你会忍不住掏出三块钱，看看这个装置是否真的能工作。在 “咔嚓 “一声接受了你的钱后，它弹出了一个新鲜的热狗，包括面包和所有的东西。\n自动售货机表现出简单的行为：当它收到钱时，它会放出一个热狗，然后为下一次购买做准备。当它的热狗用完时，它就会停止。我们周围的热狗自动售货机以不同的面貌出现，它们是独立的实体，同时对世界上的事件作出反应。你最喜欢的咖啡店的浓缩咖啡机，你小时候喜欢的宠物仓鼠–所有的东西都可以被分解成一组行为，这些行为遵循一般的形式 “当x发生时，做y\"。甚至我们写的程序也只是美化的热狗贩卖机，每一个都是独立的进程，等待着下一个事件的发生，无论是击键、超时，还是套接字上的数据到达。\nClojure 的 core.async 库允许你在一个程序中创建多个独立进程。 本章描述了思考这种编程风格的有用模型，以及你在实际编写代码时需要了解的实际细节。你将学习如何使用通道在由 go 块和thread创建的独立进程之间进行通信；了解一些关于 Clojure 如何通过停放和阻塞有效地管理线程；如何使用alts!!；以及一种更直接的创建队列的方法。最后，你将学习如何用进程管道来踢回调的屁股。\n进程的入门 core.async 的核心是*进程，一个并发运行的逻辑单元，对事件做出反应。进程对应于我们对现实世界的心理模型：实体之间的互动和响应是独立的，没有某种中央控制机制的牵制。你把钱放进机器里，就会有一个热狗出来，所有这些都不需要光照派或老大哥来策划整个事情。这与你迄今为止一直在探索的并发性观点不同，在那里，你定义的任务要么只是控制主线程的扩展（例如，用pmap实现数据并行），要么是你没有兴趣与之交流的任务（如用future创建的一次性任务）。\n把自动售货机看成是一个进程可能很奇怪：自动售货机是名词和事物，而进程是动词和行为。为了获得正确的思维方式，可以尝试将现实世界的物体定义为其事件驱动的行为的总和。当一粒种子被浇水时，它就会发芽；当母亲看着她的新生儿时，她就会感受到爱；而当你观看《星战》第一集时，你会充满愤怒和绝望。如果你想变得超级哲学，可以考虑是否有可能将每个事物的本质定义为它所识别的事件的集合，以及它如何做出反应。现实是否只是热狗售卖机的组成？\n总之，我说得够多了! 让我们通过创建一些简单的过程，从理论上走向具体。首先，用 “lein new app playsync “创建一个新的 Leiningen 项目，名为playsync。然后，打开project.clj文件，将 core.async 添加到:dependenciesVector 中，使其内容如下。\n[[org.clojure/clojure \"1.9.0\"] [org.clojure/core.async \"0.1.346.0-17112a-alpha\"]] 注意 自从我写完这篇文章后，core.async 的版本有可能有所进步。关于最新的版本，请查看 core.async 的 GitHub 项目页面。但为了这些练习的目的，请使用这里列出的版本。\n接下来，打开src/playsync/core.clj，使其看起来像这样。\n(ns playsync.core (:require [clojure.core.async :as a :refer [! !! 现在，当你在 REPL 中打开它时，你将拥有最常用的 core.async 函数供你使用。很好! 在创建像热狗售卖机那样复杂和革命性的东西之前，先创建一个进程，简单地打印它收到的消息。\n(def echo-chan (chan)) (go (println (!! echo-chan \"ketchup\") ; = true ; = ketchup 在第一行代码中，你用chan函数创建了一个名为echo-chan的通道。通道传达消息*。你可以把消息放到一个通道上，也可以把消息从一个通道上拿下来。进程等待放和取的完成–这些是进程所响应的事件。你可以认为进程有两个规则。1）当试图把一个消息放到通道上或从通道上取走一个消息时，等待并不做任何事情，直到放或取成功；2）当放或取成功时，继续执行。\n在下一行，你用go来创建一个新的进程。go表达式中的所有内容都被称为go 块，在一个单独的线程上并发运行。Go 块在一个线程池上运行你的进程，该线程池包含的线程数量等于你的机器上的核心数量的两倍，这意味着你的程序不必为每个进程创建一个新的线程。这通常会带来更好的性能，因为你避免了与创建线程有关的开销。\n在这个例子中，进程(println (表达了 “当我从`echo-chan’那里得到一个消息时，打印它”。该进程被分流到另一个线程，释放了当前线程，使你能够继续与 REPL 交互。\n在表达式(中，是take函数。它监听你给它作为参数的通道，它所属的进程等待，直到另一个进程在该通道上放出一个消息。当检索到一个值时，该值被返回并执行println表达式。\n表达式(!! echo-chan \"ketchup\")将字符串\"ketchup\"放到echo-chan上并返回true。当你把一个消息放在一个通道上时，该进程会阻塞，直到另一个进程接收该消息。在这种情况下，REPL 进程根本不需要等待，因为已经有一个进程在监听该通道，等待从该通道中获取信息。然而，如果你做了以下事情，你的 REPL 将无限期地阻塞。\n(!! (chan) \"mustard\") 你已经创建了一个新的通道，并在上面放了一些东西，但没有进程在监听这个通道。进程不仅仅是等待接收消息，他们也在等待他们放在通道上的消息被接收。\n缓冲 值得注意的是，前面的练习包含两个进程：你用go创建的进程和 REPL 进程。这些进程相互之间没有明确的知识，而且它们独立行动。\n让我们想象一下，这些过程发生在一个餐厅里。REPL 是番茄酱厨师，当他完成一个批次时，他大声说：“番茄酱！” 完全有可能的是，其他员工都在外面欣赏他们有机花园里最新的一批牛至，而厨师只是坐着等待，直到有人来取他的番茄酱。反过来说，“去 “的过程代表了其中一个工作人员，他正在耐心地等待着什么回应。可能是什么都没有发生，他只是无限期地等待，直到餐厅关门。\n这种情况似乎有点傻：哪个自尊心强的番茄酱厨师会在制作更多的番茄酱之前，只是坐等别人拿走他最新的一批番茄酱？为了避免这种悲剧的发生，你可以创建缓冲通道。\n(def echo-buffer (chan 2)) (!! echo-buffer \"ketchup\") ; = true (!! echo-buffer \"ketchup\") ; = true (!! echo-buffer \"ketchup\") ; This blocks because the channel buffer is full (小心评估最后一个(! ! echo-buffer \"ketchup\")，因为它将阻塞你的 REPL。如果你使用的是 Leiningen REPL，ctrl-C 会解除封锁）。\n在这种情况下，你已经创建了一个缓冲区大小为 2 的通道。这意味着你可以在通道上放两个值而不需要等待，但放第三个值意味着进程将等待，直到另一个进程从通道上取值。你还可以用sliding-buffer创建滑动缓冲区，它以先入先出的方式丢弃数值；用dropping-buffer创建丢弃缓冲区，它以后入先出的方式丢弃数值。这两种缓冲区都不会导致!!阻塞。\n通过使用缓冲区，番茄酱大师可以继续制作成批令人垂涎欲滴的番茄酱，而不必等待他的员工把它们带走。如果他使用普通的缓冲器，就像他有一个架子，可以把所有的番茄酱批次放在上面；一旦架子满了，他还得等待空间的打开。如果他用的是滑动缓冲器，当架子上的番茄酱满了，他就会把最旧的一批扔掉，把所有的番茄酱滑下来，然后把新的一批放到空出来的地方。如果是跌落式缓冲器，他就会把最新鲜的一批番茄酱从货架上打下来，然后把新的一批番茄酱放在那个空间里。\n缓冲区只是对核心模型的阐述：进程是独立的、并发执行的逻辑单元，对事件作出反应。你可以用 go 块来创建进程，并通过通道来沟通事件。\n堵塞和停车 你可能已经注意到，take 函数只使用了一个感叹号，而 put 函数!则使用了两个感叹号。事实上，put 和 take 都有一个感叹号和两个感叹号的种类。什么时候使用哪个？简单的答案是，你可以在 go 块内使用一个感叹号，但你必须在 go 块外使用两个感叹号。\n    Inside go block Outside go block     put ! or !! !!   take  or      这一切都归结为效率问题。因为 go 块使用一个固定大小的线程池，你可以创建 1000 个 go 进程，但只使用少量的线程。\n(def hi-chan (chan)) (doseq [n (range 1000)]) (go (! hi-chan (str \"hi \" n))))) 为了理解 Clojure 是如何做到这一点的，我们需要探索进程如何等待。等待是使用 core.async 进程的一个关键方面：我们已经确定，put会等待到另一个进程在同一通道上做take*，反之亦然。在这个例子中，1,000 个进程在等待另一个进程从 “hi-chan “中提取。\n有两种类型的等待。 停车和阻塞。阻塞是你熟悉的那种等待：一个线程停止执行，直到一个任务完成。通常这发生在你进行某种 I/O 操作的时候。这个线程仍然活着，但不做任何工作，所以如果你想让你的程序继续工作，你必须创建一个新的线程。在第 9 章中，你学到了如何用 “future “来做这件事。\n停车释放了线程，这样它就可以继续工作了。假设你有一个线程和两个进程，Process A 和 Process B，Process A 在线程上运行，然后等待放或取。Clojure 将进程 A 移出线程，并将进程 B 移到线程上。如果进程 B 开始等待，而进程 A 的 put 或 take 已经完成，那么 Clojure 将把进程 B 移出线程，把进程 A 放回线程上。停放允许多个进程的指令在一个线程上交错，类似于使用多个线程允许在一个核心上交错的方式。停放的实现并不重要；只需说它只在 go 块内实现，并且只在使用!和，或停放 put和停放 take时实现。!!和是停放的放和停放的取。\n线程 肯定有一些时候你会想使用阻塞而不是停放，比如你的进程要花很长时间才能放或取，在这些场合你应该使用线程。\n(thread (println (!! echo-chan \"mustard\") ; = true ; = mustard thread的行为几乎与future完全一样：它创建一个新的线程并在该线程上执行一个进程。与future'不同的是，thread’不是返回一个可以反推的对象，而是返回一个通道。当thread的进程停止时，该进程的返回值会被放在thread返回的通道上。\n(let [t (thread \"chili\") ] (\"chili\" 在这种情况下，进程不等待任何事件；相反，它立即停止。它的返回值是 “chili”，它被放在与t绑定的通道上。我们从t中获取，返回`“chili”。\n当你执行一个长期运行的任务时，你应该使用thread而不是 go block，原因是你不会堵塞你的线程池。想象一下，你正在运行四个进程，下载巨大的文件，保存它们，然后把文件的路径放在一个通道上。当这些进程在下载文件和保存这些文件时，Clojure 不能停放它们的线程。它只能在最后一步停放线程，即进程将文件的路径放在通道上时。因此，如果你的线程池只有四个线程，所有四个线程都将被用于下载，在其中一个下载完成之前，不允许其他进程运行。\ngo、thread、chan、、、!和!是你用来创建和与进程通信的核心工具。put 和 take 都会使一个进程等待，直到它的补码在给定的通道上被执行。go允许你使用 put 和 take 的停车变体，这可以提高性能。如果你在 put 和 take 之前执行长期运行的任务，你应该使用阻塞式变体，以及thread。\n这应该能满足你的一切需求，让你实现你的心愿，创造一台把钱变成热狗的机器。\n你一直渴望的热狗机过程 看哪，你的梦想成真了!\n(defn hot-dog-machine [] (let [in (chan) out (chan)] (go (! out \"hot dog\")) [in out])) 这个函数创建了一个in通道用于接收钱，一个out通道用于发放热狗。然后用go创建一个异步进程，等待钱，然后发放热狗。最后，它将in和out通道作为一个 Vector 返回。\n是时候吃热狗了!\n(let [[in out] (hot-dog-machine)] (!! in \"pocket lint\") (\"hot dog\" 在这个片段中，你用 destructuring（在第三章中讲到）和let将in和out通道绑定到in和out符号。然后你把 “pocket lint “放在 “in “通道上。热狗机器进程等待着一些东西，任何东西，到达in通道；一旦\"pocket lint\"到达，热狗机器进程恢复执行，将\"hot dog\"放在out通道上。\n等一下……这不对。我的意思是，是的，免费的热狗，但是一定会有人因为机器接受小棉絮作为付款而不高兴。不仅如此，这台机器在关闭前只能发放一个热狗。让我们改变热狗机的功能，让你可以指定它有多少个热狗，并且当你给它数字 3 时，它才会发放一个热狗。\n(defn hot-dog-machine-v2 [hot-dog-count] (let [in (chan) out (chan)] (go (loop [hc hot-dog-count] (if ( hc 0) (let [input (! out \"hot dog\") (recur (dec hc))) (do (! out \"wilted lettuce\") (recur hc)))) ➋(do (close! in) (close! out))))) [in out])) 这里有很多代码，但策略是直接的。新函数hot-dog-machine-v2允许你指定hot-dog-count。在➊的 go 块内，只有当数字 3（意思是三块钱）被放在`in’通道上时，它才会派发热狗；否则，它派发枯萎的生菜，这绝对不是热狗。一旦一个进程采取了输出，热狗机进程就会带着更新的热狗数量循环回来，并准备再次接收钱。\n当机器进程的热狗用完时，该进程就会在➋处关闭通道。当你关闭一个通道时，你就不能再对它执行 put，而且一旦你从一个关闭的通道上取走所有的值，任何后续的取值都将返回 “nil”。\n让我们来试试清单 11-1 中的升级版热狗机，把钱和口袋里的棉絮放进去。\n(let [[in out] (hot-dog-machine-v2 2)] (!! in \"pocket lint\") (println (!! in 3) (println (!! in 3) (println (!! in 3) (wilted lettuce ; = hotdog ; = hotdog ; = nil  清单 11-1. 与一个健壮的热狗售货机进程交互  首先，我们尝试了 “口袋里的棉絮 “这一招，得到了打蔫的生菜。接下来，我们两次投入 3 美元，两次都得到一个热狗。然后，我们试图再投入 3 美元，但这被忽略了，因为通道已经关闭；数字 3 没有被放在通道上。当我们试图从 “出 “通道取钱时，我们得到的是 “零”，这也是因为该通道是关闭的。你可能会注意到hot-dog-machine-v2的几个有趣的细节。首先，它在同一个 go 块中做了一个 put 和一个 take。这并不罕见，这也是创建进程管道的一种方法：只要让一个进程的入通道成为另一个进程的出*通道。下面的例子就是这样做的，把一个字符串通过一系列的进程进行转换，直到最后一个进程打印出这个字符串。\n(let [c1 (chan) c2 (chan) c3 (chan)] (go (! c2 (clojure.string/upper-case (! c3 (clojure.string/reverse (!! c1 \"redrum\")) ; = MURDER 在本章的最后，我将会有更多关于进程管道以及如何使用它们来代替回调的内容。\n回到清单 11-1! 另一件需要注意的事情是，热狗机在你处理完它所发放的东西之前，不会接受更多的钱。这允许你建立类似于状态机的行为模型，其中通道操作的完成会触发状态转换。例如，你可以认为自动售货机有两个状态。准备接收钱和发放物品*。插入钱和取走物品会触发这两者之间的转换。\nalts core.async 函数alts!!可以让你使用一个操作集合中第一个成功的通道操作的结果。我们在第 198 页的 “延迟 “中用延迟和 Future 做了类似的事情。在那个例子中，我们把一组头像上传到一个头像分享网站，并在第一张照片上传时通知头像所有者。下面是你如何用alts!!做同样的事情。\n(defn upload [headshot c] (go (Thread/sleep (rand 100)) (! c headshot))) ➊ (let [c1 (chan) c2 (chan) c3 (chan)] (upload \"serious.jpg\" c1) (upload \"fun.jpg\" c2) (upload \"sassy.jpg\" c3) ➋ (let [[headshot channel] (alts!! [c1 c2 c3])] (println \"Sending headshot notification for\" headshot))) ; = Sending headshot notification for sassy.jpg 在这里，upload函数接收一个头像和一个频道，并创建一个新的进程，该进程将随机睡眠一段时间（模拟上传），然后将头像放到频道上。从➊开始的let绑定和upload函数调用应该是有意义的：我们创建了三个通道，然后用它们来执行上传。\n事情在➋处变得有趣。alts!!函数需要一个通道的 Vector 作为其参数。这就好比说，“试着在这些通道上同时做一个阻塞性的拍摄。一旦取值成功，返回一个 Vector，其第一个元素是取值，第二个元素是获胜的通道”。在这个例子中，与sassy.jpg相关的通道首先收到了一个值。如果你想获取它们的值并对它们进行处理，其他通道仍然可用。alts!!所做的只是从第一个有值的通道中获取一个值；它并不触及其他通道。\nalts!!的一个很酷的方面是，你可以给它一个timeout 通道，它等待指定的毫秒数，然后关闭。这是一个优雅的机制，可以为并发操作设置一个时间限制。下面是你如何在上传服务中使用它。\n(let [c1 (chan)] (upload \"serious.jpg\" c1) (let [[headshot channel] (alts!! [c1 (timeout 20)])] (if headshot (println \"Sending headshot notification for\" headshot) (println \"Timed out!\")))) ; = Timed out! 在这种情况下，我们将超时设置为 20 毫秒。因为上传没有在这个时间段完成，我们得到了一个超时消息。\n你也可以使用alts!!来指定 put 操作。要做到这一点，在你传递给alts!!的 Vector 内放置一个 Vector，就像本例中的➊。\n(let [c1 (chan) c2 (chan)] (go (true ; = true 这里你创建了两个通道，然后创建了一个进程，等待对c2进行处理。你提供给alts!!的 Vector 告诉它，“尝试对c1'进行取舍，并尝试将“put!\"放在c2’上。如果在c1上的取值首先完成，返回其值和通道。如果在c2上的投放先完成，如果投放成功，返回true，否则返回false。” 最后，value的结果（是true，因为c2的通道是开放的）打印出来，显示返回的通道确实是c2。\n像和!!一样，alts!!有一个停车的选择，alts!，你可以在 go 块中使用它。 alts!是一个很好的方法，可以对一组通道中的哪一个进行投入或取出的选择。它仍然执行放和取，所以使用停放或阻塞变量的理由同样适用。\n这就涵盖了 core.async 的基础知识! 本章的其余部分解释了协调进程的两种常见模式。\n队列 在第 202 页的 “滚动你自己的队列 “中，你写了一个宏，让你对 Future 进行排队。进程让你以一种更直接的方式使用类似的技术。假设你想从一个网站上获得一堆随机的报价，并把它们写到一个文件中。你想确保每次只有一个报价被写入文件，这样文本就不会被交错，所以你把你的报价放在一个队列中。下面是完整的代码。\n(defn append-to-file \"Write a string to the end of a file\" [filename s] (spit filename s :append true)) (defn format-quote \"Delineate the beginning and end of a quote because it's convenient\" [quote] (str \"=== BEGIN QUOTE ===\\n\" quote \"=== END QUOTE ===\\n\\n\")) (defn random-quote \"Retrieve a random quote and format it\" [] (format-quote (slurp \"http://www.braveclojure.com/random-quote\"))) (defn snag-quotes [filename num-quotes] (let [c (chan)] (go (while true (append-to-file filename (! c (random-quote)))))) 函数append-to-file、format-quote和random-quote有文档说明它们的作用。snag-quotes是发生有趣工作的地方。首先，它创建一个通道，在产生报价的进程和消费报价的进程之间共享。然后，它创建了一个使用 “while true “来创建一个无限循环的进程。在循环的每一次迭代中，它等待一个报价到达c，然后将其追加到一个文件中。最后，snag-quotes创建一个num-quotes数量的进程来获取一个引号，然后把它放在c上。如果你评估(snag-quotes \"quotes\" 2)并检查你启动 REPL 的目录中的quotes文件，它应该有两个引号。\n=== BEGIN QUOTE === Nobody's gonna believe that computers are intelligent until they start coming in late and lying about it. === END QUOTE === === BEGIN QUOTE === Give your child mental blocks for Christmas. === END QUOTE === 这种排队方式与第 9 章中的例子不同。在那个例子中，每个任务都是按照其创建的顺序来处理的。在这里，每个获取报价的任务是按照它完成的顺序来处理的。在这两种情况下，你都要确保每次只有一个报价被写入文件。\n用进程管道逃离回调地狱 在没有通道的语言中，你需要用 “回调 “来表达 “当x发生时，做y“的想法。在像 JavaScript 这样的语言中，回调是一种定义代码的方式，一旦其他代码完成就会异步执行。如果你使用过 JavaScript，你可能已经花了一些时间在回调地狱中沉溺。\n它被称为回调地狱的原因是，在回调层之间很容易产生不明显的依赖关系。它们最终会共享状态，使得在回调被触发时很难推理整个系统的状态。你可以通过创建一个流程管道来避免这种令人沮丧的结果。这样一来，每个逻辑单元都生活在自己独立的进程中，逻辑单元之间的所有通信都通过明确定义的输入和输出通道进行。\n在下面的例子中，我们创建了三个通过通道连接的无限循环进程，将一个进程的输出通道作为管道中下一个进程的输入通道。\n(defn upper-caser [in］ (let [out (chan)] (让 [out (chan)]) (go (while true (! out (clojure.string/upper-case (! (go (while true (! out (clojure.string/reverse (！！in-chan \"redrum\") ; = MURDER (!! in-chan \"repaid\") ; = DIAPER 通过使用这样的流程处理事件，推理整个数据转换系统的各个步骤就更容易了。你可以查看每个步骤并理解它的作用，而不必参考之前可能发生的事情或之后可能发生的事情；每个过程就像一个纯函数一样容易推理。\n额外资源 Clojure 的 core.async 库在很大程度上受到 Go 的并发模型的启发，它是基于 Tony Hoare 在Communicating Sequential Processes中的工作，可在*http://www.usingcsp.com/。*\nGo 的共同创造者 Rob Pike 有一个很好的关于并发的演讲，可在*Google I/O 2012 - Go 并发模式 - YouTube*。\nClojureScript，也被称为浏览器的最佳选择，使用 core.async。不再有回调的地狱! 你可以在*https://github.com/clojure/clojurescript*了解 ClojureScript 的情况。\n最后，在*clojure.core.async - core.async 1.2.599-SNAPSHOT API documentation*查看 API 文档。\n总结 在本章中，你了解了 core.async 如何允许你创建并发进程，以响应通道上的 put 和 take 通信事件。你了解了如何使用go和thread来创建并发进程，通过停放和阻塞来等待通信事件。你还学习了如何通过使一个进程的出通道成为另一个进程的入通道来创建进程管道，以及这如何使你写的代码比嵌套回调更容易理解。最后，你思考了你是否只是一台花哨的热狗售货机。\n","wordCount":"902","inLanguage":"en","image":"https://zhenfeng-zhu.github.io/posts/chapter11/https:/raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201152206174.png","datePublished":"2022-01-15T12:56:01+08:00","dateModified":"2022-01-15T12:56:01+08:00","author":{"@type":"Person","name":"Fenix"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhenfeng-zhu.github.io/posts/chapter11/"},"publisher":{"@type":"Organization","name":"Awesome Fenix","logo":{"@type":"ImageObject","url":"https://zhenfeng-zhu.github.io/favicon.ico"}}}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8502076734034112" crossorigin=anonymous></script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhenfeng-zhu.github.io accesskey=h title="Awesome Fenix (Alt + H)">Awesome Fenix</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://zhenfeng-zhu.github.io/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/about title=About>
<span>About</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/search/ title=🔍>
<span>🔍</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://zhenfeng-zhu.github.io>Home</a>&nbsp;»&nbsp;<a href=https://zhenfeng-zhu.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Chapter11 core.async
</h1>
<div class=post-meta><span title="2022-01-15 12:56:01 +0800 +0800">January 15, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Fenix&nbsp;|&nbsp;<a href=https://github.com/zhenfeng-zhu/zhenfeng-zhu.github.io/tree/main/content/posts/Chapter11.md rel="noopener noreferrer" target=_blank>修改本文章</a>
</div>
</header>
<figure class=entry-cover><img loading=lazy src=https://raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201152206174.png alt>
<p></p>
</figure><div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e7%94%a8-coreasync-%e6%8e%8c%e6%8f%a1%e5%b9%b6%e5%8f%91%e8%bf%9b%e7%a8%8b aria-label="用 core.async 掌握并发进程">用 core.async 掌握并发进程</a><ul>
<li>
<a href=#%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%85%a5%e9%97%a8 aria-label=进程的入门>进程的入门</a><ul>
<li>
<a href=#%e7%bc%93%e5%86%b2 aria-label=缓冲>缓冲</a></li>
<li>
<a href=#%e5%a0%b5%e5%a1%9e%e5%92%8c%e5%81%9c%e8%bd%a6 aria-label=堵塞和停车>堵塞和停车</a></li>
<li>
<a href=#%e7%ba%bf%e7%a8%8b aria-label=线程>线程</a></li></ul>
</li>
<li>
<a href=#%e4%bd%a0%e4%b8%80%e7%9b%b4%e6%b8%b4%e6%9c%9b%e7%9a%84%e7%83%ad%e7%8b%97%e6%9c%ba%e8%bf%87%e7%a8%8b aria-label=你一直渴望的热狗机过程>你一直渴望的热狗机过程</a></li>
<li>
<a href=#alts aria-label=alts>alts</a></li>
<li>
<a href=#%e9%98%9f%e5%88%97 aria-label=队列>队列</a></li>
<li>
<a href=#%e7%94%a8%e8%bf%9b%e7%a8%8b%e7%ae%a1%e9%81%93%e9%80%83%e7%a6%bb%e5%9b%9e%e8%b0%83%e5%9c%b0%e7%8b%b1 aria-label=用进程管道逃离回调地狱>用进程管道逃离回调地狱</a></li>
<li>
<a href=#%e9%a2%9d%e5%a4%96%e8%b5%84%e6%ba%90 aria-label=额外资源>额外资源</a></li>
<li>
<a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=用-coreasync-掌握并发进程>用 core.async 掌握并发进程<a hidden class=anchor aria-hidden=true href=#用-coreasync-掌握并发进程>#</a></h1>
<p>有一天，当你走在大街上时，你会惊讶、好奇，并有点厌恶地发现一台热狗自动贩卖机。你的头皮被有罪的好奇心刺痛，你会忍不住掏出三块钱，看看这个装置是否真的能工作。在 &ldquo;咔嚓 &ldquo;一声接受了你的钱后，它弹出了一个新鲜的热狗，包括面包和所有的东西。</p>
<p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/core-async/hotdog-vending-machine.png alt>
</p>
<p>自动售货机表现出简单的行为：当它收到钱时，它会放出一个热狗，然后为下一次购买做准备。当它的热狗用完时，它就会停止。我们周围的热狗自动售货机以不同的面貌出现，它们是独立的实体，同时对世界上的事件作出反应。你最喜欢的咖啡店的浓缩咖啡机，你小时候喜欢的宠物仓鼠&ndash;所有的东西都可以被分解成一组行为，这些行为遵循一般的形式 &ldquo;当<em>x</em>发生时，做<em>y</em>"。甚至我们写的程序也只是美化的热狗贩卖机，每一个都是独立的进程，等待着下一个事件的发生，无论是击键、超时，还是套接字上的数据到达。</p>
<p>Clojure 的 core.async 库允许你在一个程序中创建多个独立进程。 本章描述了思考这种编程风格的有用模型，以及你在实际编写代码时需要了解的实际细节。你将学习如何使用通道在由 go 块和<code>thread</code>创建的独立进程之间进行通信；了解一些关于 Clojure 如何通过停放和阻塞有效地管理线程；如何使用<code>alts!!</code>；以及一种更直接的创建队列的方法。最后，你将学习如何用进程管道来踢回调的屁股。</p>
<h2 id=进程的入门>进程的入门<a hidden class=anchor aria-hidden=true href=#进程的入门>#</a></h2>
<p>core.async 的核心是*进程，一个并发运行的逻辑单元，对事件做出反应。进程对应于我们对现实世界的心理模型：实体之间的互动和响应是独立的，没有某种中央控制机制的牵制。你把钱放进机器里，就会有一个热狗出来，所有这些都不需要光照派或老大哥来策划整个事情。这与你迄今为止一直在探索的并发性观点不同，在那里，你定义的任务要么只是控制主线程的扩展（例如，用<code>pmap</code>实现数据并行），要么是你没有兴趣与之交流的任务（如用<code>future</code>创建的一次性任务）。</p>
<p>把自动售货机看成是一个进程可能很奇怪：自动售货机是名词和事物，而进程是动词和行为。为了获得正确的思维方式，可以尝试将现实世界的物体定义为其事件驱动的行为的总和。当一粒种子被浇水时，它就会发芽；当母亲看着她的新生儿时，她就会感受到爱；而当你观看《<em>星</em>战》第一集时，你会充满愤怒和绝望。如果你想变得超级哲学，可以考虑是否有可能将每个事物的本质定义为它所识别的事件的集合，以及它如何做出反应。现实是否只是热狗售卖机的组成？</p>
<p>总之，我说得够多了! 让我们通过创建一些简单的过程，从理论上走向具体。首先，用 &ldquo;lein new app playsync &ldquo;创建一个新的 Leiningen 项目，名为<em>playsync</em>。然后，打开<em>project.clj</em>文件，将 core.async 添加到<code>:dependencies</code>Vector 中，使其内容如下。</p>
<pre tabindex=0><code>[[org.clojure/clojure &quot;1.9.0&quot;]
[org.clojure/core.async &quot;0.1.346.0-17112a-alpha&quot;]]
</code></pre><p>注意 自从我写完这篇文章后，core.async 的版本有可能有所进步。关于最新的版本，请查看 core.async 的 GitHub 项目页面。但为了这些练习的目的，请使用这里列出的版本。</p>
<p>接下来，打开<em>src/playsync/core.clj</em>，使其看起来像这样。</p>
<pre tabindex=0><code>(ns playsync.core
  (:require [clojure.core.async
             :as a
             :refer [&gt;! &lt;! &gt;!! &lt;!! go chan buffer close! thread
                     alts! alts!! timeout]]))
</code></pre><p>现在，当你在 REPL 中打开它时，你将拥有最常用的 core.async 函数供你使用。很好! 在创建像热狗售卖机那样复杂和革命性的东西之前，先创建一个进程，简单地打印它收到的消息。</p>
<pre tabindex=0><code>(def echo-chan (chan))
(go (println (&lt;! echo-chan)))
(&gt;!! echo-chan &quot;ketchup&quot;)
; =&gt; true
; =&gt; ketchup
</code></pre><p>在第一行代码中，你用<code>chan</code>函数创建了一个名为<code>echo-chan</code>的<em>通道。通道传达</em>消息*。你可以把<em>消息放到一个通道上，也可以把</em>消息从一个通道上拿下来。进程<em>等待</em>放和取的完成&ndash;这些是进程所响应的事件。你可以认为进程有两个规则。1）当试图把一个消息放到通道上或从通道上取走一个消息时，等待并不做任何事情，直到放或取成功；2）当放或取成功时，继续执行。</p>
<p>在下一行，你用<code>go</code>来创建一个新的进程。<code>go</code>表达式中的所有内容都被称为<em>go 块</em>，在一个单独的线程上并发运行。Go 块在一个线程池上运行你的进程，该线程池包含的线程数量等于你的机器上的核心数量的两倍，这意味着你的程序不必为每个进程创建一个新的线程。这通常会带来更好的性能，因为你避免了与创建线程有关的开销。</p>
<p>在这个例子中，进程<code>(println (&lt;! echo-chan))</code>表达了 &ldquo;当我从`echo-chan&rsquo;那里得到一个消息时，打印它&rdquo;。该进程被分流到另一个线程，释放了当前线程，使你能够继续与 REPL 交互。</p>
<p>在表达式<code>(&lt;! echo-chan)</code>中，<code>&lt;!</code>是<em>take</em>函数。它监听你给它作为参数的通道，它所属的进程等待，直到另一个进程在该通道上放出一个消息。当<code>&lt;!</code>检索到一个值时，该值被返回并执行<code>println</code>表达式。</p>
<p>表达式<code>(>!! echo-chan "ketchup")</code>将字符串<code>"ketchup"</code>放到<code>echo-chan</code>上并返回<code>true</code>。当你把一个消息放在一个通道上时，该进程会阻塞，直到另一个进程接收该消息。在这种情况下，REPL 进程根本不需要等待，因为已经有一个进程在监听该通道，等待从该通道中获取信息。然而，如果你做了以下事情，你的 REPL 将无限期地阻塞。</p>
<pre tabindex=0><code>(&gt;!! (chan) &quot;mustard&quot;)
</code></pre><p>你已经创建了一个新的通道，并在上面放了一些东西，但没有进程在监听这个通道。进程不仅仅是等待接收消息，他们也在等待他们放在通道上的消息被接收。</p>
<h3 id=缓冲>缓冲<a hidden class=anchor aria-hidden=true href=#缓冲>#</a></h3>
<p>值得注意的是，前面的练习包含<em>两个</em>进程：你用<code>go</code>创建的进程和 REPL 进程。这些进程相互之间没有明确的知识，而且它们独立行动。</p>
<p>让我们想象一下，这些过程发生在一个餐厅里。REPL 是番茄酱厨师，当他完成一个批次时，他大声说：&ldquo;番茄酱！&rdquo; 完全有可能的是，其他员工都在外面欣赏他们有机花园里最新的一批牛至，而厨师只是坐着等待，直到有人来取他的番茄酱。反过来说，&ldquo;去 &ldquo;的过程代表了其中一个工作人员，他正在耐心地等待着什么回应。可能是什么都没有发生，他只是无限期地等待，直到餐厅关门。</p>
<p>这种情况似乎有点傻：哪个自尊心强的番茄酱厨师会在制作更多的番茄酱之前，只是坐等别人拿走他最新的一批番茄酱？为了避免这种悲剧的发生，你可以创建缓冲通道。</p>
<pre tabindex=0><code>(def echo-buffer (chan 2))
(&gt;!! echo-buffer &quot;ketchup&quot;)
; =&gt; true
(&gt;!! echo-buffer &quot;ketchup&quot;)
; =&gt; true
(&gt;!! echo-buffer &quot;ketchup&quot;)
; This blocks because the channel buffer is full
</code></pre><p>(小心评估最后一个<code>(>! ! echo-buffer "ketchup")</code>，因为它将阻塞你的 REPL。如果你使用的是 Leiningen REPL，ctrl-C 会解除封锁）。</p>
<p>在这种情况下，你已经创建了一个缓冲区大小为 2 的通道。这意味着你可以在通道上放两个值而不需要等待，但放第三个值意味着进程将等待，直到另一个进程从通道上取值。你还可以用<code>sliding-buffer</code>创建<em>滑动</em>缓冲区，它以先入先出的方式丢弃数值；用<code>dropping-buffer</code>创建<em>丢弃</em>缓冲区，它以后入先出的方式丢弃数值。这两种缓冲区都不会导致<code>>!!</code>阻塞。</p>
<p>通过使用缓冲区，番茄酱大师可以继续制作成批令人垂涎欲滴的番茄酱，而不必等待他的员工把它们带走。如果他使用普通的缓冲器，就像他有一个架子，可以把所有的番茄酱批次放在上面；一旦架子满了，他还得等待空间的打开。如果他用的是滑动缓冲器，当架子上的番茄酱满了，他就会把最旧的一批扔掉，把所有的番茄酱滑下来，然后把新的一批放到空出来的地方。如果是跌落式缓冲器，他就会把最新鲜的一批番茄酱从货架上打下来，然后把新的一批番茄酱放在那个空间里。</p>
<p>缓冲区只是对核心模型的阐述：进程是独立的、并发执行的逻辑单元，对事件作出反应。你可以用 go 块来创建进程，并通过通道来沟通事件。</p>
<h3 id=堵塞和停车>堵塞和停车<a hidden class=anchor aria-hidden=true href=#堵塞和停车>#</a></h3>
<p>你可能已经注意到，take 函数<code>&lt;!</code>只使用了一个感叹号，而 put 函数<code>>!</code>则使用了两个感叹号。事实上，put 和 take 都有一个感叹号和两个感叹号的种类。什么时候使用哪个？简单的答案是，你可以在 go 块内使用一个感叹号，但你必须在 go 块外使用两个感叹号。</p>
<table>
<thead>
<tr>
<th></th>
<th>Inside go block</th>
<th>Outside go block</th>
</tr>
</thead>
<tbody>
<tr>
<td>put</td>
<td><code>>!</code> or <code>>!!</code></td>
<td><code>>!!</code></td>
</tr>
<tr>
<td>take</td>
<td><code>&lt;!</code> or <code>&lt;!!</code></td>
<td><code>&lt;!!</code></td>
</tr>
</tbody>
</table>
<p>这一切都归结为效率问题。因为 go 块使用一个固定大小的线程池，你可以创建 1000 个 go 进程，但只使用少量的线程。</p>
<pre tabindex=0><code>(def hi-chan (chan))
(doseq [n (range 1000)])
  (go (&gt;! hi-chan (str &quot;hi &quot; n)))))
</code></pre><p>为了理解 Clojure 是如何做到这一点的，我们需要探索进程如何<em>等待。等待是使用 core.async 进程的一个关键方面：我们已经确定，<em>put</em>会等待到另一个进程在同一通道上做</em>take*，反之亦然。在这个例子中，1,000 个进程在等待另一个进程从 &ldquo;hi-chan &ldquo;中提取。</p>
<p>有两种类型的等待。 <em>停车</em>和<em>阻塞</em>。阻塞是你熟悉的那种等待：一个线程停止执行，直到一个任务完成。通常这发生在你进行某种 I/O 操作的时候。这个线程仍然活着，但不做任何工作，所以如果你想让你的程序继续工作，你必须创建一个新的线程。在第 9 章中，你学到了如何用 &ldquo;future &ldquo;来做这件事。</p>
<p>停车释放了线程，这样它就可以继续工作了。假设你有一个线程和两个进程，Process A 和 Process B，Process A 在线程上运行，然后等待放或取。Clojure 将进程 A 移出线程，并将进程 B 移到线程上。如果进程 B 开始等待，而进程 A 的 put 或 take 已经完成，那么 Clojure 将把进程 B 移出线程，把进程 A 放回线程上。停放允许多个进程的指令在一个线程上交错，类似于使用多个线程允许在一个核心上交错的方式。停放的实现并不重要；只需说它只在 go 块内实现，并且只在使用<code>>!</code>和<code>&lt;!</code>，或<em>停放 put</em>和<em>停放 take</em>时实现。<code>>!!</code>和<code>&lt;!!</code>是<em>停放的放</em>和<em>停放的取</em>。</p>
<h3 id=线程>线程<a hidden class=anchor aria-hidden=true href=#线程>#</a></h3>
<p>肯定有一些时候你会想使用阻塞而不是停放，比如你的进程要花很长时间才能放或取，在这些场合你应该使用<code>线程</code>。</p>
<pre tabindex=0><code>(thread (println (&lt;!! echo-chan)))
(&gt;!! echo-chan &quot;mustard&quot;)
; =&gt; true
; =&gt; mustard
</code></pre><p><code>thread</code>的行为几乎与<code>future</code>完全一样：它创建一个新的线程并在该线程上执行一个进程。与<code>future'不同的是，</code>thread&rsquo;不是返回一个可以反推的对象，而是返回一个通道。当<code>thread</code>的进程停止时，该进程的返回值会被放在<code>thread</code>返回的通道上。</p>
<pre tabindex=0><code>(let [t (thread &quot;chili&quot;) ]
  (&lt;!! t))
; =&gt; &quot;chili&quot;
</code></pre><p>在这种情况下，进程不等待任何事件；相反，它立即停止。它的返回值是 &ldquo;chili&rdquo;，它被放在与<code>t绑定的通道上。</code>我们从<code>t</code>中获取，返回`&ldquo;chili&rdquo;。</p>
<p>当你执行一个长期运行的任务时，你应该使用<code>thread</code>而不是 go block，原因是你不会堵塞你的线程池。想象一下，你正在运行四个进程，下载巨大的文件，保存它们，然后把文件的路径放在一个通道上。当这些进程在下载文件和保存这些文件时，Clojure 不能停放它们的线程。它只能在最后一步停放线程，即进程将文件的路径放在通道上时。因此，如果你的线程池只有四个线程，所有四个线程都将被用于下载，在其中一个下载完成之前，不允许其他进程运行。</p>
<p><code>go</code>、<code>thread</code>、<code>chan</code>、<code>&lt;!</code>、<code>&lt;!</code>、<code>>!</code>和<code>>!</code>是你用来创建和与进程通信的核心工具。put 和 take 都会使一个进程等待，直到它的补码在给定的通道上被执行。<code>go</code>允许你使用 put 和 take 的停车变体，这可以提高性能。如果你在 put 和 take 之前执行长期运行的任务，你应该使用阻塞式变体，以及<code>thread</code>。</p>
<p>这应该能满足你的一切需求，让你实现你的心愿，创造一台把钱变成热狗的机器。</p>
<h2 id=你一直渴望的热狗机过程>你一直渴望的热狗机过程<a hidden class=anchor aria-hidden=true href=#你一直渴望的热狗机过程>#</a></h2>
<p>看哪，你的梦想成真了!</p>
<pre tabindex=0><code>(defn hot-dog-machine
  []
  (let [in (chan)
        out (chan)]
    (go (&lt;! in)
        (&gt;! out &quot;hot dog&quot;))
    [in out]))
</code></pre><p>这个函数创建了一个<code>in</code>通道用于接收钱，一个<code>out</code>通道用于发放热狗。然后用<code>go</code>创建一个异步进程，等待钱，然后发放热狗。最后，它将<code>in</code>和<code>out</code>通道作为一个 Vector 返回。</p>
<p>是时候吃热狗了!</p>
<pre tabindex=0><code>(let [[in out] (hot-dog-machine)]
  (&gt;!! in &quot;pocket lint&quot;)
  (&lt;!! out))
; =&gt; &quot;hot dog&quot;
</code></pre><p>在这个片段中，你用 destructuring（在第三章中讲到）和<code>let</code>将<code>in</code>和<code>out</code>通道绑定到<code>in</code>和<code>out</code>符号。然后你把 &ldquo;pocket lint &ldquo;放在 &ldquo;in &ldquo;通道上。热狗机器进程等待着一些东西，任何东西，到达<code>in</code>通道；一旦<code>"pocket lint"</code>到达，热狗机器进程恢复执行，将<code>"hot dog"</code>放在<code>out</code>通道上。</p>
<p>等一下……这不对。我的意思是，是的，免费的热狗，但是一定会有人因为机器接受小棉絮作为付款而不高兴。不仅如此，这台机器在关闭前只能发放一个热狗。让我们改变热狗机的功能，让你可以指定它有多少个热狗，并且当你给它数字 3 时，它才会发放一个热狗。</p>
<pre tabindex=0><code>(defn hot-dog-machine-v2
  [hot-dog-count]
  (let [in (chan)
        out (chan)]
    (go (loop [hc hot-dog-count]
          (if (&gt; hc 0)
            (let [input (&lt;! in)]
             ➊(if (= 3 input)
                (do (&gt;! out &quot;hot dog&quot;)
                    (recur (dec hc)))
                (do (&gt;! out &quot;wilted lettuce&quot;)
                    (recur hc))))
           ➋(do (close! in)
                (close! out)))))
    [in out]))

</code></pre><p>这里有很多代码，但策略是直接的。新函数<code>hot-dog-machine-v2</code>允许你指定<code>hot-dog-count</code>。在➊的 go 块内，只有当数字 3（意思是三块钱）被放在`in&rsquo;通道上时，它才会派发热狗；否则，它派发枯萎的生菜，这绝对不是热狗。一旦一个进程采取了输出，热狗机进程就会带着更新的热狗数量循环回来，并准备再次接收钱。</p>
<p>当机器进程的热狗用完时，该进程就会在➋处<em>关闭</em>通道。当你关闭一个通道时，你就不能再对它执行 put，而且一旦你从一个关闭的通道上取走所有的值，任何后续的取值都将返回 &ldquo;nil&rdquo;。</p>
<p>让我们来试试清单 11-1 中的升级版热狗机，把钱和口袋里的棉絮放进去。</p>
<pre tabindex=0><code>(let [[in out] (hot-dog-machine-v2 2)]
  (&gt;!! in &quot;pocket lint&quot;)
  (println (&lt;!! out))

  (&gt;!! in 3)
  (println (&lt;!! out))

  (&gt;!! in 3)
  (println (&lt;!! out))

  (&gt;!! in 3)
  (&lt;!! out))
; =&gt; wilted lettuce
; =&gt; hotdog
; =&gt; hotdog
; =&gt; nil
</code></pre><ol>
<li>清单 11-1. 与一个健壮的热狗售货机进程交互</li>
</ol>
<p>首先，我们尝试了 &ldquo;口袋里的棉絮 &ldquo;这一招，得到了打蔫的生菜。接下来，我们两次投入 3 美元，两次都得到一个热狗。然后，我们试图再投入 3 美元，但这被忽略了，因为通道已经关闭；数字 3 没有被放在通道上。当我们试图从 &ldquo;出 &ldquo;通道取钱时，我们得到的是 &ldquo;零&rdquo;，这也是因为该通道是关闭的。你可能会注意到<code>hot-dog-machine-v2</code>的几个有趣的细节。首先，它在同一个 go 块中做了一个 put 和一个 take。这并不罕见，这也是创建进程<em>管道的一种方法：只要让一个进程的</em>入<em>通道成为另一个进程的</em>出*通道。下面的例子就是这样做的，把一个字符串通过一系列的进程进行转换，直到最后一个进程打印出这个字符串。</p>
<pre tabindex=0><code>(let [c1 (chan)
      c2 (chan)
      c3 (chan)]
  (go (&gt;! c2 (clojure.string/upper-case (&lt;! c1))))
  (go (&gt;! c3 (clojure.string/reverse (&lt;! c2))))
  (go (println (&lt;! c3)))
  (&gt;!! c1 &quot;redrum&quot;))
; =&gt; MURDER
</code></pre><p>在本章的最后，我将会有更多关于进程管道以及如何使用它们来代替回调的内容。</p>
<p>回到清单 11-1! 另一件需要注意的事情是，热狗机在你处理完它所发放的东西之前，不会接受更多的钱。这允许你建立类似于状态机的行为模型，其中通道操作的完成会触发状态转换。例如，你可以认为自动售货机有两个状态。<em>准备接收钱</em>和<em>发放</em>物品*。插入钱和取走物品会触发这两者之间的转换。</p>
<h2 id=alts>alts<a hidden class=anchor aria-hidden=true href=#alts>#</a></h2>
<p>core.async 函数<code>alts!!</code>可以让你使用一个操作集合中第一个成功的通道操作的结果。我们在第 198 页的 &ldquo;延迟 &ldquo;中用延迟和 Future 做了类似的事情。在那个例子中，我们把一组头像上传到一个头像分享网站，并在第一张照片上传时通知头像所有者。下面是你如何用<code>alts!!</code>做同样的事情。</p>
<pre tabindex=0><code>(defn upload
  [headshot c]
  (go (Thread/sleep (rand 100))
      (&gt;! c headshot)))

➊ (let [c1 (chan)
      c2 (chan)
      c3 (chan)]
  (upload &quot;serious.jpg&quot; c1)
  (upload &quot;fun.jpg&quot; c2)
  (upload &quot;sassy.jpg&quot; c3)
➋   (let [[headshot channel] (alts!! [c1 c2 c3])]
    (println &quot;Sending headshot notification for&quot; headshot)))
; =&gt; Sending headshot notification for sassy.jpg
</code></pre><p>在这里，<code>upload</code>函数接收一个头像和一个频道，并创建一个新的进程，该进程将随机睡眠一段时间（模拟上传），然后将头像放到频道上。从➊开始的<code>let</code>绑定和<code>upload</code>函数调用应该是有意义的：我们创建了三个通道，然后用它们来执行上传。</p>
<p>事情在➋处变得有趣。<code>alts!!</code>函数需要一个通道的 Vector 作为其参数。这就好比说，&ldquo;试着在这些通道上同时做一个阻塞性的拍摄。一旦取值成功，返回一个 Vector，其第一个元素是取值，第二个元素是获胜的通道&rdquo;。在这个例子中，与<em>sassy.jpg</em>相关的通道首先收到了一个值。如果你想获取它们的值并对它们进行处理，其他通道仍然可用。<code>alts!!</code>所做的只是从第一个有值的通道中获取一个值；它并不触及其他通道。</p>
<p><code>alts!!</code>的一个很酷的方面是，你可以给它一个<em>timeout 通道</em>，它等待指定的毫秒数，然后关闭。这是一个优雅的机制，可以为并发操作设置一个时间限制。下面是你如何在上传服务中使用它。</p>
<pre tabindex=0><code>(let [c1 (chan)]
  (upload &quot;serious.jpg&quot; c1)
  (let [[headshot channel] (alts!! [c1 (timeout 20)])]
    (if headshot
      (println &quot;Sending headshot notification for&quot; headshot)
      (println &quot;Timed out!&quot;))))
; =&gt; Timed out!
</code></pre><p>在这种情况下，我们将超时设置为 20 毫秒。因为上传没有在这个时间段完成，我们得到了一个超时消息。</p>
<p>你也可以使用<code>alts!!</code>来指定 put 操作。要做到这一点，在你传递给<code>alts!!</code>的 Vector 内放置一个 Vector，就像本例中的➊。</p>
<pre tabindex=0><code>(let [c1 (chan)
      c2 (chan)]
  (go (&lt;! c2))
➊   (let [[value channel] (alts!! [c1 [c2 &quot;put!&quot;]])]
    (println value)
    (= channel c2)))
; =&gt; true
; =&gt; true
</code></pre><p>这里你创建了两个通道，然后创建了一个进程，等待对<code>c2</code>进行处理。你提供给<code>alts!!</code>的 Vector 告诉它，&ldquo;尝试对<code>c1'进行取舍，并尝试将</code>&ldquo;put!"<code>放在</code>c2&rsquo;上。如果在<code>c1</code>上的取值首先完成，返回其值和通道。如果在<code>c2</code>上的投放先完成，如果投放成功，返回<code>true</code>，否则返回<code>false</code>。&rdquo; 最后，<code>value</code>的结果（是<code>true</code>，因为<code>c2</code>的通道是开放的）打印出来，显示返回的通道确实是<code>c2</code>。</p>
<p>像<code>&lt;!!</code>和<code>>!!</code>一样，<code>alts!!</code>有一个停车的选择，<code>alts!</code>，你可以在 go 块中使用它。 <code>alts!</code>是一个很好的方法，可以对一组通道中的哪一个进行投入或取出的选择。它仍然执行放和取，所以使用停放或阻塞变量的理由同样适用。</p>
<p>这就涵盖了 core.async 的基础知识! 本章的其余部分解释了协调进程的两种常见模式。</p>
<h2 id=队列>队列<a hidden class=anchor aria-hidden=true href=#队列>#</a></h2>
<p>在第 202 页的 &ldquo;滚动你自己的队列 &ldquo;中，你写了一个宏，让你对 Future 进行排队。进程让你以一种更直接的方式使用类似的技术。假设你想从一个网站上获得一堆随机的报价，并把它们写到一个文件中。你想确保每次只有一个报价被写入文件，这样文本就不会被交错，所以你把你的报价放在一个队列中。下面是完整的代码。</p>
<pre tabindex=0><code>(defn append-to-file
  &quot;Write a string to the end of a file&quot;
  [filename s]
  (spit filename s :append true))

(defn format-quote
  &quot;Delineate the beginning and end of a quote because it's convenient&quot;
  [quote]
  (str &quot;=== BEGIN QUOTE ===\n&quot; quote &quot;=== END QUOTE ===\n\n&quot;))

(defn random-quote
  &quot;Retrieve a random quote and format it&quot;
  []
  (format-quote (slurp &quot;http://www.braveclojure.com/random-quote&quot;)))

(defn snag-quotes
  [filename num-quotes]
  (let [c (chan)]
    (go (while true (append-to-file filename (&lt;! c))))
    (dotimes [n num-quotes] (go (&gt;! c (random-quote))))))
</code></pre><p>函数<code>append-to-file</code>、<code>format-quote</code>和<code>random-quote</code>有文档说明它们的作用。<code>snag-quotes</code>是发生有趣工作的地方。首先，它创建一个通道，在产生报价的进程和消费报价的进程之间共享。然后，它创建了一个使用 &ldquo;while true &ldquo;来创建一个无限循环的进程。在循环的每一次迭代中，它等待一个报价到达<code>c</code>，然后将其追加到一个文件中。最后，<code>snag-quotes</code>创建一个<code>num-quotes</code>数量的进程来获取一个引号，然后把它放在<code>c</code>上。如果你评估<code>(snag-quotes "quotes" 2)</code>并检查你启动 REPL 的目录中的<em>quotes</em>文件，它应该有两个引号。</p>
<pre tabindex=0><code>=== BEGIN QUOTE ===
Nobody's gonna believe that computers are intelligent until they start
coming in late and lying about it.
=== END QUOTE ===

=== BEGIN QUOTE ===
Give your child mental blocks for Christmas.
=== END QUOTE ===
</code></pre><p>这种排队方式与第 9 章中的例子不同。在那个例子中，每个任务都是按照其创建的顺序来处理的。在这里，每个获取报价的任务是按照它完成的顺序来处理的。在这两种情况下，你都要确保每次只有一个报价被写入文件。</p>
<h2 id=用进程管道逃离回调地狱>用进程管道逃离回调地狱<a hidden class=anchor aria-hidden=true href=#用进程管道逃离回调地狱>#</a></h2>
<p>在没有通道的语言中，你需要用 &ldquo;回调 &ldquo;来表达 &ldquo;当<em>x</em>发生时，做<em>y</em>&ldquo;的想法。在像 JavaScript 这样的语言中，回调是一种定义代码的方式，一旦其他代码完成就会异步执行。如果你使用过 JavaScript，你可能已经花了一些时间在<em>回调地狱</em>中沉溺。</p>
<p>它被称为回调地狱的原因是，在回调层之间很容易产生不明显的依赖关系。它们最终会共享状态，使得在回调被触发时很难推理整个系统的状态。你可以通过创建一个流程管道来避免这种令人沮丧的结果。这样一来，每个逻辑单元都生活在自己独立的进程中，逻辑单元之间的所有通信都通过明确定义的输入和输出通道进行。</p>
<p>在下面的例子中，我们创建了三个通过通道连接的无限循环进程，将一个进程的<em>输出</em>通道作为管道中下一个进程的<em>输入</em>通道。</p>
<pre tabindex=0><code>(defn upper-caser
  [in］
  (let [out (chan)] (让 [out (chan)])
    (go (while true (&gt;! out (clojure.string/upper-case (&lt;! in))))))
    out))

(defn reverser
  [in］
  (let [out (chan)] (go (while true (&gt;!
    (go (while true (&gt;! out (clojure.string/reverse (&lt;! in))))))
    out))

(defn printer
  [in］
  (go (while true (println (&lt;! in))))))

(def in-chan (chan))
(def upper-caser-out (upper-caser in-chan))
(def reverser-out (reverser upper-caser-out))
(Printer reverser-out)

(&gt;！！in-chan &quot;redrum&quot;)
; =&gt; MURDER

(&gt;!! in-chan &quot;repaid&quot;)
; =&gt; DIAPER
</code></pre><p>通过使用这样的流程处理事件，推理整个数据转换系统的各个步骤就更容易了。你可以查看每个步骤并理解它的作用，而不必参考之前可能发生的事情或之后可能发生的事情；每个过程就像一个纯函数一样容易推理。</p>
<h2 id=额外资源>额外资源<a hidden class=anchor aria-hidden=true href=#额外资源>#</a></h2>
<p>Clojure 的 core.async 库在很大程度上受到 Go 的并发模型的启发，它是基于 Tony Hoare 在<em>Communicating Sequential</em> <em>Processes</em>中的工作，可在*<a href=http://www.usingcsp.com/>http://www.usingcsp.com/</a>。*</p>
<p>Go 的共同创造者 Rob Pike 有一个很好的关于并发的演讲，可在*<a href="https://www.youtube.com/watch?v=f6kdp27TYZs">Google I/O 2012 - Go 并发模式 - YouTube</a>*。</p>
<p>ClojureScript，也被称为浏览器的最佳选择，使用 core.async。不再有回调的地狱! 你可以在*<a href=https://github.com/clojure/clojurescript%3C/span%3E>https://github.com/clojure/clojurescript</a>*了解 ClojureScript 的情况。</p>
<p>最后，在*<a href=http://clojure.github.io/core.async/>clojure.core.async - core.async 1.2.599-SNAPSHOT API documentation</a>*查看 API 文档。</p>
<h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2>
<p>在本章中，你了解了 core.async 如何允许你创建并发进程，以响应通道上的 put 和 take 通信事件。你了解了如何使用<code>go</code>和<code>thread</code>来创建并发进程，通过停放和阻塞来等待通信事件。你还学习了如何通过使一个进程的<em>出</em>通道成为另一个进程的<em>入</em>通道来创建进程管道，以及这如何使你写的代码比嵌套回调更容易理解。最后，你思考了你是否只是一台花哨的热狗售货机。</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://zhenfeng-zhu.github.io/tags/clojure/>clojure</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://zhenfeng-zhu.github.io/posts/chapter12/>
<span class=title>« Prev Page</span>
<br>
<span>Chapter12 与 Java 的互操作</span>
</a>
<a class=next href=https://zhenfeng-zhu.github.io/posts/chapter10/>
<span class=title>Next Page »</span>
<br>
<span>Chapter10 形而上学</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter11 core.async on twitter" href="https://twitter.com/intent/tweet/?text=Chapter11%20core.async&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter11%2f&hashtags=clojure"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter11 core.async on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter11%2f&title=Chapter11%20core.async&summary=Chapter11%20core.async&source=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter11%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter11 core.async on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter11%2f&title=Chapter11%20core.async"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter11 core.async on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter11%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter11 core.async on whatsapp" href="https://api.whatsapp.com/send?text=Chapter11%20core.async%20-%20https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter11%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter11 core.async on telegram" href="https://telegram.me/share/url?text=Chapter11%20core.async&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter11%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer><script src=https://utteranc.es/client.js repo=zhenfeng-zhu/zhenfeng-zhu.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://zhenfeng-zhu.github.io>Awesome Fenix</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>