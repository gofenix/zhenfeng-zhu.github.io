<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Chapter12 与 Java 的互操作 | Awesome Fenix</title>
<meta name=keywords content="clojure">
<meta name=description content="与 JVM 一起工作 在每个 Clojurist 的生命中都会有这么一天，她必须从纯函数和不可变数据结构的庇护所冒险进入野蛮的 Java 大陆。这段艰难的旅程是必要的，因为 Clojure 是在 Java 虚拟机（JVM）上托管的，这赋予了它三个基本特性。
赋予它三个基本特征。首先，你运行 Clojure 应用程序的方式与你运行 Java 应用程序的方式相同。第二，你需要使用 Java 对象来实现核心功能，如读取文件和处理日期。第三，Java 有一个庞大的有用库的生态系统，你需要对 Java 有一定的了解才能使用它们。
这样一来，Clojure 就有点像一个乌托邦社区，被放置在一个乌托邦国家的中间。显然，你更愿意与其他乌托邦人互动，但偶尔你也需要与当地人交谈，以便完成工作。
这一章就像一本短语书和 Java 国家的文化介绍之间的交叉。你将了解什么是 JVM，它是如何运行程序的，以及如何为它编译程序。本章还将为你简要介绍常用的 Java 类和方法，并解释如何使用 Clojure 与它们互动。你将学会如何思考和理解 Java，以便将任何 Java 库纳入你的 Clojure 程序中。
要运行本章的例子，你需要在电脑上安装 1.6 或更高版本的 Java 开发工具包（JDK）。你可以通过在终端运行javac -version来检查。你应该看到类似 &ldquo;java 1.8.0_40 &ldquo;的内容；如果没有，请访问http://www.oracle.com/，下载最新的 JDK。
JVM 开发人员用 JVM 这个词来指代一些不同的东西。你会听到他们说，&ldquo;Clojure 在the JVM 上运行&rdquo;，你也会听到，&ldquo;Clojure 程序在a JVM 中运行&rdquo;。在第一种情况下，JVM 指的是一个抽象概念&ndash;Java 虚拟机的一般模型。在第二种情况下，它指的是一个进程&ndash;一个正在运行的程序的实例。我们将专注于 JVM 模型，但当我们谈论运行中的 JVM 进程时，我将指出来。
为了理解 JVM，让我们回头看看普通的计算机是如何工作的。在计算机心脏的深处是它的 CPU，而 CPU 的工作是执行像加和无符号乘法这样的操作。你可能听说过程序员将这些指令编码在打卡机上、灯泡里、乌龟壳的神圣缝隙里，或者什么的，但现在这些操作在汇编语言中用 ADD 和 MUL 这样的记忆符号表示。CPU 架构（X86、ARMv7，等等）决定了哪些操作可以作为该架构的指令集的一部分。">
<meta name=author content="Fenix">
<link rel=canonical href=https://zhenfeng-zhu.github.io/posts/chapter12/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zhenfeng-zhu.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://zhenfeng-zhu.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://zhenfeng-zhu.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://zhenfeng-zhu.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://zhenfeng-zhu.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-216295420-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Chapter12 与 Java 的互操作">
<meta property="og:description" content="与 JVM 一起工作 在每个 Clojurist 的生命中都会有这么一天，她必须从纯函数和不可变数据结构的庇护所冒险进入野蛮的 Java 大陆。这段艰难的旅程是必要的，因为 Clojure 是在 Java 虚拟机（JVM）上托管的，这赋予了它三个基本特性。
赋予它三个基本特征。首先，你运行 Clojure 应用程序的方式与你运行 Java 应用程序的方式相同。第二，你需要使用 Java 对象来实现核心功能，如读取文件和处理日期。第三，Java 有一个庞大的有用库的生态系统，你需要对 Java 有一定的了解才能使用它们。
这样一来，Clojure 就有点像一个乌托邦社区，被放置在一个乌托邦国家的中间。显然，你更愿意与其他乌托邦人互动，但偶尔你也需要与当地人交谈，以便完成工作。
这一章就像一本短语书和 Java 国家的文化介绍之间的交叉。你将了解什么是 JVM，它是如何运行程序的，以及如何为它编译程序。本章还将为你简要介绍常用的 Java 类和方法，并解释如何使用 Clojure 与它们互动。你将学会如何思考和理解 Java，以便将任何 Java 库纳入你的 Clojure 程序中。
要运行本章的例子，你需要在电脑上安装 1.6 或更高版本的 Java 开发工具包（JDK）。你可以通过在终端运行javac -version来检查。你应该看到类似 &ldquo;java 1.8.0_40 &ldquo;的内容；如果没有，请访问http://www.oracle.com/，下载最新的 JDK。
JVM 开发人员用 JVM 这个词来指代一些不同的东西。你会听到他们说，&ldquo;Clojure 在the JVM 上运行&rdquo;，你也会听到，&ldquo;Clojure 程序在a JVM 中运行&rdquo;。在第一种情况下，JVM 指的是一个抽象概念&ndash;Java 虚拟机的一般模型。在第二种情况下，它指的是一个进程&ndash;一个正在运行的程序的实例。我们将专注于 JVM 模型，但当我们谈论运行中的 JVM 进程时，我将指出来。
为了理解 JVM，让我们回头看看普通的计算机是如何工作的。在计算机心脏的深处是它的 CPU，而 CPU 的工作是执行像加和无符号乘法这样的操作。你可能听说过程序员将这些指令编码在打卡机上、灯泡里、乌龟壳的神圣缝隙里，或者什么的，但现在这些操作在汇编语言中用 ADD 和 MUL 这样的记忆符号表示。CPU 架构（X86、ARMv7，等等）决定了哪些操作可以作为该架构的指令集的一部分。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhenfeng-zhu.github.io/posts/chapter12/">
<meta property="og:image" content="https://zhenfeng-zhu.github.io/posts/chapter12/https:/raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201152206174.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-15T20:55:18+08:00">
<meta property="article:modified_time" content="2022-01-15T20:55:18+08:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhenfeng-zhu.github.io/posts/chapter12/https:/raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201152206174.png">
<meta name=twitter:title content="Chapter12 与 Java 的互操作">
<meta name=twitter:description content="与 JVM 一起工作 在每个 Clojurist 的生命中都会有这么一天，她必须从纯函数和不可变数据结构的庇护所冒险进入野蛮的 Java 大陆。这段艰难的旅程是必要的，因为 Clojure 是在 Java 虚拟机（JVM）上托管的，这赋予了它三个基本特性。
赋予它三个基本特征。首先，你运行 Clojure 应用程序的方式与你运行 Java 应用程序的方式相同。第二，你需要使用 Java 对象来实现核心功能，如读取文件和处理日期。第三，Java 有一个庞大的有用库的生态系统，你需要对 Java 有一定的了解才能使用它们。
这样一来，Clojure 就有点像一个乌托邦社区，被放置在一个乌托邦国家的中间。显然，你更愿意与其他乌托邦人互动，但偶尔你也需要与当地人交谈，以便完成工作。
这一章就像一本短语书和 Java 国家的文化介绍之间的交叉。你将了解什么是 JVM，它是如何运行程序的，以及如何为它编译程序。本章还将为你简要介绍常用的 Java 类和方法，并解释如何使用 Clojure 与它们互动。你将学会如何思考和理解 Java，以便将任何 Java 库纳入你的 Clojure 程序中。
要运行本章的例子，你需要在电脑上安装 1.6 或更高版本的 Java 开发工具包（JDK）。你可以通过在终端运行javac -version来检查。你应该看到类似 &ldquo;java 1.8.0_40 &ldquo;的内容；如果没有，请访问http://www.oracle.com/，下载最新的 JDK。
JVM 开发人员用 JVM 这个词来指代一些不同的东西。你会听到他们说，&ldquo;Clojure 在the JVM 上运行&rdquo;，你也会听到，&ldquo;Clojure 程序在a JVM 中运行&rdquo;。在第一种情况下，JVM 指的是一个抽象概念&ndash;Java 虚拟机的一般模型。在第二种情况下，它指的是一个进程&ndash;一个正在运行的程序的实例。我们将专注于 JVM 模型，但当我们谈论运行中的 JVM 进程时，我将指出来。
为了理解 JVM，让我们回头看看普通的计算机是如何工作的。在计算机心脏的深处是它的 CPU，而 CPU 的工作是执行像加和无符号乘法这样的操作。你可能听说过程序员将这些指令编码在打卡机上、灯泡里、乌龟壳的神圣缝隙里，或者什么的，但现在这些操作在汇编语言中用 ADD 和 MUL 这样的记忆符号表示。CPU 架构（X86、ARMv7，等等）决定了哪些操作可以作为该架构的指令集的一部分。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://zhenfeng-zhu.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Chapter12 与 Java 的互操作","item":"https://zhenfeng-zhu.github.io/posts/chapter12/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Chapter12 与 Java 的互操作","name":"Chapter12 与 Java 的互操作","description":"与 JVM 一起工作 在每个 Clojurist 的生命中都会有这么一天，她必须从纯函数和不可变数据结构的庇护所冒险进入野蛮的 Java 大陆。这段艰难的旅程是必要的，因为 Clojure 是在 Java 虚拟机（JVM）上托管的，这赋予了它三个基本特性。\n赋予它三个基本特征。首先，你运行 Clojure 应用程序的方式与你运行 Java 应用程序的方式相同。第二，你需要使用 Java 对象来实现核心功能，如读取文件和处理日期。第三，Java 有一个庞大的有用库的生态系统，你需要对 Java 有一定的了解才能使用它们。\n这样一来，Clojure 就有点像一个乌托邦社区，被放置在一个乌托邦国家的中间。显然，你更愿意与其他乌托邦人互动，但偶尔你也需要与当地人交谈，以便完成工作。\n这一章就像一本短语书和 Java 国家的文化介绍之间的交叉。你将了解什么是 JVM，它是如何运行程序的，以及如何为它编译程序。本章还将为你简要介绍常用的 Java 类和方法，并解释如何使用 Clojure 与它们互动。你将学会如何思考和理解 Java，以便将任何 Java 库纳入你的 Clojure 程序中。\n要运行本章的例子，你需要在电脑上安装 1.6 或更高版本的 Java 开发工具包（JDK）。你可以通过在终端运行javac -version来检查。你应该看到类似 \u0026ldquo;java 1.8.0_40 \u0026ldquo;的内容；如果没有，请访问http://www.oracle.com/，下载最新的 JDK。\nJVM 开发人员用 JVM 这个词来指代一些不同的东西。你会听到他们说，\u0026ldquo;Clojure 在the JVM 上运行\u0026rdquo;，你也会听到，\u0026ldquo;Clojure 程序在a JVM 中运行\u0026rdquo;。在第一种情况下，JVM 指的是一个抽象概念\u0026ndash;Java 虚拟机的一般模型。在第二种情况下，它指的是一个进程\u0026ndash;一个正在运行的程序的实例。我们将专注于 JVM 模型，但当我们谈论运行中的 JVM 进程时，我将指出来。\n为了理解 JVM，让我们回头看看普通的计算机是如何工作的。在计算机心脏的深处是它的 CPU，而 CPU 的工作是执行像加和无符号乘法这样的操作。你可能听说过程序员将这些指令编码在打卡机上、灯泡里、乌龟壳的神圣缝隙里，或者什么的，但现在这些操作在汇编语言中用 ADD 和 MUL 这样的记忆符号表示。CPU 架构（X86、ARMv7，等等）决定了哪些操作可以作为该架构的指令集的一部分。","keywords":["clojure"],"articleBody":"与 JVM 一起工作 在每个 Clojurist 的生命中都会有这么一天，她必须从纯函数和不可变数据结构的庇护所冒险进入野蛮的 Java 大陆。这段艰难的旅程是必要的，因为 Clojure 是在 Java 虚拟机（JVM）上托管的，这赋予了它三个基本特性。\n赋予它三个基本特征。首先，你运行 Clojure 应用程序的方式与你运行 Java 应用程序的方式相同。第二，你需要使用 Java 对象来实现核心功能，如读取文件和处理日期。第三，Java 有一个庞大的有用库的生态系统，你需要对 Java 有一定的了解才能使用它们。\n这样一来，Clojure 就有点像一个乌托邦社区，被放置在一个乌托邦国家的中间。显然，你更愿意与其他乌托邦人互动，但偶尔你也需要与当地人交谈，以便完成工作。\n这一章就像一本短语书和 Java 国家的文化介绍之间的交叉。你将了解什么是 JVM，它是如何运行程序的，以及如何为它编译程序。本章还将为你简要介绍常用的 Java 类和方法，并解释如何使用 Clojure 与它们互动。你将学会如何思考和理解 Java，以便将任何 Java 库纳入你的 Clojure 程序中。\n要运行本章的例子，你需要在电脑上安装 1.6 或更高版本的 Java 开发工具包（JDK）。你可以通过在终端运行javac -version来检查。你应该看到类似 “java 1.8.0_40 “的内容；如果没有，请访问http://www.oracle.com/，下载最新的 JDK。\nJVM 开发人员用 JVM 这个词来指代一些不同的东西。你会听到他们说，“Clojure 在the JVM 上运行”，你也会听到，“Clojure 程序在a JVM 中运行”。在第一种情况下，JVM 指的是一个抽象概念–Java 虚拟机的一般模型。在第二种情况下，它指的是一个进程–一个正在运行的程序的实例。我们将专注于 JVM 模型，但当我们谈论运行中的 JVM 进程时，我将指出来。\n为了理解 JVM，让我们回头看看普通的计算机是如何工作的。在计算机心脏的深处是它的 CPU，而 CPU 的工作是执行像加和无符号乘法这样的操作。你可能听说过程序员将这些指令编码在打卡机上、灯泡里、乌龟壳的神圣缝隙里，或者什么的，但现在这些操作在汇编语言中用 ADD 和 MUL 这样的记忆符号表示。CPU 架构（X86、ARMv7，等等）决定了哪些操作可以作为该架构的指令集的一部分。\n由于用汇编语言编程并不有趣，人们发明了像 C 和 C++这样的高级语言，将其编译成 CPU 可以理解的指令。大体上说，这个过程是\n 编译器读取源代码。 编译器输出一个包含机器指令的文件。 CPU 执行这些指令。  在图 12-1 中注意到，最终，你必须将程序翻译成 CPU 能够理解的指令，而 CPU 并不关心你用哪种编程语言来产生这些指令。\nJVM 类似于计算机，它也需要将代码翻译成低级别的指令，称为Java 字节码。然而，作为一个虚拟机器，这种翻译是作为软件而不是硬件实现的。运行中的 JVM 通过将字节码实时翻译成主机可以理解的机器代码来执行，这个过程被称为及时**编译。\n图 12-1：C 语言程序如何被翻译成机器码的高级概述\n为了让一个程序在 JVM 上运行，它必须被编译成 Java 字节码。通常，当你编译程序时，产生的字节码被保存在一个*.class文件中。然后你会把这些文件打包在Java 归档*文件（JAR 文件）中。就像 CPU 不关心你用哪种编程语言来生成机器指令一样，JVM 也不关心你如何创建字节码。它不关心你是否使用 Scala、JRuby、Clojure，甚至是 Java 来创建 Java 字节码。一般来说，这个过程就像图 12-2 中所示的那样。\n Java 编译器读取源代码。 编译器输出字节码，通常是在一个 JAR 文件中。 JVM 执行字节码。 VM 向 CPU 发送机器指令。  当有人说 Clojure 在 JVM 上运行时，他们的意思之一是 Clojure 程序被编译成 Java 字节码，JVM 进程执行它们。从操作的角度来看，这意味着你对待 Clojure 程序和 Java 程序是一样的。你把它们编译成 JAR 文件，并使用java命令运行它们。如果客户需要一个在 JVM 上运行的程序，你可以偷偷地用 Clojure 而不是 Java 来编写，他们不会知道的。从外面看，你无法分辨 Java 和 Clojure 程序之间的区别，就像你无法分辨 C 和 C++程序之间的区别一样。Clojure 可以让你变得富有成效，而且是偷偷摸摸的。\n！\n图 12-2：Java 程序产生 JVM 字节码，但 JVM 仍然需要产生机器指令，就像 C 语言编译器一样。\n编写、编译和运行一个 Java 程序 让我们来看看一个真正的 Java 程序是如何工作的。在本节中，你将了解到 Java 所使用的面向对象的范式。然后，你将用 Java 建立一个简单的海盗短语书。这将帮助你对 JVM 感到更加舒适，它将为即将到来的 Java 互操作（编写直接使用 Java 类、对象和方法的 Clojure 代码）一节做好准备，如果有一个恶棍试图在公海上破坏你的战利品，它就会派上用场。为了把所有的信息联系在一起，你将在本章的最后偷看一些 Clojure 的 Java 代码。\n面向对象的编程在世界最微小的果壳中的应用 Java 是一种面向对象的语言，所以如果你想了解你在 Clojure 编程中使用 Java 库或编写 Java 互操作代码时发生了什么，你就需要了解面向对象编程（OOP）是如何工作的。你也会在 Clojure 文档中发现面向对象的术语，所以学习这些概念很重要。如果你精通 OOP，可以随意跳过本节。对于那些需要两分钟了解的人来说，这里是：OOP 的核心角色是类、对象和方法。\n我认为对象是真正的、真正的、可笑的蠢货机器人。它们是那种永远不会引起哲学辩论的机器人，即强迫有知觉的生物进行永久的奴役的伦理。这些机器人只做两件事：他们响应命令和维护数据。在我的想象中，它们通过在小 Hello Kitty 剪贴板上写下东西来做这件事。\n想象一下，一个制造这些机器人的工厂。机器人所理解的命令集和它所维护的数据集都是由制造机器人的工厂决定的。在 OOP 术语中，工厂对应于类，androids 对应于对象，而命令对应于方法。例如，你可能有一个ScaryClown'工厂（类），它生产的androids（对象）响应makeBalloonArt’命令（方法）。这个安卓机一直跟踪它所拥有的气球的数量，然后在气球的数量发生变化时更新这个数字。它可以用balloonCount报告这个数字，用receiveBalloons接收任何数量的气球。下面是你如何与代表小丑 Belly Rubs 的 Java 对象进行交互。\nScaryClown bellyRubsTheClown = new ScaryClown(); bellyRubsTheClown.balloonCount(); // = 0 bellyRubsTheClown.receiveBalloons(2); bellyRubsTheClown.balloonCount(); // = 2 bellyRubsTheClown.makeBalloonArt(); // = \"Belly Rubs makes a balloon shaped like a clown, because Belly Rubs // = is trying to scare you and nothing is scarier than clowns.\" 这个例子告诉你如何使用ScaryClown类创建一个新的对象bellyRubsTheClown。它还向你展示了如何在该对象上调用方法（如气球计数'、接收气球’和`制作气球艺术'），大概是为了让你能吓唬孩子。\n你应该知道 OOP 的最后一个方面，或者至少是它在 Java 中的实现方式，就是你也可以向工厂发送命令。在 OOP 术语中，你会说，类也有方法。例如，内置类Math有许多类方法，包括Math.abs，它返回一个数字的绝对值。\nMath.abs(-50) // = 50 我希望这些小丑没有给你造成太大的创伤。现在让我们把你的 OOP 知识用在工作上吧!\nAhoy, World 继续前进，创建一个名为phrasebook的新目录。在该目录中，创建一个名为PiratePhrases.java的文件，并编写以下内容。\npublic class PiratePhrases { public static void main(String[] args) { System.out.println(\"Shiver me timbers!!\"); } } 这个非常简单的程序将在你运行时向你的终端打印 “Shiver me timbers!!!“这句话。(这就是海盗说 “你好，世界！“的方式），当你运行它时，它将打印到你的终端。它由一个类PiratePhrases和一个属于该类的静态方法main组成。静态方法本质上是类的方法。\n在你的终端，用 javac PiratePhrases.java 命令编译PiratePhrases源代码。如果你打的字都是正确的，**你的心是纯洁的，你应该看到一个名为PiratePhrases.class的文件。\n$ ls PiratePhrases.class PiratePhrases.java 你刚刚编译了你的第一个 Java 程序，我的朋友! 现在用java PiratePhrases运行它。你应该看到这个。\nShiver me timbers!!! 这里发生的事情是你用 Java 编译器javac创建了一个 Java 类文件，PiratePhrases.class。这个文件包含了大量的 Java 字节码（好吧，对于这么大的程序，也许只有一个字节）。\n当你运行 “java PiratePhrases “时，JVM 首先查看了你的classpath，寻找一个名为 “PiratePhrases “的类。classpath 是文件系统的路径列表，JVM 通过搜索来寻找定义类的文件。默认情况下，classpath 包括你运行 java 时所在的目录。试着运行 java -classpath /tmp PiratePhrases，你会得到一个错误，尽管PiratePhrases.class就在你的当前目录中。\n注意 你可以在你的 classpath 上有多个路径，如果你在 Mac 上或运行 Linux，可以用冒号隔开，如果你在使用 Windows，可以用分号。例如，classpath /tmp:/var/maven:.包括/tmp、/var/maven 和.目录。\n在 Java 中，每个文件只允许有一个公有类，而且文件名必须与类名一致。这就是为什么java知道要尝试在PiratePhrases.class中寻找PiratePhrases类的字节码。在java找到PiratePhrases类的字节码后，它执行了该类的main方法。Java 与 C 语言类似，只要你说 “运行某些东西，并使用这个类作为入口点”，它就会一直运行这个类的main'方法；因此，这个方法必须是public'，你可以在`PiratePhrases’的源代码中看到。\n在下一节，你将学习如何处理跨越多个文件的程序代码，以及如何使用 Java 库。\n包和导入 为了了解如何使用多文件程序和 Java 库，我们将编译并运行一个程序。本节对 Clojure 有直接的影响，因为你将使用同样的想法和术语来与 Java 库进行交互。\n让我们从几个定义开始。\n 包与 Clojure 的命名空间类似，包提供了代码组织。包包含类，包名对应于文件系统的目录。如果一个文件中有 “package com.shapemaster “一行，那么目录com/shapemaster一定存在于你的 classpath 上。在该目录中会有定义类的文件。 import Java 允许你导入类，这基本上意味着你可以不使用它们的命名空间前缀来引用它们。所以如果你在com.shapemaster中有一个名为Square的类，你可以在.java文件的顶部写上import``com.shapemaster.Square;或import com.shapemaster.*;，以便在你的代码中使用Square而不是com.shapemaster.Square。  让我们试试使用package和import。在这个例子中，你将创建一个名为pirate_phrases的包，它有两个类，问候'和告别'。 首先，浏览你的phrasebook，在该目录下创建另一个目录，pirate_phrases。创建pirate_phrases是必要的，因为 Java 包的名称与文件系统的目录相对应。然后，在pirate_phrases目录下创建Greetings.java。\n➊ package pirate_phrases; public class Greetings { public static void hello() { System.out.println(\"Shiver me timbers!!!\"); } } 在➊，package pirate_phrases;表示这个类将是pirate_phrases包的一部分。现在在pirate_phrases目录下创建Farewells.java。\npackage pirate_phrases; public class Farewells { public static void goodbye() { System.out.println(\"A fair turn of the tide ter ye thar, ye magnificent sea friend!!\"); } } 现在在phrasebook目录下创建PirateConversation.java。\nimport pirate_phrases.*; public class PirateConversation { public static void main(String[] args) { Greetings greetings = new Greetings(); greetings.hello(); Farewells farewells = new Farewells(); farewells.goodbye(); } } 第一行，import pirate_phrases.*;，导入了pirate_phrases包中的所有类，其中包含问候'和告别’类。\n如果你在phrasebook目录下运行javac PirateConversation.java，接着运行java PirateConversation，你应该看到这个。\nShiver me timbers!!! A fair turn of the tide ter ye thar, ye magnificent sea friend!! 亲爱的读者，她在那里吹了起来。她确实在吹。\n注意，当你编译一个 Java 程序时，Java 会在你的 classpath 中搜索包。试着输入以下内容。\ncd pirate_phrases javac ../PirateConversation.java 你会得到这个结果。\n../PirateConversation.java:1: error: package pirate_phrases does not exist import pirate_phrases.*; ^ 轰隆隆! Java 编译器刚刚告诉你，让你羞愧地垂下头来，也许还会哭泣一下。\n为什么？它认为pirate_phrases包不存在。但这很愚蠢，对吗？你是在pirate_phrases目录下！你是在pirate_phrases目录下。\n这里发生的情况是，默认的 classpath 只包括当前的目录，在这种情况下是pirate_phrases。 javac试图找到phrasebook/pirate_phrases/pirate_phrases目录，但该目录并不存在。当你在phrasebook目录下运行javac ../PirateConversation.java时，javac试图找到phrasebook/pirate_phrases目录，该目录确实存在。在不改变目录的情况下，尝试运行 javac -classpath ../ ../PirateConversation.java。吓我一跳，居然成功了! 这是因为你手动将 classpath 设置为pirate_phrases的父目录，也就是phrasebook。从那里，javac可以成功地找到pirate_phrases目录。\n综上所述，包组织了代码，并要求有一个匹配的目录结构。导入类可以让你引用它们，而不需要预留整个类的包名。 javac和 Java 使用 classpath 查找包。\nJAR 文件 JAR 文件允许你将所有的*.class文件捆绑成一个单一的文件。导航到你的phrasebook*目录并运行以下程序。\njar cvfe conversation.jar PirateConversation PirateConversation.class pirate_phrases/*.class java -jar conversation.jar 这样就能正确显示海盗对话了。你把所有的类文件捆绑在conversation.jar中。使用e标志，你还指出PirateConversation类是入口点。入口点是包含 JAR 整体运行时应该执行的main'方法的类，jar’将这些信息存储在 JAR 文件中的META-INF/MANIFEST.MF文件中。如果你要阅读该文件，它将包含这一行。\nMain-Class: PirateConversation 顺便说一下，当你执行 JAR 文件时，你不必担心你在哪个目录下，相对于文件而言。你可以换到pirate_phrases目录，然后运行java -jar .../conversation.jar，就可以正常工作了。原因是 JAR 文件维护了目录结构。你可以用 jar tf conversation.jar 查看它的内容，它的输出是这样的。\nMETA-INF/ meta-inf/manifest.mf PirateConversation.class pirate_phrases/Farewells.class Pirate_phrases/Greetings.class 你可以看到，JAR 文件包括pirate_phrases目录。关于 JARs 还有一个有趣的事实：它们实际上只是带有*.jar*扩展名的 ZIP 文件。你可以像对待其他 ZIP 文件一样对待它们。\nclojure.jar 现在你已经准备好看看 Clojure 在引擎盖下是如何工作的了! 下载[1.9.0 稳定版]（http://repo1.maven.org/maven2/org/clojure/clojure/1.7.0/clojure-1.9.0.zip）并运行它。\njava -jar clojure-1.7.0.jar 你应该看到最舒心的景象，Clojure REPL。它究竟是如何启动的呢？让我们看看 JAR 文件中的META-INF/MANIFEST.MF。\nManifest-Version: 1.0 Archiver-Version: Plexus Archiver Created-By: Apache Maven Built-By: hudson Build-Jdk: 1.7.0_20 Main-Class: clojure.main 看起来，clojure.main被指定为入口点。这个类是怎么来的？嗯，看看 GitHub 上的clojure/main.java，网址是*https://github.com/clojure/clojure/blob/master/src/jvm/clojure/main.java*。\n/** * Copyright (c) Rich Hickey. All rights reserved. * The use and distribution terms for this software are covered by the * Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php) * which can be found in the file epl-v10.html at the root of this distribution. * By using this software in any fashion, you are agreeing to be bound by * the terms of this license. * You must not remove this notice, or any other, from this software. **/ package clojure; import clojure.lang.Symbol; import clojure.lang.Var; import clojure.lang.RT; public class main{ final static private Symbol CLOJURE_MAIN = Symbol.intern(\"clojure.main\"); final static private Var REQUIRE = RT.var(\"clojure.core\", \"require\"); final static private Var LEGACY_REPL = RT.var(\"clojure.main\", \"legacy-repl\"); final static private Var LEGACY_SCRIPT = RT.var(\"clojure.main\", \"legacy-script\"); final static private Var MAIN = RT.var(\"clojure.main\", \"main\"); public static void legacy_repl(String[] args) { REQUIRE.invoke(CLOJURE_MAIN); LEGACY_REPL.invoke(RT.seq(args)); } public static void legacy_script(String[] args) { REQUIRE.invoke(CLOJURE_MAIN); LEGACY_SCRIPT.invoke(RT.seq(args)); } public static void main(String[] args) { REQUIRE.invoke(CLOJURE_MAIN); MAIN.applyTo(RT.seq(args)); } } 正如你所看到的，该文件定义了一个名为main的类。它属于 “clojure “包，并定义了一个 “公共静态 “的 “main “方法，JVM 完全乐意将其作为一个入口点。以这种方式来看，Clojure 是一个 JVM 程序，就像其他程序一样。\n这并不是一个深入的 Java 教程，但我希望它有助于澄清程序员在谈论 Clojure “在 JVM 上运行 “或成为一种 “托管 “语言时的意思。在下一节中，你将继续探索 JVM 的魅力，学习如何在你的 Clojure 项目中使用额外的 Java 库。\nClojure 应用程序 JARs\n你现在知道 Java 是如何运行 Java JARs 的，但它是如何运行捆绑为 JARs 的 Clojure 应用程序的呢？毕竟，Clojure 应用程序没有类，不是吗？\n事实证明，你可以通过在命名空间声明中加入(:gen-class)指令，让 Clojure 编译器为一个命名空间生成一个类。(你可以在你创建的第一个 Clojure 程序中看到这一点，即第一章的clojure-noob。还记得那个程序吗，小茶壶？） 这意味着编译器会产生必要的字节码，使 JVM 把命名空间当作定义了一个 Java 类。\n你在程序的project.clj文件中，使用:main属性，为你的程序设置入口点的命名空间。对于clojure-noob，你应该看到:main ^:skip-aot clojure-noob.core。当 Leiningen 编译这个文件时，它将添加一个meta-inf/manifest.mf文件，该文件包含了生成的 JAR 文件的入口点。\n因此，如果你在命名空间中定义了一个-main函数，并包括(:gen-class)指令，同时在你的project.clj文件中设置了:main，你的程序在被编译为 JAR 时，将拥有 Java 运行它所需的一切。你可以在你的终端中试用这个方法，浏览你的clojure-noob目录并运行这个。\nlein uberjar java -jar target/uberjar/clojure-noob-0.1.0-SNAPSHOT-standalone.jar 你应该看到打印出来的两条信息。“清洁度仅次于神性 “和 “I’m a little teapot!” 注意，你不需要 Leiningen 来运行这个 JAR 文件；你可以把它发送给朋友和邻居，只要他们安装了 Java，就可以运行它。\nJava Interop Rich Hickey 对 Clojure 的设计目标之一是创造一种实用的语言。出于这个原因，Clojure 的设计是为了使你能够轻松地与 Java 类和对象进行交互，这意味着你可以使用 Java 广泛的本地功能和它的巨大生态系统。使用 Java 类、对象和方法的能力被称为Java interop*。在本节中，你将学习如何使用 Clojure 的互操作语法，如何导入 Java 包，以及如何使用最常用的 Java 类。\n互通语法 使用 Clojure 的互操作语法，与 Java 对象和类的交互是很直接的。让我们从对象互操作语法开始。\n你可以使用(.methodName object)来调用一个对象的方法。例如，因为所有的 Clojure 字符串都是作为 Java 字符串实现的，所以你可以对它们调用 Java 方法。\n(.toUpperCase \"By Bluebeard's bananas!\" ) ; = \"by bluebeard's bananas!\" ➊ (.indexOf \"Let's synergize our bleeding edges\" \"y\") ; = 7 这些等同于这个 Java。\n\"By Bluebeard's bananas!\".toUpperCase() \"Let's synergize our bleeding edges\".indexOf(\"y\") 注意，Clojure 的语法允许你向 Java 方法传递参数。在这个例子中，在➊，你把参数\"y\"传给了indexOf方法。\n你也可以调用类上的静态方法和访问类的静态字段。观察一下!\n➊ (java.lang.Math/abs -3) ; = 3 ➋ java.lang.Math/PI ; = 3.141592653589793 在➊，你调用了java.lang.Math类的abs静态方法，在➋，你访问了该类的PI静态字段。\n所有这些例子（除了java.lang.Math/PI）都使用了扩展到使用*dot 特殊形式的宏。一般来说，你不需要使用点的特殊形式，除非你想写自己的宏来与 Java 对象和类交互。尽管如此，下面是每个例子后面的宏扩展。\n(macroexpand-1 '(.toUpperCase \"By Bluebeard's bananas!\")) ; = (. \"By Bluebeard's bananas!\" toUpperCase) (macroexpand-1 '(.indexOf \"Let's synergize our bleeding edges\" \"y\")) ; = (. \"Let's synergize our bleeding edges\" indexOf \"y\") (macroexpand-1 '(Math/abs -3)) ; = (. Math abs -3) 这是点运算符的一般形式。\n(. object-expr-or-classname-symbol method-or-member-symbol optional-args*) 点运算符还有一些功能，如果你有兴趣进一步探索它，你可以看看 clojure.org 关于 Java 互操作的文档*http://clojure.org/java_interop#Java%20Interop-The%20Dot%20special%20form*。\n创建和变异对象\n上一节告诉你如何调用已经存在的对象的方法。本节向你展示如何创建新的对象以及如何与它们进行交互。\n你可以通过两种方式创建一个新的对象。(new ClassName optional-args)和(ClassName. optional-args)。\n(new String) ; = \"\" (String.) ; = \"\" (String. \"To Davey Jones's Locker with ye hardies\") ; = \"To Davey Jones's Locker with ye hardies\" 大多数人使用点的版本，(ClassName.)。\n要修改一个对象，你要像上一节那样调用其上的方法。为了研究这个问题，让我们使用java.util.Stack。这个类代表了一个后进先出（LIFO）的对象堆栈，或者只是堆栈。堆栈是一种常见的数据结构，它们之所以被称为堆栈，是因为你可以把它们想象成一摞实物，比如说，一摞你刚刚掠夺来的金币。当你向你的堆栈添加一个硬币时，你就把它添加到堆栈的顶部。当你取出一枚金币时，你就把它从上面移走。因此，最后添加的对象就是第一个被移除的对象。\n与 Clojure 数据结构不同，Java 堆栈是可变的。你可以向它们添加项目和删除项目，改变对象而不是派生出一个新的值。下面是你如何创建一个堆栈并向其添加一个对象。\n(java.util.Stack.) ; = [] ➊ (let [stack (java.util.Stack.)] (.push stack \"Latest episode of Game of Thrones, ho!\") stack) ; = [\"Latest episode of Game of Thrones, ho!\"] 这里有几个有趣的细节。首先，你需要为stack创建一个let绑定，就像你在➊看到的那样，并把它作为let形式的最后一个表达式。如果你不这样做，整个表达式的值将是字符串\"Game of Thrones, ho!\"，因为那是push的返回值。\n第二，Clojure 用方括号来打印堆栈，与它用于 Vector 的文本表示法相同，这可能会让你感到困惑，因为它不是一个 Vector。然而，你可以使用 Clojure 的seq函数来读取堆栈中的数据结构，比如first，。\n(let [stack (java.util.Stack.)] (.push stack \"Latest episode of Game of Thrones, ho!\") (first stack)) ; = \"Latest episode of Game of Thrones, ho!\" 但是你不能使用像conj和into这样的函数来添加元素到栈中。如果你这样做，你会得到一个异常。使用 Clojure 函数读取堆栈是可能的，因为 Clojure 扩展了对java.util.Stack的抽象，这个主题你将在第 13 章学习。\nClojure 提供了doto宏，它允许你更简洁地在同一个对象上执行多个方法。\n(doto (java.util.Stack.) (.push \"Latest episode of Game of Thrones, ho!\") (.push \"Whoops, I meant 'Land, ho!'\")) ; = [\"Latest episode of Game of Thrones, ho!\" \"Whoops, I meant 'Land, ho!'\"] doto宏返回对象，而不是任何方法调用的返回值，它更容易理解。如果你用macroexpand-1展开它，你可以看到它的结构与你刚才在前面的例子中看到的let表达式相同。\n(macroexpand-1 '(doto (java.util.Stack.) (.push \"Latest episode of Game of Thrones, ho!\") (.push \"Whoops, I meant 'Land, ho!'\"))) ; = (clojure.core/let [G__2876 (java.util.Stack.)] (.push G__2876 \"Latest episode of Game of Thrones, ho!\") (.push G__2876 \"Whoops, I meant 'Land, ho!'\") G__2876) 很方便!\n导入 在 Clojure 中，导入的效果和 Java 中的一样：你可以使用类，而不需要打出整个包的前缀。\n(import java.util.Stack) (Stack.) ; = [] 你也可以使用这种一般形式一次导入多个类。\n(import [package.name1 ClassName1 ClassName2] [package.name2 ClassName3 ClassName4]) 下面是一个例子。\n(import [java.util Date Stack] [java.net Proxy URI]) (Date.) ; = #inst \"2016-09-19T20:40:02.733-00:00\" 但通常情况下，你会在ns宏中做所有的导入工作，像这样。\n(ns pirate.talk (:import [java.util Date Stack]. [java.net Proxy URI]) 这两种不同的导入类的方法有相同的结果，但通常第二种方法更可取，因为对于阅读你的代码的人来说，在ns声明中看到所有涉及命名的代码很方便。\n这就是你导入类的方法! 很简单。为了使生活更加简单，Clojure 自动导入了java.lang中的类，包括java.lang.String和java.lang.Math，这就是为什么你能够使用String而不用前面的包名。\n常用的 Java 类 为了完善本章，让我们快速浏览一下你最可能用到的 Java 类。\n系统类 系统 “类具有有用的类字段和方法，可以与程序运行的环境进行交互。你可以用它来获取环境变量，与标准输入、标准输出和错误输出流进行交互。\n最有用的方法和成员是exit、getenv和getProperty。你可能在第 5 章中认识System/exit，在那里你用它来退出 Peg Thing 游戏。`System/exit’可以终止当前程序，你可以把状态代码作为参数传给它。如果你对状态代码不熟悉，我推荐维基百科的 “退出状态 “文章，网址是*退出状态-维基百科*。\nSystem/getenv将以 Map 形式返回所有系统的环境变量。\n(System/getenv) {\"USER\" \"the-incredible-bulk\" \"JAVA_ARCH\" \"x86_64\" } 环境变量的一个常见用途是配置你的程序。\nJVM 有自己的属性列表，与计算机的环境变量分开，如果需要读取它们，可以使用System/getProperty。\n➊ (System/getProperty \"user.dir\") ; = \"/Users/dabulk/projects/dabook\" ➋ (System/getProperty \"java.version\") ; = \"1.7.0_17\" 第一个调用➊返回 JVM 启动的目录，第二个调用➋返回 JVM 的版本。\n日期类 Java 有很好的工具来处理日期问题。我不会对java.util.Date类做太多的介绍，因为在线的 API 文档（可在*Date (Java Platform SE 7 )*)很详尽。作为一个 Clojure 开发者，你应该知道这个date类的三个特点。首先，Clojure 允许你使用这样的形式将日期表示为字面意义。\n#inst \"2016-09-19T20:40:02.733-00:00\" 第二，如果你想自定义如何将日期转换成字符串，或者你想将字符串转换成日期，你需要使用java.util.DateFormat类。第三，如果你要做的任务是比较日期或试图在日期上添加分钟、小时或其他时间单位，你应该使用极其有用的 clj-time 库（你可以在*GitHub - clj-time/clj-time: 一个用于 Clojure 的日期和时间库，包装了 Joda 时间库。*)。\n文件和输入/输出 在这一节中，你将了解到 Java 的输入/输出（IO）方法，以及 Clojure 如何简化它。clojure.java.io命名空间提供了许多方便的函数来简化 IO（clojure.java.io - Clojure v1.10.3 API 文档）。这很好，因为 Java 的 IO 并不完全是简单的。因为在你的编程生涯中，你可能会在某些时候想要执行 IO，让我们开始把你的思想触角缠绕在它上面。\nIO 涉及到资源，无论是文件、套接字、缓冲区，还是其他什么。Java 有独立的类来读取资源的内容，写入其内容，以及与资源的属性进行交互。\n例如，java.io.File类用于与文件的属性进行交互。\n(let [file (java.io.File. \"/\")] ➊ (println (.exists file)) ➋ (println (.canWrite file)) ➌ (println (.getPath file))) ; = true ; = false ; = / 在其他任务中，你可以用它来检查一个文件是否存在，获得文件的读/写/执行权限，并获得其文件系统路径，你可以在➊、➋和➌分别看到。\n在这个能力列表中，明显缺少读和写。要读一个文件，你可以使用java.io.BufferedReader类或者java.io.FileReader。同样地，你可以使用java.io.BufferedWriter或java.io.FileWriter类来写。其他类也可用于读写，你选择哪一个取决于你的具体需求。读取器和写入器类的接口都有相同的基本方法集；读取器实现了读取'、关闭’等，而写入器实现了添加'、写入'、关闭'和刷新'。Java 给你提供了各种 IO 工具。一个愤世嫉俗的人可能会说，Java 给你的绳子足以让你上吊，如果你找到这样一个人，我希望你能给他一个拥抱。\n不管怎么说，Clojure 使你的读写更容易，因为它包括了统一不同种类资源的读写的函数。例如，spit写到一个资源，而slurp从一个资源中读出。下面是一个使用它们来写和读一个文件的例子。\n(spit \"/tmp/hercules-todo-list\" \"- kill dat lion brov - chop up what nasty multi-headed snake thing\") (slurp \"/tmp/hercules-todo-list\") ; = \"- kill dat lion brov - chop up what nasty multi-headed snake thing\" 你也可以对代表文件以外的资源的对象使用这些函数。下一个例子使用了一个StringWriter，它允许你对一个字符串进行 IO 操作。\n(let [s (java.io.StringWriter.)] (spit s \"- capture cerynian hind like for real\") (.toString s)) ; = \"- capture cerynian hind like for real\" 你也可以使用 “slurp “从StringReader中读取。\n(let [s (java.io.StringReader. \"- get erymanthian pig what with the tusks\")] (slurp s)) ; = \"- get erymanthian pig what with the tusks\" 此外，你可以对资源使用读和写方法。使用哪种方法并没有什么区别；spit和slurp很方便，因为它们只需使用一个代表文件系统路径或 URL 的字符串。\nwith-open宏是另一种便利：它在其主体的末尾隐含地关闭一个资源，确保你不会因为忘记手动关闭资源而意外地占用资源。reader函数是一个方便的工具，根据clojure.java.ioAPI 文档，“试图将其参数强制到一个开放的java.io.Reader\"。当你不想使用slurp时，这很方便，因为你不想尝试完整地读取一个资源，你也不想弄清楚你需要使用哪个 Java 类。如果你想一行一行地读取一个文件，你可以使用reader和with-open以及line-seq函数。下面是如何打印 Hercules 待办事项清单的第一项的。\n(with-open [todo-list-rdr (clojure.java.io/reader \"/tmp/hercules-todo-list\")] (println (first (line-seq todo-list-rdr)))) ; = - kill dat lion brov 这应该足以让你在 Clojure 中开始使用 IO。如果你想做更复杂的任务，一定要看看clojure.java.io docs，[java.nio.file](https://docs.oracle.com/javase/7/docs/api/java/nio/file/package-summary.html)包文档，或[java.io](http://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html)包文档。\n资源  “Java 虚拟机和编译器的解释”。 Java 虚拟机和编译器的解释–YouTube clojure.org Java 互操作文档。 Clojure - Java Interop 维基百科的 “退出状态 “文章。 退出状态 - 维基百科  总结 在本章中，你了解了 Clojure 被托管在 JVM 上的含义。Clojure 程序被编译成 Java 字节码并在 JVM 进程中执行。Clojure 程序也可以访问 Java 库，你可以使用 Clojure 的互操作设施轻松地与它们交互。\n","wordCount":"1459","inLanguage":"en","image":"https://zhenfeng-zhu.github.io/posts/chapter12/https:/raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201152206174.png","datePublished":"2022-01-15T20:55:18+08:00","dateModified":"2022-01-15T20:55:18+08:00","author":{"@type":"Person","name":"Fenix"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhenfeng-zhu.github.io/posts/chapter12/"},"publisher":{"@type":"Organization","name":"Awesome Fenix","logo":{"@type":"ImageObject","url":"https://zhenfeng-zhu.github.io/favicon.ico"}}}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8502076734034112" crossorigin=anonymous></script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhenfeng-zhu.github.io accesskey=h title="Awesome Fenix (Alt + H)">Awesome Fenix</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://zhenfeng-zhu.github.io/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/about title=About>
<span>About</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/search/ title=🔍>
<span>🔍</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://zhenfeng-zhu.github.io>Home</a>&nbsp;»&nbsp;<a href=https://zhenfeng-zhu.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Chapter12 与 Java 的互操作
</h1>
<div class=post-meta><span title="2022-01-15 20:55:18 +0800 +0800">January 15, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Fenix&nbsp;|&nbsp;<a href=https://github.com/zhenfeng-zhu/zhenfeng-zhu.github.io/tree/main/content/posts/Chapter12.md rel="noopener noreferrer" target=_blank>修改本文章</a>
</div>
</header>
<figure class=entry-cover><img loading=lazy src=https://raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201152206174.png alt>
<p></p>
</figure><div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e4%b8%8e-jvm-%e4%b8%80%e8%b5%b7%e5%b7%a5%e4%bd%9c aria-label="与 JVM 一起工作">与 JVM 一起工作</a><ul>
<li>
<a href=#jvm aria-label=JVM>JVM</a></li>
<li>
<a href=#%e7%bc%96%e5%86%99%e7%bc%96%e8%af%91%e5%92%8c%e8%bf%90%e8%a1%8c%e4%b8%80%e4%b8%aa-java-%e7%a8%8b%e5%ba%8f aria-label="编写、编译和运行一个 Java 程序">编写、编译和运行一个 Java 程序</a><ul>
<li>
<a href=#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%bc%96%e7%a8%8b%e5%9c%a8%e4%b8%96%e7%95%8c%e6%9c%80%e5%be%ae%e5%b0%8f%e7%9a%84%e6%9e%9c%e5%a3%b3%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8 aria-label=面向对象的编程在世界最微小的果壳中的应用>面向对象的编程在世界最微小的果壳中的应用</a></li>
<li>
<a href=#ahoy-world aria-label="Ahoy, World">Ahoy, World</a></li></ul>
</li>
<li>
<a href=#%e5%8c%85%e5%92%8c%e5%af%bc%e5%85%a5 aria-label=包和导入>包和导入</a></li>
<li>
<a href=#jar-%e6%96%87%e4%bb%b6 aria-label="JAR 文件">JAR 文件</a></li>
<li>
<a href=#clojurejar aria-label=clojure.jar>clojure.jar</a></li>
<li>
<a href=#java-interop aria-label="Java Interop">Java Interop</a><ul>
<li>
<a href=#%e4%ba%92%e9%80%9a%e8%af%ad%e6%b3%95 aria-label=互通语法>互通语法</a></li>
<li>
<a href=#%e5%af%bc%e5%85%a5 aria-label=导入>导入</a></li></ul>
</li>
<li>
<a href=#%e5%b8%b8%e7%94%a8%e7%9a%84-java-%e7%b1%bb aria-label="常用的 Java 类">常用的 Java 类</a><ul>
<li>
<a href=#%e7%b3%bb%e7%bb%9f%e7%b1%bb aria-label=系统类>系统类</a></li>
<li>
<a href=#%e6%97%a5%e6%9c%9f%e7%b1%bb aria-label=日期类>日期类</a></li></ul>
</li>
<li>
<a href=#%e6%96%87%e4%bb%b6%e5%92%8c%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba aria-label=文件和输入/输出>文件和输入/输出</a></li>
<li>
<a href=#%e8%b5%84%e6%ba%90 aria-label=资源>资源</a></li>
<li>
<a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=与-jvm-一起工作>与 JVM 一起工作<a hidden class=anchor aria-hidden=true href=#与-jvm-一起工作>#</a></h1>
<p>在每个 Clojurist 的生命中都会有这么一天，她必须从纯函数和不可变数据结构的庇护所冒险进入野蛮的 Java 大陆。这段艰难的旅程是必要的，因为 Clojure 是在 Java 虚拟机（JVM）上托管的，这赋予了它三个基本特性。</p>
<p>赋予它三个基本特征。首先，你运行 Clojure 应用程序的方式与你运行 Java 应用程序的方式相同。第二，你需要使用 Java 对象来实现核心功能，如读取文件和处理日期。第三，Java 有一个庞大的有用库的生态系统，你需要对 Java 有一定的了解才能使用它们。</p>
<p>这样一来，Clojure 就有点像一个乌托邦社区，被放置在一个乌托邦国家的中间。显然，你更愿意与其他乌托邦人互动，但偶尔你也需要与当地人交谈，以便完成工作。</p>
<p>这一章就像一本短语书和 Java 国家的文化介绍之间的交叉。你将了解什么是 JVM，它是如何运行程序的，以及如何为它编译程序。本章还将为你简要介绍常用的 Java 类和方法，并解释如何使用 Clojure 与它们互动。你将学会如何思考和理解 Java，以便将任何 Java 库纳入你的 Clojure 程序中。</p>
<p>要运行本章的例子，你需要在电脑上安装 1.6 或更高版本的 Java 开发工具包（JDK）。你可以通过在终端运行<code>javac -version</code>来检查。你应该看到类似 &ldquo;java 1.8.0_40 &ldquo;的内容；如果没有，请访问<a href=http://www.oracle.com/technetwork/java/javase/downloads/index.html><em>http://www.oracle.com/</em></a>，下载最新的 JDK。</p>
<h2 id=jvm>JVM<a hidden class=anchor aria-hidden=true href=#jvm>#</a></h2>
<p>开发人员用 JVM 这个词来指代一些不同的东西。你会听到他们说，&ldquo;Clojure 在<em>the</em> JVM 上运行&rdquo;，你也会听到，&ldquo;Clojure 程序在<em>a</em> JVM 中运行&rdquo;。在第一种情况下，JVM 指的是一个抽象概念&ndash;Java 虚拟机的一般模型。在第二种情况下，它指的是一个进程&ndash;一个正在运行的程序的实例。我们将专注于 JVM 模型，但当我们谈论运行中的 JVM 进程时，我将指出来。</p>
<p>为了理解 JVM，让我们回头看看普通的计算机是如何工作的。在计算机心脏的深处是它的 CPU，而 CPU 的工作是执行像<em>加和</em>无符号乘法这样的操作。你可能听说过程序员将这些指令编码在打卡机上、灯泡里、乌龟壳的神圣缝隙里，或者<em>什么的，但现在这些操作在汇编语言中用 ADD 和 MUL 这样的记忆符号表示。CPU 架构（X86、ARMv7，等等）决定了哪些操作可以作为该架构的</em>指令集的一部分。</p>
<p>由于用汇编语言编程并不有趣，人们发明了像 C 和 C++这样的高级语言，将其编译成 CPU 可以理解的指令。大体上说，这个过程是</p>
<ol>
<li>编译器读取源代码。</li>
<li>编译器输出一个包含机器指令的文件。</li>
<li>CPU 执行这些指令。</li>
</ol>
<p>在图 12-1 中注意到，最终，你必须将程序翻译成 CPU 能够理解的指令，而 CPU 并不关心你用哪种编程语言来产生这些指令。</p>
<p>JVM 类似于计算机，它也需要将代码翻译成低级别的指令，称为<em>Java 字节码</em>。然而，作为一个<em>虚拟</em>机器，这种翻译是作为软件而不是硬件实现的。运行中的 JVM 通过将字节码实时翻译成主机可以理解的机器代码来执行，这个过程被称为<em>及时**编译</em>。</p>
<p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/java/compile.png alt>
</p>
<p>图 12-1：C 语言程序如何被翻译成机器码的高级概述</p>
<p>为了让一个程序在 JVM 上运行，它必须被编译成 Java 字节码。通常，当你编译程序时，产生的字节码被保存在一个*.class<em>文件中。然后你会把这些文件打包在</em>Java 归档*文件（JAR 文件）中。就像 CPU 不关心你用哪种编程语言来生成机器指令一样，JVM 也不关心你如何创建字节码。它不关心你是否使用 Scala、JRuby、Clojure，甚至是 Java 来创建 Java 字节码。一般来说，这个过程就像图 12-2 中所示的那样。</p>
<ol>
<li>Java 编译器读取源代码。</li>
<li>编译器输出字节码，通常是在一个 JAR 文件中。</li>
<li>JVM 执行字节码。</li>
<li>VM 向 CPU 发送机器指令。</li>
</ol>
<p>当有人说 Clojure 在 JVM 上运行时，他们的意思之一是 Clojure 程序被编译成 Java 字节码，JVM 进程执行它们。从操作的角度来看，这意味着你对待 Clojure 程序和 Java 程序是一样的。你把它们编译成 JAR 文件，并使用<code>java</code>命令运行它们。如果客户需要一个在 JVM 上运行的程序，你可以偷偷地用 Clojure 而不是 Java 来编写，他们不会知道的。从外面看，你无法分辨 Java 和 Clojure 程序之间的区别，就像你无法分辨 C 和 C++程序之间的区别一样。Clojure 可以让你变得富有成效，而且是偷偷摸摸的。</p>
<p>！<a href=https://www.braveclojure.com/assets/images/cftbat/java/jvm-compile.png></a></p>
<p>图 12-2：Java 程序产生 JVM 字节码，但 JVM 仍然需要产生机器指令，就像 C 语言编译器一样。</p>
<h2 id=编写编译和运行一个-java-程序>编写、编译和运行一个 Java 程序<a hidden class=anchor aria-hidden=true href=#编写编译和运行一个-java-程序>#</a></h2>
<p>让我们来看看一个真正的 Java 程序是如何工作的。在本节中，你将了解到 Java 所使用的面向对象的范式。然后，你将用 Java 建立一个简单的海盗短语书。这将帮助你对 JVM 感到更加舒适，它将为即将到来的 Java 互操作（编写直接使用 Java 类、对象和方法的 Clojure 代码）一节做好准备，如果有一个恶棍试图在公海上破坏你的战利品，它就会派上用场。为了把所有的信息联系在一起，你将在本章的最后偷看一些 Clojure 的 Java 代码。</p>
<h3 id=面向对象的编程在世界最微小的果壳中的应用>面向对象的编程在世界最微小的果壳中的应用<a hidden class=anchor aria-hidden=true href=#面向对象的编程在世界最微小的果壳中的应用>#</a></h3>
<p>Java 是一种面向对象的语言，所以如果你想了解你在 Clojure 编程中使用 Java 库或编写 Java 互操作代码时发生了什么，你就需要了解面向对象编程（OOP）是如何工作的。你也会在 Clojure 文档中发现面向对象的术语，所以学习这些概念很重要。如果你精通 OOP，可以随意跳过本节。对于那些需要两分钟了解的人来说，这里是：OOP 的核心角色是<em>类</em>、<em>对象</em>和<em>方法</em>。</p>
<p>我认为对象是真正的、真正的、可笑的蠢货机器人。它们是那种永远不会引起哲学辩论的机器人，即强迫有知觉的生物进行永久的奴役的伦理。这些机器人只做两件事：他们响应命令和维护数据。在我的想象中，它们通过在小 Hello Kitty 剪贴板上写下东西来做这件事。</p>
<p>想象一下，一个制造这些机器人的工厂。机器人所理解的命令集和它所维护的数据集都是由制造机器人的工厂决定的。在 OOP 术语中，工厂对应于类，androids 对应于对象，而命令对应于方法。例如，你可能有一个<code>ScaryClown'工厂（类），它生产的androids（对象）响应</code>makeBalloonArt&rsquo;命令（方法）。这个安卓机一直跟踪它所拥有的气球的数量，然后在气球的数量发生变化时更新这个数字。它可以用<code>balloonCount</code>报告这个数字，用<code>receiveBalloons</code>接收任何数量的气球。下面是你如何与代表小丑 Belly Rubs 的 Java 对象进行交互。</p>
<pre tabindex=0><code>ScaryClown bellyRubsTheClown = new ScaryClown();
bellyRubsTheClown.balloonCount();
// =&gt; 0

bellyRubsTheClown.receiveBalloons(2);
bellyRubsTheClown.balloonCount();
// =&gt; 2

bellyRubsTheClown.makeBalloonArt();
// =&gt; &quot;Belly Rubs makes a balloon shaped like a clown, because Belly Rubs
// =&gt; is trying to scare you and nothing is scarier than clowns.&quot;
</code></pre><p>这个例子告诉你如何使用<code>ScaryClown</code>类创建一个新的对象<code>bellyRubsTheClown</code>。它还向你展示了如何在该对象上调用方法（如<code>气球计数'、</code>接收气球&rsquo;和`制作气球艺术'），大概是为了让你能吓唬孩子。</p>
<p>你应该知道 OOP 的最后一个方面，或者至少是它在 Java 中的实现方式，就是你也可以向工厂发送命令。在 OOP 术语中，你会说，类也有方法。例如，内置类<code>Math</code>有许多类方法，包括<code>Math.abs</code>，它返回一个数字的绝对值。</p>
<pre tabindex=0><code>Math.abs(-50)
// =&gt; 50
</code></pre><p>我希望这些小丑没有给你造成太大的创伤。现在让我们把你的 OOP 知识用在工作上吧!</p>
<h3 id=ahoy-world>Ahoy, World<a hidden class=anchor aria-hidden=true href=#ahoy-world>#</a></h3>
<p>继续前进，创建一个名为<em>phrasebook</em>的新目录。在该目录中，创建一个名为<em>PiratePhrases.java</em>的文件，并编写以下内容。</p>
<pre tabindex=0><code>public class PiratePhrases
{
    public static void main(String[] args)
    {
        System.out.println(&quot;Shiver me timbers!!&quot;);
    }
}
</code></pre><p>这个非常简单的程序将在你运行时向你的终端打印 &ldquo;Shiver me timbers!!!&ldquo;这句话。(这就是海盗说 &ldquo;你好，世界！&ldquo;的方式），当你运行它时，它将打印到你的终端。它由一个类<code>PiratePhrases</code>和一个属于该类的静态方法<code>main</code>组成。静态方法本质上是类的方法。</p>
<p>在你的终端，用 javac PiratePhrases.java 命令编译<code>PiratePhrases</code>源代码。如果你打的字都是正确的，**你的心是纯洁的，你应该看到一个名为<em>PiratePhrases.class</em>的文件。</p>
<pre tabindex=0><code>$ ls
PiratePhrases.class PiratePhrases.java
</code></pre><p>你刚刚编译了你的第一个 Java 程序，我的朋友! 现在用<code>java PiratePhrases</code>运行它。你应该看到这个。</p>
<pre tabindex=0><code>Shiver me timbers!!!
</code></pre><p>这里发生的事情是你用 Java 编译器<code>javac</code>创建了一个 Java 类文件，<em>PiratePhrases.class</em>。这个文件包含了大量的 Java 字节码（好吧，对于这么大的程序，也许只有一个字节）。</p>
<p>当你运行 &ldquo;java PiratePhrases &ldquo;时，JVM 首先查看了你的<em>classpath</em>，寻找一个名为 &ldquo;PiratePhrases &ldquo;的类。classpath 是文件系统的路径列表，JVM 通过搜索来寻找定义类的文件。默认情况下，classpath 包括你运行 java 时所在的目录。试着运行 java -classpath /tmp PiratePhrases，你会得到一个错误，尽管<em>PiratePhrases.class</em>就在你的当前目录中。</p>
<p>注意 你可以在你的 classpath 上有多个路径，如果你在 Mac 上或运行 Linux，可以用冒号隔开，如果你在使用 Windows，可以用分号。例如，classpath /tmp:/var/maven:.包括/tmp、/var/maven 和.目录。</p>
<p>在 Java 中，每个文件只允许有一个公有类，而且文件名必须与类名一致。这就是为什么<code>java</code>知道要尝试在<em>PiratePhrases.class</em>中寻找<code>PiratePhrases</code>类的字节码。在<code>java</code>找到<code>PiratePhrases</code>类的字节码后，它执行了该类的<code>main</code>方法。Java 与 C 语言类似，只要你说 &ldquo;运行某些东西，并使用这个类作为入口点&rdquo;，它就会一直运行这个类的<code>main'方法；因此，这个方法必须是</code>public'，你可以在`PiratePhrases&rsquo;的源代码中看到。</p>
<p>在下一节，你将学习如何处理跨越多个文件的程序代码，以及如何使用 Java 库。</p>
<h2 id=包和导入>包和导入<a hidden class=anchor aria-hidden=true href=#包和导入>#</a></h2>
<p>为了了解如何使用多文件程序和 Java 库，我们将编译并运行一个程序。本节对 Clojure 有直接的影响，因为你将使用同样的想法和术语来与 Java 库进行交互。</p>
<p>让我们从几个定义开始。</p>
<ul>
<li><strong>包</strong>与 Clojure 的命名空间类似，包提供了代码组织。包包含类，包名对应于文件系统的目录。如果一个文件中有 &ldquo;package com.shapemaster &ldquo;一行，那么目录<em>com/shapemaster</em>一定存在于你的 classpath 上。在该目录中会有定义类的文件。</li>
<li><strong>import</strong> Java 允许你导入类，这基本上意味着你可以不使用它们的命名空间前缀来引用它们。所以如果你在<code>com.shapemaster</code>中有一个名为<code>Square</code>的类，你可以在<code>.java</code>文件的顶部写上<code>import``com.shapemaster.Square;</code>或<code>import com.shapemaster.*;</code>，以便在你的代码中使用<code>Square</code>而不是<code>com.shapemaster.Square</code>。</li>
</ul>
<p>让我们试试使用<code>package</code>和<code>import</code>。在这个例子中，你将创建一个名为<code>pirate_phrases</code>的包，它有两个类，<code>问候'和</code>告别'。 首先，浏览你的<em>phrasebook</em>，在该目录下创建另一个目录，<em>pirate_phrases</em>。创建<em>pirate_phrases</em>是必要的，因为 Java 包的名称与文件系统的目录相对应。然后，在<em>pirate_phrases</em>目录下创建<em>Greetings.java</em>。</p>
<pre tabindex=0><code>➊ package pirate_phrases;

public class Greetings
{
    public static void hello()
    {
        System.out.println(&quot;Shiver me timbers!!!&quot;);
    }
}
</code></pre><p>在➊，<code>package pirate_phrases;</code>表示这个类将是<code>pirate_phrases</code>包的一部分。现在在<em>pirate_phrases</em>目录下创建<em>Farewells.java</em>。</p>
<pre tabindex=0><code>package pirate_phrases;

public class Farewells
{
    public static void goodbye()
    {
        System.out.println(&quot;A fair turn of the tide ter ye thar, ye magnificent sea friend!!&quot;);
    }
}
</code></pre><p>现在在<em>phrasebook</em>目录下创建<em>PirateConversation.java</em>。</p>
<pre tabindex=0><code>import pirate_phrases.*;

public class PirateConversation
{
    public static void main(String[] args)
    {
        Greetings greetings = new Greetings();
        greetings.hello();

        Farewells farewells = new Farewells();
        farewells.goodbye();
    }
}
</code></pre><p>第一行，<code>import pirate_phrases.*;</code>，导入了<code>pirate_phrases</code>包中的所有类，其中包含<code>问候'和</code>告别&rsquo;类。</p>
<p>如果你在<em>phrasebook</em>目录下运行<code>javac PirateConversation.java</code>，接着运行<code>java PirateConversation</code>，你应该看到这个。</p>
<pre tabindex=0><code>Shiver me timbers!!!
A fair turn of the tide ter ye thar, ye magnificent sea friend!!
</code></pre><p>亲爱的读者，她在那里吹了起来。她确实在吹。</p>
<p>注意，当你编译一个 Java 程序时，Java 会在你的 classpath 中搜索包。试着输入以下内容。</p>
<pre tabindex=0><code>cd pirate_phrases
javac ../PirateConversation.java
</code></pre><p>你会得到这个结果。</p>
<pre tabindex=0><code>../PirateConversation.java:1: error: package pirate_phrases does not exist
import pirate_phrases.*;
^
</code></pre><p>轰隆隆! Java 编译器刚刚告诉你，让你羞愧地垂下头来，也许还会哭泣一下。</p>
<p>为什么？它认为<code>pirate_phrases</code>包不存在。但这很愚蠢，对吗？你是在<em>pirate_phrases</em>目录下！你是在<em>pirate_phrases</em>目录下。</p>
<p>这里发生的情况是，默认的 classpath 只包括当前的目录，在这种情况下是<em>pirate_phrases</em>。 <code>javac</code>试图找到<em>phrasebook/pirate_phrases/pirate_phrases</em>目录，但该目录并不存在。当你在<em>phrasebook</em>目录下运行<code>javac ../PirateConversation.java</code>时，<code>javac</code>试图找到<em>phrasebook/pirate_phrases</em>目录，该目录确实存在。在不改变目录的情况下，尝试运行 javac -classpath ../ ../PirateConversation.java。吓我一跳，居然成功了! 这是因为你手动将 classpath 设置为<em>pirate_phrases</em>的父目录，也就是<em>phrasebook</em>。从那里，<code>javac</code>可以成功地找到<em>pirate_phrases</em>目录。</p>
<p>综上所述，包组织了代码，并要求有一个匹配的目录结构。导入类可以让你引用它们，而不需要预留整个类的包名。 <code>javac</code>和 Java 使用 classpath 查找包。</p>
<h2 id=jar-文件>JAR 文件<a hidden class=anchor aria-hidden=true href=#jar-文件>#</a></h2>
<p>JAR 文件允许你将所有的*.class<em>文件捆绑成一个单一的文件。导航到你的</em>phrasebook*目录并运行以下程序。</p>
<pre tabindex=0><code>jar cvfe conversation.jar PirateConversation PirateConversation.class
pirate_phrases/*.class
java -jar conversation.jar
</code></pre><p>这样就能正确显示海盗对话了。你把所有的类文件捆绑在<em>conversation.jar</em>中。使用<code>e</code>标志，你还指出<code>PirateConversation</code>类是<em>入口点</em>。入口点是包含 JAR 整体运行时应该执行的<code>main'方法的类，</code>jar&rsquo;将这些信息存储在 JAR 文件中的<em>META-INF/MANIFEST.MF</em>文件中。如果你要阅读该文件，它将包含这一行。</p>
<pre tabindex=0><code>Main-Class: PirateConversation
</code></pre><p>顺便说一下，当你执行 JAR 文件时，你不必担心你在哪个目录下，相对于文件而言。你可以换到<em>pirate_phrases</em>目录，然后运行<code>java -jar .../conversation.jar</code>，就可以正常工作了。原因是 JAR 文件维护了目录结构。你可以用 jar tf conversation.jar 查看它的内容，它的输出是这样的。</p>
<pre tabindex=0><code>META-INF/
meta-inf/manifest.mf
PirateConversation.class
pirate_phrases/Farewells.class
Pirate_phrases/Greetings.class
</code></pre><p>你可以看到，JAR 文件包括<em>pirate_phrases</em>目录。关于 JARs 还有一个有趣的事实：它们实际上只是带有*.jar*扩展名的 ZIP 文件。你可以像对待其他 ZIP 文件一样对待它们。</p>
<h2 id=clojurejar>clojure.jar<a hidden class=anchor aria-hidden=true href=#clojurejar>#</a></h2>
<p>现在你已经准备好看看 Clojure 在引擎盖下是如何工作的了! 下载[1.9.0 稳定版]（<a href=http://repo1.maven.org/maven2/org/clojure/clojure/1.7.0/clojure-1.9.0.zip>http://repo1.maven.org/maven2/org/clojure/clojure/1.7.0/clojure-1.9.0.zip</a>）并运行它。</p>
<pre tabindex=0><code>java -jar clojure-1.7.0.jar
</code></pre><p>你应该看到最舒心的景象，Clojure REPL。它究竟是如何启动的呢？让我们看看 JAR 文件中的<em>META-INF/MANIFEST.MF</em>。</p>
<pre tabindex=0><code>Manifest-Version: 1.0
Archiver-Version: Plexus Archiver
Created-By: Apache Maven
Built-By: hudson
Build-Jdk: 1.7.0_20
Main-Class: clojure.main
</code></pre><p>看起来，<code>clojure.main</code>被指定为入口点。这个类是怎么来的？嗯，看看 GitHub 上的<em>clojure/main.java</em>，网址是*<a href=https://github.com/clojure/clojure/blob/master/src/jvm/clojure/main.java>https://github.com/clojure/clojure/blob/master/src/jvm/clojure/main.java</a>*。</p>
<pre tabindex=0><code>/**
 *   Copyright (c) Rich Hickey. All rights reserved.
 *   The use and distribution terms for this software are covered by the
 *   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
 *   which can be found in the file epl-v10.html at the root of this distribution.
 *   By using this software in any fashion, you are agreeing to be bound by
 *   the terms of this license.
 *   You must not remove this notice, or any other, from this software.
 **/

package clojure;

import clojure.lang.Symbol;
import clojure.lang.Var;
import clojure.lang.RT;

public class main{

final static private Symbol CLOJURE_MAIN = Symbol.intern(&quot;clojure.main&quot;);
final static private Var REQUIRE = RT.var(&quot;clojure.core&quot;, &quot;require&quot;);
final static private Var LEGACY_REPL = RT.var(&quot;clojure.main&quot;, &quot;legacy-repl&quot;);
final static private Var LEGACY_SCRIPT = RT.var(&quot;clojure.main&quot;, &quot;legacy-script&quot;);
final static private Var MAIN = RT.var(&quot;clojure.main&quot;, &quot;main&quot;);

public static void legacy_repl(String[] args) {
    REQUIRE.invoke(CLOJURE_MAIN);
    LEGACY_REPL.invoke(RT.seq(args));
}

public static void legacy_script(String[] args) {
    REQUIRE.invoke(CLOJURE_MAIN);
    LEGACY_SCRIPT.invoke(RT.seq(args));
}

public static void main(String[] args) {
    REQUIRE.invoke(CLOJURE_MAIN);
    MAIN.applyTo(RT.seq(args));
}
}
</code></pre><p>正如你所看到的，该文件定义了一个名为<code>main</code>的类。它属于 &ldquo;clojure &ldquo;包，并定义了一个 &ldquo;公共静态 &ldquo;的 &ldquo;main &ldquo;方法，JVM 完全乐意将其作为一个入口点。以这种方式来看，Clojure 是一个 JVM 程序，就像其他程序一样。</p>
<p>这并不是一个深入的 Java 教程，但我希望它有助于澄清程序员在谈论 Clojure &ldquo;在 JVM 上运行 &ldquo;或成为一种 &ldquo;托管 &ldquo;语言时的意思。在下一节中，你将继续探索 JVM 的魅力，学习如何在你的 Clojure 项目中使用额外的 Java 库。</p>
<p>Clojure 应用程序 JARs</p>
<p>你现在知道 Java 是如何运行 Java JARs 的，但它是如何运行捆绑为 JARs 的 Clojure 应用程序的呢？毕竟，Clojure 应用程序没有类，不是吗？</p>
<p>事实证明，你可以通过在命名空间声明中加入<code>(:gen-class)</code>指令，让 Clojure 编译器为一个命名空间生成一个类。(你可以在你创建的第一个 Clojure 程序中看到这一点，即第一章的<em>clojure-noob</em>。还记得那个程序吗，小茶壶？） 这意味着编译器会产生必要的字节码，使 JVM 把命名空间当作定义了一个 Java 类。</p>
<p>你在程序的<em>project.clj</em>文件中，使用<code>:main</code>属性，为你的程序设置入口点的命名空间。对于<em>clojure-noob</em>，你应该看到<code>:main ^:skip-aot clojure-noob.core</code>。当 Leiningen 编译这个文件时，它将添加一个<em>meta-inf/manifest.mf</em>文件，该文件包含了生成的 JAR 文件的入口点。</p>
<p>因此，如果你在命名空间中定义了一个<code>-main</code>函数，并包括<code>(:gen-class)</code>指令，同时在你的<em>project.clj</em>文件中设置了<code>:main</code>，你的程序在被编译为 JAR 时，将拥有 Java 运行它所需的一切。你可以在你的终端中试用这个方法，浏览你的<em>clojure-noob</em>目录并运行这个。</p>
<pre tabindex=0><code>lein uberjar
java -jar target/uberjar/clojure-noob-0.1.0-SNAPSHOT-standalone.jar
</code></pre><p>你应该看到打印出来的两条信息。&ldquo;清洁度仅次于神性 &ldquo;和 &ldquo;I&rsquo;m a little teapot!&rdquo; 注意，你不需要 Leiningen 来运行这个 JAR 文件；你可以把它发送给朋友和邻居，只要他们安装了 Java，就可以运行它。</p>
<h2 id=java-interop>Java Interop<a hidden class=anchor aria-hidden=true href=#java-interop>#</a></h2>
<p>Rich Hickey 对 Clojure 的设计目标之一是创造一种<em>实用的语言。出于这个原因，Clojure 的设计是为了使你能够轻松地与 Java 类和对象进行交互，这意味着你可以使用 Java 广泛的本地功能和它的巨大生态系统。使用 Java 类、对象和方法的能力被称为</em>Java interop*。在本节中，你将学习如何使用 Clojure 的互操作语法，如何导入 Java 包，以及如何使用最常用的 Java 类。</p>
<h3 id=互通语法>互通语法<a hidden class=anchor aria-hidden=true href=#互通语法>#</a></h3>
<p>使用 Clojure 的互操作语法，与 Java 对象和类的交互是很直接的。让我们从对象互操作语法开始。</p>
<p>你可以使用<code>(.</code>methodName object)来调用一个对象的方法。例如，因为所有的 Clojure 字符串都是作为 Java 字符串实现的，所以你可以对它们调用 Java 方法。</p>
<pre tabindex=0><code>(.toUpperCase &quot;By Bluebeard's bananas!&quot; )
; =&gt; &quot;by bluebeard's bananas!&quot;

➊ (.indexOf &quot;Let's synergize our bleeding edges&quot; &quot;y&quot;) 
; =&gt; 7
</code></pre><p>这些等同于这个 Java。</p>
<pre tabindex=0><code>&quot;By Bluebeard's bananas!&quot;.toUpperCase()
&quot;Let's synergize our bleeding edges&quot;.indexOf(&quot;y&quot;)
</code></pre><p>注意，Clojure 的语法允许你向 Java 方法传递参数。在这个例子中，在➊，你把参数<code>"y"</code>传给了<code>indexOf</code>方法。</p>
<p>你也可以调用类上的静态方法和访问类的静态字段。观察一下!</p>
<pre tabindex=0><code>➊ (java.lang.Math/abs -3) 
; =&gt; 3

➋ java.lang.Math/PI 
; =&gt; 3.141592653589793
</code></pre><p>在➊，你调用了<code>java.lang.Math</code>类的<code>abs</code>静态方法，在➋，你访问了该类的<code>PI</code>静态字段。</p>
<p>所有这些例子（除了<code>java.lang.Math/PI</code>）都使用了扩展到使用*dot 特殊形式的宏。一般来说，你不需要使用点的特殊形式，除非你想写自己的宏来与 Java 对象和类交互。尽管如此，下面是每个例子后面的宏扩展。</p>
<pre tabindex=0><code>(macroexpand-1 '(.toUpperCase &quot;By Bluebeard's bananas!&quot;))
; =&gt; (. &quot;By Bluebeard's bananas!&quot; toUpperCase)

(macroexpand-1 '(.indexOf &quot;Let's synergize our bleeding edges&quot; &quot;y&quot;))
; =&gt; (. &quot;Let's synergize our bleeding edges&quot; indexOf &quot;y&quot;)

(macroexpand-1 '(Math/abs -3))
; =&gt; (. Math abs -3)
</code></pre><p>这是点运算符的一般形式。</p>
<pre tabindex=0><code>(. object-expr-or-classname-symbol method-or-member-symbol optional-args*)
</code></pre><p>点运算符还有一些功能，如果你有兴趣进一步探索它，你可以看看 clojure.org 关于 Java 互操作的文档*<a href=http://clojure.org/java_interop#Java%20Interop-The%20Dot%20special%20form>http://clojure.org/java_interop#Java%20Interop-The%20Dot%20special%20form</a>*。</p>
<p>创建和变异对象</p>
<p>上一节告诉你如何调用已经存在的对象的方法。本节向你展示如何创建新的对象以及如何与它们进行交互。</p>
<p>你可以通过两种方式创建一个新的对象。<code>(new ClassName optional-args)</code>和<code>(ClassName. optional-args)</code>。</p>
<pre tabindex=0><code>(new String)
; =&gt; &quot;&quot;

(String.)
; =&gt; &quot;&quot;

(String. &quot;To Davey Jones's Locker with ye hardies&quot;)
; =&gt; &quot;To Davey Jones's Locker with ye hardies&quot;
</code></pre><p>大多数人使用点的版本，<code>(ClassName.)</code>。</p>
<p>要修改一个对象，你要像上一节那样调用其上的方法。为了研究这个问题，让我们使用<code>java.util.Stack</code>。这个类代表了一个后进先出（LIFO）的对象堆栈，或者只是<em>堆栈</em>。<em>堆栈</em>是一种常见的数据结构，它们之所以被称为堆栈，是因为你可以把它们想象成一摞实物，比如说，一摞你刚刚掠夺来的金币。当你向你的堆栈添加一个硬币时，你就把它添加到堆栈的顶部。当你取出一枚金币时，你就把它从上面移走。因此，最后添加的对象就是第一个被移除的对象。</p>
<p>与 Clojure 数据结构不同，Java 堆栈是可变的。你可以向它们添加项目和删除项目，改变对象而不是派生出一个新的值。下面是你如何创建一个堆栈并向其添加一个对象。</p>
<pre tabindex=0><code>(java.util.Stack.)
; =&gt; []

➊ (let [stack (java.util.Stack.)] 
  (.push stack &quot;Latest episode of Game of Thrones, ho!&quot;)
  stack)
; =&gt; [&quot;Latest episode of Game of Thrones, ho!&quot;]
</code></pre><p>这里有几个有趣的细节。首先，你需要为<code>stack</code>创建一个<code>let</code>绑定，就像你在➊看到的那样，并把它作为<code>let</code>形式的最后一个表达式。如果你不这样做，整个表达式的值将是字符串<code>"Game of Thrones, ho!"</code>，因为那是<code>push</code>的返回值。</p>
<p>第二，Clojure 用方括号来打印堆栈，与它用于 Vector 的文本表示法相同，这可能会让你感到困惑，因为它不是一个 Vector。然而，你可以使用 Clojure 的<code>seq</code>函数来读取堆栈中的数据结构，比如<code>first</code>，。</p>
<pre tabindex=0><code>(let [stack (java.util.Stack.)]
  (.push stack &quot;Latest episode of Game of Thrones, ho!&quot;)
  (first stack))
; =&gt; &quot;Latest episode of Game of Thrones, ho!&quot;
</code></pre><p>但是你不能使用像<code>conj</code>和<code>into</code>这样的函数来添加元素到栈中。如果你这样做，你会得到一个异常。使用 Clojure 函数读取堆栈是可能的，因为 Clojure 扩展了对<code>java.util.Stack</code>的抽象，这个主题你将在第 13 章学习。</p>
<p>Clojure 提供了<code>doto</code>宏，它允许你更简洁地在同一个对象上执行多个方法。</p>
<pre tabindex=0><code>(doto (java.util.Stack.)
  (.push &quot;Latest episode of Game of Thrones, ho!&quot;)
  (.push &quot;Whoops, I meant 'Land, ho!'&quot;))
; =&gt; [&quot;Latest episode of Game of Thrones, ho!&quot; &quot;Whoops, I meant 'Land, ho!'&quot;]
</code></pre><p><code>doto</code>宏返回对象，而不是任何方法调用的返回值，它更容易理解。如果你用<code>macroexpand-1</code>展开它，你可以看到它的结构与你刚才在前面的例子中看到的<code>let</code>表达式相同。</p>
<pre tabindex=0><code>(macroexpand-1
 '(doto (java.util.Stack.)
    (.push &quot;Latest episode of Game of Thrones, ho!&quot;)
    (.push &quot;Whoops, I meant 'Land, ho!'&quot;)))
; =&gt; (clojure.core/let
      [G__2876 (java.util.Stack.)]
      (.push G__2876 &quot;Latest episode of Game of Thrones, ho!&quot;)
      (.push G__2876 &quot;Whoops, I meant 'Land, ho!'&quot;)
      G__2876)
</code></pre><p>很方便!</p>
<h3 id=导入>导入<a hidden class=anchor aria-hidden=true href=#导入>#</a></h3>
<p>在 Clojure 中，导入的效果和 Java 中的一样：你可以使用类，而不需要打出整个包的前缀。</p>
<pre tabindex=0><code>(import java.util.Stack)
(Stack.)
; =&gt; []
</code></pre><p>你也可以使用这种一般形式一次导入多个类。</p>
<pre tabindex=0><code>(import [package.name1 ClassName1 ClassName2]
        [package.name2 ClassName3 ClassName4])
</code></pre><p>下面是一个例子。</p>
<pre tabindex=0><code>(import [java.util Date Stack]
        [java.net Proxy URI])

(Date.)
; =&gt; #inst &quot;2016-09-19T20:40:02.733-00:00&quot;
</code></pre><p>但通常情况下，你会在<code>ns</code>宏中做所有的导入工作，像这样。</p>
<pre tabindex=0><code>(ns pirate.talk
  (:import [java.util Date Stack].
           [java.net Proxy URI])
</code></pre><p>这两种不同的导入类的方法有相同的结果，但通常第二种方法更可取，因为对于阅读你的代码的人来说，在<code>ns</code>声明中看到所有涉及命名的代码很方便。</p>
<p>这就是你导入类的方法! 很简单。为了使生活更加简单，Clojure 自动导入了<code>java.lang</code>中的类，包括<code>java.lang.String</code>和<code>java.lang.Math</code>，这就是为什么你能够使用<code>String</code>而不用前面的包名。</p>
<h2 id=常用的-java-类>常用的 Java 类<a hidden class=anchor aria-hidden=true href=#常用的-java-类>#</a></h2>
<p>为了完善本章，让我们快速浏览一下你最可能用到的 Java 类。</p>
<h3 id=系统类>系统类<a hidden class=anchor aria-hidden=true href=#系统类>#</a></h3>
<p>系统 &ldquo;类具有有用的类字段和方法，可以与程序运行的环境进行交互。你可以用它来获取环境变量，与标准输入、标准输出和错误输出流进行交互。</p>
<p>最有用的方法和成员是<code>exit</code>、<code>getenv</code>和<code>getProperty</code>。你可能在第 5 章中认识<code>System/exit</code>，在那里你用它来退出 Peg Thing 游戏。`System/exit&rsquo;可以终止当前程序，你可以把状态代码作为参数传给它。如果你对状态代码不熟悉，我推荐维基百科的 &ldquo;退出状态 &ldquo;文章，网址是*<a href=http://en.wikipedia.org/wiki/Exit_status>退出状态-维基百科</a>*。</p>
<p><code>System/getenv</code>将以 Map 形式返回所有系统的环境变量。</p>
<pre tabindex=0><code>(System/getenv)
{&quot;USER&quot; &quot;the-incredible-bulk&quot;
 &quot;JAVA_ARCH&quot; &quot;x86_64&quot; }
</code></pre><p>环境变量的一个常见用途是配置你的程序。</p>
<p>JVM 有自己的属性列表，与计算机的环境变量分开，如果需要读取它们，可以使用<code>System/getProperty</code>。</p>
<pre tabindex=0><code>➊ (System/getProperty &quot;user.dir&quot;)
; =&gt; &quot;/Users/dabulk/projects/dabook&quot;

➋ (System/getProperty &quot;java.version&quot;)
; =&gt; &quot;1.7.0_17&quot;
</code></pre><p>第一个调用➊返回 JVM 启动的目录，第二个调用➋返回 JVM 的版本。</p>
<h3 id=日期类>日期类<a hidden class=anchor aria-hidden=true href=#日期类>#</a></h3>
<p>Java 有很好的工具来处理日期问题。我不会对<code>java.util.Date</code>类做太多的介绍，因为在线的 API 文档（可在*<a href=http://docs.oracle.com/javase/7/docs/api/java/util/Date.html>Date (Java Platform SE 7 )</a>*)很详尽。作为一个 Clojure 开发者，你应该知道这个<code>date</code>类的三个特点。首先，Clojure 允许你使用这样的形式将日期表示为字面意义。</p>
<pre tabindex=0><code>#inst &quot;2016-09-19T20:40:02.733-00:00&quot;
</code></pre><p>第二，如果你想自定义如何将日期转换成字符串，或者你想将字符串转换成日期，你需要使用<code>java.util.DateFormat</code>类。第三，如果你要做的任务是比较日期或试图在日期上添加分钟、小时或其他时间单位，你应该使用极其有用的 clj-time 库（你可以在*<a href=https://github.com/clj-time/clj-time>GitHub - clj-time/clj-time: 一个用于 Clojure 的日期和时间库，包装了 Joda 时间库。</a>*)。</p>
<h2 id=文件和输入输出>文件和输入/输出<a hidden class=anchor aria-hidden=true href=#文件和输入输出>#</a></h2>
<p>在这一节中，你将了解到 Java 的输入/输出（IO）方法，以及 Clojure 如何简化它。<code>clojure.java.io</code>命名空间提供了许多方便的函数来简化 IO（<em><a href=https://clojure.github.io/clojure/clojure.java.io-api.html>clojure.java.io - Clojure v1.10.3 API 文档</a></em>）。这很好，因为 Java 的 IO 并不完全是简单的。因为在你的编程生涯中，你可能会在某些时候想要执行 IO，让我们开始把你的思想触角缠绕在它上面。</p>
<p>IO 涉及到资源，无论是文件、套接字、缓冲区，还是其他什么。Java 有独立的类来读取资源的内容，写入其内容，以及与资源的属性进行交互。</p>
<p>例如，<code>java.io.File</code>类用于与文件的属性进行交互。</p>
<pre tabindex=0><code>(let [file (java.io.File. &quot;/&quot;)]
➊   (println (.exists file))  
➋   (println (.canWrite file))
➌   (println (.getPath file))) 
; =&gt; true
; =&gt; false
; =&gt; /
</code></pre><p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/java/lion.png alt>
</p>
<p>在其他任务中，你可以用它来检查一个文件是否存在，获得文件的读/写/执行权限，并获得其文件系统路径，你可以在➊、➋和➌分别看到。</p>
<p>在这个能力列表中，明显缺少读和写。要读一个文件，你可以使用<code>java.io.BufferedReader</code>类或者<code>java.io.FileReader</code>。同样地，你可以使用<code>java.io.BufferedWriter</code>或<code>java.io.FileWriter</code>类来写。其他类也可用于读写，你选择哪一个取决于你的具体需求。读取器和写入器类的接口都有相同的基本方法集；读取器实现了<code>读取'、</code>关闭&rsquo;等，而写入器实现了<code>添加'、</code>写入'、<code>关闭'和</code>刷新'。Java 给你提供了各种 IO 工具。一个愤世嫉俗的人可能会说，Java 给你的绳子足以让你上吊，如果你找到这样一个人，我希望你能给他一个拥抱。</p>
<p>不管怎么说，Clojure 使你的读写更容易，因为它包括了统一不同种类资源的读写的函数。例如，<code>spit</code>写到一个资源，而<code>slurp</code>从一个资源中读出。下面是一个使用它们来写和读一个文件的例子。</p>
<pre tabindex=0><code>(spit &quot;/tmp/hercules-todo-list&quot;
&quot;- kill dat lion brov
- chop up what nasty multi-headed snake thing&quot;)

(slurp &quot;/tmp/hercules-todo-list&quot;)

; =&gt; &quot;- kill dat lion brov
      - chop up what nasty multi-headed snake thing&quot;
</code></pre><p>你也可以对代表文件以外的资源的对象使用这些函数。下一个例子使用了一个<code>StringWriter</code>，它允许你对一个字符串进行 IO 操作。</p>
<pre tabindex=0><code>(let [s (java.io.StringWriter.)]
  (spit s &quot;- capture cerynian hind like for real&quot;)
  (.toString s))
; =&gt; &quot;- capture cerynian hind like for real&quot;
</code></pre><p>你也可以使用 &ldquo;slurp &ldquo;从<code>StringReader</code>中读取。</p>
<pre tabindex=0><code>(let [s (java.io.StringReader. &quot;- get erymanthian pig what with the tusks&quot;)]
  (slurp s))
; =&gt; &quot;- get erymanthian pig what with the tusks&quot;
</code></pre><p>此外，你可以对资源使用<code>读</code>和<code>写</code>方法。使用哪种方法并没有什么区别；<code>spit</code>和<code>slurp</code>很方便，因为它们只需使用一个代表文件系统路径或 URL 的字符串。</p>
<p><code>with-open</code>宏是另一种便利：它在其主体的末尾隐含地关闭一个资源，确保你不会因为忘记手动关闭资源而意外地占用资源。<code>reader</code>函数是一个方便的工具，根据<code>clojure.java.io</code>API 文档，&ldquo;试图将其参数强制到一个开放的<code>java.io.Reader</code>"。当你不想使用<code>slurp</code>时，这很方便，因为你不想尝试完整地读取一个资源，你也不想弄清楚你需要使用哪个 Java 类。如果你想一行一行地读取一个文件，你可以使用<code>reader</code>和<code>with-open</code>以及<code>line-seq</code>函数。下面是如何打印 Hercules 待办事项清单的第一项的。</p>
<pre tabindex=0><code>(with-open [todo-list-rdr (clojure.java.io/reader &quot;/tmp/hercules-todo-list&quot;)]
  (println (first (line-seq todo-list-rdr))))
; =&gt; - kill dat lion brov
</code></pre><p>这应该足以让你在 Clojure 中开始使用 IO。如果你想做更复杂的任务，一定要看看<a href=https://clojure.github.io/clojure/clojure.java.io-api.html><code>clojure.java.io</code> docs</a>，<code>[java.nio.file](https://docs.oracle.com/javase/7/docs/api/java/nio/file/package-summary.html)</code>包文档，或<code>[java.io](http://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html)</code>包文档。</p>
<h2 id=资源>资源<a hidden class=anchor aria-hidden=true href=#资源>#</a></h2>
<ul>
<li>&ldquo;Java 虚拟机和编译器的解释&rdquo;。 <em><a href="https://www.youtube.com/watch?v=XjNwyXx2os8">Java 虚拟机和编译器的解释&ndash;YouTube</a></em></li>
<li>clojure.org Java 互操作文档。 <em><a href=http://clojure.org/java_interop>Clojure - Java Interop</a></em></li>
<li>维基百科的 &ldquo;退出状态 &ldquo;文章。 <em><a href=http://en.wikipedia.org/wiki/Exit_status>退出状态 - 维基百科</a></em></li>
</ul>
<h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2>
<p>在本章中，你了解了 Clojure 被托管在 JVM 上的含义。Clojure 程序被编译成 Java 字节码并在 JVM 进程中执行。Clojure 程序也可以访问 Java 库，你可以使用 Clojure 的互操作设施轻松地与它们交互。</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://zhenfeng-zhu.github.io/tags/clojure/>clojure</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://zhenfeng-zhu.github.io/posts/chapter13/>
<span class=title>« Prev Page</span>
<br>
<span>Chapter13 抽象</span>
</a>
<a class=next href=https://zhenfeng-zhu.github.io/posts/chapter11/>
<span class=title>Next Page »</span>
<br>
<span>Chapter11 core.async</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter12 与 Java 的互操作 on twitter" href="https://twitter.com/intent/tweet/?text=Chapter12%20%e4%b8%8e%20Java%20%e7%9a%84%e4%ba%92%e6%93%8d%e4%bd%9c&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter12%2f&hashtags=clojure"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter12 与 Java 的互操作 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter12%2f&title=Chapter12%20%e4%b8%8e%20Java%20%e7%9a%84%e4%ba%92%e6%93%8d%e4%bd%9c&summary=Chapter12%20%e4%b8%8e%20Java%20%e7%9a%84%e4%ba%92%e6%93%8d%e4%bd%9c&source=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter12%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter12 与 Java 的互操作 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter12%2f&title=Chapter12%20%e4%b8%8e%20Java%20%e7%9a%84%e4%ba%92%e6%93%8d%e4%bd%9c"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter12 与 Java 的互操作 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter12%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter12 与 Java 的互操作 on whatsapp" href="https://api.whatsapp.com/send?text=Chapter12%20%e4%b8%8e%20Java%20%e7%9a%84%e4%ba%92%e6%93%8d%e4%bd%9c%20-%20https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter12%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter12 与 Java 的互操作 on telegram" href="https://telegram.me/share/url?text=Chapter12%20%e4%b8%8e%20Java%20%e7%9a%84%e4%ba%92%e6%93%8d%e4%bd%9c&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter12%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer><script src=https://utteranc.es/client.js repo=zhenfeng-zhu/zhenfeng-zhu.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://zhenfeng-zhu.github.io>Awesome Fenix</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>