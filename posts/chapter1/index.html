<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Chapter1 构建、运行和 REPL | Awesome Fenix</title>
<meta name=keywords content="clojure">
<meta name=description content="构建、运行和 REPL 在本章中，你将预先投入少量时间来熟悉建立和运行 Clojure 程序的快速、傻瓜式方法。让一个真正的程序运行起来感觉很好。达到了这个里程碑，你就可以自由地进行实验，分享你的工作，并向那些仍在使用上个世纪的语言的同事幸灾乐祸。这将有助于保持你的积极性!
你还将学习如何使用*Read-Eval-Print Loop（REPL）*在一个正在运行的 Clojure 进程中即时运行代码，这使你能够快速测试你对语言的理解并更有效地学习。
但首先，我将简要地介绍 Clojure。接下来，我将介绍 Leiningen，这是 Clojure 事实上的标准构建工具。在本章结束时，你将知道如何做以下事情。
 用 Leiningen 创建一个新的 Clojure 项目 构建该项目以创建一个可执行的 JAR 文件 执行 JAR 文件 在 Clojure REPL 中执行代码  First Things First: 什么是 Clojure Clojure 是由 Rich Hickey 在一座神话般的火山中铸造的。他使用 Lisp、函数式编程和他自己的一绺史诗般的头发的合金，创造了一种令人愉快而强大的语言。它的 Lisp 遗产使你有能力写出比大多数非 Lisp 语言更有表现力的代码，而它对函数式编程的独特理解将使你作为一个程序员的思维更敏锐。此外，Clojure 为你提供了更好的工具来处理复杂的领域（如并发编程），这些领域在传统上被认为会使开发人员陷入多年的治疗中。
不过，在谈论 Clojure 时，重要的是要牢记 Clojure 语言和 Clojure 编译器之间的区别。Clojure 语言是一种强调函数的 Lisp 方言，其语法和语义与任何实现都无关。编译器是一个可执行的 JAR 文件，clojure.jar，它接收用 Clojure 语言编写的代码并将其编译为 Java 虚拟机（JVM）字节码。你会看到Clojure被用来指代语言和编译器，如果你不知道它们是独立的东西，就会感到困惑。但现在你意识到了，你就会好起来。
这种区分是必要的，因为与大多数编程语言如 Ruby、Python、C 和其他许多语言不同，Clojure 是一种托管语言。Clojure 程序在 JVM 中执行，并依赖 JVM 的核心功能，如线程和垃圾收集。Clojure 还针对 JavaScript 和微软的通用语言运行时（CLR），但本书只关注 JVM 的实现。">
<meta name=author content="Fenix">
<link rel=canonical href=https://zhenfeng-zhu.github.io/posts/chapter1/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zhenfeng-zhu.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://zhenfeng-zhu.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://zhenfeng-zhu.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://zhenfeng-zhu.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://zhenfeng-zhu.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-216295420-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Chapter1 构建、运行和 REPL">
<meta property="og:description" content="构建、运行和 REPL 在本章中，你将预先投入少量时间来熟悉建立和运行 Clojure 程序的快速、傻瓜式方法。让一个真正的程序运行起来感觉很好。达到了这个里程碑，你就可以自由地进行实验，分享你的工作，并向那些仍在使用上个世纪的语言的同事幸灾乐祸。这将有助于保持你的积极性!
你还将学习如何使用*Read-Eval-Print Loop（REPL）*在一个正在运行的 Clojure 进程中即时运行代码，这使你能够快速测试你对语言的理解并更有效地学习。
但首先，我将简要地介绍 Clojure。接下来，我将介绍 Leiningen，这是 Clojure 事实上的标准构建工具。在本章结束时，你将知道如何做以下事情。
 用 Leiningen 创建一个新的 Clojure 项目 构建该项目以创建一个可执行的 JAR 文件 执行 JAR 文件 在 Clojure REPL 中执行代码  First Things First: 什么是 Clojure Clojure 是由 Rich Hickey 在一座神话般的火山中铸造的。他使用 Lisp、函数式编程和他自己的一绺史诗般的头发的合金，创造了一种令人愉快而强大的语言。它的 Lisp 遗产使你有能力写出比大多数非 Lisp 语言更有表现力的代码，而它对函数式编程的独特理解将使你作为一个程序员的思维更敏锐。此外，Clojure 为你提供了更好的工具来处理复杂的领域（如并发编程），这些领域在传统上被认为会使开发人员陷入多年的治疗中。
不过，在谈论 Clojure 时，重要的是要牢记 Clojure 语言和 Clojure 编译器之间的区别。Clojure 语言是一种强调函数的 Lisp 方言，其语法和语义与任何实现都无关。编译器是一个可执行的 JAR 文件，clojure.jar，它接收用 Clojure 语言编写的代码并将其编译为 Java 虚拟机（JVM）字节码。你会看到Clojure被用来指代语言和编译器，如果你不知道它们是独立的东西，就会感到困惑。但现在你意识到了，你就会好起来。
这种区分是必要的，因为与大多数编程语言如 Ruby、Python、C 和其他许多语言不同，Clojure 是一种托管语言。Clojure 程序在 JVM 中执行，并依赖 JVM 的核心功能，如线程和垃圾收集。Clojure 还针对 JavaScript 和微软的通用语言运行时（CLR），但本书只关注 JVM 的实现。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhenfeng-zhu.github.io/posts/chapter1/">
<meta property="og:image" content="https://zhenfeng-zhu.github.io/posts/chapter1/https:/raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201152206174.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-13T10:26:48+08:00">
<meta property="article:modified_time" content="2022-01-13T10:26:48+08:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhenfeng-zhu.github.io/posts/chapter1/https:/raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201152206174.png">
<meta name=twitter:title content="Chapter1 构建、运行和 REPL">
<meta name=twitter:description content="构建、运行和 REPL 在本章中，你将预先投入少量时间来熟悉建立和运行 Clojure 程序的快速、傻瓜式方法。让一个真正的程序运行起来感觉很好。达到了这个里程碑，你就可以自由地进行实验，分享你的工作，并向那些仍在使用上个世纪的语言的同事幸灾乐祸。这将有助于保持你的积极性!
你还将学习如何使用*Read-Eval-Print Loop（REPL）*在一个正在运行的 Clojure 进程中即时运行代码，这使你能够快速测试你对语言的理解并更有效地学习。
但首先，我将简要地介绍 Clojure。接下来，我将介绍 Leiningen，这是 Clojure 事实上的标准构建工具。在本章结束时，你将知道如何做以下事情。
 用 Leiningen 创建一个新的 Clojure 项目 构建该项目以创建一个可执行的 JAR 文件 执行 JAR 文件 在 Clojure REPL 中执行代码  First Things First: 什么是 Clojure Clojure 是由 Rich Hickey 在一座神话般的火山中铸造的。他使用 Lisp、函数式编程和他自己的一绺史诗般的头发的合金，创造了一种令人愉快而强大的语言。它的 Lisp 遗产使你有能力写出比大多数非 Lisp 语言更有表现力的代码，而它对函数式编程的独特理解将使你作为一个程序员的思维更敏锐。此外，Clojure 为你提供了更好的工具来处理复杂的领域（如并发编程），这些领域在传统上被认为会使开发人员陷入多年的治疗中。
不过，在谈论 Clojure 时，重要的是要牢记 Clojure 语言和 Clojure 编译器之间的区别。Clojure 语言是一种强调函数的 Lisp 方言，其语法和语义与任何实现都无关。编译器是一个可执行的 JAR 文件，clojure.jar，它接收用 Clojure 语言编写的代码并将其编译为 Java 虚拟机（JVM）字节码。你会看到Clojure被用来指代语言和编译器，如果你不知道它们是独立的东西，就会感到困惑。但现在你意识到了，你就会好起来。
这种区分是必要的，因为与大多数编程语言如 Ruby、Python、C 和其他许多语言不同，Clojure 是一种托管语言。Clojure 程序在 JVM 中执行，并依赖 JVM 的核心功能，如线程和垃圾收集。Clojure 还针对 JavaScript 和微软的通用语言运行时（CLR），但本书只关注 JVM 的实现。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://zhenfeng-zhu.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Chapter1 构建、运行和 REPL","item":"https://zhenfeng-zhu.github.io/posts/chapter1/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Chapter1 构建、运行和 REPL","name":"Chapter1 构建、运行和 REPL","description":"构建、运行和 REPL 在本章中，你将预先投入少量时间来熟悉建立和运行 Clojure 程序的快速、傻瓜式方法。让一个真正的程序运行起来感觉很好。达到了这个里程碑，你就可以自由地进行实验，分享你的工作，并向那些仍在使用上个世纪的语言的同事幸灾乐祸。这将有助于保持你的积极性!\n你还将学习如何使用*Read-Eval-Print Loop（REPL）*在一个正在运行的 Clojure 进程中即时运行代码，这使你能够快速测试你对语言的理解并更有效地学习。\n但首先，我将简要地介绍 Clojure。接下来，我将介绍 Leiningen，这是 Clojure 事实上的标准构建工具。在本章结束时，你将知道如何做以下事情。\n 用 Leiningen 创建一个新的 Clojure 项目 构建该项目以创建一个可执行的 JAR 文件 执行 JAR 文件 在 Clojure REPL 中执行代码  First Things First: 什么是 Clojure Clojure 是由 Rich Hickey 在一座神话般的火山中铸造的。他使用 Lisp、函数式编程和他自己的一绺史诗般的头发的合金，创造了一种令人愉快而强大的语言。它的 Lisp 遗产使你有能力写出比大多数非 Lisp 语言更有表现力的代码，而它对函数式编程的独特理解将使你作为一个程序员的思维更敏锐。此外，Clojure 为你提供了更好的工具来处理复杂的领域（如并发编程），这些领域在传统上被认为会使开发人员陷入多年的治疗中。\n不过，在谈论 Clojure 时，重要的是要牢记 Clojure 语言和 Clojure 编译器之间的区别。Clojure 语言是一种强调函数的 Lisp 方言，其语法和语义与任何实现都无关。编译器是一个可执行的 JAR 文件，clojure.jar，它接收用 Clojure 语言编写的代码并将其编译为 Java 虚拟机（JVM）字节码。你会看到Clojure被用来指代语言和编译器，如果你不知道它们是独立的东西，就会感到困惑。但现在你意识到了，你就会好起来。\n这种区分是必要的，因为与大多数编程语言如 Ruby、Python、C 和其他许多语言不同，Clojure 是一种托管语言。Clojure 程序在 JVM 中执行，并依赖 JVM 的核心功能，如线程和垃圾收集。Clojure 还针对 JavaScript 和微软的通用语言运行时（CLR），但本书只关注 JVM 的实现。","keywords":["clojure"],"articleBody":"构建、运行和 REPL 在本章中，你将预先投入少量时间来熟悉建立和运行 Clojure 程序的快速、傻瓜式方法。让一个真正的程序运行起来感觉很好。达到了这个里程碑，你就可以自由地进行实验，分享你的工作，并向那些仍在使用上个世纪的语言的同事幸灾乐祸。这将有助于保持你的积极性!\n你还将学习如何使用*Read-Eval-Print Loop（REPL）*在一个正在运行的 Clojure 进程中即时运行代码，这使你能够快速测试你对语言的理解并更有效地学习。\n但首先，我将简要地介绍 Clojure。接下来，我将介绍 Leiningen，这是 Clojure 事实上的标准构建工具。在本章结束时，你将知道如何做以下事情。\n 用 Leiningen 创建一个新的 Clojure 项目 构建该项目以创建一个可执行的 JAR 文件 执行 JAR 文件 在 Clojure REPL 中执行代码  First Things First: 什么是 Clojure Clojure 是由 Rich Hickey 在一座神话般的火山中铸造的。他使用 Lisp、函数式编程和他自己的一绺史诗般的头发的合金，创造了一种令人愉快而强大的语言。它的 Lisp 遗产使你有能力写出比大多数非 Lisp 语言更有表现力的代码，而它对函数式编程的独特理解将使你作为一个程序员的思维更敏锐。此外，Clojure 为你提供了更好的工具来处理复杂的领域（如并发编程），这些领域在传统上被认为会使开发人员陷入多年的治疗中。\n不过，在谈论 Clojure 时，重要的是要牢记 Clojure 语言和 Clojure 编译器之间的区别。Clojure 语言是一种强调函数的 Lisp 方言，其语法和语义与任何实现都无关。编译器是一个可执行的 JAR 文件，clojure.jar，它接收用 Clojure 语言编写的代码并将其编译为 Java 虚拟机（JVM）字节码。你会看到Clojure被用来指代语言和编译器，如果你不知道它们是独立的东西，就会感到困惑。但现在你意识到了，你就会好起来。\n这种区分是必要的，因为与大多数编程语言如 Ruby、Python、C 和其他许多语言不同，Clojure 是一种托管语言。Clojure 程序在 JVM 中执行，并依赖 JVM 的核心功能，如线程和垃圾收集。Clojure 还针对 JavaScript 和微软的通用语言运行时（CLR），但本书只关注 JVM 的实现。\n稍后我们将更多地探讨 Clojure 和 JVM 之间的关系，但现在你需要了解的主要概念是这些。\n JVM 进程执行 Java 字节码。 通常情况下，Java 编译器从 Java 源代码中产生 Java 字节码。 JAR 文件是 Java 字节码的集合。 Java 程序通常以 JAR 文件分发。 Java 程序clojure.jar 读取 Clojure 源代码并产生 Java 字节码。 然后，该 Java 字节码由已经运行clojure.jar的同一 JVM 进程执行。  Clojure 继续发展。截至目前，Clojure 的版本为 1.9.0，开发工作正在进行中。如果你在遥远的未来读到这本书，并且 Clojure 有更高的版本号，不要担心！这本书涵盖了 Clojure 的所有内容。本书涵盖了 Clojure 的基础知识，这些知识在不同的版本中应该不会改变。没有必要让你的机器人管家把这本书退回给书店。\n现在你知道什么是 Clojure 了，让我们来实际构建一个该死的 Clojure 程序吧!\nlein new app clojure-noob 这个命令应该创建一个与此相似的目录结构（如果有一些差异也没关系）。\n| .gitignore | doc | | intro.md ➊ | project.clj | README.md ➋ | resources | src | | clojure_noob ➌ | | | core.clj ➍ | test | | clojure_noob | | | core_test.clj 这个项目骨架本身并不特别，也不像 Clojure 那样。它只是 Leiningen 使用的一种惯例。你将使用 Leiningen 来构建和运行 Clojure 应用程序，Leiningen 希望你的应用程序有这种结构。第一个需要注意的文件是位于➊的project.clj，它是 Leiningen 的一个配置文件。它可以帮助 Leiningen 回答这样的问题：“这个项目有什么依赖性？“和 “当这个 Clojure 程序运行时，什么函数应该先运行？” 一般来说，你会把你的源代码保存在src/。在这种情况下，位于➌的src/clojure_noob/core.clj文件就是你要写一段时间的 Clojure 代码的地方。位于➍的test目录显然包含了测试，而位于➋的resources是你存储图片等资产的地方。\n运行 Clojure 项目 现在让我们来实际运行这个项目。在你喜欢的编辑器中打开src/clojure_noob/core.clj。你应该看到这个。\n➊ (ns clojure-noob.core (:gen-class)) ➋ (defn -main \"I don't do a whole lot...yet.\" [\u0026 args] ➌ (println \"Hello, World!\")) ➊处的行声明了一个命名空间，你现在不需要担心这个问题。➋处的-main'函数是你的程序的*入口，这个话题将在附录A中介绍。现在，将➌处的 \"你好，世界！“改为 “我是一个小茶壶！\"。全行应该是(println \"I'm a little teapot!\"))。\n接下来，在你的终端导航到clojure_noob目录，然后输入。\nlein run 你应该看到输出\"我是一个小茶壶！\"恭喜你，小茶壶，你写并执行了一个程序！\"。\n当你阅读本书时，你会了解到更多关于程序中实际发生的事情，但现在你需要知道的是，你创建了一个函数，-main'，当你在命令行执行lein run’时，这个函数就会运行。\n构建 Clojure 项目 使用lein run对于尝试你的代码是很好的，但是如果你想与没有安装 Leiningen 的人分享你的工作，该怎么办？要做到这一点，你可以创建一个独立的文件，任何安装了 Java 的人（基本上就是所有人）都可以执行。要创建这个文件，请运行以下程序。\nlein uberjar 这个命令创建了target/uberjar/clojure-noob-0.1.0**-SNAPSHOT-standalone.jar文件。你可以通过运行这个命令使 Java 执行它。\njava -jar target/uberjar/clojure-noob-0.1.0-SNAPSHOT-standalone.jar 看看这个! 文件target/uberjar/clojure-noob-0.1.0-SNAPSHOT**-standalone.jar是你新的、获奖的 Clojure 程序，你可以在几乎任何平台上发布和运行。\n现在你已经掌握了构建、运行和分发（非常）基本的 Clojure 程序所需的所有基本细节。在后面的章节中，你会了解到更多的细节，当你运行前面的命令时，Leiningen 在做什么，对 Clojure 与 JVM 的关系以及你如何运行生产代码有了完整的了解。\n在我们进入第二章，讨论 Emacs 的神奇和荣耀之前，让我们来看看另一个重要的工具：REPL。\n使用 REPL REPL 是一个用于试验代码的工具。它允许你与正在运行的程序进行交互，并快速尝试各种想法。它通过向你提供一个提示，让你输入代码来实现这一目的。然后，它读取你的输入，评估它，打印结果，并循环，再次向你提供提示。\n这个过程实现了一个快速的反馈循环，这在大多数其他语言中是不可能的。我强烈建议你经常使用它，因为你能够在学习过程中快速检查你对 Clojure 的理解。除此之外，REPL 开发是 Lisp 体验的一个重要部分，如果你不使用它，你就真的错过了。\n要启动一个 REPL，请运行以下程序。\nlein repl 输出应该是这样的。\nnREPL server started on port 28925 REPL-y 0.1.10 Clojure 1.9.0 Exit: Control+D or (exit) or (quit) Commands: (user/help) Docs: (doc function-name-here) (find-doc \"part-of-name-here\") Source: (source function-name-here) (user/sourcery function-name-here) Javadoc: (javadoc java-object-or-class-here) Examples from clojuredocs.org: [clojuredocs or cdoc] (user/clojuredocs name-here) (user/clojuredocs \"ns-here\" \"name-here\") clojure-noob.core= 最后一行，clojure-noob.core=，告诉你，你在clojure-noob.core`命名空间中。你将在后面学习命名空间，但现在注意到命名空间基本上与你的src/clojure_noob/core.clj文件的名称一致。另外，注意到 REPL 显示的版本是Clojure 1.9.0，但如前所述，无论你使用哪个版本，一切都可以正常工作。\n该提示还表明你的代码在 REPL 中被加载，你可以执行被定义的函数。现在只有一个函数，-main，被定义了。现在就去执行它吧。\nclojure-noob.core= (-main) I'm a little teapot! nil 干得好! 你刚刚使用 REPL 评估了一个函数调用。试试几个更基本的 Clojure 函数。\nclojure-noob.core= (+ 1 2 3 4) 10 clojure-noob.core= (* 1 2 3 4) 24 clojure-noob.core= (first [1 2 3 4]) 1 真棒! 你加了一些数字，乘了一些数字，并从一个向量中取出了第一个元素。你还第一次接触到了奇怪的 Lisp 语法! 所有的 Lisp，包括 Clojure，都采用前缀符号，这意味着运算符在表达式中总是排在第一位。如果你不确定这意味着什么，不要担心。你很快就会了解到 Clojure 的所有语法。\n从概念上讲，REPL 类似于安全外壳（SSH）。就像你可以使用 SSH 与远程服务器交互一样，Clojure REPL 允许你与正在运行的 Clojure 进程交互。这项功能可以非常强大，因为你甚至可以将 REPL 附加到一个实时生产的应用程序，并在它运行时修改你的程序。不过现在，你将使用 REPL 来建立你对 Clojure 语法和语义的了解。\n还有一点要注意：今后，本书将介绍没有 REPL 提示的代码，但请尝试一下这些代码! 下面是一个例子。\n(do (println \"no prompt here!\") (+ 1 3)) ; = no prompt here! ; = 4 当你看到这样的代码片段时，以；=开头的行表示正在运行的代码的输出。在这种情况下，应该打印出这里没有提示'的文字，代码的返回值是4'。\nClojure 编辑器 到此为止，你应该已经具备了开始学习 Clojure 语言所需的基本知识，而不需要对编辑器或集成开发环境（IDE）大费周章。但如果你确实想要一个关于强大编辑器的好教程，第 2 章涉及 Emacs，这是 Clojurists 中最受欢迎的编辑器。你绝对不需要在 Clojure 开发中使用 Emacs，但 Emacs 提供了与 Clojure REPL 的紧密集成，非常适合编写 Lisp 代码。然而，最重要的是，你要使用适合你的东西。\n如果 Emacs 不是你的那杯茶，这里有一些为 Clojure 开发设置其他文本编辑器和 IDE 的资源。\n 这个 YouTube 视频将告诉你如何为 Clojure 开发设置 Sublime Text 2。 - YouTube。 Vim 有很好的工具用于 Clojure 开发。这篇文章是一个很好的起点。 Writing Clojure With Vim In 2013 - mybuddymichael.com。 Counterclockwise 是一个强烈推荐的 Eclipse 插件。GoogleCodeHome - ccw-ide/ccw Wiki - GitHub。 Cursive Clojure 是推荐给那些使用 IntelliJ 的 IDE： https://cursiveclojure.com/。 Nightcode 是一个用 Clojure 编写的简单、免费的 IDE。 GitHub - oakes/Nightcode: An IDE for Clojure。  总结 我真为你感到骄傲，小茶壶。你已经运行了你的第一个 Clojure 程序! 不仅如此，你还熟悉了 REPL，这是开发 Clojure 软件的最重要工具之一。太神奇了! 这让我想起了我个人英雄之一的《万岁》中的不朽名句。\n You held your head like a hero\nOn a history book page\nIt was the end of a decade\nBut the start of an age\n—Taylor Swift\n 好样的!\n","wordCount":"510","inLanguage":"en","image":"https://zhenfeng-zhu.github.io/posts/chapter1/https:/raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201152206174.png","datePublished":"2022-01-13T10:26:48+08:00","dateModified":"2022-01-13T10:26:48+08:00","author":{"@type":"Person","name":"Fenix"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhenfeng-zhu.github.io/posts/chapter1/"},"publisher":{"@type":"Organization","name":"Awesome Fenix","logo":{"@type":"ImageObject","url":"https://zhenfeng-zhu.github.io/favicon.ico"}}}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8502076734034112" crossorigin=anonymous></script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhenfeng-zhu.github.io accesskey=h title="Awesome Fenix (Alt + H)">Awesome Fenix</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://zhenfeng-zhu.github.io/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/about title=About>
<span>About</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/search/ title=🔍>
<span>🔍</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://zhenfeng-zhu.github.io>Home</a>&nbsp;»&nbsp;<a href=https://zhenfeng-zhu.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Chapter1 构建、运行和 REPL
</h1>
<div class=post-meta><span title="2022-01-13 10:26:48 +0800 +0800">January 13, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Fenix&nbsp;|&nbsp;<a href=https://github.com/zhenfeng-zhu/zhenfeng-zhu.github.io/tree/main/content/posts/Chapter1.md rel="noopener noreferrer" target=_blank>修改本文章</a>
</div>
</header>
<figure class=entry-cover><img loading=lazy src=https://raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201152206174.png alt>
<p></p>
</figure><div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e6%9e%84%e5%bb%ba%e8%bf%90%e8%a1%8c%e5%92%8c-repl aria-label="构建、运行和 REPL">构建、运行和 REPL</a><ul>
<li>
<a href=#first-things-first-%e4%bb%80%e4%b9%88%e6%98%af-clojure aria-label="First Things First: 什么是 Clojure">First Things First: 什么是 Clojure</a><ul>
<li>
<a href=#%e8%bf%90%e8%a1%8c-clojure-%e9%a1%b9%e7%9b%ae aria-label="运行 Clojure 项目">运行 Clojure 项目</a></li>
<li>
<a href=#%e6%9e%84%e5%bb%ba-clojure-%e9%a1%b9%e7%9b%ae aria-label="构建 Clojure 项目">构建 Clojure 项目</a></li>
<li>
<a href=#%e4%bd%bf%e7%94%a8-repl aria-label="使用 REPL">使用 REPL</a></li></ul>
</li>
<li>
<a href=#clojure-%e7%bc%96%e8%be%91%e5%99%a8 aria-label="Clojure 编辑器">Clojure 编辑器</a></li>
<li>
<a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=构建运行和-repl>构建、运行和 REPL<a hidden class=anchor aria-hidden=true href=#构建运行和-repl>#</a></h1>
<p>在本章中，你将预先投入少量时间来熟悉建立和运行 Clojure 程序的快速、傻瓜式方法。让一个真正的程序运行起来感觉很好。达到了这个里程碑，你就可以自由地进行实验，分享你的工作，并向那些仍在使用上个世纪的语言的同事幸灾乐祸。这将有助于保持你的积极性!</p>
<p>你还将学习如何使用*Read-Eval-Print Loop（REPL）*在一个正在运行的 Clojure 进程中即时运行代码，这使你能够快速测试你对语言的理解并更有效地学习。</p>
<p>但首先，我将简要地介绍 Clojure。接下来，我将介绍 Leiningen，这是 Clojure 事实上的标准构建工具。在本章结束时，你将知道如何做以下事情。</p>
<ul>
<li>用 Leiningen 创建一个新的 Clojure 项目</li>
<li>构建该项目以创建一个可执行的 JAR 文件</li>
<li>执行 JAR 文件</li>
<li>在 Clojure REPL 中执行代码</li>
</ul>
<h2 id=first-things-first-什么是-clojure>First Things First: 什么是 Clojure<a hidden class=anchor aria-hidden=true href=#first-things-first-什么是-clojure>#</a></h2>
<p>Clojure 是由 Rich Hickey 在一座神话般的火山中铸造的。他使用 Lisp、函数式编程和他自己的一绺史诗般的头发的合金，创造了一种令人愉快而强大的语言。它的 Lisp 遗产使你有能力写出比大多数非 Lisp 语言更有表现力的代码，而它对函数式编程的独特理解将使你作为一个程序员的思维更敏锐。此外，Clojure 为你提供了更好的工具来处理复杂的领域（如并发编程），这些领域在传统上被认为会使开发人员陷入多年的治疗中。</p>
<p>不过，在谈论 Clojure 时，重要的是要牢记 Clojure 语言和 Clojure 编译器之间的区别。Clojure 语言是一种强调函数的 Lisp 方言，其语法和语义与任何实现都无关。编译器是一个可执行的 JAR 文件，<em>clojure.jar</em>，它接收用 Clojure 语言编写的代码并将其编译为 Java 虚拟机（JVM）字节码。你会看到<em>Clojure</em>被用来指代语言和编译器，如果你不知道它们是独立的东西，就会感到困惑。但现在你意识到了，你就会好起来。</p>
<p>这种区分是必要的，因为与大多数编程语言如 Ruby、Python、C 和其他许多语言不同，Clojure 是一种<em>托管语言</em>。Clojure 程序在 JVM 中执行，并依赖 JVM 的核心功能，如线程和垃圾收集。Clojure 还针对 JavaScript 和微软的通用语言运行时（CLR），但本书只关注 JVM 的实现。</p>
<p>稍后我们将更多地探讨 Clojure 和 JVM 之间的关系，但现在你需要了解的主要概念是这些。</p>
<ul>
<li>JVM 进程执行 Java 字节码。</li>
<li>通常情况下，Java 编译器从 Java 源代码中产生 Java 字节码。</li>
<li>JAR 文件是 Java 字节码的集合。</li>
<li>Java 程序通常以 JAR 文件分发。</li>
<li>Java 程序<em>clojure.jar</em> 读取 Clojure 源代码并产生 Java 字节码。</li>
<li>然后，该 Java 字节码由已经运行<em>clojure.jar</em>的同一 JVM 进程执行。</li>
</ul>
<p>Clojure 继续发展。截至目前，Clojure 的版本为 1.9.0，开发工作正在进行中。如果你在遥远的未来读到这本书，并且 Clojure 有更高的版本号，不要担心！这本书涵盖了 Clojure 的所有内容。本书涵盖了 Clojure 的基础知识，这些知识在不同的版本中应该不会改变。没有必要让你的机器人管家把这本书退回给书店。</p>
<p>现在你知道什么是 Clojure 了，让我们来实际构建一个该死的 Clojure 程序吧!</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>lein <span style=color:#66d9ef>new </span>app clojure-noob
</code></pre></div><p>这个命令应该创建一个与此相似的目录结构（如果有一些差异也没关系）。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=color:#960050;background-color:#1e0010>|</span> .gitignore
<span style=color:#960050;background-color:#1e0010>|</span> doc
<span style=color:#960050;background-color:#1e0010>|</span> <span style=color:#960050;background-color:#1e0010>|</span> intro.md
<span style=color:#960050;background-color:#1e0010>➊</span> <span style=color:#960050;background-color:#1e0010>|</span> project.clj
<span style=color:#960050;background-color:#1e0010>|</span> README.md
<span style=color:#960050;background-color:#1e0010>➋</span> <span style=color:#960050;background-color:#1e0010>|</span> resources
<span style=color:#960050;background-color:#1e0010>|</span> src
<span style=color:#960050;background-color:#1e0010>|</span> <span style=color:#960050;background-color:#1e0010>|</span> clojure_noob
<span style=color:#960050;background-color:#1e0010>➌</span> <span style=color:#960050;background-color:#1e0010>|</span> <span style=color:#960050;background-color:#1e0010>|</span> <span style=color:#960050;background-color:#1e0010>|</span> core.clj
<span style=color:#960050;background-color:#1e0010>➍</span> <span style=color:#960050;background-color:#1e0010>|</span> test
<span style=color:#960050;background-color:#1e0010>|</span> <span style=color:#960050;background-color:#1e0010>|</span> clojure_noob
<span style=color:#960050;background-color:#1e0010>|</span> <span style=color:#960050;background-color:#1e0010>|</span> <span style=color:#960050;background-color:#1e0010>|</span> core_test.clj
</code></pre></div><p>这个项目骨架本身并不特别，也不像 Clojure 那样。它只是 Leiningen 使用的一种惯例。你将使用 Leiningen 来构建和运行 Clojure 应用程序，Leiningen 希望你的应用程序有这种结构。第一个需要注意的文件是位于➊的<em>project.clj</em>，它是 Leiningen 的一个配置文件。它可以帮助 Leiningen 回答这样的问题：&ldquo;这个项目有什么依赖性？&ldquo;和 &ldquo;当这个 Clojure 程序运行时，什么函数应该先运行？&rdquo; 一般来说，你会把你的源代码保存在<em>src/&lt;project_name></em>。在这种情况下，位于➌的<em>src/clojure_noob/core.clj</em>文件就是你要写一段时间的 Clojure 代码的地方。位于➍的<em>test</em>目录显然包含了测试，而位于➋的<em>resources</em>是你存储图片等资产的地方。</p>
<h3 id=运行-clojure-项目>运行 Clojure 项目<a hidden class=anchor aria-hidden=true href=#运行-clojure-项目>#</a></h3>
<p>现在让我们来实际运行这个项目。在你喜欢的编辑器中打开<em>src/clojure_noob/core.clj</em>。你应该看到这个。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=color:#960050;background-color:#1e0010>➊</span> (<span style=color:#66d9ef>ns </span>clojure-noob.core
  (<span style=color:#e6db74>:gen-class</span>))

<span style=color:#960050;background-color:#1e0010>➋</span> (<span style=color:#66d9ef>defn </span>-main
  <span style=color:#e6db74>&#34;I don&#39;t do a whole lot...yet.&#34;</span>
  [<span style=color:#f92672>&amp;</span> args]
<span style=color:#960050;background-color:#1e0010>➌</span>   (println <span style=color:#e6db74>&#34;Hello, World!&#34;</span>))
</code></pre></div><p>➊处的行声明了一个命名空间，你现在不需要担心这个问题。➋处的<code>-main'函数是你的程序的*入口，这个话题将在附录A中介绍。现在，将➌处的 "你好，</code>世界！&ldquo;改为 &ldquo;我是一个小茶壶！"。全行应该是<code>(println "I'm a little teapot!"))</code>。</p>
<p>接下来，在你的终端导航到<em>clojure_noob</em>目录，然后输入。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>lein run
</code></pre></div><p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/getting-started/teapot.png alt>
</p>
<p>你应该看到输出<code>"我是一个小茶壶！"</code>恭喜你，小茶壶，你写并执行了一个程序！"。</p>
<p>当你阅读本书时，你会了解到更多关于程序中实际发生的事情，但现在你需要知道的是，你创建了一个函数，<code>-main'，当你在命令行执行</code>lein run&rsquo;时，这个函数就会运行。</p>
<h3 id=构建-clojure-项目>构建 Clojure 项目<a hidden class=anchor aria-hidden=true href=#构建-clojure-项目>#</a></h3>
<p>使用<code>lein run</code>对于尝试你的代码是很好的，但是如果你想与没有安装 Leiningen 的人分享你的工作，该怎么办？要做到这一点，你可以创建一个独立的文件，任何安装了 Java 的人（基本上就是所有人）都可以执行。要创建这个文件，请运行以下程序。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>lein uberjar
</code></pre></div><p>这个命令创建了<em>target/uberjar/clojure-noob-0.1.0**-SNAPSHOT-standalone.jar</em>文件。你可以通过运行这个命令使 Java 执行它。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>java -jar target/uberjar/clojure-noob-0.1.0-SNAPSHOT-standalone.jar
</code></pre></div><p>看看这个! 文件<em>target/uberjar/clojure-noob-0.1.0-SNAPSHOT**-standalone.jar</em>是你新的、获奖的 Clojure 程序，你可以在几乎任何平台上发布和运行。</p>
<p>现在你已经掌握了构建、运行和分发（非常）基本的 Clojure 程序所需的所有基本细节。在后面的章节中，你会了解到更多的细节，当你运行前面的命令时，Leiningen 在做什么，对 Clojure 与 JVM 的关系以及你如何运行生产代码有了完整的了解。</p>
<p>在我们进入第二章，讨论 Emacs 的神奇和荣耀之前，让我们来看看另一个重要的工具：REPL。</p>
<h3 id=使用-repl>使用 REPL<a hidden class=anchor aria-hidden=true href=#使用-repl>#</a></h3>
<p>REPL 是一个用于试验代码的工具。它允许你与正在运行的程序进行交互，并快速尝试各种想法。它通过向你提供一个提示，让你输入代码来实现这一目的。然后，它<em>读取</em>你的输入，<em>评估</em>它，<em>打印</em>结果，并<em>循环</em>，再次向你提供提示。</p>
<p>这个过程实现了一个快速的反馈循环，这在大多数其他语言中是不可能的。我强烈建议你经常使用它，因为你能够在学习过程中快速检查你对 Clojure 的理解。除此之外，REPL 开发是 Lisp 体验的一个重要部分，如果你不使用它，你就真的错过了。</p>
<p>要启动一个 REPL，请运行以下程序。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>lein repl
</code></pre></div><p>输出应该是这样的。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>nREPL server started on port <span style=color:#ae81ff>28925</span>
REPL-y <span style=color:#ae81ff>0.1</span>.10
Clojure <span style=color:#ae81ff>1.9</span>.0
    Exit<span style=color:#960050;background-color:#1e0010>:</span> Control+D or (<span style=color:#a6e22e>exit</span>) or (<span style=color:#a6e22e>quit</span>)
Commands<span style=color:#960050;background-color:#1e0010>:</span> (<span style=color:#a6e22e>user/help</span>)
    Docs<span style=color:#960050;background-color:#1e0010>:</span> (doc function-name-here)
          (find-doc <span style=color:#e6db74>&#34;part-of-name-here&#34;</span>)
  Source<span style=color:#960050;background-color:#1e0010>:</span> (<span style=color:#a6e22e>source</span> function-name-here)
          (<span style=color:#a6e22e>user/sourcery</span> function-name-here)
 Javadoc<span style=color:#960050;background-color:#1e0010>:</span> (<span style=color:#a6e22e>javadoc</span> java-object-or-class-here)
Examples from clojuredocs.org<span style=color:#960050;background-color:#1e0010>:</span> [clojuredocs or cdoc]
          (<span style=color:#a6e22e>user/clojuredocs</span> name-here)
          (<span style=color:#a6e22e>user/clojuredocs</span> <span style=color:#e6db74>&#34;ns-here&#34;</span> <span style=color:#e6db74>&#34;name-here&#34;</span>)
clojure-noob.core=&gt;
</code></pre></div><p>最后一行，<code>clojure-noob.core=></code>，告诉你，你在<code>clojure</code>-noob.core`命名空间中。你将在后面学习命名空间，但现在注意到命名空间基本上与你的<em>src/<strong>clojure_noob</strong>/core.clj</em>文件的名称一致。另外，注意到 REPL 显示的版本是<em>Clojure 1.9.0</em>，但如前所述，无论你使用哪个版本，一切都可以正常工作。</p>
<p>该提示还表明你的代码在 REPL 中被加载，你可以执行被定义的函数。现在只有一个函数，<code>-main</code>，被定义了。现在就去执行它吧。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>clojure-noob.core=&gt; (<span style=color:#a6e22e>-main</span>)
I<span style=color:#e6db74>&#39;m</span> a little teapot!
nil
</code></pre></div><p>干得好! 你刚刚使用 REPL 评估了一个函数调用。试试几个更基本的 Clojure 函数。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>clojure-noob.core=&gt; (+ <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span>)
<span style=color:#ae81ff>10</span>
clojure-noob.core=&gt; (* <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span>)
<span style=color:#ae81ff>24</span>
clojure-noob.core=&gt; (first [<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span>])
<span style=color:#ae81ff>1</span>
</code></pre></div><p>真棒! 你加了一些数字，乘了一些数字，并从一个向量中取出了第一个元素。你还第一次接触到了奇怪的 Lisp 语法! 所有的 Lisp，包括 Clojure，都采用<em>前缀符号</em>，这意味着运算符在表达式中总是排在第一位。如果你不确定这意味着什么，不要担心。你很快就会了解到 Clojure 的所有语法。</p>
<p>从概念上讲，REPL 类似于安全外壳（SSH）。就像你可以使用 SSH 与远程服务器交互一样，Clojure REPL 允许你与正在运行的 Clojure 进程交互。这项功能可以非常强大，因为你甚至可以将 REPL 附加到一个实时生产的应用程序，并在它运行时修改你的程序。不过现在，你将使用 REPL 来建立你对 Clojure 语法和语义的了解。</p>
<p>还有一点要注意：今后，本书将介绍没有 REPL 提示的代码，但请尝试一下这些代码! 下面是一个例子。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>do </span>(println <span style=color:#e6db74>&#34;no prompt here!&#34;</span>)
   (+ <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>3</span>))
<span style=color:#75715e>; =&gt; no prompt here!</span>
<span style=color:#75715e>; =&gt; 4</span>
</code></pre></div><p>当你看到这样的代码片段时，以<code>；=></code>开头的行表示正在运行的代码的输出。在这种情况下，应该打印出<code>这里没有提示'的文字，代码的返回值是</code>4'。</p>
<h2 id=clojure-编辑器>Clojure 编辑器<a hidden class=anchor aria-hidden=true href=#clojure-编辑器>#</a></h2>
<p>到此为止，你应该已经具备了开始学习 Clojure 语言所需的基本知识，而不需要对编辑器或集成开发环境（IDE）大费周章。但如果你确实想要一个关于强大编辑器的好教程，第 2 章涉及 Emacs，这是 Clojurists 中最受欢迎的编辑器。你绝对不需要在 Clojure 开发中使用 Emacs，但 Emacs 提供了与 Clojure REPL 的紧密集成，非常适合编写 Lisp 代码。然而，最重要的是，你要使用适合你的东西。</p>
<p>如果 Emacs 不是你的那杯茶，这里有一些为 Clojure 开发设置其他文本编辑器和 IDE 的资源。</p>
<ul>
<li>这个 YouTube 视频将告诉你如何为 Clojure 开发设置 Sublime Text 2。  <em><a href="http://www.youtube.com/watch?v=wBl0rYXQdGg/">- YouTube</a></em>。</li>
<li>Vim 有很好的工具用于 Clojure 开发。这篇文章是一个很好的起点。 <em><a href=http://mybuddymichael.com/writings/writing-clojure-with-vim-in-2013.html>Writing Clojure With Vim In 2013 - mybuddymichael.com</a></em>。</li>
<li>Counterclockwise 是一个强烈推荐的 Eclipse 插件。<em><a href=https://github.com/laurentpetit/ccw/wiki/GoogleCodeHome>GoogleCodeHome - ccw-ide/ccw Wiki - GitHub</a></em>。</li>
<li>Cursive Clojure 是推荐给那些使用 IntelliJ 的 IDE： <em><a href=https://cursiveclojure.com/>https://cursiveclojure.com/</a></em>。</li>
<li>Nightcode 是一个用 Clojure 编写的简单、免费的 IDE。 <em><a href=https://github.com/oakes/Nightcode/>GitHub - oakes/Nightcode: An IDE for Clojure</a></em>。</li>
</ul>
<h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2>
<p>我真为你感到骄傲，小茶壶。你已经运行了你的第一个 Clojure 程序! 不仅如此，你还熟悉了 REPL，这是开发 Clojure 软件的最重要工具之一。太神奇了! 这让我想起了我个人英雄之一的《万岁》中的不朽名句。</p>
<blockquote>
<p>You held your head like a hero<br>
On a history book page<br>
It was the end of a decade<br>
But the start of an age<br>
—Taylor Swift</p>
</blockquote>
<p>好样的!</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://zhenfeng-zhu.github.io/tags/clojure/>clojure</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://zhenfeng-zhu.github.io/posts/chapter2/>
<span class=title>« Prev Page</span>
<br>
<span>Chapter2 如何使用 Emacs</span>
</a>
<a class=next href=https://zhenfeng-zhu.github.io/posts/introduction/>
<span class=title>Next Page »</span>
<br>
<span>Introduction</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter1 构建、运行和 REPL on twitter" href="https://twitter.com/intent/tweet/?text=Chapter1%20%e6%9e%84%e5%bb%ba%e3%80%81%e8%bf%90%e8%a1%8c%e5%92%8c%20REPL&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter1%2f&hashtags=clojure"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter1 构建、运行和 REPL on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter1%2f&title=Chapter1%20%e6%9e%84%e5%bb%ba%e3%80%81%e8%bf%90%e8%a1%8c%e5%92%8c%20REPL&summary=Chapter1%20%e6%9e%84%e5%bb%ba%e3%80%81%e8%bf%90%e8%a1%8c%e5%92%8c%20REPL&source=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter1 构建、运行和 REPL on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter1%2f&title=Chapter1%20%e6%9e%84%e5%bb%ba%e3%80%81%e8%bf%90%e8%a1%8c%e5%92%8c%20REPL"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter1 构建、运行和 REPL on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter1 构建、运行和 REPL on whatsapp" href="https://api.whatsapp.com/send?text=Chapter1%20%e6%9e%84%e5%bb%ba%e3%80%81%e8%bf%90%e8%a1%8c%e5%92%8c%20REPL%20-%20https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter1 构建、运行和 REPL on telegram" href="https://telegram.me/share/url?text=Chapter1%20%e6%9e%84%e5%bb%ba%e3%80%81%e8%bf%90%e8%a1%8c%e5%92%8c%20REPL&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter1%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer><script src=https://utteranc.es/client.js repo=zhenfeng-zhu/zhenfeng-zhu.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://zhenfeng-zhu.github.io>Awesome Fenix</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>