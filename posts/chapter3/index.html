<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Chapter3 | Awesome Fenix</title>
<meta name=keywords content="clojure">
<meta name=description content="做事情：Clojure 速成班 是时候学习如何用 Clojure 真正地做事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。
在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!
当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!
语法 Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。
形式 所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。
 数据结构的字面表示（如数字、字符串、Map 和向量） 操作  我们使用术语form来指代有效的代码。我有时也会用表达式来指代 Clojure 形式。但不要太纠结于术语。Clojure 评价每一个表单，以产生一个值。这些字面表达都是有效的形式。
1 &#34;a string&#34; [&#34;a&#34; &#34;vector&#34; &#34;of&#34; &#34;strings&#34;] 当然，你的代码很少包含自由浮动的字元，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你做事情的方式。所有操作的形式都是：*开括号，*操作符，*操作数，闭括号。
(operator operand1 operand2 ... operandn) 请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。
(+ 1 2 3) ; => 6 (str &#34;It was the panda &#34; &#34;in the library &#34; &#34;with a dust buster&#34;) ; => &#34;It was the panda in the library with a dust buster&#34; 在第一个操作中，运算符+将操作数1、2和3相加。在第二个操作中，运算符str将三个字符串连接起来，形成一个新的字符串。这两种形式都是有效的。这里有一个不是形式的东西，因为它没有一个结束的小括号。">
<meta name=author content="Fenix">
<link rel=canonical href=https://zhenfeng-zhu.github.io/posts/chapter3/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zhenfeng-zhu.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://zhenfeng-zhu.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://zhenfeng-zhu.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://zhenfeng-zhu.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://zhenfeng-zhu.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-216295420-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Chapter3">
<meta property="og:description" content="做事情：Clojure 速成班 是时候学习如何用 Clojure 真正地做事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。
在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!
当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!
语法 Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。
形式 所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。
 数据结构的字面表示（如数字、字符串、Map 和向量） 操作  我们使用术语form来指代有效的代码。我有时也会用表达式来指代 Clojure 形式。但不要太纠结于术语。Clojure 评价每一个表单，以产生一个值。这些字面表达都是有效的形式。
1 &#34;a string&#34; [&#34;a&#34; &#34;vector&#34; &#34;of&#34; &#34;strings&#34;] 当然，你的代码很少包含自由浮动的字元，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你做事情的方式。所有操作的形式都是：*开括号，*操作符，*操作数，闭括号。
(operator operand1 operand2 ... operandn) 请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。
(+ 1 2 3) ; => 6 (str &#34;It was the panda &#34; &#34;in the library &#34; &#34;with a dust buster&#34;) ; => &#34;It was the panda in the library with a dust buster&#34; 在第一个操作中，运算符+将操作数1、2和3相加。在第二个操作中，运算符str将三个字符串连接起来，形成一个新的字符串。这两种形式都是有效的。这里有一个不是形式的东西，因为它没有一个结束的小括号。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhenfeng-zhu.github.io/posts/chapter3/"><meta property="og:image" content="https://zhenfeng-zhu.github.io/papermod-cover.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-13T11:12:19+08:00">
<meta property="article:modified_time" content="2022-01-13T11:12:19+08:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhenfeng-zhu.github.io/papermod-cover.png">
<meta name=twitter:title content="Chapter3">
<meta name=twitter:description content="做事情：Clojure 速成班 是时候学习如何用 Clojure 真正地做事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。
在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!
当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!
语法 Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。
形式 所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。
 数据结构的字面表示（如数字、字符串、Map 和向量） 操作  我们使用术语form来指代有效的代码。我有时也会用表达式来指代 Clojure 形式。但不要太纠结于术语。Clojure 评价每一个表单，以产生一个值。这些字面表达都是有效的形式。
1 &#34;a string&#34; [&#34;a&#34; &#34;vector&#34; &#34;of&#34; &#34;strings&#34;] 当然，你的代码很少包含自由浮动的字元，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你做事情的方式。所有操作的形式都是：*开括号，*操作符，*操作数，闭括号。
(operator operand1 operand2 ... operandn) 请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。
(+ 1 2 3) ; => 6 (str &#34;It was the panda &#34; &#34;in the library &#34; &#34;with a dust buster&#34;) ; => &#34;It was the panda in the library with a dust buster&#34; 在第一个操作中，运算符+将操作数1、2和3相加。在第二个操作中，运算符str将三个字符串连接起来，形成一个新的字符串。这两种形式都是有效的。这里有一个不是形式的东西，因为它没有一个结束的小括号。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://zhenfeng-zhu.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Chapter3","item":"https://zhenfeng-zhu.github.io/posts/chapter3/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Chapter3","name":"Chapter3","description":"做事情：Clojure 速成班 是时候学习如何用 Clojure 真正地做事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。\n在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!\n当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!\n语法 Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。\n形式 所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。\n 数据结构的字面表示（如数字、字符串、Map 和向量） 操作  我们使用术语form来指代有效的代码。我有时也会用表达式来指代 Clojure 形式。但不要太纠结于术语。Clojure 评价每一个表单，以产生一个值。这些字面表达都是有效的形式。\n1 \u0026quot;a string\u0026quot; [\u0026quot;a\u0026quot; \u0026quot;vector\u0026quot; \u0026quot;of\u0026quot; \u0026quot;strings\u0026quot;] 当然，你的代码很少包含自由浮动的字元，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你做事情的方式。所有操作的形式都是：*开括号，*操作符，*操作数，闭括号。\n(operator operand1 operand2 ... operandn) 请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。\n(+ 1 2 3) ; =\u0026gt; 6 (str \u0026quot;It was the panda \u0026quot; \u0026quot;in the library \u0026quot; \u0026quot;with a dust buster\u0026quot;) ; =\u0026gt; \u0026quot;It was the panda in the library with a dust buster\u0026quot; 在第一个操作中，运算符+将操作数1、2和3相加。在第二个操作中，运算符str将三个字符串连接起来，形成一个新的字符串。这两种形式都是有效的。这里有一个不是形式的东西，因为它没有一个结束的小括号。","keywords":["clojure"],"articleBody":"做事情：Clojure 速成班 是时候学习如何用 Clojure 真正地做事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。\n在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!\n当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!\n语法 Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。\n形式 所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。\n 数据结构的字面表示（如数字、字符串、Map 和向量） 操作  我们使用术语form来指代有效的代码。我有时也会用表达式来指代 Clojure 形式。但不要太纠结于术语。Clojure 评价每一个表单，以产生一个值。这些字面表达都是有效的形式。\n1 \"a string\" [\"a\" \"vector\" \"of\" \"strings\"] 当然，你的代码很少包含自由浮动的字元，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你做事情的方式。所有操作的形式都是：*开括号，*操作符，*操作数，闭括号。\n(operator operand1 operand2 ... operandn) 请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。\n(+ 1 2 3) ; = 6 (str \"It was the panda \" \"in the library \" \"with a dust buster\") ; = \"It was the panda in the library with a dust buster\" 在第一个操作中，运算符+将操作数1、2和3相加。在第二个操作中，运算符str将三个字符串连接起来，形成一个新的字符串。这两种形式都是有效的。这里有一个不是形式的东西，因为它没有一个结束的小括号。\n(+ Clojure 的结构统一性可能与你所习惯的不同。在其他语言中，不同的操作可能有不同的结构，这取决于操作符和操作数。例如，JavaScript 采用的是 infix 符号、点运算符和小括号的大杂烩。\n1 + 2 + 3 \"It was the panda \".concat(\"in the library \", \"with a dust buster\") 相比之下，Clojure 的结构是非常简单和一致的。无论你使用哪种运算符，或对哪种数据进行操作，其结构都是一样的。\n控制流 让我们来看看三个基本的控制流操作符。if, do, 和when。在本书中，你会遇到更多的操作，但这些操作可以让你开始。\nif 这是一个 “if “表达式的一般结构。\n(if boolean-form then-form optional-else-form) 布尔形式只是一个评估为真值或假值的形式。你会在下一节中了解到真实性和虚假性。下面是几个`if’的例子。\n(if true \"By Zeus's hammer!\" \"By Aquaman's trident!\") ; = \"By Zeus's hammer!\" (if false \"By Zeus's hammer!\" \"By Aquaman's trident!\") ; = \"By Aquaman's trident!\" 第一个例子返回 “靠宙斯的锤子！\"，因为其布尔形式评估为 “true”，是一个真实的值；第二个例子返回 “靠阿卡曼的三叉戟！\"，因为其布尔形式 “false”，评估为一个错误的值。\n你也可以省略else分支。如果你这样做，并且布尔表达式是假的，Clojure 会返回nil，就像这样。\n(if false \"By Odin's Elbow!\") ; = nil 注意if使用操作数位置将操作数与then和else分支联系起来：第一个操作数是then分支，第二个操作数是（可选）else分支。因此，每个分支只能有一种形式。这与大多数语言不同。例如，你可以在 Ruby 中这样写。\nif true doer.do_thing(1) doer.do_thing(2) else other_doer.do_thing(1) other_doer.do_thing(2) end 为了绕过这个明显的限制，你可以使用do操作符。\ndo do操作符可以让你在括号中包裹起多个表单，并运行其中的每一个。在你的 REPL 中尝试以下操作。\n(if true (do (println \"Success!\") \"By Zeus's hammer!\") (do (println \"Failure!\") \"By Aquaman's trident!\")) ; = Success! ; = \"By Zeus's hammer!\" 这个操作符让你在if表达式的每个分支中做多件事情。在这种情况下，会发生两件事。成功！被打印在 REPL 中，\"通过宙斯的锤子！\"被作为整个if表达式的值返回。\nwhen when操作符就像if和do的组合，但没有else分支。下面是一个例子。\n(when true (println \"Success!\") \"abra cadabra\") ; = Success! ; = \"abra cadabra\" 如果你想在某个条件为真时做多件事，而你总是想在条件为假时返回nil'，请使用when`。\nnil, true, false, Truthiness, Equality, and Boolean Expressions Clojure 有true和false值。nil在 Clojure 中用来表示没有值。你可以用适当命名的nil?函数来检查一个值是否为nil。\n(nil? 1) ; = false (nil? nil) ; = true nil和false都是用来表示逻辑上的虚假性，而所有其他的值都是逻辑上的真实性。Truthy和falsey指的是在布尔表达式中如何处理一个值，比如传递给if的第一个表达式。\n(if \"bears eat beets\" \"bears beets Battlestar Galactica\") ; = \"bears beets Battlestar Galactica\" (if nil \"This won't be the result because nil is falsey\" \"nil is falsey\") ; = \"nil is falsey\" 在第一个例子中，字符串\"熊吃甜菜\"被认为是真实的，所以if表达式评估为\"熊吃甜菜Battlestar Galactica\"。第二个例子显示一个假值是假的。\nClojure 的平等运算符是=。\n(= 1 1) ; = true (= nil nil) ; = true (= 1 2) ; = false 其他一些语言要求你在比较不同类型的值时使用不同的运算符。例如，你可能不得不使用某种专门为字符串制作的特殊字符串平等运算符。但在使用 Clojure 的内置数据结构时，你不需要像这样奇怪或繁琐的东西来测试平等性。\nClojure 使用布尔运算符or和and。or返回第一个真值或最后一个值。and返回第一个错误的值，如果没有错误的值，则返回最后一个真实的值。让我们先看一下or。\n(or false nil :large_I_mean_venti :why_cant_I_just_say_large) ; = :large_I_mean_venti (or (= 0 1) (= \"yes\" \"no\")) ; = false (or nil) ; = nil 在第一个例子中，返回值是:large_I_mean_venti，因为它是第一个真值。第二个例子没有真值，所以or返回最后一个值，即false。在最后一个例子中，同样没有真值存在，or返回最后一个值，即nil。现在我们来看看and。\n(and :free_wifi :hot_coffee) ; = :hot_coffee (and :feelin_super_cool nil false) ; = nil 在第一个例子中，and返回最后一个真值，:hot_coffee。在第二个例子中, and返回nil, 这是第一个错误的值.\n用 def 命名数值 在 Clojure 中, 你可以使用def将一个名字与一个值结合起来:\n(def failed-protagonist-names [\"Larry Potter\" \"Doreen the Explorer\" \"The Incredible Bulk\"]) failed-protagonist-names ; = [\"Larry Potter\" \"Doreen the Explorer\" \"The Incredible Bulk\"] 在这个例子中，你把名字failed-protagonist-names绑定到一个包含三个字符串的向量（你将在“向量 “第 45 页中了解向量）。\n请注意，我使用的是 “绑定 “一词，而在其他语言中，你会说你是在给一个变量赋值。那些其他语言通常鼓励你对同一个变量进行多次赋值。\n例如，在 Ruby 中，你可以对一个变量进行多次赋值，以建立它的值。\nseverity = :mild error_message = \"OH GOD! IT'S A DISASTER! WE'RE \" if severity == :mild error_message = error_message + \"MILDLY INCONVENIENCED!\" else error_message = error_message + \"DOOOOOOOMED!\" end 你可能想在 Clojure 中做类似的事情。\n(def severity :mild) (def error-message \"OH GOD! IT'S A DISASTER! WE'RE \") (if (= severity :mild) (def error-message (str error-message \"MILDLY INCONVENIENCED!\")) (def error-message (str error-message \"DOOOOOOOMED!\"))) 然而，像这样改变与名字相关的值会使你更难理解你的程序的行为，因为更难知道哪个值是与名字相关的，或者为什么这个值可能已经改变了。Clojure 有一套处理变化的工具，你会在第 10 章中了解到。随着你对 Clojure 的学习，你会发现你很少需要改变一个名字/值的关联。下面是你写前面代码的一种方式。\n(defn error-message [severity] (str \"OH GOD! IT'S A DISASTER! WE'RE \" (if (= severity :mild) \"MILDLY INCONVENIENCED!\" \"DOOOOOOOMED!\"))) (error-message :mild) ; = \"OH GOD! IT'S A DISASTER! WE'RE MILDLY INCONVENIENCED!\" 这里，你创建了一个函数，error-message，它接受一个参数，severity，并使用它来决定返回哪个字符串。然后你用:mild作为严重程度来调用这个函数。你将在“函数 “第 48 页中学习所有关于创建函数的知识；与此同时，你应该把def当作定义常量。在接下来的几章中，你将学习如何通过接受函数式编程范式来处理这个明显的限制。\n数据结构 Clojure 带有少量的数据结构，你在大多数时候都会用到。如果你来自面向对象的背景，你会惊讶于你可以用这里介绍的看似基本的类型做很多事情。\nClojure 的所有数据结构都是不可改变的，这意味着你不能在原地改变它们。例如，在 Ruby 中，你可以做以下事情来重新分配索引为 0 的失败主角的名字。\nfailed_protagonist_names = [ \"Larry Potter\", \"Doreen the Explorer\", \"The Incredible Bulk\" ] failed_protagonist_names[0] = \"Gary Potter\" failed_protagonist_names # = [ # \"Gary Potter\", # \"Doreen the Explorer\", # \"The Incredible Bulk\" # ] Clojure 没有与之对应的东西。你会在第 10 章中了解到更多关于 Clojure 这样实现的原因，但现在只学习如何做事情，而不考虑所有的哲学问题，这很有趣。不多说了，让我们来看看 Clojure 中的数字。\n数字 Clojure 有相当复杂的数字支持。我不会花太多时间纠缠于无聊的技术细节（比如强制和传染），因为那会妨碍做事情。如果你对这些枯燥的细节感兴趣，请查看*http://clojure.org/data_**structures#Data%20Structures-Numbers*的文档。可以说，Clojure 会很高兴地处理你扔给它的几乎所有东西。\n在此期间，我们将使用整数和浮点数。我们还将使用比率，Clojure 可以直接表示这些比率。下面分别是一个整数、一个浮点数和一个比率。\n93 1.2 1/5 字符串 字符串代表文本。这个名字来自于古代腓尼基人，他们在一次涉及纱线的事故后，有一天发明了字母表。下面是一些字符串字面的例子。\n\"Lord Voldemort\" \"\\\"He who must not be named\\\"\" \"\\\"Great cow of Moscow!\\\" - Hermes Conrad\" 注意，Clojure 只允许用双引号来划分字符串。例如，“Lord Voldemort “就不是一个有效的字符串。还要注意，Clojure 没有字符串插值。它只允许通过str函数进行连接。\n(def name \"Chewbacca\") (str \"\\\"Uggllglglglglglll\\\" - \" name) ; = \"Uggllglglglglglll\" - Chewbacca Map Map 类似于其他语言中的字典或哈希值。它们是一种将一些值与另一些值联系起来的方式。Clojure 中的两种 Map 是哈希 Map 和排序 Map。我将只介绍更基本的哈希图。让我们来看看 Map 字面的一些例子。这里有一个空 Map。\n{} 在这个例子中，:first-name和:last-name是关键字（我将在下一节介绍这些）。\n{:first-name \"Charlie\" :last-name \"McFishwich\"} 这里我们把\"string-key\"和+函数联系起来。\n{\"string-key\" +} Map 可以被嵌套。\n{:name {:first \"John\" :middle \"Jacob\" :last \"Jingleheimerschmidt\"}}. 注意，Map 的值可以是任何类型–字符串、数字、Map、向量，甚至函数。Clojure 并不关心这个问题。\n除了使用 map 字面，你还可以使用hash-map函数来创建一个 map。\n(hash-map :a 1 :b 2) ; = {:a 1 :b 2}. 你可以用get函数在 Map 中查询数值。\n(get {:a 0 :b 1} :b) ; = 1 (get {:a 0 :b {:c \"ho hum\"}} :b) ; = {:c \"ho hum\"} 在这两个例子中，我们向get询问给定 Map 中:b键的值–在第一个例子中，它返回1，而在第二个例子中，它返回嵌套 Map{:c \"ho hum\"}。\n如果没有找到你的键，get将返回nil'，或者你可以给它一个默认值，例如“独角兽？\"`。\n(get {:a 0 :b 1} :c) ; = nil (get {:a 0 :b 1} :c \"unicorns?\") ; = \"unicorns?\" get-in函数可以让你在嵌套 Map 中查询数值。\n(get-in {:a 0 :b {:c \"ho hum\"}} [:b :c]) ; = \"ho hum\" 另一种在 Map 中查询数值的方法是把 Map 当作一个以键为参数的函数。\n({:name \"The Human Coffeepot\"} :name) ; = \"The Human Coffeepot\" 你可以用 Map 做的另一件很酷的事情是把 Keywords 作为函数来查询它们的值，这就引出了下一个主题，Keywords。\nKeywords 了解 Clojure 关键字的最好方法是看它们是如何被使用的。正如你在上一节中所看到的，它们主要是作为 Map 中的键来使用。下面是一些 Keywords 的例子。\n:a :rumplestiltsken :34 :_? Keywords 可以作为函数使用，在数据结构中查找相应的值。例如，你可以在一个 Map 中查找:a。\n(:a {:a 1 :b 2 :c 3}) ; = 1 这相当于。\n(get {:a 1 :b 2 :c 3} :a) ; = 1 你可以提供一个默认值，和get一样。\n(:d {:a 1 :b 2 :c 3} \"No gnome knows homes like Noah knows\") ; = \"No gnome knows homes like Noah knows\" 使用关键字作为一个函数是令人愉快的简洁，Real Clojurists 一直在这样做。你也应该这样做!\n矢量 向量类似于数组, 它是一个以 0 为索引的 Set。例如, 下面是一个向量的字面意思:\n[3 2 1] 这里我们要返回一个向量的第 0 个元素。\n(get [3 2 1] 0) ; = 3 下面是另一个按索引获取的例子。\n(get [\"a\" {:name \"Pugsley Winterbottom\"} \"c\"] 1) ; = {:name \"Pugsley Winterbottom\"} 你可以看到，向量元素可以是任何类型，而且你可以混合类型。还注意到我们使用的get函数与我们在 Map 中查找数值时使用的相同。\n你可以用vector函数来创建向量。\n(vector \"creepy\" \"full\" \"moon\") ; = [\"creepy\" \"full\" \"moon\"] 你可以使用conj函数来添加额外的元素到向量中。元素被添加到向量的*端。\n(conj [1 2 3] 4) ; = [1 2 3 4] 向量不是存储序列的唯一方法；Clojure 还有列表。\nLists Lists 与向量类似，它们都是数值的线性 Set。但也有一些区别。例如，你不能用get检索列表元素。要写一个列表的字面意思, 只需将元素插入括号内, 并在开头使用单引号:\n'(1 2 3 4) ; = (1 2 3 4) 注意，当 REPL 打印出列表时，它不包括单引号。我们将在后面的第 7 章中再来讨论为什么会这样。如果你想从一个列表中检索一个元素，你可以使用 nth 函数。\n(nth '(:a :b :c) 0) ; = :a (nth '(:a :b :c) 2) ; = :c 我在本书中没有详细介绍性能，因为我认为在你熟悉一种语言之后再关注它是没有用的。然而，知道使用nth从列表中检索一个元素比使用get从向量中检索一个元素要慢一些是很好的。这是因为 Clojure 必须遍历一个列表中的所有n个元素才能到达n个，而通过索引访问一个向量元素最多只需要几跳。\n列表值可以有任何类型，你可以用list函数创建列表。\n(list 1 \"two\" {3 4}) ; = (1 \"二\" {3 4}) 元素被添加到一个列表的开头。\n(conj '(1 2 3) 4) ; = (4 1 2 3) 什么时候应该使用列表，什么时候应该使用向量？一个好的经验法则是，如果你需要很容易地把项目添加到一个序列的开头，或者你正在写一个宏，你应该使用一个列表。否则，你应该使用矢量。随着你学习的深入，你会对何时使用哪种方法有很好的感觉。\nSet Set 是唯一值的 Set。Clojure 有两种类型的 Set：哈希 Set 和排序 Set。我将专注于哈希集，因为它们更经常被使用。下面是一个哈希集的文字符号。\n#{\"kurt vonnegut\" 20 :icicle}. 你也可以用hash-set来创建一个 Set:\n(hash-set 1 1 2 2) ; = #{1 2} 注意，一个值的多个实例在 Set 中成为一个唯一的值，所以我们只剩下一个1和一个2。如果你试图将一个值添加到一个已经包含该值的 Set 中（比如下面代码中的:b），它仍然只有一个该值。\n( conj #{:a :b} :b) ; = #{:a :b} 你也可以通过使用set函数从现有的向量和列表中创建 Set。\n(set [3 3 3 4 4]) ; = #{3 4} 你可以使用contains?函数来检查 Set 的成员资格，通过使用get，或通过使用关键字作为函数，以 Set 为参数。contains?返回true或false，而get和关键字查找将返回存在的值，如果不存在，则返回nil。\n下面是你如何使用contains?。\n(contains? #{:a :b} :a) ; = true (contains? #{:a :b} 3) ; = false (contains? #{nil} nil) ; = true 下面是你如何使用关键字。\n(:a #{:a :b}) ; = :a 这里是你如何使用get的方法。\n(get #{:a :b} :a) ; = :a (get #{:a nil} nil) ; = nil (get #{:a :b} \"kurt vonnegut\") ; = nil 注意，使用get来测试一个 Set 是否包含nil，将总是返回nil，这令人困惑。当你专门测试 Set 成员时，contains?可能是更好的选择。\n简单性 你可能已经注意到，到目前为止，对数据结构的处理并不包括对如何创建新类型或类的描述。原因是 Clojure 对简单性的强调鼓励你首先去接触内置的数据结构。\n如果你来自面向对象的背景，你可能会认为这种方法很奇怪而且落后。然而，你会发现，你的数据不一定非要和一个类紧密地捆绑在一起，才是有用和可理解的。这里有一个被 Clojurists 喜爱的寓言故事，暗示了 Clojure 的哲学。\n 让 100 个函数操作一个数据结构比让 10 个函数操作 10 个数据结构要好。 -Alan Perlis\n 在接下来的章节中，你会了解到更多关于 Clojure 哲学的这个方面。现在，请留意你通过坚持使用基本数据结构来获得代码重用性的方法。\n我们的 Clojure 数据结构入门课程到此结束。现在，是时候深入到函数中去，学习如何使用这些数据结构了\n函数 人们为 Lisps 疯狂的原因之一是，这些语言可以让你建立起行为复杂的程序，但主要的构件–函数–却是如此简单。本节通过解释以下内容，让你开始了解 Lisp 函数的美丽和优雅。\n 调用函数 函数与宏和特殊形式有什么不同 定义函数 匿名函数 返回函数  调用函数 现在你已经看到了许多函数调用的例子。\n(+ 1 2 3 4) (* 1 2 3 4) (first [1 2 3 4]) 请记住，所有的 Clojure 操作都有相同的语法：开括号、操作符、操作数、闭括号。函数**调用只是操作的另一个术语，其中运算符是一个函数或一个函数**表达式（一个返回函数的表达式）。\n这可以让你写出一些相当有趣的代码。下面是一个函数表达式，它返回+（加法）函数。\n(or + -) ; = #该返回值是加法函数的字符串表示。因为or的返回值是第一个真值，而这里的加法函数是真值，所以返回的是加法函数。你也可以在另一个表达式中使用这个表达式作为运算符。\n((or + -) 1 2 3) ; = 6 因为(or + -)返回+，这个表达式被评估为1、2和3之和，返回6。\n下面是几个有效的函数调用，它们都返回`6'。\n((and (= 1 1) +) 1 2 3) ; = 6 ((first [+ 0]) 1 2 3) ; = 6 在第一个例子中，and的返回值是第一个假值或最后一个真值。在这个例子中，+被返回，因为它是最后一个真值，然后被应用于参数1 2 3，返回6。在第二个例子中，first的返回值是一个序列中的第一个元素，在这个例子中是+。\n然而，这些都不是有效的函数调用，因为数字和字符串都不是函数。\n(1 2 3 4) (\"test\" 1 2 3) 如果你在 REPL 中运行这些，你会得到这样的结果。\nClassCastException java.lang.String cannot be cast to clojure.lang.IFn user/eval728 (NO_SOURCE_FILE:1) 当你继续使用 Clojure 时，你可能会多次看到这个错误。 cannot be cast to clojure.lang.IFn只是意味着你试图将某个东西作为一个函数使用，而它并不是。\n函数的灵活性并没有随着函数表达式的出现而结束! 在语法上，函数可以接受任何表达式作为参数–包括其他函数*。可以接受一个函数作为参数或返回一个函数的函数被称为高阶函数*。具有高阶函数的编程语言被称为支持第一类函数*，因为你可以像对待数字和向量等更熟悉的数据类型一样，将函数作为值来处理。\n以map函数（不要与 map 数据结构混淆）为例。map通过对一个集合的每个成员应用一个函数来创建一个新的列表。这里，inc函数将一个数字增加 1。\n(inc 1.1) ; = 2.1 (map inc [0 1 2 3]) ; = (1 2 3 4) (注意map并不返回一个向量，尽管我们提供了一个向量作为参数。你将在第四章中了解原因。现在，请相信这是好的，也是预期的）。\nClojure 对一级函数的支持使你能够建立比没有一级函数的语言更强大的抽象概念。那些不熟悉这种编程方式的人认为函数允许你对数据实例进行泛化操作。例如，+函数对任何特定数字的加法进行了抽象。\n相比之下，Clojure（以及所有 Lisps）允许你创建泛化进程的函数。map允许你通过在任何集合上应用一个函数–任何函数–来概括转换一个集合的过程。\n你需要知道的关于函数调用的最后一个细节是，Clojure 在将所有函数参数传递给函数之前，会递归地评估这些参数。下面是 Clojure 如何评估一个参数也是函数调用的函数调用。\n(+ (inc 199) (/ 100 (- 7 2))) (+ 200 (/ 100 (- 7 2))) ; evaluated \"(inc 199)\" (+ 200 (/ 100 5)) ; evaluated (- 7 2) (+ 200 20) ; evaluated (/ 100 5) 220 ; final evaluation 函数调用启动了评估过程，在应用+函数之前，所有的子表格都被评估了。\n函数调用、宏调用和特殊形式 在上一节中，你了解到函数调用是以函数表达式为操作符的表达式。另外两种表达式是宏调用和特殊形式。你已经看到了几种特殊形式：定义和if表达式。\n你将在第 7 章中学习关于宏调用和特殊形式的所有知识。现在，使特殊形式 “特殊 “的主要特征是，与函数调用不同，它们不总是评估所有**它们的操作数。\n以 “if “为例。这是它的一般结构。\n(if boolean-form then-form optional-else-form) 现在想象一下你有一个这样的if语句。\n(if good-mood (tweet walking-on-sunshine-lyrics) (tweet mopey-country-song-lyrics)) 显然，在这样的if表达中，我们希望 Clojure 只评估两个分支中的一个。如果 Clojure 同时评估两个`tweet’函数调用，你的 Twitter 粉丝们最终会非常困惑。\n另一个区别于特殊形式的特征是，你不能把它们作为函数的参数。一般来说，特殊形式实现了 Clojure 的核心功能，只是不能用函数实现。Clojure 只有少量的特殊形式，而如此丰富的语言是用如此小的一组构建块来实现的，这是很令人惊讶的。\n宏与特殊形式类似，它们对操作数的评估与函数调用不同，而且它们也不能作为参数传递给函数。但这段弯路已经走得够长了；现在是学习如何定义函数的时候了!\n定义函数 函数的定义由五个主要部分组成。\n defn 函数名称 描述该函数的 docstring(可选) 括号中列出的参数 函数主体  下面是一个函数定义的例子和函数的调用示例。\n➊ (defn too-enthusiastic ➋ \"Return a cheer that might be a bit too enthusiastic\" ➌ [name] ➍ (str \"OH. MY. GOD! \" name \" YOU ARE MOST DEFINITELY LIKE THE BEST \" \"MAN SLASH WOMAN EVER I LOVE YOU AND WE SHOULD RUN AWAY SOMEWHERE\")) (too-enthusiastic \"Zelda\") ; = \"OH. MY. GOD! Zelda YOU ARE MOST DEFINITELY LIKE THE BEST MAN SLASH WOMAN EVER I LOVE YOU AND WE SHOULD RUN AWAY SOMEWHERE\" 在➊处，too-enthusiastic是函数的名称，在➋处有一个描述性的 docstring。参数 “name “在➌处给出，函数体在➍处接受参数，并做了它所描述的事情–返回一个可能有点过于热情的欢呼。\n让我们更深入地了解 do’c’s’t’ri’n’g、参数和函数体。\n","wordCount":"1344","inLanguage":"en","datePublished":"2022-01-13T11:12:19+08:00","dateModified":"2022-01-13T11:12:19+08:00","author":{"@type":"Person","name":"Fenix"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhenfeng-zhu.github.io/posts/chapter3/"},"publisher":{"@type":"Organization","name":"Awesome Fenix","logo":{"@type":"ImageObject","url":"https://zhenfeng-zhu.github.io/favicon.ico"}}}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8502076734034112" crossorigin=anonymous></script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhenfeng-zhu.github.io accesskey=h title="Awesome Fenix (Alt + H)">Awesome Fenix</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://zhenfeng-zhu.github.io/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/about title=About>
<span>About</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/search/ title=🔍>
<span>🔍</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://zhenfeng-zhu.github.io>Home</a>&nbsp;»&nbsp;<a href=https://zhenfeng-zhu.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Chapter3
</h1>
<div class=post-meta><span title="2022-01-13 11:12:19 +0800 +0800">January 13, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Fenix&nbsp;|&nbsp;<a href=https://github.com/zhenfeng-zhu/zhenfeng-zhu.github.io/tree/main/content/posts/Chapter3.md rel="noopener noreferrer" target=_blank>修改本文章</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e5%81%9a%e4%ba%8b%e6%83%85clojure-%e9%80%9f%e6%88%90%e7%8f%ad aria-label="做事情：Clojure 速成班">做事情：Clojure 速成班</a><ul>
<li>
<a href=#%e8%af%ad%e6%b3%95 aria-label=语法>语法</a><ul>
<li>
<a href=#%e5%bd%a2%e5%bc%8f aria-label=形式>形式</a></li>
<li>
<a href=#%e6%8e%a7%e5%88%b6%e6%b5%81 aria-label=控制流>控制流</a><ul>
<li>
<a href=#if aria-label=if>if</a></li>
<li>
<a href=#do aria-label=do>do</a></li>
<li>
<a href=#when aria-label=when>when</a></li>
<li>
<a href=#nil-true-false-truthiness-equality-and-boolean-expressions aria-label="nil, true, false, Truthiness, Equality, and Boolean Expressions">nil, true, false, Truthiness, Equality, and Boolean Expressions</a></li></ul>
</li>
<li>
<a href=#%e7%94%a8-def-%e5%91%bd%e5%90%8d%e6%95%b0%e5%80%bc aria-label="用 def 命名数值">用 def 命名数值</a></li></ul>
</li>
<li>
<a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=数据结构>数据结构</a><ul>
<li>
<a href=#%e6%95%b0%e5%ad%97 aria-label=数字>数字</a></li>
<li>
<a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label=字符串>字符串</a></li>
<li>
<a href=#map aria-label=Map>Map</a></li>
<li>
<a href=#keywords aria-label=Keywords>Keywords</a></li>
<li>
<a href=#%e7%9f%a2%e9%87%8f aria-label=矢量>矢量</a></li>
<li>
<a href=#lists aria-label=Lists>Lists</a></li>
<li>
<a href=#set aria-label=Set>Set</a></li>
<li>
<a href=#%e7%ae%80%e5%8d%95%e6%80%a7 aria-label=简单性>简单性</a></li></ul>
</li>
<li>
<a href=#%e5%87%bd%e6%95%b0 aria-label=函数>函数</a><ul>
<li>
<a href=#%e8%b0%83%e7%94%a8%e5%87%bd%e6%95%b0 aria-label=调用函数>调用函数</a></li>
<li>
<a href=#%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e5%ae%8f%e8%b0%83%e7%94%a8%e5%92%8c%e7%89%b9%e6%ae%8a%e5%bd%a2%e5%bc%8f aria-label=函数调用、宏调用和特殊形式>函数调用、宏调用和特殊形式</a></li>
<li>
<a href=#%e5%ae%9a%e4%b9%89%e5%87%bd%e6%95%b0 aria-label=定义函数>定义函数</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=做事情clojure-速成班>做事情：Clojure 速成班<a hidden class=anchor aria-hidden=true href=#做事情clojure-速成班>#</a></h1>
<p>是时候学习如何用 Clojure 真正地<em>做</em>事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。</p>
<p>在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!</p>
<p>当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!</p>
<h2 id=语法>语法<a hidden class=anchor aria-hidden=true href=#语法>#</a></h2>
<p>Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。</p>
<h3 id=形式>形式<a hidden class=anchor aria-hidden=true href=#形式>#</a></h3>
<p>所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。</p>
<ul>
<li>数据结构的字面表示（如数字、字符串、Map 和向量）</li>
<li>操作</li>
</ul>
<p>我们使用术语<em>form</em>来指代有效的代码。我有时也会用<em>表达式</em>来指代 Clojure 形式。但不要太纠结于术语。Clojure <em>评价</em>每一个表单，以产生一个值。这些字面表达都是有效的形式。</p>
<pre tabindex=0><code>1
&quot;a string&quot;
[&quot;a&quot; &quot;vector&quot; &quot;of&quot; &quot;strings&quot;]
</code></pre><p>当然，你的代码很少包含自由浮动的字元，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你<em>做</em>事情的方式。所有操作的形式都是：*开括号，*操作符，*操作数，<em>闭括号</em>。</p>
<pre tabindex=0><code>(operator operand1 operand2 ... operandn)
</code></pre><p>请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。</p>
<pre tabindex=0><code>(+ 1 2 3)
; =&gt; 6

(str &quot;It was the panda &quot; &quot;in the library &quot; &quot;with a dust buster&quot;)
; =&gt; &quot;It was the panda in the library with a dust buster&quot;
</code></pre><p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/do-things/panda.png alt=img>
</p>
<p>在第一个操作中，运算符<code>+</code>将操作数<code>1</code>、<code>2</code>和<code>3</code>相加。在第二个操作中，运算符<code>str</code>将三个字符串连接起来，形成一个新的字符串。这两种形式都是有效的。这里有一个不是形式的东西，因为它没有一个结束的小括号。</p>
<pre tabindex=0><code>(+
</code></pre><p>Clojure 的结构统一性可能与你所习惯的不同。在其他语言中，不同的操作可能有不同的结构，这取决于操作符和操作数。例如，JavaScript 采用的是 infix 符号、点运算符和小括号的大杂烩。</p>
<pre tabindex=0><code>1 + 2 + 3
&quot;It was the panda &quot;.concat(&quot;in the library &quot;, &quot;with a dust buster&quot;)
</code></pre><p>相比之下，Clojure 的结构是非常简单和一致的。无论你使用哪种运算符，或对哪种数据进行操作，其结构都是一样的。</p>
<h3 id=控制流>控制流<a hidden class=anchor aria-hidden=true href=#控制流>#</a></h3>
<p>让我们来看看三个基本的控制流操作符。<code>if</code>, <code>do</code>, 和<code>when</code>。在本书中，你会遇到更多的操作，但这些操作可以让你开始。</p>
<h4 id=if>if<a hidden class=anchor aria-hidden=true href=#if>#</a></h4>
<p>这是一个 &ldquo;if &ldquo;表达式的一般结构。</p>
<pre tabindex=0><code>(if boolean-form
  then-form
  optional-else-form)
</code></pre><p>布尔形式只是一个评估为真值或假值的形式。你会在下一节中了解到真实性和虚假性。下面是几个`if&rsquo;的例子。</p>
<pre tabindex=0><code>(if true
  &quot;By Zeus's hammer!&quot;
  &quot;By Aquaman's trident!&quot;)
; =&gt; &quot;By Zeus's hammer!&quot;

(if false
  &quot;By Zeus's hammer!&quot;
  &quot;By Aquaman's trident!&quot;)
; =&gt; &quot;By Aquaman's trident!&quot;
</code></pre><p>第一个例子返回 &ldquo;靠宙斯的锤子！"，因为其布尔形式评估为 &ldquo;true&rdquo;，是一个真实的值；第二个例子返回 &ldquo;靠阿卡曼的三叉戟！"，因为其布尔形式 &ldquo;false&rdquo;，评估为一个错误的值。</p>
<p>你也可以省略<code>else</code>分支。如果你这样做，并且布尔表达式是假的，Clojure 会返回<code>nil</code>，就像这样。</p>
<pre tabindex=0><code>(if false
  &quot;By Odin's Elbow!&quot;)
; =&gt; nil
</code></pre><p>注意<code>if</code>使用操作数位置将操作数与<code>then</code>和<code>else</code>分支联系起来：第一个操作数是<code>then</code>分支，第二个操作数是（可选）<code>else</code>分支。因此，每个分支只能有一种形式。这与大多数语言不同。例如，你可以在 Ruby 中这样写。</p>
<pre tabindex=0><code>if true
  doer.do_thing(1)
  doer.do_thing(2)
else
  other_doer.do_thing(1)
  other_doer.do_thing(2)
end
</code></pre><p>为了绕过这个明显的限制，你可以使用<code>do</code>操作符。</p>
<h4 id=do>do<a hidden class=anchor aria-hidden=true href=#do>#</a></h4>
<p><code>do</code>操作符可以让你在括号中<em>包裹</em>起多个表单，并运行其中的每一个。在你的 REPL 中尝试以下操作。</p>
<pre tabindex=0><code>(if true
  (do (println &quot;Success!&quot;)
      &quot;By Zeus's hammer!&quot;)
  (do (println &quot;Failure!&quot;)
      &quot;By Aquaman's trident!&quot;))
; =&gt; Success!
; =&gt; &quot;By Zeus's hammer!&quot;
</code></pre><p>这个操作符让你在<code>if</code>表达式的每个分支中做多件事情。在这种情况下，会发生两件事。<code>成功！</code>被打印在 REPL 中，<code>"</code>通过宙斯的锤子！<code>"</code>被作为整个<code>if</code>表达式的值返回。</p>
<h4 id=when>when<a hidden class=anchor aria-hidden=true href=#when>#</a></h4>
<p><code>when</code>操作符就像<code>if</code>和<code>do</code>的组合，但没有<code>else</code>分支。下面是一个例子。</p>
<pre tabindex=0><code>(when true
  (println &quot;Success!&quot;)
  &quot;abra cadabra&quot;)
; =&gt; Success!
; =&gt; &quot;abra cadabra&quot;
</code></pre><p>如果你想在某个条件为真时做多件事，而你总是想在条件为假时返回<code>nil'，请使用</code>when`。</p>
<h4 id=nil-true-false-truthiness-equality-and-boolean-expressions>nil, true, false, Truthiness, Equality, and Boolean Expressions<a hidden class=anchor aria-hidden=true href=#nil-true-false-truthiness-equality-and-boolean-expressions>#</a></h4>
<p>Clojure 有<code>true</code>和<code>false</code>值。<code>nil</code>在 Clojure 中用来表示<em>没有</em>值。你可以用适当命名的<code>nil?</code>函数来检查一个值是否为<code>nil</code>。</p>
<pre tabindex=0><code>(nil? 1)
; =&gt; false

(nil? nil)
; =&gt; true
</code></pre><p><code>nil</code>和<code>false</code>都是用来表示逻辑上的虚假性，而所有其他的值都是逻辑上的真实性。<em>Truthy</em>和<em>falsey</em>指的是在布尔表达式中如何处理一个值，比如传递给<code>if</code>的第一个表达式。</p>
<pre tabindex=0><code>(if &quot;bears eat beets&quot;
  &quot;bears beets Battlestar Galactica&quot;)
; =&gt; &quot;bears beets Battlestar Galactica&quot;

(if nil
  &quot;This won't be the result because nil is falsey&quot;
  &quot;nil is falsey&quot;)
; =&gt; &quot;nil is falsey&quot;
</code></pre><p>在第一个例子中，字符串<code>"熊吃甜菜"</code>被认为是真实的，所以<code>if</code>表达式评估为<code>"熊吃甜菜Battlestar Galactica"</code>。第二个例子显示一个假值是假的。</p>
<p>Clojure 的平等运算符是<code>=</code>。</p>
<pre tabindex=0><code>(= 1 1)
; =&gt; true

(= nil nil)
; =&gt; true

(= 1 2)
; =&gt; false
</code></pre><p>其他一些语言要求你在比较不同类型的值时使用不同的运算符。例如，你可能不得不使用某种专门为字符串制作的特殊字符串平等运算符。但在使用 Clojure 的内置数据结构时，你不需要像这样奇怪或繁琐的东西来测试平等性。</p>
<p>Clojure 使用布尔运算符<code>or</code>和<code>and</code>。<code>or</code>返回第一个真值或最后一个值。<code>and</code>返回第一个错误的值，如果没有错误的值，则返回最后一个真实的值。让我们先看一下<code>or</code>。</p>
<pre tabindex=0><code>(or false nil :large_I_mean_venti :why_cant_I_just_say_large)
; =&gt; :large_I_mean_venti

(or (= 0 1) (= &quot;yes&quot; &quot;no&quot;))
; =&gt; false

(or nil)
; =&gt; nil
</code></pre><p>在第一个例子中，返回值是<code>:large_I_mean_venti</code>，因为它是第一个真值。第二个例子没有真值，所以<code>or</code>返回最后一个值，即<code>false</code>。在最后一个例子中，同样没有真值存在，<code>or</code>返回最后一个值，即<code>nil</code>。现在我们来看看<code>and</code>。</p>
<pre tabindex=0><code>(and :free_wifi :hot_coffee)
; =&gt; :hot_coffee

(and :feelin_super_cool nil false)
; =&gt; nil
</code></pre><p>在第一个例子中，<code>and</code>返回最后一个真值，<code>:hot_coffee</code>。在第二个例子中, <code>and</code>返回<code>nil</code>, 这是第一个错误的值.</p>
<h3 id=用-def-命名数值>用 def 命名数值<a hidden class=anchor aria-hidden=true href=#用-def-命名数值>#</a></h3>
<p>在 Clojure 中, 你可以使用<code>def</code>将一个名字与一个值结合起来:</p>
<pre tabindex=0><code>(def failed-protagonist-names
  [&quot;Larry Potter&quot; &quot;Doreen the Explorer&quot; &quot;The Incredible Bulk&quot;])

failed-protagonist-names
; =&gt; [&quot;Larry Potter&quot; &quot;Doreen the Explorer&quot; &quot;The Incredible Bulk&quot;]
</code></pre><p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/do-things/larry-potter.png alt=img>
</p>
<p>在这个例子中，你把名字<code>failed-protagonist-names</code>绑定到一个包含三个字符串的向量（你将在<a href=https://www.braveclojure.com/do-things/#Anchor-3>&ldquo;向量 &ldquo;第 45 页</a>中了解向量）。</p>
<p>请注意，我使用的是 &ldquo;绑定 &ldquo;一词，而在其他语言中，你会说你是在给一个<em>变量</em>赋值。那些其他语言通常鼓励你对同一个变量进行多次赋值。</p>
<p>例如，在 Ruby 中，你可以对一个变量进行多次赋值，以建立它的值。</p>
<pre tabindex=0><code>severity = :mild
error_message = &quot;OH GOD! IT'S A DISASTER! WE'RE &quot;
if severity == :mild
  error_message = error_message + &quot;MILDLY INCONVENIENCED!&quot;
else
  error_message = error_message + &quot;DOOOOOOOMED!&quot;
end
</code></pre><p>你可能想在 Clojure 中做类似的事情。</p>
<pre tabindex=0><code>(def severity :mild)
(def error-message &quot;OH GOD! IT'S A DISASTER! WE'RE &quot;)
(if (= severity :mild)
  (def error-message (str error-message &quot;MILDLY INCONVENIENCED!&quot;))
  (def error-message (str error-message &quot;DOOOOOOOMED!&quot;)))
</code></pre><p>然而，像这样改变与名字相关的值会使你更难理解你的程序的行为，因为更难知道哪个值是与名字相关的，或者为什么这个值可能已经改变了。Clojure 有一套处理变化的工具，你会在第 10 章中了解到。随着你对 Clojure 的学习，你会发现你很少需要改变一个名字/值的关联。下面是你写前面代码的一种方式。</p>
<pre tabindex=0><code>(defn error-message
  [severity]
  (str &quot;OH GOD! IT'S A DISASTER! WE'RE &quot;
       (if (= severity :mild)
         &quot;MILDLY INCONVENIENCED!&quot;
         &quot;DOOOOOOOMED!&quot;)))

(error-message :mild)
; =&gt; &quot;OH GOD! IT'S A DISASTER! WE'RE MILDLY INCONVENIENCED!&quot;
</code></pre><p>这里，你创建了一个函数，<code>error-message</code>，它接受一个参数，<code>severity</code>，并使用它来决定返回哪个字符串。然后你用<code>:mild</code>作为严重程度来调用这个函数。你将在<a href=https://www.braveclojure.com/do-things/#Anchor-4>&ldquo;函数 &ldquo;第 48 页</a>中学习所有关于创建函数的知识；与此同时，你应该把<code>def</code>当作定义常量。在接下来的几章中，你将学习如何通过接受函数式编程范式来处理这个明显的限制。</p>
<h2 id=数据结构>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构>#</a></h2>
<p>Clojure 带有少量的数据结构，你在大多数时候都会用到。如果你来自面向对象的背景，你会惊讶于你可以用这里介绍的看似基本的类型做很多事情。</p>
<p>Clojure 的所有数据结构都是不可改变的，这意味着你不能在原地改变它们。例如，在 Ruby 中，你可以做以下事情来重新分配索引为 0 的失败主角的名字。</p>
<pre tabindex=0><code>failed_protagonist_names = [
  &quot;Larry Potter&quot;,
  &quot;Doreen the Explorer&quot;,
  &quot;The Incredible Bulk&quot;
]
failed_protagonist_names[0] = &quot;Gary Potter&quot;

failed_protagonist_names
# =&gt; [
#   &quot;Gary Potter&quot;,
#   &quot;Doreen the Explorer&quot;,
#   &quot;The Incredible Bulk&quot;
# ]
</code></pre><p>Clojure 没有与之对应的东西。你会在第 10 章中了解到更多关于 Clojure 这样实现的原因，但现在只学习如何做事情，而不考虑所有的哲学问题，这很有趣。不多说了，让我们来看看 Clojure 中的数字。</p>
<h3 id=数字>数字<a hidden class=anchor aria-hidden=true href=#数字>#</a></h3>
<p>Clojure 有相当复杂的数字支持。我不会花太多时间纠缠于无聊的技术细节（比如强制和传染），因为那会妨碍<em>做事情</em>。如果你对这些枯燥的细节感兴趣，请查看*<a href=http://clojure.org/data_**structures#Data%20Structures-Numbers>http://clojure.org/data_**structures#Data%20Structures-Numbers</a>*的文档。可以说，Clojure 会很高兴地处理你扔给它的几乎所有东西。</p>
<p>在此期间，我们将使用整数和浮点数。我们还将使用比率，Clojure 可以直接表示这些比率。下面分别是一个整数、一个浮点数和一个比率。</p>
<pre tabindex=0><code>93
1.2
1/5
</code></pre><h3 id=字符串>字符串<a hidden class=anchor aria-hidden=true href=#字符串>#</a></h3>
<p>字符串代表文本。这个名字来自于古代腓尼基人，他们在一次涉及纱线的事故后，有一天发明了字母表。下面是一些字符串字面的例子。</p>
<pre tabindex=0><code>&quot;Lord Voldemort&quot;
&quot;\&quot;He who must not be named\&quot;&quot;
&quot;\&quot;Great cow of Moscow!\&quot; - Hermes Conrad&quot;
</code></pre><p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/do-things/wookie.png alt=img>
</p>
<p>注意，Clojure 只允许用双引号来划分字符串。例如，&ldquo;Lord Voldemort &ldquo;就不是一个有效的字符串。还要注意，Clojure 没有字符串插值。它只允许通过<code>str</code>函数进行连接。</p>
<pre tabindex=0><code>(def name &quot;Chewbacca&quot;)
(str &quot;\&quot;Uggllglglglglglll\&quot; - &quot; name)
; =&gt; &quot;Uggllglglglglglll&quot; - Chewbacca
</code></pre><h3 id=map>Map<a hidden class=anchor aria-hidden=true href=#map>#</a></h3>
<p>Map 类似于其他语言中的字典或哈希值。它们是一种将一些值与另一些值联系起来的方式。Clojure 中的两种 Map 是哈希 Map 和排序 Map。我将只介绍更基本的哈希图。让我们来看看 Map 字面的一些例子。这里有一个空 Map。</p>
<pre tabindex=0><code>{}
</code></pre><p>在这个例子中，<code>:first-name</code>和<code>:last-name</code>是关键字（我将在下一节介绍这些）。</p>
<pre tabindex=0><code>{:first-name &quot;Charlie&quot;
 :last-name &quot;McFishwich&quot;}
</code></pre><p>这里我们把<code>"string-key"</code>和<code>+</code>函数联系起来。</p>
<pre tabindex=0><code>{&quot;string-key&quot; +}
</code></pre><p>Map 可以被嵌套。</p>
<pre tabindex=0><code>{:name {:first &quot;John&quot; :middle &quot;Jacob&quot; :last &quot;Jingleheimerschmidt&quot;}}.
</code></pre><p>注意，Map 的值可以是任何类型&ndash;字符串、数字、Map、向量，甚至函数。Clojure 并不关心这个问题。</p>
<p>除了使用 map 字面，你还可以使用<code>hash-map</code>函数来创建一个 map。</p>
<pre tabindex=0><code>(hash-map :a 1 :b 2)
; =&gt; {:a 1 :b 2}.
</code></pre><p>你可以用<code>get</code>函数在 Map 中查询数值。</p>
<pre tabindex=0><code>(get {:a 0 :b 1} :b)
; =&gt; 1

(get {:a 0 :b {:c &quot;ho hum&quot;}} :b)
; =&gt; {:c &quot;ho hum&quot;}
</code></pre><p>在这两个例子中，我们向<code>get</code>询问给定 Map 中<code>:b</code>键的值&ndash;在第一个例子中，它返回<code>1</code>，而在第二个例子中，它返回嵌套 Map<code>{:c "ho hum"}</code>。</p>
<p>如果没有找到你的键，<code>get</code>将返回<code>nil'，或者你可以给它一个默认值，例如</code>&ldquo;独角兽？"`。</p>
<pre tabindex=0><code>(get {:a 0 :b 1} :c)
; =&gt; nil

(get {:a 0 :b 1} :c &quot;unicorns?&quot;)
; =&gt; &quot;unicorns?&quot;
</code></pre><p><code>get-in</code>函数可以让你在嵌套 Map 中查询数值。</p>
<pre tabindex=0><code>(get-in {:a 0 :b {:c &quot;ho hum&quot;}} [:b :c])
; =&gt; &quot;ho hum&quot;
</code></pre><p>另一种在 Map 中查询数值的方法是把 Map 当作一个以键为参数的函数。</p>
<pre tabindex=0><code>({:name &quot;The Human Coffeepot&quot;} :name)
; =&gt; &quot;The Human Coffeepot&quot;
</code></pre><p>你可以用 Map 做的另一件很酷的事情是把 Keywords 作为函数来查询它们的值，这就引出了下一个主题，Keywords。</p>
<h3 id=keywords>Keywords<a hidden class=anchor aria-hidden=true href=#keywords>#</a></h3>
<p>了解 Clojure 关键字的最好方法是看它们是如何被使用的。正如你在上一节中所看到的，它们主要是作为 Map 中的键来使用。下面是一些 Keywords 的例子。</p>
<pre tabindex=0><code>:a
:rumplestiltsken
:34
:_?
</code></pre><p>Keywords 可以作为函数使用，在数据结构中查找相应的值。例如，你可以在一个 Map 中查找<code>:a</code>。</p>
<pre tabindex=0><code>(:a {:a 1 :b 2 :c 3})
; =&gt; 1
</code></pre><p>这相当于。</p>
<pre tabindex=0><code>(get {:a 1 :b 2 :c 3} :a)
; =&gt; 1
</code></pre><p>你可以提供一个默认值，和<code>get</code>一样。</p>
<pre tabindex=0><code>(:d {:a 1 :b 2 :c 3} &quot;No gnome knows homes like Noah knows&quot;)
; =&gt; &quot;No gnome knows homes like Noah knows&quot;
</code></pre><p>使用关键字作为一个函数是令人愉快的简洁，Real Clojurists 一直在这样做。你也应该这样做!</p>
<h3 id=矢量>矢量<a hidden class=anchor aria-hidden=true href=#矢量>#</a></h3>
<p>向量类似于数组, 它是一个以 0 为索引的 Set。例如, 下面是一个向量的字面意思:</p>
<pre tabindex=0><code>[3 2 1]
</code></pre><p>这里我们要返回一个向量的第 0 个元素。</p>
<pre tabindex=0><code>(get [3 2 1] 0)
; =&gt; 3
</code></pre><p>下面是另一个按索引获取的例子。</p>
<pre tabindex=0><code>(get [&quot;a&quot; {:name &quot;Pugsley Winterbottom&quot;} &quot;c&quot;] 1)
; =&gt; {:name &quot;Pugsley Winterbottom&quot;}
</code></pre><p>你可以看到，向量元素可以是任何类型，而且你可以混合类型。还注意到我们使用的<code>get</code>函数与我们在 Map 中查找数值时使用的相同。</p>
<p>你可以用<code>vector</code>函数来创建向量。</p>
<pre tabindex=0><code>(vector &quot;creepy&quot; &quot;full&quot; &quot;moon&quot;)
; =&gt; [&quot;creepy&quot; &quot;full&quot; &quot;moon&quot;]
</code></pre><p>你可以使用<code>conj</code>函数来添加额外的元素到向量中。元素被添加到向量的*端。</p>
<pre tabindex=0><code>(conj [1 2 3] 4)
; =&gt; [1 2 3 4]
</code></pre><p>向量不是存储序列的唯一方法；Clojure 还有<em>列表</em>。</p>
<h3 id=lists>Lists<a hidden class=anchor aria-hidden=true href=#lists>#</a></h3>
<p>Lists 与向量类似，它们都是数值的线性 Set。但也有一些区别。例如，你不能用<code>get</code>检索列表元素。要写一个列表的字面意思, 只需将元素插入括号内, 并在开头使用单引号:</p>
<pre tabindex=0><code>'(1 2 3 4)
; =&gt; (1 2 3 4)
</code></pre><p>注意，当 REPL 打印出列表时，它不包括单引号。我们将在后面的第 7 章中再来讨论为什么会这样。如果你想从一个列表中检索一个元素，你可以使用 <code>nth</code> 函数。</p>
<pre tabindex=0><code>(nth '(:a :b :c) 0)
; =&gt; :a

(nth '(:a :b :c) 2)
; =&gt; :c
</code></pre><p>我在本书中没有详细介绍性能，因为我认为在你熟悉一种语言之后再关注它是没有用的。然而，知道使用<code>nth</code>从列表中检索一个元素比使用<code>get</code>从向量中检索一个元素要慢一些是很好的。这是因为 Clojure 必须遍历一个列表中的所有<em>n</em>个元素才能到达<em>n</em>个，而通过索引访问一个向量元素最多只需要几跳。</p>
<p>列表值可以有任何类型，你可以用<code>list</code>函数创建列表。</p>
<pre tabindex=0><code>(list 1 &quot;two&quot; {3 4})
; =&gt; (1 &quot;二&quot; {3 4})
</code></pre><p>元素被添加到一个列表的<em>开头</em>。</p>
<pre tabindex=0><code>(conj '(1 2 3) 4)
; =&gt; (4 1 2 3)
</code></pre><p>什么时候应该使用列表，什么时候应该使用向量？一个好的经验法则是，如果你需要很容易地把项目添加到一个序列的开头，或者你正在写一个宏，你应该使用一个列表。否则，你应该使用矢量。随着你学习的深入，你会对何时使用哪种方法有很好的感觉。</p>
<h3 id=set>Set<a hidden class=anchor aria-hidden=true href=#set>#</a></h3>
<p>Set 是唯一值的 Set。Clojure 有两种类型的 Set：哈希 Set 和排序 Set。我将专注于哈希集，因为它们更经常被使用。下面是一个哈希集的文字符号。</p>
<pre tabindex=0><code>#{&quot;kurt vonnegut&quot; 20 :icicle}.
</code></pre><p>你也可以用<code>hash-set</code>来创建一个 Set:</p>
<pre tabindex=0><code>(hash-set 1 1 2 2)
; =&gt; #{1 2}
</code></pre><p>注意，一个值的多个实例在 Set 中成为一个唯一的值，所以我们只剩下一个<code>1</code>和一个<code>2</code>。如果你试图将一个值添加到一个已经包含该值的 Set 中（比如下面代码中的<code>:b</code>），它仍然只有一个该值。</p>
<pre tabindex=0><code>( conj #{:a :b} :b)
; =&gt; #{:a :b}
</code></pre><p>你也可以通过使用<code>set</code>函数从现有的向量和列表中创建 Set。</p>
<pre tabindex=0><code>(set [3 3 3 4 4])
; =&gt; #{3 4}
</code></pre><p>你可以使用<code>contains?</code>函数来检查 Set 的成员资格，通过使用<code>get</code>，或通过使用关键字作为函数，以 Set 为参数。<code>contains?</code>返回<code>true</code>或<code>false</code>，而<code>get</code>和关键字查找将返回存在的值，如果不存在，则返回<code>nil</code>。</p>
<p>下面是你如何使用<code>contains?</code>。</p>
<pre tabindex=0><code>(contains? #{:a :b} :a)
; =&gt; true

(contains? #{:a :b} 3)
; =&gt; false

(contains? #{nil} nil)
; =&gt; true
</code></pre><p>下面是你如何使用关键字。</p>
<pre tabindex=0><code>(:a #{:a :b})
; =&gt; :a
</code></pre><p>这里是你如何使用<code>get</code>的方法。</p>
<pre tabindex=0><code>(get #{:a :b} :a)
; =&gt; :a

(get #{:a nil} nil)
; =&gt; nil

(get #{:a :b} &quot;kurt vonnegut&quot;)
; =&gt; nil
</code></pre><p>注意，使用<code>get</code>来测试一个 Set 是否包含<code>nil</code>，将总是返回<code>nil</code>，这令人困惑。当你专门测试 Set 成员时，<code>contains?</code>可能是更好的选择。</p>
<h3 id=简单性>简单性<a hidden class=anchor aria-hidden=true href=#简单性>#</a></h3>
<p>你可能已经注意到，到目前为止，对数据结构的处理并不包括对如何创建新类型或类的描述。原因是 Clojure 对简单性的强调鼓励你首先去接触内置的数据结构。</p>
<p>如果你来自面向对象的背景，你可能会认为这种方法很奇怪而且落后。然而，你会发现，你的数据不一定非要和一个类紧密地捆绑在一起，才是有用和可理解的。这里有一个被 Clojurists 喜爱的寓言故事，暗示了 Clojure 的哲学。</p>
<blockquote>
<p>让 100 个函数操作一个数据结构比让 10 个函数操作 10 个数据结构要好。
-Alan Perlis</p>
</blockquote>
<p>在接下来的章节中，你会了解到更多关于 Clojure 哲学的这个方面。现在，请留意你通过坚持使用基本数据结构来获得代码重用性的方法。</p>
<p>我们的 Clojure 数据结构入门课程到此结束。现在，是时候深入到函数中去，学习如何使用这些数据结构了</p>
<h2 id=函数>函数<a hidden class=anchor aria-hidden=true href=#函数>#</a></h2>
<p>人们为 Lisps 疯狂的原因之一是，这些语言可以让你建立起行为复杂的程序，但主要的构件&ndash;函数&ndash;却是如此简单。本节通过解释以下内容，让你开始了解 Lisp 函数的美丽和优雅。</p>
<ul>
<li>调用函数</li>
<li>函数与宏和特殊形式有什么不同</li>
<li>定义函数</li>
<li>匿名函数</li>
<li>返回函数</li>
</ul>
<h3 id=调用函数>调用函数<a hidden class=anchor aria-hidden=true href=#调用函数>#</a></h3>
<p>现在你已经看到了许多函数调用的例子。</p>
<pre tabindex=0><code>(+ 1 2 3 4)
(* 1 2 3 4)
(first [1 2 3 4])
</code></pre><p>请记住，所有的 Clojure 操作都有相同的语法：开括号、操作符、操作数、闭括号。<em>函数**调用</em>只是操作的另一个术语，其中运算符是一个函数或一个<em>函数**表达式</em>（一个返回函数的表达式）。</p>
<p>这可以让你写出一些相当有趣的代码。下面是一个函数表达式，它返回<code>+</code>（加法）函数。</p>
<pre tabindex=0><code>(or + -)
; =&gt; #&lt;core$_PLUS_ clojure.core$_PLUS_@76dace31&gt;
</code></pre><p>该返回值是加法函数的字符串表示。因为<code>or</code>的返回值是第一个真值，而这里的加法函数是真值，所以返回的是加法函数。你也可以在另一个表达式中使用这个表达式作为运算符。</p>
<pre tabindex=0><code>((or + -) 1 2 3)
; =&gt; 6
</code></pre><p>因为<code>(or + -)</code>返回<code>+</code>，这个表达式被评估为<code>1</code>、<code>2</code>和<code>3</code>之和，返回<code>6</code>。</p>
<p>下面是几个有效的函数调用，它们都返回`6'。</p>
<pre tabindex=0><code>((and (= 1 1) +) 1 2 3)
; =&gt; 6

((first [+ 0]) 1 2 3)
; =&gt; 6
</code></pre><p>在第一个例子中，<code>and</code>的返回值是第一个假值或最后一个真值。在这个例子中，<code>+</code>被返回，因为它是最后一个真值，然后被应用于参数<code>1 2 3</code>，返回<code>6</code>。在第二个例子中，<code>first</code>的返回值是一个序列中的第一个元素，在这个例子中是<code>+</code>。</p>
<p>然而，这些都不是有效的函数调用，因为数字和字符串都不是函数。</p>
<pre tabindex=0><code>(1 2 3 4)
(&quot;test&quot; 1 2 3)
</code></pre><p>如果你在 REPL 中运行这些，你会得到这样的结果。</p>
<pre tabindex=0><code>ClassCastException java.lang.String cannot be cast to clojure.lang.IFn
user/eval728 (NO_SOURCE_FILE:1)
</code></pre><p>当你继续使用 Clojure 时，你可能会多次看到这个错误。<em></em> <em>cannot</em> <em>be</em> <em>cast</em> <em>to</em> <em>clojure.lang.IFn</em>只是意味着你试图将某个东西作为一个函数使用，而它并不是。</p>
<p>函数的灵活性并没有随着函数表达式的出现而结束! 在语法上，函数可以接受任何表达式作为参数&ndash;包括<em>其他</em>函数*。可以接受一个函数作为参数或返回一个函数的函数被称为<em>高阶</em>函数*。具有高阶函数的编程语言被称为支持<em>第一类</em>函数*，因为你可以像对待数字和向量等更熟悉的数据类型一样，将函数作为值来处理。</p>
<p>以<code>map</code>函数（不要与 map 数据结构混淆）为例。<code>map</code>通过对一个集合的每个成员应用一个函数来创建一个新的列表。这里，<code>inc</code>函数将一个数字增加 1。</p>
<pre tabindex=0><code>(inc 1.1)
; =&gt; 2.1

(map inc [0 1 2 3])
; =&gt; (1 2 3 4)
</code></pre><p>(注意<code>map</code>并不返回一个向量，尽管我们提供了一个向量作为参数。你将在第四章中了解原因。现在，请相信这是好的，也是预期的）。</p>
<p>Clojure 对一级函数的支持使你能够建立比没有一级函数的语言更强大的抽象概念。那些不熟悉这种编程方式的人认为函数允许你对数据实例进行泛化操作。例如，<code>+</code>函数对任何特定数字的加法进行了抽象。</p>
<p>相比之下，Clojure（以及所有 Lisps）允许你创建泛化进程的函数。<code>map</code>允许你通过在任何集合上应用一个函数&ndash;任何函数&ndash;来概括转换一个集合的过程。</p>
<p>你需要知道的关于函数调用的最后一个细节是，Clojure 在将所有函数参数传递给函数之前，会递归地评估这些参数。下面是 Clojure 如何评估一个参数也是函数调用的函数调用。</p>
<pre tabindex=0><code>(+ (inc 199) (/ 100 (- 7 2)))
(+ 200 (/ 100 (- 7 2))) ; evaluated &quot;(inc 199)&quot;
(+ 200 (/ 100 5)) ; evaluated (- 7 2)
(+ 200 20) ; evaluated (/ 100 5)
220 ; final evaluation
</code></pre><p>函数调用启动了评估过程，在应用<code>+</code>函数之前，所有的子表格都被评估了。</p>
<h3 id=函数调用宏调用和特殊形式>函数调用、宏调用和特殊形式<a hidden class=anchor aria-hidden=true href=#函数调用宏调用和特殊形式>#</a></h3>
<p>在上一节中，你了解到函数调用是以函数表达式为操作符的表达式。另外两种表达式是<em>宏调用</em>和<em>特殊形式</em>。你已经看到了几种特殊形式：定义和<code>if</code>表达式。</p>
<p>你将在第 7 章中学习关于宏调用和特殊形式的所有知识。现在，使特殊形式 &ldquo;特殊 &ldquo;的主要特征是，与函数调用不同，它们<em>不</em>总是<em><strong>评估</strong></em>所有**<em><em>它们的</em>操作数</em>。</p>
<p>以 &ldquo;if &ldquo;为例。这是它的一般结构。</p>
<pre tabindex=0><code>(if boolean-form
  then-form
  optional-else-form)
</code></pre><p>现在想象一下你有一个这样的<code>if</code>语句。</p>
<pre tabindex=0><code>(if good-mood
  (tweet walking-on-sunshine-lyrics)
  (tweet mopey-country-song-lyrics))
</code></pre><p>显然，在这样的<code>if</code>表达中，我们希望 Clojure 只评估两个分支中的一个。如果 Clojure 同时评估两个`tweet&rsquo;函数调用，你的 Twitter 粉丝们最终会非常困惑。</p>
<p>另一个区别于特殊形式的特征是，你不能把它们作为函数的参数。一般来说，特殊形式实现了 Clojure 的核心功能，只是不能用函数实现。Clojure 只有少量的特殊形式，而如此丰富的语言是用如此小的一组构建块来实现的，这是很令人惊讶的。</p>
<p>宏与特殊形式类似，它们对操作数的评估与函数调用不同，而且它们也不能作为参数传递给函数。但这段弯路已经走得够长了；现在是学习如何定义函数的时候了!</p>
<h3 id=定义函数>定义函数<a hidden class=anchor aria-hidden=true href=#定义函数>#</a></h3>
<p>函数的定义由五个主要部分组成。</p>
<ul>
<li><code>defn</code></li>
<li>函数名称</li>
<li>描述该函数的 docstring(可选)</li>
<li>括号中列出的参数</li>
<li>函数主体</li>
</ul>
<p>下面是一个函数定义的例子和函数的调用示例。</p>
<pre tabindex=0><code>➊ (defn too-enthusiastic
➋   &quot;Return a cheer that might be a bit too enthusiastic&quot;
➌   [name]
➍   (str &quot;OH. MY. GOD! &quot; name &quot; YOU ARE MOST DEFINITELY LIKE THE BEST &quot;
  &quot;MAN SLASH WOMAN EVER I LOVE YOU AND WE SHOULD RUN AWAY SOMEWHERE&quot;))

(too-enthusiastic &quot;Zelda&quot;)
; =&gt; &quot;OH. MY. GOD! Zelda YOU ARE MOST DEFINITELY LIKE THE BEST MAN SLASH WOMAN EVER I LOVE YOU AND WE SHOULD RUN AWAY SOMEWHERE&quot;
</code></pre><p>在➊处，<code>too-enthusiastic</code>是函数的名称，在➋处有一个描述性的 docstring。参数 &ldquo;name &ldquo;在➌处给出，函数体在➍处接受参数，并做了它所描述的事情&ndash;返回一个可能有点过于热情的欢呼。</p>
<p>让我们更深入地了解 do&rsquo;c&rsquo;s&rsquo;t&rsquo;ri&rsquo;n&rsquo;g、参数和函数体。</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://zhenfeng-zhu.github.io/tags/clojure/>clojure</a></li>
</ul>
<nav class=paginav>
<a class=next href=https://zhenfeng-zhu.github.io/posts/chapter2/>
<span class=title>Next Page »</span>
<br>
<span>Chapter2</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter3 on twitter" href="https://twitter.com/intent/tweet/?text=Chapter3&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f&hashtags=clojure"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter3 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f&title=Chapter3&summary=Chapter3&source=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter3 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f&title=Chapter3"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter3 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter3 on whatsapp" href="https://api.whatsapp.com/send?text=Chapter3%20-%20https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter3 on telegram" href="https://telegram.me/share/url?text=Chapter3&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer><script src=https://utteranc.es/client.js repo=zhenfeng-zhu/zhenfeng-zhu.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://zhenfeng-zhu.github.io>Awesome Fenix</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>