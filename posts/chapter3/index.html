<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Chapter3 Clojure 速成班 | Awesome Fenix</title>
<meta name=keywords content="clojure">
<meta name=description content="做事情：Clojure 速成班 是时候学习如何用 Clojure 真正地做事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。
在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!
当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!
语法 Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。
形式 所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。
 数据结构的字面表示（如数字、字符串、Map 和向量） 操作  我们使用术语form来指代有效的代码。我有时也会用表达式来指代 Clojure 形式。但不要太纠结于术语。Clojure 评价每一个表单，以产生一个值。这些字面表达都是有效的形式。
1 &#34;a string&#34; [&#34;a&#34; &#34;vector&#34; &#34;of&#34; &#34;strings&#34;] 当然，你的代码很少包含自由浮动的字元，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你做事情的方式。所有操作的形式都是：*开括号，*操作符，*操作数，闭括号。
(operator operand1 operand2 ... operandn) 请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。
(+ 1 2 3) ; => 6 (str &#34;It was the panda &#34; &#34;in the library &#34; &#34;with a dust buster&#34;) ; => &#34;It was the panda in the library with a dust buster&#34; 在第一个操作中，运算符+将操作数1、2和3相加。在第二个操作中，运算符str将三个字符串连接起来，形成一个新的字符串。这两种形式都是有效的。这里有一个不是形式的东西，因为它没有一个结束的小括号。">
<meta name=author content="Fenix">
<link rel=canonical href=https://zhenfeng-zhu.github.io/posts/chapter3/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zhenfeng-zhu.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://zhenfeng-zhu.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://zhenfeng-zhu.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://zhenfeng-zhu.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://zhenfeng-zhu.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-216295420-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Chapter3 Clojure 速成班">
<meta property="og:description" content="做事情：Clojure 速成班 是时候学习如何用 Clojure 真正地做事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。
在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!
当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!
语法 Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。
形式 所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。
 数据结构的字面表示（如数字、字符串、Map 和向量） 操作  我们使用术语form来指代有效的代码。我有时也会用表达式来指代 Clojure 形式。但不要太纠结于术语。Clojure 评价每一个表单，以产生一个值。这些字面表达都是有效的形式。
1 &#34;a string&#34; [&#34;a&#34; &#34;vector&#34; &#34;of&#34; &#34;strings&#34;] 当然，你的代码很少包含自由浮动的字元，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你做事情的方式。所有操作的形式都是：*开括号，*操作符，*操作数，闭括号。
(operator operand1 operand2 ... operandn) 请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。
(+ 1 2 3) ; => 6 (str &#34;It was the panda &#34; &#34;in the library &#34; &#34;with a dust buster&#34;) ; => &#34;It was the panda in the library with a dust buster&#34; 在第一个操作中，运算符+将操作数1、2和3相加。在第二个操作中，运算符str将三个字符串连接起来，形成一个新的字符串。这两种形式都是有效的。这里有一个不是形式的东西，因为它没有一个结束的小括号。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhenfeng-zhu.github.io/posts/chapter3/">
<meta property="og:image" content="https://zhenfeng-zhu.github.io/posts/chapter3/https:/raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201131821608.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-13T11:12:19+08:00">
<meta property="article:modified_time" content="2022-01-13T11:12:19+08:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhenfeng-zhu.github.io/posts/chapter3/https:/raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201131821608.png">
<meta name=twitter:title content="Chapter3 Clojure 速成班">
<meta name=twitter:description content="做事情：Clojure 速成班 是时候学习如何用 Clojure 真正地做事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。
在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!
当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!
语法 Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。
形式 所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。
 数据结构的字面表示（如数字、字符串、Map 和向量） 操作  我们使用术语form来指代有效的代码。我有时也会用表达式来指代 Clojure 形式。但不要太纠结于术语。Clojure 评价每一个表单，以产生一个值。这些字面表达都是有效的形式。
1 &#34;a string&#34; [&#34;a&#34; &#34;vector&#34; &#34;of&#34; &#34;strings&#34;] 当然，你的代码很少包含自由浮动的字元，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你做事情的方式。所有操作的形式都是：*开括号，*操作符，*操作数，闭括号。
(operator operand1 operand2 ... operandn) 请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。
(+ 1 2 3) ; => 6 (str &#34;It was the panda &#34; &#34;in the library &#34; &#34;with a dust buster&#34;) ; => &#34;It was the panda in the library with a dust buster&#34; 在第一个操作中，运算符+将操作数1、2和3相加。在第二个操作中，运算符str将三个字符串连接起来，形成一个新的字符串。这两种形式都是有效的。这里有一个不是形式的东西，因为它没有一个结束的小括号。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://zhenfeng-zhu.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Chapter3 Clojure 速成班","item":"https://zhenfeng-zhu.github.io/posts/chapter3/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Chapter3 Clojure 速成班","name":"Chapter3 Clojure 速成班","description":"做事情：Clojure 速成班 是时候学习如何用 Clojure 真正地做事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。\n在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!\n当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!\n语法 Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。\n形式 所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。\n 数据结构的字面表示（如数字、字符串、Map 和向量） 操作  我们使用术语form来指代有效的代码。我有时也会用表达式来指代 Clojure 形式。但不要太纠结于术语。Clojure 评价每一个表单，以产生一个值。这些字面表达都是有效的形式。\n1 \u0026quot;a string\u0026quot; [\u0026quot;a\u0026quot; \u0026quot;vector\u0026quot; \u0026quot;of\u0026quot; \u0026quot;strings\u0026quot;] 当然，你的代码很少包含自由浮动的字元，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你做事情的方式。所有操作的形式都是：*开括号，*操作符，*操作数，闭括号。\n(operator operand1 operand2 ... operandn) 请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。\n(+ 1 2 3) ; =\u0026gt; 6 (str \u0026quot;It was the panda \u0026quot; \u0026quot;in the library \u0026quot; \u0026quot;with a dust buster\u0026quot;) ; =\u0026gt; \u0026quot;It was the panda in the library with a dust buster\u0026quot; 在第一个操作中，运算符+将操作数1、2和3相加。在第二个操作中，运算符str将三个字符串连接起来，形成一个新的字符串。这两种形式都是有效的。这里有一个不是形式的东西，因为它没有一个结束的小括号。","keywords":["clojure"],"articleBody":"做事情：Clojure 速成班 是时候学习如何用 Clojure 真正地做事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。\n在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!\n当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!\n语法 Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。\n形式 所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。\n 数据结构的字面表示（如数字、字符串、Map 和向量） 操作  我们使用术语form来指代有效的代码。我有时也会用表达式来指代 Clojure 形式。但不要太纠结于术语。Clojure 评价每一个表单，以产生一个值。这些字面表达都是有效的形式。\n1 \"a string\" [\"a\" \"vector\" \"of\" \"strings\"] 当然，你的代码很少包含自由浮动的字元，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你做事情的方式。所有操作的形式都是：*开括号，*操作符，*操作数，闭括号。\n(operator operand1 operand2 ... operandn) 请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。\n(+ 1 2 3) ; = 6 (str \"It was the panda \" \"in the library \" \"with a dust buster\") ; = \"It was the panda in the library with a dust buster\" 在第一个操作中，运算符+将操作数1、2和3相加。在第二个操作中，运算符str将三个字符串连接起来，形成一个新的字符串。这两种形式都是有效的。这里有一个不是形式的东西，因为它没有一个结束的小括号。\n(+ Clojure 的结构统一性可能与你所习惯的不同。在其他语言中，不同的操作可能有不同的结构，这取决于操作符和操作数。例如，JavaScript 采用的是 infix 符号、点运算符和小括号的大杂烩。\n1 + 2 + 3 \"It was the panda \".concat(\"in the library \", \"with a dust buster\") 相比之下，Clojure 的结构是非常简单和一致的。无论你使用哪种运算符，或对哪种数据进行操作，其结构都是一样的。\n控制流 让我们来看看三个基本的控制流操作符。if, do, 和when。在本书中，你会遇到更多的操作，但这些操作可以让你开始。\nif 这是一个 “if “表达式的一般结构。\n(if boolean-form then-form optional-else-form) 布尔形式只是一个评估为真值或假值的形式。你会在下一节中了解到真实性和虚假性。下面是几个`if’的例子。\n(if true \"By Zeus's hammer!\" \"By Aquaman's trident!\") ; = \"By Zeus's hammer!\" (if false \"By Zeus's hammer!\" \"By Aquaman's trident!\") ; = \"By Aquaman's trident!\" 第一个例子返回 “靠宙斯的锤子！\"，因为其布尔形式评估为 “true”，是一个真实的值；第二个例子返回 “靠阿卡曼的三叉戟！\"，因为其布尔形式 “false”，评估为一个错误的值。\n你也可以省略else分支。如果你这样做，并且布尔表达式是假的，Clojure 会返回nil，就像这样。\n(if false \"By Odin's Elbow!\") ; = nil 注意if使用操作数位置将操作数与then和else分支联系起来：第一个操作数是then分支，第二个操作数是（可选）else分支。因此，每个分支只能有一种形式。这与大多数语言不同。例如，你可以在 Ruby 中这样写。\nif true doer.do_thing(1) doer.do_thing(2) else other_doer.do_thing(1) other_doer.do_thing(2) end 为了绕过这个明显的限制，你可以使用do操作符。\ndo do操作符可以让你在括号中包裹起多个表单，并运行其中的每一个。在你的 REPL 中尝试以下操作。\n(if true (do (println \"Success!\") \"By Zeus's hammer!\") (do (println \"Failure!\") \"By Aquaman's trident!\")) ; = Success! ; = \"By Zeus's hammer!\" 这个操作符让你在if表达式的每个分支中做多件事情。在这种情况下，会发生两件事。成功！被打印在 REPL 中，\"通过宙斯的锤子！\"被作为整个if表达式的值返回。\nwhen when操作符就像if和do的组合，但没有else分支。下面是一个例子。\n(when true (println \"Success!\") \"abra cadabra\") ; = Success! ; = \"abra cadabra\" 如果你想在某个条件为真时做多件事，而你总是想在条件为假时返回nil'，请使用when`。\nnil, true, false, Truthiness, Equality, and Boolean Expressions Clojure 有true和false值。nil在 Clojure 中用来表示没有值。你可以用适当命名的nil?函数来检查一个值是否为nil。\n(nil? 1) ; = false (nil? nil) ; = true nil和false都是用来表示逻辑上的虚假性，而所有其他的值都是逻辑上的真实性。Truthy和falsey指的是在布尔表达式中如何处理一个值，比如传递给if的第一个表达式。\n(if \"bears eat beets\" \"bears beets Battlestar Galactica\") ; = \"bears beets Battlestar Galactica\" (if nil \"This won't be the result because nil is falsey\" \"nil is falsey\") ; = \"nil is falsey\" 在第一个例子中，字符串\"熊吃甜菜\"被认为是真实的，所以if表达式评估为\"熊吃甜菜Battlestar Galactica\"。第二个例子显示一个假值是假的。\nClojure 的平等运算符是=。\n(= 1 1) ; = true (= nil nil) ; = true (= 1 2) ; = false 其他一些语言要求你在比较不同类型的值时使用不同的运算符。例如，你可能不得不使用某种专门为字符串制作的特殊字符串平等运算符。但在使用 Clojure 的内置数据结构时，你不需要像这样奇怪或繁琐的东西来测试平等性。\nClojure 使用布尔运算符or和and。or返回第一个真值或最后一个值。and返回第一个错误的值，如果没有错误的值，则返回最后一个真实的值。让我们先看一下or。\n(or false nil :large_I_mean_venti :why_cant_I_just_say_large) ; = :large_I_mean_venti (or (= 0 1) (= \"yes\" \"no\")) ; = false (or nil) ; = nil 在第一个例子中，返回值是:large_I_mean_venti，因为它是第一个真值。第二个例子没有真值，所以or返回最后一个值，即false。在最后一个例子中，同样没有真值存在，or返回最后一个值，即nil。现在我们来看看and。\n(and :free_wifi :hot_coffee) ; = :hot_coffee (and :feelin_super_cool nil false) ; = nil 在第一个例子中，and返回最后一个真值，:hot_coffee。在第二个例子中, and返回nil, 这是第一个错误的值.\n用 def 命名数值 在 Clojure 中, 你可以使用def将一个名字与一个值结合起来:\n(def failed-protagonist-names [\"Larry Potter\" \"Doreen the Explorer\" \"The Incredible Bulk\"]) failed-protagonist-names ; = [\"Larry Potter\" \"Doreen the Explorer\" \"The Incredible Bulk\"] 在这个例子中，你把名字failed-protagonist-names绑定到一个包含三个字符串的向量（你将在“向量 “第 45 页中了解向量）。\n请注意，我使用的是 “绑定 “一词，而在其他语言中，你会说你是在给一个变量赋值。那些其他语言通常鼓励你对同一个变量进行多次赋值。\n例如，在 Ruby 中，你可以对一个变量进行多次赋值，以建立它的值。\nseverity = :mild error_message = \"OH GOD! IT'S A DISASTER! WE'RE \" if severity == :mild error_message = error_message + \"MILDLY INCONVENIENCED!\" else error_message = error_message + \"DOOOOOOOMED!\" end 你可能想在 Clojure 中做类似的事情。\n(def severity :mild) (def error-message \"OH GOD! IT'S A DISASTER! WE'RE \") (if (= severity :mild) (def error-message (str error-message \"MILDLY INCONVENIENCED!\")) (def error-message (str error-message \"DOOOOOOOMED!\"))) 然而，像这样改变与名字相关的值会使你更难理解你的程序的行为，因为更难知道哪个值是与名字相关的，或者为什么这个值可能已经改变了。Clojure 有一套处理变化的工具，你会在第 10 章中了解到。随着你对 Clojure 的学习，你会发现你很少需要改变一个名字/值的关联。下面是你写前面代码的一种方式。\n(defn error-message [severity] (str \"OH GOD! IT'S A DISASTER! WE'RE \" (if (= severity :mild) \"MILDLY INCONVENIENCED!\" \"DOOOOOOOMED!\"))) (error-message :mild) ; = \"OH GOD! IT'S A DISASTER! WE'RE MILDLY INCONVENIENCED!\" 这里，你创建了一个函数，error-message，它接受一个参数，severity，并使用它来决定返回哪个字符串。然后你用:mild作为严重程度来调用这个函数。你将在“函数 “第 48 页中学习所有关于创建函数的知识；与此同时，你应该把def当作定义常量。在接下来的几章中，你将学习如何通过接受函数式编程范式来处理这个明显的限制。\n数据结构 Clojure 带有少量的数据结构，你在大多数时候都会用到。如果你来自面向对象的背景，你会惊讶于你可以用这里介绍的看似基本的类型做很多事情。\nClojure 的所有数据结构都是不可改变的，这意味着你不能在原地改变它们。例如，在 Ruby 中，你可以做以下事情来重新分配索引为 0 的失败主角的名字。\nfailed_protagonist_names = [ \"Larry Potter\", \"Doreen the Explorer\", \"The Incredible Bulk\" ] failed_protagonist_names[0] = \"Gary Potter\" failed_protagonist_names # = [ # \"Gary Potter\", # \"Doreen the Explorer\", # \"The Incredible Bulk\" # ] Clojure 没有与之对应的东西。你会在第 10 章中了解到更多关于 Clojure 这样实现的原因，但现在只学习如何做事情，而不考虑所有的哲学问题，这很有趣。不多说了，让我们来看看 Clojure 中的数字。\n数字 Clojure 有相当复杂的数字支持。我不会花太多时间纠缠于无聊的技术细节（比如强制和传染），因为那会妨碍做事情。如果你对这些枯燥的细节感兴趣，请查看*http://clojure.org/data_**structures#Data%20Structures-Numbers*的文档。可以说，Clojure 会很高兴地处理你扔给它的几乎所有东西。\n在此期间，我们将使用整数和浮点数。我们还将使用比率，Clojure 可以直接表示这些比率。下面分别是一个整数、一个浮点数和一个比率。\n93 1.2 1/5 字符串 字符串代表文本。这个名字来自于古代腓尼基人，他们在一次涉及纱线的事故后，有一天发明了字母表。下面是一些字符串字面的例子。\n\"Lord Voldemort\" \"\\\"He who must not be named\\\"\" \"\\\"Great cow of Moscow!\\\" - Hermes Conrad\" 注意，Clojure 只允许用双引号来划分字符串。例如，“Lord Voldemort “就不是一个有效的字符串。还要注意，Clojure 没有字符串插值。它只允许通过str函数进行连接。\n(def name \"Chewbacca\") (str \"\\\"Uggllglglglglglll\\\" - \" name) ; = \"Uggllglglglglglll\" - Chewbacca Map Map 类似于其他语言中的字典或哈希值。它们是一种将一些值与另一些值联系起来的方式。Clojure 中的两种 Map 是哈希 Map 和排序 Map。我将只介绍更基本的哈希图。让我们来看看 Map 字面的一些例子。这里有一个空 Map。\n{} 在这个例子中，:first-name和:last-name是关键字（我将在下一节介绍这些）。\n{:first-name \"Charlie\" :last-name \"McFishwich\"} 这里我们把\"string-key\"和+函数联系起来。\n{\"string-key\" +} Map 可以被嵌套。\n{:name {:first \"John\" :middle \"Jacob\" :last \"Jingleheimerschmidt\"}}. 注意，Map 的值可以是任何类型–字符串、数字、Map、向量，甚至函数。Clojure 并不关心这个问题。\n除了使用 map 字面，你还可以使用hash-map函数来创建一个 map。\n(hash-map :a 1 :b 2) ; = {:a 1 :b 2}. 你可以用get函数在 Map 中查询数值。\n(get {:a 0 :b 1} :b) ; = 1 (get {:a 0 :b {:c \"ho hum\"}} :b) ; = {:c \"ho hum\"} 在这两个例子中，我们向get询问给定 Map 中:b键的值–在第一个例子中，它返回1，而在第二个例子中，它返回嵌套 Map{:c \"ho hum\"}。\n如果没有找到你的键，get将返回nil'，或者你可以给它一个默认值，例如“独角兽？\"`。\n(get {:a 0 :b 1} :c) ; = nil (get {:a 0 :b 1} :c \"unicorns?\") ; = \"unicorns?\" get-in函数可以让你在嵌套 Map 中查询数值。\n(get-in {:a 0 :b {:c \"ho hum\"}} [:b :c]) ; = \"ho hum\" 另一种在 Map 中查询数值的方法是把 Map 当作一个以键为参数的函数。\n({:name \"The Human Coffeepot\"} :name) ; = \"The Human Coffeepot\" 你可以用 Map 做的另一件很酷的事情是把 Keywords 作为函数来查询它们的值，这就引出了下一个主题，Keywords。\nKeywords 了解 Clojure 关键字的最好方法是看它们是如何被使用的。正如你在上一节中所看到的，它们主要是作为 Map 中的键来使用。下面是一些 Keywords 的例子。\n:a :rumplestiltsken :34 :_? Keywords 可以作为函数使用，在数据结构中查找相应的值。例如，你可以在一个 Map 中查找:a。\n(:a {:a 1 :b 2 :c 3}) ; = 1 这相当于。\n(get {:a 1 :b 2 :c 3} :a) ; = 1 你可以提供一个默认值，和get一样。\n(:d {:a 1 :b 2 :c 3} \"No gnome knows homes like Noah knows\") ; = \"No gnome knows homes like Noah knows\" 使用关键字作为一个函数是令人愉快的简洁，Real Clojurists 一直在这样做。你也应该这样做!\n矢量 向量类似于数组, 它是一个以 0 为索引的 Set。例如, 下面是一个向量的字面意思:\n[3 2 1] 这里我们要返回一个向量的第 0 个元素。\n(get [3 2 1] 0) ; = 3 下面是另一个按索引获取的例子。\n(get [\"a\" {:name \"Pugsley Winterbottom\"} \"c\"] 1) ; = {:name \"Pugsley Winterbottom\"} 你可以看到，向量元素可以是任何类型，而且你可以混合类型。还注意到我们使用的get函数与我们在 Map 中查找数值时使用的相同。\n你可以用vector函数来创建向量。\n(vector \"creepy\" \"full\" \"moon\") ; = [\"creepy\" \"full\" \"moon\"] 你可以使用conj函数来添加额外的元素到向量中。元素被添加到向量的*端。\n(conj [1 2 3] 4) ; = [1 2 3 4] 向量不是存储序列的唯一方法；Clojure 还有列表。\nLists Lists 与向量类似，它们都是数值的线性 Set。但也有一些区别。例如，你不能用get检索列表元素。要写一个列表的字面意思, 只需将元素插入括号内, 并在开头使用单引号:\n'(1 2 3 4) ; = (1 2 3 4) 注意，当 REPL 打印出列表时，它不包括单引号。我们将在后面的第 7 章中再来讨论为什么会这样。如果你想从一个列表中检索一个元素，你可以使用 nth 函数。\n(nth '(:a :b :c) 0) ; = :a (nth '(:a :b :c) 2) ; = :c 我在本书中没有详细介绍性能，因为我认为在你熟悉一种语言之后再关注它是没有用的。然而，知道使用nth从列表中检索一个元素比使用get从向量中检索一个元素要慢一些是很好的。这是因为 Clojure 必须遍历一个列表中的所有n个元素才能到达n个，而通过索引访问一个向量元素最多只需要几跳。\n列表值可以有任何类型，你可以用list函数创建列表。\n(list 1 \"two\" {3 4}) ; = (1 \"二\" {3 4}) 元素被添加到一个列表的开头。\n(conj '(1 2 3) 4) ; = (4 1 2 3) 什么时候应该使用列表，什么时候应该使用向量？一个好的经验法则是，如果你需要很容易地把项目添加到一个序列的开头，或者你正在写一个宏，你应该使用一个列表。否则，你应该使用矢量。随着你学习的深入，你会对何时使用哪种方法有很好的感觉。\nSet Set 是唯一值的 Set。Clojure 有两种类型的 Set：哈希 Set 和排序 Set。我将专注于哈希集，因为它们更经常被使用。下面是一个哈希集的文字符号。\n#{\"kurt vonnegut\" 20 :icicle}. 你也可以用hash-set来创建一个 Set:\n(hash-set 1 1 2 2) ; = #{1 2} 注意，一个值的多个实例在 Set 中成为一个唯一的值，所以我们只剩下一个1和一个2。如果你试图将一个值添加到一个已经包含该值的 Set 中（比如下面代码中的:b），它仍然只有一个该值。\n( conj #{:a :b} :b) ; = #{:a :b} 你也可以通过使用set函数从现有的向量和列表中创建 Set。\n(set [3 3 3 4 4]) ; = #{3 4} 你可以使用contains?函数来检查 Set 的成员资格，通过使用get，或通过使用关键字作为函数，以 Set 为参数。contains?返回true或false，而get和关键字查找将返回存在的值，如果不存在，则返回nil。\n下面是你如何使用contains?。\n(contains? #{:a :b} :a) ; = true (contains? #{:a :b} 3) ; = false (contains? #{nil} nil) ; = true 下面是你如何使用关键字。\n(:a #{:a :b}) ; = :a 这里是你如何使用get的方法。\n(get #{:a :b} :a) ; = :a (get #{:a nil} nil) ; = nil (get #{:a :b} \"kurt vonnegut\") ; = nil 注意，使用get来测试一个 Set 是否包含nil，将总是返回nil，这令人困惑。当你专门测试 Set 成员时，contains?可能是更好的选择。\n简单性 你可能已经注意到，到目前为止，对数据结构的处理并不包括对如何创建新类型或类的描述。原因是 Clojure 对简单性的强调鼓励你首先去接触内置的数据结构。\n如果你来自面向对象的背景，你可能会认为这种方法很奇怪而且落后。然而，你会发现，你的数据不一定非要和一个类紧密地捆绑在一起，才是有用和可理解的。这里有一个被 Clojurists 喜爱的寓言故事，暗示了 Clojure 的哲学。\n 让 100 个函数操作一个数据结构比让 10 个函数操作 10 个数据结构要好。 -Alan Perlis\n 在接下来的章节中，你会了解到更多关于 Clojure 哲学的这个方面。现在，请留意你通过坚持使用基本数据结构来获得代码重用性的方法。\n我们的 Clojure 数据结构入门课程到此结束。现在，是时候深入到函数中去，学习如何使用这些数据结构了\n函数 人们为 Lisps 疯狂的原因之一是，这些语言可以让你建立起行为复杂的程序，但主要的构件–函数–却是如此简单。本节通过解释以下内容，让你开始了解 Lisp 函数的美丽和优雅。\n 调用函数 函数与宏和特殊形式有什么不同 定义函数 匿名函数 返回函数  调用函数 现在你已经看到了许多函数调用的例子。\n(+ 1 2 3 4) (* 1 2 3 4) (first [1 2 3 4]) 请记住，所有的 Clojure 操作都有相同的语法：开括号、操作符、操作数、闭括号。函数**调用只是操作的另一个术语，其中运算符是一个函数或一个函数**表达式（一个返回函数的表达式）。\n这可以让你写出一些相当有趣的代码。下面是一个函数表达式，它返回+（加法）函数。\n(or + -) ; = #该返回值是加法函数的字符串表示。因为or的返回值是第一个真值，而这里的加法函数是真值，所以返回的是加法函数。你也可以在另一个表达式中使用这个表达式作为运算符。\n((or + -) 1 2 3) ; = 6 因为(or + -)返回+，这个表达式被评估为1、2和3之和，返回6。\n下面是几个有效的函数调用，它们都返回`6'。\n((and (= 1 1) +) 1 2 3) ; = 6 ((first [+ 0]) 1 2 3) ; = 6 在第一个例子中，and的返回值是第一个假值或最后一个真值。在这个例子中，+被返回，因为它是最后一个真值，然后被应用于参数1 2 3，返回6。在第二个例子中，first的返回值是一个序列中的第一个元素，在这个例子中是+。\n然而，这些都不是有效的函数调用，因为数字和字符串都不是函数。\n(1 2 3 4) (\"test\" 1 2 3) 如果你在 REPL 中运行这些，你会得到这样的结果。\nClassCastException java.lang.String cannot be cast to clojure.lang.IFn user/eval728 (NO_SOURCE_FILE:1) 当你继续使用 Clojure 时，你可能会多次看到这个错误。 cannot be cast to clojure.lang.IFn只是意味着你试图将某个东西作为一个函数使用，而它并不是。\n函数的灵活性并没有随着函数表达式的出现而结束! 在语法上，函数可以接受任何表达式作为参数–包括其他函数*。可以接受一个函数作为参数或返回一个函数的函数被称为高阶函数*。具有高阶函数的编程语言被称为支持第一类函数*，因为你可以像对待数字和向量等更熟悉的数据类型一样，将函数作为值来处理。\n以map函数（不要与 map 数据结构混淆）为例。map通过对一个集合的每个成员应用一个函数来创建一个新的列表。这里，inc函数将一个数字增加 1。\n(inc 1.1) ; = 2.1 (map inc [0 1 2 3]) ; = (1 2 3 4) (注意map并不返回一个向量，尽管我们提供了一个向量作为参数。你将在第四章中了解原因。现在，请相信这是好的，也是预期的）。\nClojure 对一级函数的支持使你能够建立比没有一级函数的语言更强大的抽象概念。那些不熟悉这种编程方式的人认为函数允许你对数据实例进行泛化操作。例如，+函数对任何特定数字的加法进行了抽象。\n相比之下，Clojure（以及所有 Lisps）允许你创建泛化进程的函数。map允许你通过在任何集合上应用一个函数–任何函数–来概括转换一个集合的过程。\n你需要知道的关于函数调用的最后一个细节是，Clojure 在将所有函数参数传递给函数之前，会递归地评估这些参数。下面是 Clojure 如何评估一个参数也是函数调用的函数调用。\n(+ (inc 199) (/ 100 (- 7 2))) (+ 200 (/ 100 (- 7 2))) ; evaluated \"(inc 199)\" (+ 200 (/ 100 5)) ; evaluated (- 7 2) (+ 200 20) ; evaluated (/ 100 5) 220 ; final evaluation 函数调用启动了评估过程，在应用+函数之前，所有的子表格都被评估了。\n函数调用、宏调用和特殊形式 在上一节中，你了解到函数调用是以函数表达式为操作符的表达式。另外两种表达式是宏调用和特殊形式。你已经看到了几种特殊形式：定义和if表达式。\n你将在第 7 章中学习关于宏调用和特殊形式的所有知识。现在，使特殊形式 “特殊 “的主要特征是，与函数调用不同，它们不总是评估所有**它们的操作数。\n以 “if “为例。这是它的一般结构。\n(if boolean-form then-form optional-else-form) 现在想象一下你有一个这样的if语句。\n(if good-mood (tweet walking-on-sunshine-lyrics) (tweet mopey-country-song-lyrics)) 显然，在这样的if表达中，我们希望 Clojure 只评估两个分支中的一个。如果 Clojure 同时评估两个`tweet’函数调用，你的 Twitter 粉丝们最终会非常困惑。\n另一个区别于特殊形式的特征是，你不能把它们作为函数的参数。一般来说，特殊形式实现了 Clojure 的核心功能，只是不能用函数实现。Clojure 只有少量的特殊形式，而如此丰富的语言是用如此小的一组构建块来实现的，这是很令人惊讶的。\n宏与特殊形式类似，它们对操作数的评估与函数调用不同，而且它们也不能作为参数传递给函数。但这段弯路已经走得够长了；现在是学习如何定义函数的时候了!\n定义函数 函数的定义由五个主要部分组成。\n defn 函数名称 描述该函数的 docstring(可选) 括号中列出的参数 函数主体  下面是一个函数定义的例子和函数的调用示例。\n➊ (defn too-enthusiastic ➋ \"Return a cheer that might be a bit too enthusiastic\" ➌ [name] ➍ (str \"OH. MY. GOD! \" name \" YOU ARE MOST DEFINITELY LIKE THE BEST \" \"MAN SLASH WOMAN EVER I LOVE YOU AND WE SHOULD RUN AWAY SOMEWHERE\")) (too-enthusiastic \"Zelda\") ; = \"OH. MY. GOD! Zelda YOU ARE MOST DEFINITELY LIKE THE BEST MAN SLASH WOMAN EVER I LOVE YOU AND WE SHOULD RUN AWAY SOMEWHERE\" 在➊处，too-enthusiastic是函数的名称，在➋处有一个描述性的 docstring。参数 “name “在➌处给出，函数体在➍处接受参数，并做了它所描述的事情–返回一个可能有点过于热情的欢呼。\n让我们更深入地了解 docstring、参数和函数体。\ndocstring docstring*是一种描述和记录你的代码的有用方法。你可以在 REPL 中用 (docfn-name)查看一个函数的 docstring，例如 (doc map)。如果你使用一个工具为你的代码生成文档，那么 docstring 也会发挥作用。\n参数和 Arity Clojure 函数可以用零个或多个参数来定义。你传递给函数的值被称为arguments，参数可以是任何类型。参数的数量就是函数的*特性。下面是一些具有不同性质的函数定义。\n(defn no-params [] \"I take no parameters!\") (defn one-param [x] (str \"I take one parameter: \" x)) (defn two-params [x y] (str \"Two parameters! That's nothing! Pah! I will smoosh them \" \"together to spite you! \" x y)) 在这些例子中，no-params是一个 0-arity 函数，one-param是 1-arity，two-params是 2-arity。\n函数也支持 arity overloading。这意味着你可以定义一个函数，使不同的函数体根据不同的 arity 来运行。下面是一个多义性函数定义的一般形式。请注意，每个数位定义都被括在括号里，并且有一个参数列表。\n(defn multi-arity ;; 3-arity arguments and body ([first-arg second-arg third-arg] (do-things first-arg second-arg third-arg)) ;; 2-arity arguments and body ([first-arg second-arg] (do-things first-arg second-arg)) ;; 1-arity arguments and body ([first-arg] (do-things first-arg))) Arity 重载是为参数提供默认值的一种方法。在下面的例子中，\"karate\"是chop-type参数的默认参数。\n(defn x-chop \"Describe the kind of chop you're inflicting on someone\" ([name chop-type] (str \"I \" chop-type \" chop \" name \"! Take that!\")) ([name] (x-chop name \"karate\"))) 如果你用两个参数调用x-chop，该函数的工作原理和它不是一个多义性函数时一样。\n(x-chop \"Kanye West\" \"slap\") ; = \"I slap chop Kanye West! Take that!\" 如果你调用x-chop时只有一个参数，x-chop实际上会在提供第二个参数\"空手道\"时调用自己。\n(x-chop \"Kanye East\") ; = \"I karate chop Kanye East! Take that!\" 像这样用函数本身来定义一个函数，可能显得不寻常。如果是这样，那就好了! 你正在学习一种新的方法来做事!\n你也可以让每个 arity 做一些完全不相关的事情。\n(defn weird-arity ([] \"Destiny dressed you this morning, my friend, and now Fear is trying to pull off your pants. If you give up, if you give in, you're gonna end up naked with Fear just standing there laughing at your dangling unmentionables! - the Tick\") ([number] (inc number))) 0-arity 主体返回一个明智的引号，1-arity 主体增加一个数字。最有可能的是，你不会想写一个这样的函数，因为有两个完全不相关的函数体会让人困惑。\nClojure 还允许你通过包括一个rest 参数来定义可变极性函数，就像 “把这些参数的其余部分放在一个列表中，名称如下”。休息参数用安培号（\u0026）表示，如➊所示。\n(defn codger-communication [whippersnapper] (str \"Get off my lawn, \" whippersnapper \"!!!\")) (defn codger ➊ [\u0026 whippersnappers] (map codger-communication whippersnappers)) (codger \"Billy\" \"Anne-Marie\" \"The Incredible Bulk\") ; = (\"Get off my lawn, Billy!!!\" \"Get off my lawn, Anne-Marie!!!\" \"Get off my lawn, The Incredible Bulk!!!\") 正如你所看到的，当你为变量性质的函数提供参数时，参数被当作一个列表来处理。你可以把休息参数和普通参数混在一起，但休息参数必须放在最后。\n(defn favorite-things [name \u0026 things] (str \"Hi, \" name \", here are my favorite things: \" (clojure.string/join \", \" things))) (favorite-things \"Doreen\" \"gum\" \"shoes\" \"kara-te\") ; = \"Hi, Doreen, here are my favorite things: gum, shoes, kara-te\" 最后，Clojure 有一种更复杂的定义参数的方法，叫做destructuring，这值得有自己的小节。\n解构 解构的基本思想是，它可以让你在一个集合中简洁地将名字与值绑定。让我们看看一个基本的例子。\n;; Return the first element of a collection (defn my-first [[first-thing]] ; Notice that first-thing is within a vector first-thing) (my-first [\"oven\" \"bike\" \"war-axe\"]) ; = \"oven\" 这里，my-first函数将符号first-thing与作为参数传入的向量中的第一个元素联系起来。你告诉my-first这样做，就是把符号first-thing放在一个向量中。\n矢量就像一个巨大的牌子，对 Clojure 说：“嘿！这个函数将收到一个列表或矢量作为参数。让我的生活更轻松，为我拆开参数的结构，并将有意义的名字与参数的不同部分联系起来！” 当对一个向量或列表进行解构时，你可以随意命名你想要的元素，也可以使用其他参数。\n(defn chooser [[first-choice second-choice \u0026 unimportant-choices]] (println (str \"Your first choice is: \" first-choice)) (println (str \"Your second choice is: \" second-choice)) (println (str \"We're ignoring the rest of your choices. \" \"Here they are in case you need to cry over them: \" (clojure.string/join \", \" unimportant-choices)))) (chooser [\"Marmalade\", \"Handsome Jack\", \"Pigpen\", \"Aquaman\"]) ; = Your first choice is: Marmalade ; = Your second choice is: Handsome Jack ; = We're ignoring the rest of your choices. Here they are in case \\ you need to cry over them: Pigpen, Aquaman 这里，其余的参数unimportant``-choices处理用户在第一和第二选择之后的任何数量的额外选择。\n你也可以对 Map 进行去结构化。就像你告诉 Clojure 通过提供一个向量作为参数来解除向量或列表的结构一样，你可以通过提供一个 Map 作为参数来解除 Map 的结构。\n(defn announce-treasure-location ➊ [{lat :lat lng :lng}] (println (str \"Treasure lat: \" lat)) (println (str \"Treasure lng: \" lng))) (announce-treasure-location {:lat 28.22 :lng 81.33}) ; = Treasure lat: 28.22 ; = Treasure lng: 81.33 让我们更详细地看看➊的那一行。这就像告诉 Clojure，“哟！Clojure! 为我做一件事，把lat这个名字与键:lat对应的值联系起来。对lng和:lng做同样的事情，好吗？”\n我们经常想直接把关键词从 Map 中分离出来，所以有一个更短的语法。这和前面的例子有相同的结果。\n(defn announce-treasure-location [{:keys [lat lng]}] 。 (println (str \"Treasure lat: \" lat)) (println (str \"Treasure lng: \" lng))) 你可以通过使用:as关键字保留对原始 Map 参数的访问。在下面的例子中，原始 Map 是用treasure-location来访问的。\n(defn receive-treasure-location [{:keys [lat lng] :as treasure-location}] (println (str \"Treasure lat: \" lat)) (println (str \"Treasure lng: \" lng)) ;; One would assume that this would put in new coordinates for your ship (steer-ship! treasure-location)) 一般来说，你可以把重构看作是指示 Clojure 如何将名字与列表、Map、集合或向量中的值联系起来。现在，我们来看看函数中真正起作用的部分：函数体!\n函数体 函数主体可以包含任何形式的表单。Clojure 会自动返回最后评估的形式。这个函数体只包含三种形式，当你调用这个函数时，它会吐出最后一种形式，\"joe\"。\n(defn illustrative-function [] (+ 1 304) 30 \"joe\") (exstrative-function) ; = \"joe\" 下面是另一个函数体，它使用一个if表达式。\n(defn number-comment [x] (if ( x 6) \"Oh my gosh! What a big number!\" \"That number's OK, I guess\")) (number-comment 5) ; = \"That number's OK, I guess\" (number-comment 7) ; = \"Oh my gosh! What a big number!\" 所有函数都是平等的 最后说明一下：Clojure 没有特权函数。+只是一个函数，-只是一个函数，而inc和map也只是函数。它们并不比你自己定义的函数好。所以，不要让他们给你任何口实!\n更重要的是，这个事实有助于证明 Clojure 的底层简单性。在某种程度上，Clojure 是非常愚蠢的。当你进行函数调用时，Clojure 只是说，\"map？当然，不管怎样! 我只是应用这个并继续前进”。它并不关心这个函数是什么，或者它来自哪里；它对所有的函数都一视同仁。在它的核心，Clojure 并不关心加法、乘法或映射的问题。它只关心函数的应用。\n当你继续用 Clojure 编程时，你会发现这种简单性是很理想的。你不必为处理不同的函数而担心特殊的规则或语法。它们的工作原理都是一样的!\n匿名函数 在 Clojure 中，函数不需要有名字。事实上，你会一直使用匿名函数。多么神秘啊! 你可以通过两种方式创建匿名函数。第一种是使用fn形式。\n(fn [param-list] function body) 看起来很像defn，不是吗？让我们试一试几个例子。\n(map (fn [name] (str \"Hi, \" name)) [\"Darth Vader\" \"Mr. Magoo\"] ) ; = (\"Hi, Darth Vader\" \"Hi, Mr. Magoo\") ((fn [x] (* x 3)) 8) ; = 24 你可以用处理fn的方式来处理defn，这几乎是相同的。参数列表和函数体的工作原理完全相同。你可以使用参数重构，休息参数，等等。你甚至可以将你的匿名函数与一个名字联系起来，这不应该是一个惊喜（如果这确实是一个惊喜，那么 … … 惊喜！）。\n(def my-special-multiplier (fn [x] (* x 3)) (my-special-multiplier 12) ; = 36 Clojure 还提供了另一种更紧凑的方式来创建匿名函数。下面是一个匿名函数的样子。\n#(* % 3) 哇，这看起来很奇怪。来吧，应用这个看起来很奇怪的函数。\n(#(* % 3) 8) ; = 24 下面是一个将匿名函数作为参数传递给 map 的例子。\n(map #(str \"Hi, \" %) [\"Darth Vader\" \"Mr. Magoo\"]) ; = (\"Hi, Darth Vader\" \"Hi, Mr. Magoo\") 这种看起来很奇怪的匿名函数的编写方式是由一个叫做reader**macros的函数实现的。你会在第 7 章中了解到这些。现在，只学习如何使用这些匿名函数就可以了。\n你可以看到，这种语法肯定更紧凑，但也有点奇怪。让我们把它分解一下。这种匿名函数看起来很像函数调用，只是它前面有一个哈希标记，#。\n;; Function call (* 8 3) ;; Anonymous function #(* % 3) 这种相似性使你能更快地看到应用这个匿名函数时将发生什么。“哦，“你可以对自己说，“这是要把它的参数乘以 3”。\n现在你可能已经猜到了，百分号%，表示传递给函数的参数。如果你的匿名函数需要多个参数，你可以像这样区分它们。%1, %2, %3, 以此类推。%相当于%1。\n(#(str %1 \" and \" %2) \"cornbread\" \"butter beans\") ; = \"cornbread and butter beans\" 你也可以用%\u0026传递其余参数。\n(#(identity %\u0026) 1 \"blarg\" :yip) ; = (1 \"blarg\" :yip) 在这种情况下，你将身份函数应用于其余参数。Identity 返回它所给的参数而不改变它。休息参数是以列表形式存储的，所以函数应用返回所有参数的列表。\n如果你需要写一个简单的匿名函数，使用这种风格是最好的，因为它在视觉上很紧凑。另一方面，如果你要写一个更长、更复杂的函数，它很容易变得不可读。如果是这种情况，请使用fn。\n返回函数 现在你已经看到，函数可以返回其他函数。返回的函数是closures，这意味着它们可以访问函数创建时在范围内的所有变量。下面是一个标准的例子。\n(defn inc-maker \"Create a custom incrementor\" [inc-by] #(+ % inc-by)) (def inc3 (inc-maker 3)) (inc3 7) ; = 10 这里，inc-by在范围内，所以即使返回的函数在inc-maker之外使用，也可以访问它。\n把这一切拉到一起 好了! 是时候把你新发现的知识用于一个崇高的目的了：打倒霍比特人! 要打一个霍比特人，你首先要建立它的身体部位模型。每个身体部位都将包括其相对大小，以表明该部位被击中的可能性有多大。为了避免重复，霍比特人的模型将只包括左**脚，左**耳的条目，以此类推。因此，你需要一个函数来完全对称该模型，创建右**脚，右**耳，等等。最后，你将创建一个函数，迭代身体各部分，并随机选择击中的部分。在这一过程中，你将了解到一些新的 Clojure 工具。let表达式，循环，和正则表达式。有趣的是!\n夏尔的下一个顶级模型 对于我们的霍比特人模型，我们将避开霍比特人的特征，如活泼和调皮，只关注霍比特人的小身板。下面是霍比特人的模型。\n(def asym-hobbit-body-parts [{:name \"head\" :size 3} {:name \"left-eye\" :size 1} {:name \"left-ear\" :size 1} {:name \"mouth\" :size 1} {:name \"nose\" :size 1} {:name \"neck\" :size 2} {:name \"left-shoulder\" :size 3} {:name \"left-upper-arm\" :size 3} {:name \"chest\" :size 10} {:name \"back\" :size 10} {:name \"left-forearm\" :size 3} {:name \"abdomen\" :size 6} {:name \"left-kidney\" :size 1} {:name \"left-hand\" :size 2} {:name \"left-knee\" :size 2} {:name \"left-thigh\" :size 4} {:name \"left-lower-leg\" :size 3} {:name \"left-achilles\" :size 1} {:name \"left-foot\" :size 2}]) 这是一个 Map 的向量。每个 Map 都有身体部位的名称和身体部位的相对大小。(我知道只有动漫人物的眼睛是头部的三分之一大小，但就这样吧，好吗？)\n明显缺少的是霍比特人的右侧。让我们来解决这个问题。清单 3-1 是到目前为止你看到的最复杂的代码，它引入了一些新的想法。但是不要担心，因为我们将详细地研究它。\n(defn matching-part [part] {:name (clojure.string/replace (:name part) #\"^left-\" \"right-\") :size (:size part)}) (defn symmetrize-body-parts \"Expects a seq of maps that have a :name and :size\" [asym-body-parts] (loop [remaining-asym-parts asym-body-parts final-body-parts []] (if (empty? remaining-asym-parts) final-body-parts (let [[part \u0026 remaining] remaining-asym-parts] (recur remaining (into final-body-parts (set [part (matching-part part)])))))))  3-1. 匹配-部分和对称-身体-部分的函数  当我们对asym-hobbit-body-parts调用函数symmetriz-body-parts时，我们得到一个完全对称的霍比特人。\n(symmetrize-body-parts asym-hobbit-body-parts) ; = [{:name \"head\", :size 3} {:name \"left-eye\", :size 1} {:name \"right-eye\", :size 1} {:name \"left-ear\", :size 1} {:name \"right-ear\", :size 1} {:name \"mouth\", :size 1} {:name \"nose\", :size 1} {:name \"neck\", :size 2} {:name \"left-shoulder\", :size 3} {:name \"right-shoulder\", :size 3} {:name \"left-upper-arm\", :size 3} {:name \"right-upper-arm\", :size 3} {:name \"chest\", :size 10} {:name \"back\", :size 10} {:name \"left-forearm\", :size 3} {:name \"right-forearm\", :size 3} {:name \"abdomen\", :size 6} {:name \"left-kidney\", :size 1} {:name \"right-kidney\", :size 1} {:name \"left-hand\", :size 2} {:name \"right-hand\", :size 2} {:name \"left-knee\", :size 2} {:name \"right-knee\", :size 2} {:name \"left-thigh\", :size 4} {:name \"right-thigh\", :size 4} {:name \"left-lower-leg\", :size 3} {:name \"right-lower-leg\", :size 3} {:name \"left-achilles\", :size 1} {:name \"right-achilles\", :size 1} {:name \"left-foot\", :size 2} {:name \"right-foot\", :size 2}] 让我们来分析一下这段代码!\nlet 在清单 3-1 的大量疯狂中，你可以看到结构(let ...)的形式。让我们通过一个例子来建立对let的理解，当我们熟悉了所有的部分后，再来检查程序中的完整例子。\nlet将名字与值绑定。你可以认为let是let it be的缩写，这也是披头士乐队关于编程的一首优美的歌曲。这里有一个例子。\n(让 [x 3] x) ; = 3 (def dalmatian-list [\"Pongo\" \"Perdita\" \"Puppy 1\" \"Puppy 2\"] ) (让 [dalmatians (take 2 dalmatian-list)]) 达尔马提亚人) ; = (\"Pongo\" \"Perdita\") 在第一个例子中，你将名字x与值3绑定。在第二个例子中，你把名字dalmatians绑定到表达式(取2dalmatian-list)的结果，也就是列表(\"Pongo\" \"Perdita\")。let还引入了一个新的*范围。\n(def x 0) (let [x 1] x) ; = 1 这里，你首先使用def将名字x绑定到值0上。然后，let创建了一个新的作用域，在这个作用域中，名字x被绑定到值1上。我认为范围是指事物的上下文。例如，在 “请清理这些烟头 “这句话中，烟头的含义是不同的，这取决于你是在产科病房工作还是在香烟制造商大会的监管人员工作。在这个代码片段中，你在说：“我希望x'在全局上下文中是0'，但在这个let'表达式的上下文中，它应该是1'。”\n你可以在你的let绑定中引用现有的绑定。\n(def x 0) (let [x (inc x)] x) ; = 1 在这个例子中，(inc x)中的x是指由(def x 0)创建的绑定。结果是1'，然后在let’创建的新作用域中与名称x'绑定。在let表单的范围内，x指的是1，而不是0`。\n你也可以在let中使用休息参数，就像你在函数中一样。\n(let [[Pongo \u0026 dalmatians] dalmatian-list] [Pongo dalmatians]) [Pongo dalmatians]) ; = [\"Pongo\" (\"Perdita\" \"Puppy 1\" \"Puppy 2\") ] 注意，let表单的值是其主体中最后被评估的表单。let形式遵循所有在“调用函数 “第 48 页中介绍的析构规则。在这个例子中，[pongo \u0026 dalmatians]解构了dalmatian-list'，将字符串“Pongo “绑定到名称pongo'上，将其余的dalmatians列表绑定到dalmatians上。向量[pongo dalmatians]是let的最后一个表达式，所以它是let`形式的值。\nlet形式有两个主要用途。首先，它们通过允许你对事物进行命名来提供清晰度。其次，它们允许你只评估一个表达式，并重复使用其结果。当你需要重复使用一个昂贵的函数调用的结果时，这一点特别重要，比如网络 API 调用。当表达式有副作用时，这也很重要。\n让我们再看一下我们的对称函数中的let形式，这样我们就能明白到底发生了什么。\n(let [[part \u0026 remaining] remaining-asym-parts]) (recur remaining (in into final-body-parts (set [part (matching-part part part)])))) 这段代码告诉 Clojure，“创建一个新的范围。在它里面，将part与remaining-asym-parts的第一个元素相关联。将remaining与remaining-asym-parts中的其他元素联系起来”。\n至于let表达式的主体，你将在下一节中了解到recur的含义。函数调用\n(in into final-body-parts (set [part (matching-part part part)] )) 首先告诉 Clojure, “使用set'函数创建一个由part’和它的匹配部分组成的集合。然后使用函数into将该集合的元素添加到向量final-body-parts中”。你在这里创建一个集合，以确保你向final-body-parts添加唯一的元素，因为part和(matching-part part)有时是同一个东西，正如你将在接下来的正则表达式部分看到的。下面是一个简化的例子。\n(into [] (set [:a :a])) ; = [:a] 首先，(set [:a :a])返回集合#{:a}，因为集合不包含重复的元素。然后(into [] #{:a})返回向量[:a]。\n回到let'：注意part’在let'的主体中被多次使用。如果我们使用原来的表达式，而不是使用part和remaining`的名字，那将是一个混乱的局面! 下面是一个例子。\n(recur (rest remaining-asym-parts) (in into final-body-parts (set [(first remaining-asym-parts) (matching-part (first remaining-asym-parts)) ])) 所以，let是一种方便的方法，可以为值引入本地名称，这有助于简化代码。\n循环 在我们的symmetrize-body-parts函数中，我们使用了loop，它提供了另一种在 Clojure 中进行递归的方法。让我们看看一个简单的例子。\n(loop [iteration 0] (println (str \"Iteration \" iteration)) (if ( iteration 3) (println \"Goodbye!\") (recur (inc iteration)))) ; = Iteration 0 ; = Iteration 1 ; = Iteration 2 ; = Iteration 3 ; = Iteration 4 ; = Goodbye! 第一行，loop [iteration 0]，开始了循环并引入了一个初始值的绑定。在循环的第一次传递中，iteration的值为 0.接下来，它打印一个短消息。然后，它检查iteration的值。如果该值大于 3，那么是时候说再见了。否则，我们就 “重来”。这就好比loop创建了一个匿名函数，其参数名为iteration，而recur允许你从其内部调用该函数，传递参数(inc iteration)。\n事实上，你可以通过使用一个普通的函数定义来完成同样的事情。\n(defn recursive-printer ([] (recursive-printer 0)) ([iteration] (println iteration) (if ( iteration 3) (println \"Goodbye!\") (recursive-printer (inc iteration))))) (recursive-printer) ; = Iteration 0 ; = Iteration 1 ; = Iteration 2 ; = Iteration 3 ; = Iteration 4 ; = Goodbye! 但正如你所看到的，这是个比较啰嗦的方法。而且，loop有更好的性能。在我们的对称化函数中，我们将使用loop遍历不对称的身体部位列表中的每个元素。\n正则表达式 正则表达式是对文本进行模式匹配的工具。正则表达式的文字符号是将表达式放在哈希标记后的引号中。\n#\"regular-expression\" 在清单 3-1 中的函数matching-part中，clojure.string/replace使用正则表达式#\"^left-\"来匹配以\"left-\"开头的字符串，以便用\"right-\"替换\"left-\"。卡特，^，是正则表达式发出的信号，即只有当文本\"left-\"位于字符串的开头时，它才会匹配，这就确保了像\"cleft-chin\"这样的字符串不会匹配。你可以用re-find来测试，它检查一个字符串是否与正则表达式描述的模式相匹配，如果不匹配，则返回匹配的文本或nil。\n(re-find #\"^left-\" \"left-eye\") ; = \"left-\" (re-find #\"^left-\" \"cleft-chin\") ; = nil (re-find #\"^left-\" \"wongleblart\") ; = nil 下面是几个matching-part'的例子，使用一个重词将“left-“替换为`“right-\"。\n(defn matching-part [part] {:name (clojure.string/replace (:name part) #\"^left-\" \"right-\") :size (:size part)}) (matching-part {:name \"left-eye\" :size 1}) ; = {:name \"right-eye\" :size 1}] (matching-part {:name \"head\" :size 3}) ; = {:name \"head\" :size 3}] 请注意，名称 “head” “是原样返回的。\n对称器 现在让我们回到完整的对称器，对其进行更详细的分析。\n(def asym-hobbit-body-parts [{:name \"head\" :size 3} {:name \"left-eye\" :size 1} {:name \"left-ear\" :size 1} {:name \"mouth\" :size 1} {:name \"nose\" :size 1} {:name \"neck\" :size 2} {:name \"left-shoulder\" :size 3} {:name \"left-upper-arm\" :size 3} {:name \"chest\" :size 10} {:name \"back\" :size 10} {:name \"left-forearm\" :size 3} {:name \"abdomen\" :size 6} {:name \"left-kidney\" :size 1} {:name \"left-hand\" :size 2} {:name \"left-knee\" :size 2} {:name \"left-thigh\" :size 4} {:name \"left-lower-leg\" :size 3} {:name \"left-achilles\" :size 1} {:name \"left-foot\" :size 2}]) (defn matching-part [part] {:name (clojure.string/replace (:name part) #\"^left-\" \"right-\") :size (:size part)}) ➊ (defn symmetrize-body-parts \"Expects a seq of maps that have a :name and :size\" [asym-body-parts] ➋ (loop [remaining-asym-parts asym-body-parts final-body-parts []] ➌ (if (empty? remaining-asym-parts) final-body-parts ➍ (let [[part \u0026 remaining] remaining-asym-parts] ➎ (recur remaining (into final-body-parts (set [part (matching-part part)]))))))) symmetriz-body-parts函数（从➊开始）采用了函数式编程中常见的一般策略。给定一个序列（在本例中，是一个身体部位及其尺寸的向量），该函数连续地将该序列分割成head和尾。然后，它处理头部，将其添加到某个结果中，并使用递归来继续处理尾部的过程。\n我们在➋处开始循环处理主体部分。序列的尾部将被绑定到remaining-asym-parts。最初，它被绑定到传递给函数的完整序列：asym-body-parts'。我们还创建了一个结果序列，final-body-parts`；它的初始值是一个空向量。\n如果remaining-asym-parts在➌处是空的，这意味着我们已经处理了整个序列，可以返回结果，final-body-parts。否则，在➍，我们将列表分成头，部分，和尾，剩余。\n在➎处，我们用remaining进行循环，这个列表在循环的每一次迭代中都会缩短一个元素，还有(in)表达式，它建立了对称的身体部分的向量。\n如果你是这种编程的新手，这段代码可能需要一些时间来解决。请坚持下去! 一旦你理解了正在发生的事情，你会觉得自己像个百万富翁!\n更好的对称器与 reduce 处理********************************************的模式非常普遍，以至于有一个内置的函数叫做reduce。下面是一个简单的例子。\n;; sum with reduce (reduce + [1 2 3 4]) ; = 10 这就像告诉 Clojure 这样做。\n(+ (+ (+ 1 2) 3) 4) reduce函数按照以下步骤工作。\n 将给定的函数应用于一个序列的前两个元素。这就是(+ 1 2)的由来。 将给定的函数应用于结果和序列的下一个元素。在本例中，步骤 1 的结果是3，序列的下一个元素也是3。所以最后的结果是`(+3 3)'。 对序列中剩下的每个元素重复第 2 步。  reduce也需要一个可选的初始值。这里的初始值是15。\n(reduce + 15 [1 2 3 4]) 如果你提供了一个初始值，reduce就会开始对初始值和序列的第一个元素应用给定的函数，而不是序列的前两个元素。\n需要注意的一个细节是，在这些例子中，reduce接收一个元素的集合，[1 2 3 4]，并返回一个单一的数字。虽然程序员经常这样使用reduce，但你也可以使用reduce来返回一个比你开始时更大的集合，就像我们在symmetrize-body-parts中尝试做的那样。reduce抽象了 \"处理一个集合并建立一个结果 \"的任务，它对返回的结果类型是不确定的。为了进一步了解reduce`的工作原理，这里有一种方法可以实现它。\n(defn my-reduce ([f initial coll] (loop [result initial remaining coll] (if (empty? remaining) result (recur (f result (first remaining)) (rest remaining))))) ([f [head \u0026 tail]] (my-reduce f head tail))) 我们可以重新实现我们的对称器，如下所示。\n(defn better-symmetrize-body-parts \"Expects a seq of maps that have a :name and :size\" [asym-body-parts] (reduce (fn [final-body-parts part] (into final-body-parts (set [part (matching-part part)]))) [] asym-body-parts)) 真棒! 使用reduce的一个显而易见的好处是，你写的代码总体上更少。你传递给reduce的匿名函数只专注于处理一个元素和建立一个结果。原因是reduce处理了底层的机制，即跟踪哪些元素已经被处理，并决定是否返回一个最终结果或递归。\n使用reduce也更有表现力。如果你的代码的读者遇到 “loop”，如果不阅读所有的代码，他们将不能确定这个循环到底在做什么。但是如果他们看到reduce，他们会立即知道代码的目的是处理一个集合的元素以建立一个结果。\n最后，通过将 “reduce “过程抽象为一个以另一个函数为参数的函数，你的程序变得更有可塑性。例如，你可以将reduce函数作为一个参数传递给其他函数。你还可以创建一个更通用的 “对称体-部件 “版本，例如 “扩展体-部件”。除了身体部位的列表外，它还可以接受一个扩展器函数，并让你的模型不仅仅是霍比特人。例如，你可以有一个蜘蛛扩展器，可以增加眼睛和腿的数量。我会让你自己来写，因为我是邪恶的。\n霍比特人的暴力 我的话，这真是为勇敢和真实的人准备的 Clojure! 为了给你的工作画上句号，这里有一个函数可以确定霍比特人的哪个部分被击中。\n(defn hit [asym-body-parts] (let [sym-parts (➊better-symmetrize-body-parts asym-body-parts) ➋body-part-size-sum (reduce + (map :size sym-parts)) target (rand body-part-size-sum)] ➌(loop [[part \u0026 remaining] sym-parts accumulated-size (:size part)] (if ( accumulated-size target) part (recur remaining (+ accumulated-size (:size (first remaining)))))))) hit的工作原理是取一个不对称的身体部位的向量，在➊处对称，然后在➋处将各部位的大小相加。一旦我们将这些尺寸相加，就好像从 1 到身体部位尺寸之和的每个数字都对应于一个身体部位；1 可能对应于左眼，而 2、3、4 可能对应于头部。这使得当你击中一个身体部位时（通过在这个范围内选择一个随机数字），特定身体部位被击中的可能性将取决于身体部位的大小。\n图 3-1：身体部位与数字的范围相对应，如果目标在这个范围内，就会被击中。\n最后，这些数字中的一个被随机选择，然后我们在➌处使用loop来寻找并返回与该数字对应的身体部位。循环是通过跟踪我们已经检查过的部分的累计大小，并检查累计大小是否大于目标值来实现的。我把这个过程想象成用一排编号的槽来排列身体部位。在我排完一个身体部位后，我问自己：“我已经达到目标了吗？” 如果我达到了，这意味着我刚刚排好的身体部位就是被击中的那个部位。否则，我就继续排查这些部位。\n例如，假设你的零件清单是头、左眼和左手，如图 3-1。在取完第一个部分，即头部后，累计大小为 3。当累计大小超过目标时，身体部分就被击中，所以如果目标小于 3，那么头部就被击中了。否则，你取下下一个部分，即左眼，并将累积大小增加到 4，如果目标大于或等于 3 且小于 4，则产生一个命中。\n下面是一些hit函数的运行样本。\n(hit asym-hobbit-body-parts) ; = {:name \"right-upper-arm\", :size 3} (hit asym-hobbit-body-parts) ; = {:name \"chest\", :size 10} (hit asym-hobbit-body-parts) ; = {:name \"left-eye\", :size 1} 哦，我的上帝，那个可怜的霍比特人！你这个怪物！\"。你这个怪物!\n总结 本章让你对如何在 Clojure 中做事有了一个旋风式的了解。你现在知道了如何用字符串、数字、Map、关键字、向量、列表和集合来表示信息，以及如何用def和let来命名这些表示法。你已经了解了函数的灵活性以及如何创建你自己的函数。此外，你还了解了 Clojure 的简洁哲学，包括其统一的语法和强调在原始数据类型上使用大型函数库。\n第 4 章将带你详细考察 Clojure 的核心函数，第 5 章解释了函数式编程的思维模式。本章向你展示了如何编写 Clojure 代码–接下来的两章将向你展示如何编写 Clojure*好。\n在这一点上，我建议你开始写代码，我的每一根纤维都是这样。没有比这更好的方法来巩固你的 Clojure 知识了。Clojure Cheat Sheet（http://clojure.org/api/cheatsheet）是一个很好的参考资料，它列出了所有在本章中涉及的数据结构上操作的内置函数。\n下面的练习会让你的大脑非常兴奋。如果你想更多地测试你的新技能，可以在*http://www.projecteuler.net/尝试一些 Project Euler 挑战。你还可以看看 4Clojure（http://www.4clojure.com/problems/*），这是一套在线的 Clojure 问题，旨在测试你的知识。写点什么吧!\n练习 这些练习是为了测试你的 Clojure 知识和学习更多的 Clojure 函数，是一种有趣的方式。前三个可以只用本章介绍的信息来完成，但后三个需要你使用到目前为止还没有涉及的函数。如果你真的很想写更多的代码并探索 Clojure 的标准库，那么就去解决后三个问题。如果你觉得这些练习太难了，可以在读完第 4 章和第 5 章后再来看看，你会发现它们要容易得多。\n  使用str, vector, list, hash-map, 和hash-set函数。\n  编写一个函数，接收一个数字，并向其添加 100。\n  写一个函数。\ndec-maker ，其工作原理与函数\ninc-maker 除了用减法。\n(def dec9 (dec-maker 9)) (dec9 10) ; = 1   写一个函数。\nmapset ，它的工作原理是\nmap 除了返回值是一个集合。\n(mapset inc [1 1 2 2]) ; = #{2 3}   创建一个类似于symmetriz-body-parts的函数，只是它必须与具有径向对称性的奇怪的太空外星人一起工作。他们没有两只眼睛、胳膊、腿等等，而是有五只。\n  创建一个函数，将`symmetriz-body-parts’和你在练习 5 中创建的函数通用化。这个新的函数应该接受一个身体部位的集合，以及要增加的匹配身体部位的数量。如果你对 Lisp 语言和函数式编程是完全陌生的，那么如何做到这一点可能并不明显。如果你被卡住了，只需转到下一章，以后再重温这个问题。\n  ","wordCount":"3116","inLanguage":"en","image":"https://zhenfeng-zhu.github.io/posts/chapter3/https:/raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201131821608.png","datePublished":"2022-01-13T11:12:19+08:00","dateModified":"2022-01-13T11:12:19+08:00","author":{"@type":"Person","name":"Fenix"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhenfeng-zhu.github.io/posts/chapter3/"},"publisher":{"@type":"Organization","name":"Awesome Fenix","logo":{"@type":"ImageObject","url":"https://zhenfeng-zhu.github.io/favicon.ico"}}}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8502076734034112" crossorigin=anonymous></script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhenfeng-zhu.github.io accesskey=h title="Awesome Fenix (Alt + H)">Awesome Fenix</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://zhenfeng-zhu.github.io/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/about title=About>
<span>About</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/search/ title=🔍>
<span>🔍</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://zhenfeng-zhu.github.io>Home</a>&nbsp;»&nbsp;<a href=https://zhenfeng-zhu.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Chapter3 Clojure 速成班
</h1>
<div class=post-meta><span title="2022-01-13 11:12:19 +0800 +0800">January 13, 2022</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Fenix&nbsp;|&nbsp;<a href=https://github.com/zhenfeng-zhu/zhenfeng-zhu.github.io/tree/main/content/posts/Chapter3.md rel="noopener noreferrer" target=_blank>修改本文章</a>
</div>
</header>
<figure class=entry-cover><img loading=lazy src=https://raw.githubusercontent.com/zhenfeng-zhu/pic-go/main/202201131821608.png alt>
<p></p>
</figure><div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e5%81%9a%e4%ba%8b%e6%83%85clojure-%e9%80%9f%e6%88%90%e7%8f%ad aria-label="做事情：Clojure 速成班">做事情：Clojure 速成班</a><ul>
<li>
<a href=#%e8%af%ad%e6%b3%95 aria-label=语法>语法</a><ul>
<li>
<a href=#%e5%bd%a2%e5%bc%8f aria-label=形式>形式</a></li>
<li>
<a href=#%e6%8e%a7%e5%88%b6%e6%b5%81 aria-label=控制流>控制流</a><ul>
<li>
<a href=#if aria-label=if>if</a></li>
<li>
<a href=#do aria-label=do>do</a></li>
<li>
<a href=#when aria-label=when>when</a></li>
<li>
<a href=#nil-true-false-truthiness-equality-and-boolean-expressions aria-label="nil, true, false, Truthiness, Equality, and Boolean Expressions">nil, true, false, Truthiness, Equality, and Boolean Expressions</a></li></ul>
</li>
<li>
<a href=#%e7%94%a8-def-%e5%91%bd%e5%90%8d%e6%95%b0%e5%80%bc aria-label="用 def 命名数值">用 def 命名数值</a></li></ul>
</li>
<li>
<a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=数据结构>数据结构</a><ul>
<li>
<a href=#%e6%95%b0%e5%ad%97 aria-label=数字>数字</a></li>
<li>
<a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label=字符串>字符串</a></li>
<li>
<a href=#map aria-label=Map>Map</a></li>
<li>
<a href=#keywords aria-label=Keywords>Keywords</a></li>
<li>
<a href=#%e7%9f%a2%e9%87%8f aria-label=矢量>矢量</a></li>
<li>
<a href=#lists aria-label=Lists>Lists</a></li>
<li>
<a href=#set aria-label=Set>Set</a></li>
<li>
<a href=#%e7%ae%80%e5%8d%95%e6%80%a7 aria-label=简单性>简单性</a></li></ul>
</li>
<li>
<a href=#%e5%87%bd%e6%95%b0 aria-label=函数>函数</a><ul>
<li>
<a href=#%e8%b0%83%e7%94%a8%e5%87%bd%e6%95%b0 aria-label=调用函数>调用函数</a></li>
<li>
<a href=#%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e5%ae%8f%e8%b0%83%e7%94%a8%e5%92%8c%e7%89%b9%e6%ae%8a%e5%bd%a2%e5%bc%8f aria-label=函数调用、宏调用和特殊形式>函数调用、宏调用和特殊形式</a></li>
<li>
<a href=#%e5%ae%9a%e4%b9%89%e5%87%bd%e6%95%b0 aria-label=定义函数>定义函数</a><ul>
<li>
<a href=#docstring aria-label=docstring>docstring</a></li>
<li>
<a href=#%e5%8f%82%e6%95%b0%e5%92%8c-arity aria-label="参数和 Arity">参数和 Arity</a></li>
<li>
<a href=#%e8%a7%a3%e6%9e%84 aria-label=解构>解构</a></li>
<li>
<a href=#%e5%87%bd%e6%95%b0%e4%bd%93 aria-label=函数体>函数体</a></li>
<li>
<a href=#%e6%89%80%e6%9c%89%e5%87%bd%e6%95%b0%e9%83%bd%e6%98%af%e5%b9%b3%e7%ad%89%e7%9a%84 aria-label=所有函数都是平等的>所有函数都是平等的</a></li></ul>
</li>
<li>
<a href=#%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0 aria-label=匿名函数>匿名函数</a></li>
<li>
<a href=#%e8%bf%94%e5%9b%9e%e5%87%bd%e6%95%b0 aria-label=返回函数>返回函数</a></li></ul>
</li>
<li>
<a href=#%e6%8a%8a%e8%bf%99%e4%b8%80%e5%88%87%e6%8b%89%e5%88%b0%e4%b8%80%e8%b5%b7 aria-label=把这一切拉到一起>把这一切拉到一起</a><ul>
<li>
<a href=#%e5%a4%8f%e5%b0%94%e7%9a%84%e4%b8%8b%e4%b8%80%e4%b8%aa%e9%a1%b6%e7%ba%a7%e6%a8%a1%e5%9e%8b aria-label=夏尔的下一个顶级模型>夏尔的下一个顶级模型</a></li>
<li>
<a href=#let aria-label=let>let</a></li>
<li>
<a href=#%e5%be%aa%e7%8e%af aria-label=循环>循环</a></li>
<li>
<a href=#%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f aria-label=正则表达式>正则表达式</a></li>
<li>
<a href=#%e5%af%b9%e7%a7%b0%e5%99%a8 aria-label=对称器>对称器</a></li>
<li>
<a href=#%e6%9b%b4%e5%a5%bd%e7%9a%84%e5%af%b9%e7%a7%b0%e5%99%a8%e4%b8%8e-reduce aria-label="更好的对称器与 reduce">更好的对称器与 reduce</a></li>
<li>
<a href=#%e9%9c%8d%e6%af%94%e7%89%b9%e4%ba%ba%e7%9a%84%e6%9a%b4%e5%8a%9b aria-label=霍比特人的暴力>霍比特人的暴力</a></li></ul>
</li>
<li>
<a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li>
<li>
<a href=#%e7%bb%83%e4%b9%a0 aria-label=练习>练习</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=做事情clojure-速成班>做事情：Clojure 速成班<a hidden class=anchor aria-hidden=true href=#做事情clojure-速成班>#</a></h1>
<p>是时候学习如何用 Clojure 真正地<em>做</em>事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。</p>
<p>在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!</p>
<p>当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!</p>
<h2 id=语法>语法<a hidden class=anchor aria-hidden=true href=#语法>#</a></h2>
<p>Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。</p>
<h3 id=形式>形式<a hidden class=anchor aria-hidden=true href=#形式>#</a></h3>
<p>所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。</p>
<ul>
<li>数据结构的字面表示（如数字、字符串、Map 和向量）</li>
<li>操作</li>
</ul>
<p>我们使用术语<em>form</em>来指代有效的代码。我有时也会用<em>表达式</em>来指代 Clojure 形式。但不要太纠结于术语。Clojure <em>评价</em>每一个表单，以产生一个值。这些字面表达都是有效的形式。</p>
<pre tabindex=0><code>1
&quot;a string&quot;
[&quot;a&quot; &quot;vector&quot; &quot;of&quot; &quot;strings&quot;]
</code></pre><p>当然，你的代码很少包含自由浮动的字元，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你<em>做</em>事情的方式。所有操作的形式都是：*开括号，*操作符，*操作数，<em>闭括号</em>。</p>
<pre tabindex=0><code>(operator operand1 operand2 ... operandn)
</code></pre><p>请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。</p>
<pre tabindex=0><code>(+ 1 2 3)
; =&gt; 6

(str &quot;It was the panda &quot; &quot;in the library &quot; &quot;with a dust buster&quot;)
; =&gt; &quot;It was the panda in the library with a dust buster&quot;
</code></pre><p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/do-things/panda.png alt=img>
</p>
<p>在第一个操作中，运算符<code>+</code>将操作数<code>1</code>、<code>2</code>和<code>3</code>相加。在第二个操作中，运算符<code>str</code>将三个字符串连接起来，形成一个新的字符串。这两种形式都是有效的。这里有一个不是形式的东西，因为它没有一个结束的小括号。</p>
<pre tabindex=0><code>(+
</code></pre><p>Clojure 的结构统一性可能与你所习惯的不同。在其他语言中，不同的操作可能有不同的结构，这取决于操作符和操作数。例如，JavaScript 采用的是 infix 符号、点运算符和小括号的大杂烩。</p>
<pre tabindex=0><code>1 + 2 + 3
&quot;It was the panda &quot;.concat(&quot;in the library &quot;, &quot;with a dust buster&quot;)
</code></pre><p>相比之下，Clojure 的结构是非常简单和一致的。无论你使用哪种运算符，或对哪种数据进行操作，其结构都是一样的。</p>
<h3 id=控制流>控制流<a hidden class=anchor aria-hidden=true href=#控制流>#</a></h3>
<p>让我们来看看三个基本的控制流操作符。<code>if</code>, <code>do</code>, 和<code>when</code>。在本书中，你会遇到更多的操作，但这些操作可以让你开始。</p>
<h4 id=if>if<a hidden class=anchor aria-hidden=true href=#if>#</a></h4>
<p>这是一个 &ldquo;if &ldquo;表达式的一般结构。</p>
<pre tabindex=0><code>(if boolean-form
  then-form
  optional-else-form)
</code></pre><p>布尔形式只是一个评估为真值或假值的形式。你会在下一节中了解到真实性和虚假性。下面是几个`if&rsquo;的例子。</p>
<pre tabindex=0><code>(if true
  &quot;By Zeus's hammer!&quot;
  &quot;By Aquaman's trident!&quot;)
; =&gt; &quot;By Zeus's hammer!&quot;

(if false
  &quot;By Zeus's hammer!&quot;
  &quot;By Aquaman's trident!&quot;)
; =&gt; &quot;By Aquaman's trident!&quot;
</code></pre><p>第一个例子返回 &ldquo;靠宙斯的锤子！"，因为其布尔形式评估为 &ldquo;true&rdquo;，是一个真实的值；第二个例子返回 &ldquo;靠阿卡曼的三叉戟！"，因为其布尔形式 &ldquo;false&rdquo;，评估为一个错误的值。</p>
<p>你也可以省略<code>else</code>分支。如果你这样做，并且布尔表达式是假的，Clojure 会返回<code>nil</code>，就像这样。</p>
<pre tabindex=0><code>(if false
  &quot;By Odin's Elbow!&quot;)
; =&gt; nil
</code></pre><p>注意<code>if</code>使用操作数位置将操作数与<code>then</code>和<code>else</code>分支联系起来：第一个操作数是<code>then</code>分支，第二个操作数是（可选）<code>else</code>分支。因此，每个分支只能有一种形式。这与大多数语言不同。例如，你可以在 Ruby 中这样写。</p>
<pre tabindex=0><code>if true
  doer.do_thing(1)
  doer.do_thing(2)
else
  other_doer.do_thing(1)
  other_doer.do_thing(2)
end
</code></pre><p>为了绕过这个明显的限制，你可以使用<code>do</code>操作符。</p>
<h4 id=do>do<a hidden class=anchor aria-hidden=true href=#do>#</a></h4>
<p><code>do</code>操作符可以让你在括号中<em>包裹</em>起多个表单，并运行其中的每一个。在你的 REPL 中尝试以下操作。</p>
<pre tabindex=0><code>(if true
  (do (println &quot;Success!&quot;)
      &quot;By Zeus's hammer!&quot;)
  (do (println &quot;Failure!&quot;)
      &quot;By Aquaman's trident!&quot;))
; =&gt; Success!
; =&gt; &quot;By Zeus's hammer!&quot;
</code></pre><p>这个操作符让你在<code>if</code>表达式的每个分支中做多件事情。在这种情况下，会发生两件事。<code>成功！</code>被打印在 REPL 中，<code>"</code>通过宙斯的锤子！<code>"</code>被作为整个<code>if</code>表达式的值返回。</p>
<h4 id=when>when<a hidden class=anchor aria-hidden=true href=#when>#</a></h4>
<p><code>when</code>操作符就像<code>if</code>和<code>do</code>的组合，但没有<code>else</code>分支。下面是一个例子。</p>
<pre tabindex=0><code>(when true
  (println &quot;Success!&quot;)
  &quot;abra cadabra&quot;)
; =&gt; Success!
; =&gt; &quot;abra cadabra&quot;
</code></pre><p>如果你想在某个条件为真时做多件事，而你总是想在条件为假时返回<code>nil'，请使用</code>when`。</p>
<h4 id=nil-true-false-truthiness-equality-and-boolean-expressions>nil, true, false, Truthiness, Equality, and Boolean Expressions<a hidden class=anchor aria-hidden=true href=#nil-true-false-truthiness-equality-and-boolean-expressions>#</a></h4>
<p>Clojure 有<code>true</code>和<code>false</code>值。<code>nil</code>在 Clojure 中用来表示<em>没有</em>值。你可以用适当命名的<code>nil?</code>函数来检查一个值是否为<code>nil</code>。</p>
<pre tabindex=0><code>(nil? 1)
; =&gt; false

(nil? nil)
; =&gt; true
</code></pre><p><code>nil</code>和<code>false</code>都是用来表示逻辑上的虚假性，而所有其他的值都是逻辑上的真实性。<em>Truthy</em>和<em>falsey</em>指的是在布尔表达式中如何处理一个值，比如传递给<code>if</code>的第一个表达式。</p>
<pre tabindex=0><code>(if &quot;bears eat beets&quot;
  &quot;bears beets Battlestar Galactica&quot;)
; =&gt; &quot;bears beets Battlestar Galactica&quot;

(if nil
  &quot;This won't be the result because nil is falsey&quot;
  &quot;nil is falsey&quot;)
; =&gt; &quot;nil is falsey&quot;
</code></pre><p>在第一个例子中，字符串<code>"熊吃甜菜"</code>被认为是真实的，所以<code>if</code>表达式评估为<code>"熊吃甜菜Battlestar Galactica"</code>。第二个例子显示一个假值是假的。</p>
<p>Clojure 的平等运算符是<code>=</code>。</p>
<pre tabindex=0><code>(= 1 1)
; =&gt; true

(= nil nil)
; =&gt; true

(= 1 2)
; =&gt; false
</code></pre><p>其他一些语言要求你在比较不同类型的值时使用不同的运算符。例如，你可能不得不使用某种专门为字符串制作的特殊字符串平等运算符。但在使用 Clojure 的内置数据结构时，你不需要像这样奇怪或繁琐的东西来测试平等性。</p>
<p>Clojure 使用布尔运算符<code>or</code>和<code>and</code>。<code>or</code>返回第一个真值或最后一个值。<code>and</code>返回第一个错误的值，如果没有错误的值，则返回最后一个真实的值。让我们先看一下<code>or</code>。</p>
<pre tabindex=0><code>(or false nil :large_I_mean_venti :why_cant_I_just_say_large)
; =&gt; :large_I_mean_venti

(or (= 0 1) (= &quot;yes&quot; &quot;no&quot;))
; =&gt; false

(or nil)
; =&gt; nil
</code></pre><p>在第一个例子中，返回值是<code>:large_I_mean_venti</code>，因为它是第一个真值。第二个例子没有真值，所以<code>or</code>返回最后一个值，即<code>false</code>。在最后一个例子中，同样没有真值存在，<code>or</code>返回最后一个值，即<code>nil</code>。现在我们来看看<code>and</code>。</p>
<pre tabindex=0><code>(and :free_wifi :hot_coffee)
; =&gt; :hot_coffee

(and :feelin_super_cool nil false)
; =&gt; nil
</code></pre><p>在第一个例子中，<code>and</code>返回最后一个真值，<code>:hot_coffee</code>。在第二个例子中, <code>and</code>返回<code>nil</code>, 这是第一个错误的值.</p>
<h3 id=用-def-命名数值>用 def 命名数值<a hidden class=anchor aria-hidden=true href=#用-def-命名数值>#</a></h3>
<p>在 Clojure 中, 你可以使用<code>def</code>将一个名字与一个值结合起来:</p>
<pre tabindex=0><code>(def failed-protagonist-names
  [&quot;Larry Potter&quot; &quot;Doreen the Explorer&quot; &quot;The Incredible Bulk&quot;])

failed-protagonist-names
; =&gt; [&quot;Larry Potter&quot; &quot;Doreen the Explorer&quot; &quot;The Incredible Bulk&quot;]
</code></pre><p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/do-things/larry-potter.png alt=img>
</p>
<p>在这个例子中，你把名字<code>failed-protagonist-names</code>绑定到一个包含三个字符串的向量（你将在<a href=https://www.braveclojure.com/do-things/#Anchor-3>&ldquo;向量 &ldquo;第 45 页</a>中了解向量）。</p>
<p>请注意，我使用的是 &ldquo;绑定 &ldquo;一词，而在其他语言中，你会说你是在给一个<em>变量</em>赋值。那些其他语言通常鼓励你对同一个变量进行多次赋值。</p>
<p>例如，在 Ruby 中，你可以对一个变量进行多次赋值，以建立它的值。</p>
<pre tabindex=0><code>severity = :mild
error_message = &quot;OH GOD! IT'S A DISASTER! WE'RE &quot;
if severity == :mild
  error_message = error_message + &quot;MILDLY INCONVENIENCED!&quot;
else
  error_message = error_message + &quot;DOOOOOOOMED!&quot;
end
</code></pre><p>你可能想在 Clojure 中做类似的事情。</p>
<pre tabindex=0><code>(def severity :mild)
(def error-message &quot;OH GOD! IT'S A DISASTER! WE'RE &quot;)
(if (= severity :mild)
  (def error-message (str error-message &quot;MILDLY INCONVENIENCED!&quot;))
  (def error-message (str error-message &quot;DOOOOOOOMED!&quot;)))
</code></pre><p>然而，像这样改变与名字相关的值会使你更难理解你的程序的行为，因为更难知道哪个值是与名字相关的，或者为什么这个值可能已经改变了。Clojure 有一套处理变化的工具，你会在第 10 章中了解到。随着你对 Clojure 的学习，你会发现你很少需要改变一个名字/值的关联。下面是你写前面代码的一种方式。</p>
<pre tabindex=0><code>(defn error-message
  [severity]
  (str &quot;OH GOD! IT'S A DISASTER! WE'RE &quot;
       (if (= severity :mild)
         &quot;MILDLY INCONVENIENCED!&quot;
         &quot;DOOOOOOOMED!&quot;)))

(error-message :mild)
; =&gt; &quot;OH GOD! IT'S A DISASTER! WE'RE MILDLY INCONVENIENCED!&quot;
</code></pre><p>这里，你创建了一个函数，<code>error-message</code>，它接受一个参数，<code>severity</code>，并使用它来决定返回哪个字符串。然后你用<code>:mild</code>作为严重程度来调用这个函数。你将在<a href=https://www.braveclojure.com/do-things/#Anchor-4>&ldquo;函数 &ldquo;第 48 页</a>中学习所有关于创建函数的知识；与此同时，你应该把<code>def</code>当作定义常量。在接下来的几章中，你将学习如何通过接受函数式编程范式来处理这个明显的限制。</p>
<h2 id=数据结构>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构>#</a></h2>
<p>Clojure 带有少量的数据结构，你在大多数时候都会用到。如果你来自面向对象的背景，你会惊讶于你可以用这里介绍的看似基本的类型做很多事情。</p>
<p>Clojure 的所有数据结构都是不可改变的，这意味着你不能在原地改变它们。例如，在 Ruby 中，你可以做以下事情来重新分配索引为 0 的失败主角的名字。</p>
<pre tabindex=0><code>failed_protagonist_names = [
  &quot;Larry Potter&quot;,
  &quot;Doreen the Explorer&quot;,
  &quot;The Incredible Bulk&quot;
]
failed_protagonist_names[0] = &quot;Gary Potter&quot;

failed_protagonist_names
# =&gt; [
#   &quot;Gary Potter&quot;,
#   &quot;Doreen the Explorer&quot;,
#   &quot;The Incredible Bulk&quot;
# ]
</code></pre><p>Clojure 没有与之对应的东西。你会在第 10 章中了解到更多关于 Clojure 这样实现的原因，但现在只学习如何做事情，而不考虑所有的哲学问题，这很有趣。不多说了，让我们来看看 Clojure 中的数字。</p>
<h3 id=数字>数字<a hidden class=anchor aria-hidden=true href=#数字>#</a></h3>
<p>Clojure 有相当复杂的数字支持。我不会花太多时间纠缠于无聊的技术细节（比如强制和传染），因为那会妨碍<em>做事情</em>。如果你对这些枯燥的细节感兴趣，请查看*<a href=http://clojure.org/data_**structures#Data%20Structures-Numbers>http://clojure.org/data_**structures#Data%20Structures-Numbers</a>*的文档。可以说，Clojure 会很高兴地处理你扔给它的几乎所有东西。</p>
<p>在此期间，我们将使用整数和浮点数。我们还将使用比率，Clojure 可以直接表示这些比率。下面分别是一个整数、一个浮点数和一个比率。</p>
<pre tabindex=0><code>93
1.2
1/5
</code></pre><h3 id=字符串>字符串<a hidden class=anchor aria-hidden=true href=#字符串>#</a></h3>
<p>字符串代表文本。这个名字来自于古代腓尼基人，他们在一次涉及纱线的事故后，有一天发明了字母表。下面是一些字符串字面的例子。</p>
<pre tabindex=0><code>&quot;Lord Voldemort&quot;
&quot;\&quot;He who must not be named\&quot;&quot;
&quot;\&quot;Great cow of Moscow!\&quot; - Hermes Conrad&quot;
</code></pre><p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/do-things/wookie.png alt=img>
</p>
<p>注意，Clojure 只允许用双引号来划分字符串。例如，&ldquo;Lord Voldemort &ldquo;就不是一个有效的字符串。还要注意，Clojure 没有字符串插值。它只允许通过<code>str</code>函数进行连接。</p>
<pre tabindex=0><code>(def name &quot;Chewbacca&quot;)
(str &quot;\&quot;Uggllglglglglglll\&quot; - &quot; name)
; =&gt; &quot;Uggllglglglglglll&quot; - Chewbacca
</code></pre><h3 id=map>Map<a hidden class=anchor aria-hidden=true href=#map>#</a></h3>
<p>Map 类似于其他语言中的字典或哈希值。它们是一种将一些值与另一些值联系起来的方式。Clojure 中的两种 Map 是哈希 Map 和排序 Map。我将只介绍更基本的哈希图。让我们来看看 Map 字面的一些例子。这里有一个空 Map。</p>
<pre tabindex=0><code>{}
</code></pre><p>在这个例子中，<code>:first-name</code>和<code>:last-name</code>是关键字（我将在下一节介绍这些）。</p>
<pre tabindex=0><code>{:first-name &quot;Charlie&quot;
 :last-name &quot;McFishwich&quot;}
</code></pre><p>这里我们把<code>"string-key"</code>和<code>+</code>函数联系起来。</p>
<pre tabindex=0><code>{&quot;string-key&quot; +}
</code></pre><p>Map 可以被嵌套。</p>
<pre tabindex=0><code>{:name {:first &quot;John&quot; :middle &quot;Jacob&quot; :last &quot;Jingleheimerschmidt&quot;}}.
</code></pre><p>注意，Map 的值可以是任何类型&ndash;字符串、数字、Map、向量，甚至函数。Clojure 并不关心这个问题。</p>
<p>除了使用 map 字面，你还可以使用<code>hash-map</code>函数来创建一个 map。</p>
<pre tabindex=0><code>(hash-map :a 1 :b 2)
; =&gt; {:a 1 :b 2}.
</code></pre><p>你可以用<code>get</code>函数在 Map 中查询数值。</p>
<pre tabindex=0><code>(get {:a 0 :b 1} :b)
; =&gt; 1

(get {:a 0 :b {:c &quot;ho hum&quot;}} :b)
; =&gt; {:c &quot;ho hum&quot;}
</code></pre><p>在这两个例子中，我们向<code>get</code>询问给定 Map 中<code>:b</code>键的值&ndash;在第一个例子中，它返回<code>1</code>，而在第二个例子中，它返回嵌套 Map<code>{:c "ho hum"}</code>。</p>
<p>如果没有找到你的键，<code>get</code>将返回<code>nil'，或者你可以给它一个默认值，例如</code>&ldquo;独角兽？"`。</p>
<pre tabindex=0><code>(get {:a 0 :b 1} :c)
; =&gt; nil

(get {:a 0 :b 1} :c &quot;unicorns?&quot;)
; =&gt; &quot;unicorns?&quot;
</code></pre><p><code>get-in</code>函数可以让你在嵌套 Map 中查询数值。</p>
<pre tabindex=0><code>(get-in {:a 0 :b {:c &quot;ho hum&quot;}} [:b :c])
; =&gt; &quot;ho hum&quot;
</code></pre><p>另一种在 Map 中查询数值的方法是把 Map 当作一个以键为参数的函数。</p>
<pre tabindex=0><code>({:name &quot;The Human Coffeepot&quot;} :name)
; =&gt; &quot;The Human Coffeepot&quot;
</code></pre><p>你可以用 Map 做的另一件很酷的事情是把 Keywords 作为函数来查询它们的值，这就引出了下一个主题，Keywords。</p>
<h3 id=keywords>Keywords<a hidden class=anchor aria-hidden=true href=#keywords>#</a></h3>
<p>了解 Clojure 关键字的最好方法是看它们是如何被使用的。正如你在上一节中所看到的，它们主要是作为 Map 中的键来使用。下面是一些 Keywords 的例子。</p>
<pre tabindex=0><code>:a
:rumplestiltsken
:34
:_?
</code></pre><p>Keywords 可以作为函数使用，在数据结构中查找相应的值。例如，你可以在一个 Map 中查找<code>:a</code>。</p>
<pre tabindex=0><code>(:a {:a 1 :b 2 :c 3})
; =&gt; 1
</code></pre><p>这相当于。</p>
<pre tabindex=0><code>(get {:a 1 :b 2 :c 3} :a)
; =&gt; 1
</code></pre><p>你可以提供一个默认值，和<code>get</code>一样。</p>
<pre tabindex=0><code>(:d {:a 1 :b 2 :c 3} &quot;No gnome knows homes like Noah knows&quot;)
; =&gt; &quot;No gnome knows homes like Noah knows&quot;
</code></pre><p>使用关键字作为一个函数是令人愉快的简洁，Real Clojurists 一直在这样做。你也应该这样做!</p>
<h3 id=矢量>矢量<a hidden class=anchor aria-hidden=true href=#矢量>#</a></h3>
<p>向量类似于数组, 它是一个以 0 为索引的 Set。例如, 下面是一个向量的字面意思:</p>
<pre tabindex=0><code>[3 2 1]
</code></pre><p>这里我们要返回一个向量的第 0 个元素。</p>
<pre tabindex=0><code>(get [3 2 1] 0)
; =&gt; 3
</code></pre><p>下面是另一个按索引获取的例子。</p>
<pre tabindex=0><code>(get [&quot;a&quot; {:name &quot;Pugsley Winterbottom&quot;} &quot;c&quot;] 1)
; =&gt; {:name &quot;Pugsley Winterbottom&quot;}
</code></pre><p>你可以看到，向量元素可以是任何类型，而且你可以混合类型。还注意到我们使用的<code>get</code>函数与我们在 Map 中查找数值时使用的相同。</p>
<p>你可以用<code>vector</code>函数来创建向量。</p>
<pre tabindex=0><code>(vector &quot;creepy&quot; &quot;full&quot; &quot;moon&quot;)
; =&gt; [&quot;creepy&quot; &quot;full&quot; &quot;moon&quot;]
</code></pre><p>你可以使用<code>conj</code>函数来添加额外的元素到向量中。元素被添加到向量的*端。</p>
<pre tabindex=0><code>(conj [1 2 3] 4)
; =&gt; [1 2 3 4]
</code></pre><p>向量不是存储序列的唯一方法；Clojure 还有<em>列表</em>。</p>
<h3 id=lists>Lists<a hidden class=anchor aria-hidden=true href=#lists>#</a></h3>
<p>Lists 与向量类似，它们都是数值的线性 Set。但也有一些区别。例如，你不能用<code>get</code>检索列表元素。要写一个列表的字面意思, 只需将元素插入括号内, 并在开头使用单引号:</p>
<pre tabindex=0><code>'(1 2 3 4)
; =&gt; (1 2 3 4)
</code></pre><p>注意，当 REPL 打印出列表时，它不包括单引号。我们将在后面的第 7 章中再来讨论为什么会这样。如果你想从一个列表中检索一个元素，你可以使用 <code>nth</code> 函数。</p>
<pre tabindex=0><code>(nth '(:a :b :c) 0)
; =&gt; :a

(nth '(:a :b :c) 2)
; =&gt; :c
</code></pre><p>我在本书中没有详细介绍性能，因为我认为在你熟悉一种语言之后再关注它是没有用的。然而，知道使用<code>nth</code>从列表中检索一个元素比使用<code>get</code>从向量中检索一个元素要慢一些是很好的。这是因为 Clojure 必须遍历一个列表中的所有<em>n</em>个元素才能到达<em>n</em>个，而通过索引访问一个向量元素最多只需要几跳。</p>
<p>列表值可以有任何类型，你可以用<code>list</code>函数创建列表。</p>
<pre tabindex=0><code>(list 1 &quot;two&quot; {3 4})
; =&gt; (1 &quot;二&quot; {3 4})
</code></pre><p>元素被添加到一个列表的<em>开头</em>。</p>
<pre tabindex=0><code>(conj '(1 2 3) 4)
; =&gt; (4 1 2 3)
</code></pre><p>什么时候应该使用列表，什么时候应该使用向量？一个好的经验法则是，如果你需要很容易地把项目添加到一个序列的开头，或者你正在写一个宏，你应该使用一个列表。否则，你应该使用矢量。随着你学习的深入，你会对何时使用哪种方法有很好的感觉。</p>
<h3 id=set>Set<a hidden class=anchor aria-hidden=true href=#set>#</a></h3>
<p>Set 是唯一值的 Set。Clojure 有两种类型的 Set：哈希 Set 和排序 Set。我将专注于哈希集，因为它们更经常被使用。下面是一个哈希集的文字符号。</p>
<pre tabindex=0><code>#{&quot;kurt vonnegut&quot; 20 :icicle}.
</code></pre><p>你也可以用<code>hash-set</code>来创建一个 Set:</p>
<pre tabindex=0><code>(hash-set 1 1 2 2)
; =&gt; #{1 2}
</code></pre><p>注意，一个值的多个实例在 Set 中成为一个唯一的值，所以我们只剩下一个<code>1</code>和一个<code>2</code>。如果你试图将一个值添加到一个已经包含该值的 Set 中（比如下面代码中的<code>:b</code>），它仍然只有一个该值。</p>
<pre tabindex=0><code>( conj #{:a :b} :b)
; =&gt; #{:a :b}
</code></pre><p>你也可以通过使用<code>set</code>函数从现有的向量和列表中创建 Set。</p>
<pre tabindex=0><code>(set [3 3 3 4 4])
; =&gt; #{3 4}
</code></pre><p>你可以使用<code>contains?</code>函数来检查 Set 的成员资格，通过使用<code>get</code>，或通过使用关键字作为函数，以 Set 为参数。<code>contains?</code>返回<code>true</code>或<code>false</code>，而<code>get</code>和关键字查找将返回存在的值，如果不存在，则返回<code>nil</code>。</p>
<p>下面是你如何使用<code>contains?</code>。</p>
<pre tabindex=0><code>(contains? #{:a :b} :a)
; =&gt; true

(contains? #{:a :b} 3)
; =&gt; false

(contains? #{nil} nil)
; =&gt; true
</code></pre><p>下面是你如何使用关键字。</p>
<pre tabindex=0><code>(:a #{:a :b})
; =&gt; :a
</code></pre><p>这里是你如何使用<code>get</code>的方法。</p>
<pre tabindex=0><code>(get #{:a :b} :a)
; =&gt; :a

(get #{:a nil} nil)
; =&gt; nil

(get #{:a :b} &quot;kurt vonnegut&quot;)
; =&gt; nil
</code></pre><p>注意，使用<code>get</code>来测试一个 Set 是否包含<code>nil</code>，将总是返回<code>nil</code>，这令人困惑。当你专门测试 Set 成员时，<code>contains?</code>可能是更好的选择。</p>
<h3 id=简单性>简单性<a hidden class=anchor aria-hidden=true href=#简单性>#</a></h3>
<p>你可能已经注意到，到目前为止，对数据结构的处理并不包括对如何创建新类型或类的描述。原因是 Clojure 对简单性的强调鼓励你首先去接触内置的数据结构。</p>
<p>如果你来自面向对象的背景，你可能会认为这种方法很奇怪而且落后。然而，你会发现，你的数据不一定非要和一个类紧密地捆绑在一起，才是有用和可理解的。这里有一个被 Clojurists 喜爱的寓言故事，暗示了 Clojure 的哲学。</p>
<blockquote>
<p>让 100 个函数操作一个数据结构比让 10 个函数操作 10 个数据结构要好。
-Alan Perlis</p>
</blockquote>
<p>在接下来的章节中，你会了解到更多关于 Clojure 哲学的这个方面。现在，请留意你通过坚持使用基本数据结构来获得代码重用性的方法。</p>
<p>我们的 Clojure 数据结构入门课程到此结束。现在，是时候深入到函数中去，学习如何使用这些数据结构了</p>
<h2 id=函数>函数<a hidden class=anchor aria-hidden=true href=#函数>#</a></h2>
<p>人们为 Lisps 疯狂的原因之一是，这些语言可以让你建立起行为复杂的程序，但主要的构件&ndash;函数&ndash;却是如此简单。本节通过解释以下内容，让你开始了解 Lisp 函数的美丽和优雅。</p>
<ul>
<li>调用函数</li>
<li>函数与宏和特殊形式有什么不同</li>
<li>定义函数</li>
<li>匿名函数</li>
<li>返回函数</li>
</ul>
<h3 id=调用函数>调用函数<a hidden class=anchor aria-hidden=true href=#调用函数>#</a></h3>
<p>现在你已经看到了许多函数调用的例子。</p>
<pre tabindex=0><code>(+ 1 2 3 4)
(* 1 2 3 4)
(first [1 2 3 4])
</code></pre><p>请记住，所有的 Clojure 操作都有相同的语法：开括号、操作符、操作数、闭括号。<em>函数**调用</em>只是操作的另一个术语，其中运算符是一个函数或一个<em>函数**表达式</em>（一个返回函数的表达式）。</p>
<p>这可以让你写出一些相当有趣的代码。下面是一个函数表达式，它返回<code>+</code>（加法）函数。</p>
<pre tabindex=0><code>(or + -)
; =&gt; #&lt;core$_PLUS_ clojure.core$_PLUS_@76dace31&gt;
</code></pre><p>该返回值是加法函数的字符串表示。因为<code>or</code>的返回值是第一个真值，而这里的加法函数是真值，所以返回的是加法函数。你也可以在另一个表达式中使用这个表达式作为运算符。</p>
<pre tabindex=0><code>((or + -) 1 2 3)
; =&gt; 6
</code></pre><p>因为<code>(or + -)</code>返回<code>+</code>，这个表达式被评估为<code>1</code>、<code>2</code>和<code>3</code>之和，返回<code>6</code>。</p>
<p>下面是几个有效的函数调用，它们都返回`6'。</p>
<pre tabindex=0><code>((and (= 1 1) +) 1 2 3)
; =&gt; 6

((first [+ 0]) 1 2 3)
; =&gt; 6
</code></pre><p>在第一个例子中，<code>and</code>的返回值是第一个假值或最后一个真值。在这个例子中，<code>+</code>被返回，因为它是最后一个真值，然后被应用于参数<code>1 2 3</code>，返回<code>6</code>。在第二个例子中，<code>first</code>的返回值是一个序列中的第一个元素，在这个例子中是<code>+</code>。</p>
<p>然而，这些都不是有效的函数调用，因为数字和字符串都不是函数。</p>
<pre tabindex=0><code>(1 2 3 4)
(&quot;test&quot; 1 2 3)
</code></pre><p>如果你在 REPL 中运行这些，你会得到这样的结果。</p>
<pre tabindex=0><code>ClassCastException java.lang.String cannot be cast to clojure.lang.IFn
user/eval728 (NO_SOURCE_FILE:1)
</code></pre><p>当你继续使用 Clojure 时，你可能会多次看到这个错误。<em></em> <em>cannot</em> <em>be</em> <em>cast</em> <em>to</em> <em>clojure.lang.IFn</em>只是意味着你试图将某个东西作为一个函数使用，而它并不是。</p>
<p>函数的灵活性并没有随着函数表达式的出现而结束! 在语法上，函数可以接受任何表达式作为参数&ndash;包括<em>其他</em>函数*。可以接受一个函数作为参数或返回一个函数的函数被称为<em>高阶</em>函数*。具有高阶函数的编程语言被称为支持<em>第一类</em>函数*，因为你可以像对待数字和向量等更熟悉的数据类型一样，将函数作为值来处理。</p>
<p>以<code>map</code>函数（不要与 map 数据结构混淆）为例。<code>map</code>通过对一个集合的每个成员应用一个函数来创建一个新的列表。这里，<code>inc</code>函数将一个数字增加 1。</p>
<pre tabindex=0><code>(inc 1.1)
; =&gt; 2.1

(map inc [0 1 2 3])
; =&gt; (1 2 3 4)
</code></pre><p>(注意<code>map</code>并不返回一个向量，尽管我们提供了一个向量作为参数。你将在第四章中了解原因。现在，请相信这是好的，也是预期的）。</p>
<p>Clojure 对一级函数的支持使你能够建立比没有一级函数的语言更强大的抽象概念。那些不熟悉这种编程方式的人认为函数允许你对数据实例进行泛化操作。例如，<code>+</code>函数对任何特定数字的加法进行了抽象。</p>
<p>相比之下，Clojure（以及所有 Lisps）允许你创建泛化进程的函数。<code>map</code>允许你通过在任何集合上应用一个函数&ndash;任何函数&ndash;来概括转换一个集合的过程。</p>
<p>你需要知道的关于函数调用的最后一个细节是，Clojure 在将所有函数参数传递给函数之前，会递归地评估这些参数。下面是 Clojure 如何评估一个参数也是函数调用的函数调用。</p>
<pre tabindex=0><code>(+ (inc 199) (/ 100 (- 7 2)))
(+ 200 (/ 100 (- 7 2))) ; evaluated &quot;(inc 199)&quot;
(+ 200 (/ 100 5)) ; evaluated (- 7 2)
(+ 200 20) ; evaluated (/ 100 5)
220 ; final evaluation
</code></pre><p>函数调用启动了评估过程，在应用<code>+</code>函数之前，所有的子表格都被评估了。</p>
<h3 id=函数调用宏调用和特殊形式>函数调用、宏调用和特殊形式<a hidden class=anchor aria-hidden=true href=#函数调用宏调用和特殊形式>#</a></h3>
<p>在上一节中，你了解到函数调用是以函数表达式为操作符的表达式。另外两种表达式是<em>宏调用</em>和<em>特殊形式</em>。你已经看到了几种特殊形式：定义和<code>if</code>表达式。</p>
<p>你将在第 7 章中学习关于宏调用和特殊形式的所有知识。现在，使特殊形式 &ldquo;特殊 &ldquo;的主要特征是，与函数调用不同，它们<em>不</em>总是<em><strong>评估</strong></em>所有**<em><em>它们的</em>操作数</em>。</p>
<p>以 &ldquo;if &ldquo;为例。这是它的一般结构。</p>
<pre tabindex=0><code>(if boolean-form
  then-form
  optional-else-form)
</code></pre><p>现在想象一下你有一个这样的<code>if</code>语句。</p>
<pre tabindex=0><code>(if good-mood
  (tweet walking-on-sunshine-lyrics)
  (tweet mopey-country-song-lyrics))
</code></pre><p>显然，在这样的<code>if</code>表达中，我们希望 Clojure 只评估两个分支中的一个。如果 Clojure 同时评估两个`tweet&rsquo;函数调用，你的 Twitter 粉丝们最终会非常困惑。</p>
<p>另一个区别于特殊形式的特征是，你不能把它们作为函数的参数。一般来说，特殊形式实现了 Clojure 的核心功能，只是不能用函数实现。Clojure 只有少量的特殊形式，而如此丰富的语言是用如此小的一组构建块来实现的，这是很令人惊讶的。</p>
<p>宏与特殊形式类似，它们对操作数的评估与函数调用不同，而且它们也不能作为参数传递给函数。但这段弯路已经走得够长了；现在是学习如何定义函数的时候了!</p>
<h3 id=定义函数>定义函数<a hidden class=anchor aria-hidden=true href=#定义函数>#</a></h3>
<p>函数的定义由五个主要部分组成。</p>
<ul>
<li><code>defn</code></li>
<li>函数名称</li>
<li>描述该函数的 docstring(可选)</li>
<li>括号中列出的参数</li>
<li>函数主体</li>
</ul>
<p>下面是一个函数定义的例子和函数的调用示例。</p>
<pre tabindex=0><code>➊ (defn too-enthusiastic
➋   &quot;Return a cheer that might be a bit too enthusiastic&quot;
➌   [name]
➍   (str &quot;OH. MY. GOD! &quot; name &quot; YOU ARE MOST DEFINITELY LIKE THE BEST &quot;
  &quot;MAN SLASH WOMAN EVER I LOVE YOU AND WE SHOULD RUN AWAY SOMEWHERE&quot;))

(too-enthusiastic &quot;Zelda&quot;)
; =&gt; &quot;OH. MY. GOD! Zelda YOU ARE MOST DEFINITELY LIKE THE BEST MAN SLASH WOMAN EVER I LOVE YOU AND WE SHOULD RUN AWAY SOMEWHERE&quot;
</code></pre><p>在➊处，<code>too-enthusiastic</code>是函数的名称，在➋处有一个描述性的 docstring。参数 &ldquo;name &ldquo;在➌处给出，函数体在➍处接受参数，并做了它所描述的事情&ndash;返回一个可能有点过于热情的欢呼。</p>
<p>让我们更深入地了解 docstring、参数和函数体。</p>
<h4 id=docstring>docstring<a hidden class=anchor aria-hidden=true href=#docstring>#</a></h4>
<p>docstring*是一种描述和记录你的代码的有用方法。你可以在 REPL 中用 <code>(doc</code>fn-name<code>)</code>查看一个函数的 docstring，例如 <code>(doc map)</code>。如果你使用一个工具为你的代码生成文档，那么 docstring 也会发挥作用。</p>
<h4 id=参数和-arity>参数和 Arity<a hidden class=anchor aria-hidden=true href=#参数和-arity>#</a></h4>
<p>Clojure 函数可以用零个或多个参数来定义。你传递给函数的值被称为<em>arguments</em>，参数可以是任何类型。参数的数量就是函数的*特性。下面是一些具有不同性质的函数定义。</p>
<pre tabindex=0><code>(defn no-params
  []
  &quot;I take no parameters!&quot;)
(defn one-param
  [x]
  (str &quot;I take one parameter: &quot; x))
(defn two-params
  [x y]
  (str &quot;Two parameters! That's nothing! Pah! I will smoosh them &quot;
  &quot;together to spite you! &quot; x y))
</code></pre><p>在这些例子中，<code>no-params</code>是一个 0-arity 函数，<code>one-param</code>是 1-arity，<code>two-params</code>是 2-arity。</p>
<p>函数也支持 <em>arity overloading</em>。这意味着你可以定义一个函数，使不同的函数体根据不同的 arity 来运行。下面是一个多义性函数定义的一般形式。请注意，每个数位定义都被括在括号里，并且有一个参数列表。</p>
<pre tabindex=0><code>(defn multi-arity
  ;; 3-arity arguments and body
  ([first-arg second-arg third-arg]
     (do-things first-arg second-arg third-arg))
  ;; 2-arity arguments and body
  ([first-arg second-arg]
     (do-things first-arg second-arg))
  ;; 1-arity arguments and body
  ([first-arg]
     (do-things first-arg)))
</code></pre><p>Arity 重载是为参数提供默认值的一种方法。在下面的例子中，<code>"karate"</code>是<code>chop-type</code>参数的默认参数。</p>
<pre tabindex=0><code>(defn x-chop
  &quot;Describe the kind of chop you're inflicting on someone&quot;
  ([name chop-type]
     (str &quot;I &quot; chop-type &quot; chop &quot; name &quot;! Take that!&quot;))
  ([name]
     (x-chop name &quot;karate&quot;)))
</code></pre><p>如果你用两个参数调用<code>x-chop</code>，该函数的工作原理和它不是一个多义性函数时一样。</p>
<pre tabindex=0><code>(x-chop &quot;Kanye West&quot; &quot;slap&quot;)
; =&gt; &quot;I slap chop Kanye West! Take that!&quot;
</code></pre><p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/do-things/kanye.png alt=img>
</p>
<p>如果你调用<code>x-chop</code>时只有一个参数，<code>x-chop</code>实际上会在提供第二个参数<code>"空手道"</code>时调用自己。</p>
<pre tabindex=0><code>(x-chop &quot;Kanye East&quot;)
; =&gt; &quot;I karate chop Kanye East! Take that!&quot;
</code></pre><p>像这样用函数本身来定义一个函数，可能显得不寻常。如果是这样，那就好了! 你正在学习一种新的方法来做事!</p>
<p>你也可以让每个 arity 做一些完全不相关的事情。</p>
<pre tabindex=0><code>(defn weird-arity
  ([]
     &quot;Destiny dressed you this morning, my friend, and now Fear is
     trying to pull off your pants. If you give up, if you give in,
     you're gonna end up naked with Fear just standing there laughing
     at your dangling unmentionables! - the Tick&quot;)
  ([number]
     (inc number)))
</code></pre><p>0-arity 主体返回一个明智的引号，1-arity 主体增加一个数字。最有可能的是，你不会想写一个这样的函数，因为有两个完全不相关的函数体会让人困惑。</p>
<p>Clojure 还允许你通过包括一个<em>rest 参数</em>来定义可变极性函数，就像 &ldquo;把这些参数的其余部分放在一个列表中，名称如下&rdquo;。休息参数用安培号（<code>&</code>）表示，如➊所示。</p>
<p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/do-things/old-man.png alt=img>
</p>
<pre tabindex=0><code>(defn codger-communication
  [whippersnapper]
  (str &quot;Get off my lawn, &quot; whippersnapper &quot;!!!&quot;))

(defn codger
➊   [&amp; whippersnappers]
  (map codger-communication whippersnappers))

(codger &quot;Billy&quot; &quot;Anne-Marie&quot; &quot;The Incredible Bulk&quot;)
; =&gt; (&quot;Get off my lawn, Billy!!!&quot;
      &quot;Get off my lawn, Anne-Marie!!!&quot;
      &quot;Get off my lawn, The Incredible Bulk!!!&quot;)
</code></pre><p>正如你所看到的，当你为变量性质的函数提供参数时，参数被当作一个列表来处理。你可以把休息参数和普通参数混在一起，但休息参数必须放在最后。</p>
<pre tabindex=0><code>(defn favorite-things
  [name &amp; things]
  (str &quot;Hi, &quot; name &quot;, here are my favorite things: &quot;
       (clojure.string/join &quot;, &quot; things)))

(favorite-things &quot;Doreen&quot; &quot;gum&quot; &quot;shoes&quot; &quot;kara-te&quot;)
; =&gt; &quot;Hi, Doreen, here are my favorite things: gum, shoes, kara-te&quot;
</code></pre><p>最后，Clojure 有一种更复杂的定义参数的方法，叫做<em>destructuring</em>，这值得有自己的小节。</p>
<h4 id=解构>解构<a hidden class=anchor aria-hidden=true href=#解构>#</a></h4>
<p>解构的基本思想是，它可以让你在一个集合中简洁地将名字与值绑定。让我们看看一个基本的例子。</p>
<pre tabindex=0><code>;; Return the first element of a collection
(defn my-first
  [[first-thing]] ; Notice that first-thing is within a vector
  first-thing)

(my-first [&quot;oven&quot; &quot;bike&quot; &quot;war-axe&quot;])
; =&gt; &quot;oven&quot;
</code></pre><p>这里，<code>my-first</code>函数将符号<code>first-thing</code>与作为参数传入的向量中的第一个元素联系起来。你告诉<code>my-first</code>这样做，就是把符号<code>first-thing</code>放在一个向量中。</p>
<p>矢量就像一个巨大的牌子，对 Clojure 说：&ldquo;嘿！这个函数将收到一个列表或矢量作为参数。让我的生活更轻松，为我拆开参数的结构，并将有意义的名字与参数的不同部分联系起来！&rdquo; 当对一个向量或列表进行解构时，你可以随意命名你想要的元素，也可以使用其他参数。</p>
<pre tabindex=0><code>(defn chooser
  [[first-choice second-choice &amp; unimportant-choices]]
  (println (str &quot;Your first choice is: &quot; first-choice))
  (println (str &quot;Your second choice is: &quot; second-choice))
  (println (str &quot;We're ignoring the rest of your choices. &quot;
                &quot;Here they are in case you need to cry over them: &quot;
                (clojure.string/join &quot;, &quot; unimportant-choices))))

(chooser [&quot;Marmalade&quot;, &quot;Handsome Jack&quot;, &quot;Pigpen&quot;, &quot;Aquaman&quot;])
; =&gt; Your first choice is: Marmalade
; =&gt; Your second choice is: Handsome Jack
; =&gt; We're ignoring the rest of your choices. Here they are in case \
     you need to cry over them: Pigpen, Aquaman
</code></pre><p>这里，其余的参数<code>unimportant``-choices</code>处理用户在第一和第二选择之后的任何数量的额外选择。</p>
<p>你也可以对 Map 进行去结构化。就像你告诉 Clojure 通过提供一个向量作为参数来解除向量或列表的结构一样，你可以通过提供一个 Map 作为参数来解除 Map 的结构。</p>
<pre tabindex=0><code>(defn announce-treasure-location
➊   [{lat :lat lng :lng}]
  (println (str &quot;Treasure lat: &quot; lat))
  (println (str &quot;Treasure lng: &quot; lng)))

(announce-treasure-location {:lat 28.22 :lng 81.33})
; =&gt; Treasure lat: 28.22
; =&gt; Treasure lng: 81.33
</code></pre><p>让我们更详细地看看➊的那一行。这就像告诉 Clojure，&ldquo;哟！Clojure! 为我做一件事，把<code>lat</code>这个名字与键<code>:lat</code>对应的值联系起来。对<code>lng</code>和<code>:lng</code>做同样的事情，好吗？&rdquo;</p>
<p>我们经常想直接把关键词从 Map 中分离出来，所以有一个更短的语法。这和前面的例子有相同的结果。</p>
<pre tabindex=0><code>(defn announce-treasure-location
  [{:keys [lat lng]}] 。
  (println (str &quot;Treasure lat: &quot; lat))
  (println (str &quot;Treasure lng: &quot; lng)))
</code></pre><p>你可以通过使用<code>:as</code>关键字保留对原始 Map 参数的访问。在下面的例子中，原始 Map 是用<code>treasure-location</code>来访问的。</p>
<pre tabindex=0><code>(defn receive-treasure-location
  [{:keys [lat lng] :as treasure-location}]
  (println (str &quot;Treasure lat: &quot; lat))
  (println (str &quot;Treasure lng: &quot; lng))

  ;; One would assume that this would put in new coordinates for your ship
  (steer-ship! treasure-location))
</code></pre><p>一般来说，你可以把重构看作是指示 Clojure 如何将名字与列表、Map、集合或向量中的值联系起来。现在，我们来看看函数中真正起作用的部分：函数体!</p>
<h4 id=函数体>函数体<a hidden class=anchor aria-hidden=true href=#函数体>#</a></h4>
<p>函数主体可以包含任何形式的表单。Clojure 会自动返回最后评估的形式。这个函数体只包含三种形式，当你调用这个函数时，它会吐出最后一种形式，<code>"joe"</code>。</p>
<pre tabindex=0><code>(defn illustrative-function
  []
  (+ 1 304)
  30
  &quot;joe&quot;)

(exstrative-function)
; =&gt; &quot;joe&quot;
</code></pre><p>下面是另一个函数体，它使用一个<code>if</code>表达式。</p>
<pre tabindex=0><code>(defn number-comment
  [x]
  (if (&gt; x 6)
    &quot;Oh my gosh! What a big number!&quot;
    &quot;That number's OK, I guess&quot;))

(number-comment 5)
; =&gt; &quot;That number's OK, I guess&quot;

(number-comment 7)
; =&gt; &quot;Oh my gosh! What a big number!&quot;
</code></pre><h4 id=所有函数都是平等的>所有函数都是平等的<a hidden class=anchor aria-hidden=true href=#所有函数都是平等的>#</a></h4>
<p>最后说明一下：Clojure 没有特权函数。<code>+</code>只是一个函数，<code>-</code>只是一个函数，而<code>inc</code>和<code>map</code>也只是函数。它们并不比你自己定义的函数好。所以，不要让他们给你任何口实!</p>
<p>更重要的是，这个事实有助于证明 Clojure 的底层简单性。在某种程度上，Clojure 是非常愚蠢的。当你进行函数调用时，Clojure 只是说，"<code>map</code>？当然，不管怎样! 我只是应用这个并继续前进&rdquo;。它并不关心这个函数是什么，或者它来自哪里；它对所有的函数都一视同仁。在它的核心，Clojure 并不关心加法、乘法或映射的问题。它只关心函数的应用。</p>
<p>当你继续用 Clojure 编程时，你会发现这种简单性是很理想的。你不必为处理不同的函数而担心特殊的规则或语法。它们的工作原理都是一样的!</p>
<h3 id=匿名函数>匿名函数<a hidden class=anchor aria-hidden=true href=#匿名函数>#</a></h3>
<p>在 Clojure 中，函数不需要有名字。事实上，你会一直使用<em>匿名</em>函数。多么神秘啊! 你可以通过两种方式创建匿名函数。第一种是使用<code>fn</code>形式。</p>
<pre tabindex=0><code>(fn [param-list]
  function body)
</code></pre><p>看起来很像<code>defn</code>，不是吗？让我们试一试几个例子。</p>
<pre tabindex=0><code>(map (fn [name] (str &quot;Hi, &quot; name))
     [&quot;Darth Vader&quot; &quot;Mr. Magoo&quot;] )
; =&gt; (&quot;Hi, Darth Vader&quot; &quot;Hi, Mr. Magoo&quot;)

((fn [x] (* x 3)) 8)
; =&gt; 24
</code></pre><p>你可以用处理<code>fn</code>的方式来处理<code>defn</code>，这几乎是相同的。参数列表和函数体的工作原理完全相同。你可以使用参数重构，休息参数，等等。你甚至可以将你的匿名函数与一个名字联系起来，这不应该是一个惊喜（如果这确实是一个惊喜，那么 &mldr; &mldr; 惊喜！）。</p>
<pre tabindex=0><code>(def my-special-multiplier (fn [x] (* x 3))
(my-special-multiplier 12)
; =&gt; 36
</code></pre><p>Clojure 还提供了另一种更紧凑的方式来创建匿名函数。下面是一个匿名函数的样子。</p>
<pre tabindex=0><code>#(* % 3)
</code></pre><p>哇，这看起来很奇怪。来吧，应用这个看起来很奇怪的函数。</p>
<pre tabindex=0><code>(#(* % 3) 8)
; =&gt; 24
</code></pre><p>下面是一个将匿名函数作为参数传递给 map 的例子。</p>
<pre tabindex=0><code>(map #(str &quot;Hi, &quot; %)
     [&quot;Darth Vader&quot; &quot;Mr. Magoo&quot;])
; =&gt; (&quot;Hi, Darth Vader&quot; &quot;Hi, Mr. Magoo&quot;)
</code></pre><p>这种看起来很奇怪的匿名函数的编写方式是由一个叫做<em>reader**macros</em>的函数实现的。你会在第 7 章中了解到这些。现在，只学习如何使用这些匿名函数就可以了。</p>
<p>你可以看到，这种语法肯定更紧凑，但也有点奇怪。让我们把它分解一下。这种匿名函数看起来很像函数调用，只是它前面有一个哈希标记，<code>#</code>。</p>
<pre tabindex=0><code>;; Function call
(* 8 3)

;; Anonymous function
#(* % 3)
</code></pre><p>这种相似性使你能更快地看到应用这个匿名函数时将发生什么。&ldquo;哦，&ldquo;你可以对自己说，&ldquo;这是要把它的参数乘以 3&rdquo;。</p>
<p>现在你可能已经猜到了，百分号<code>%</code>，表示传递给函数的参数。如果你的匿名函数需要多个参数，你可以像这样区分它们。<code>%1</code>, <code>%2</code>, <code>%3</code>, 以此类推。<code>%</code>相当于<code>%1</code>。</p>
<pre tabindex=0><code>(#(str %1 &quot; and &quot; %2) &quot;cornbread&quot; &quot;butter beans&quot;)
; =&gt; &quot;cornbread and butter beans&quot;
</code></pre><p>你也可以用<code>%&</code>传递其余参数。</p>
<pre tabindex=0><code>(#(identity %&amp;) 1 &quot;blarg&quot; :yip)
; =&gt; (1 &quot;blarg&quot; :yip)
</code></pre><p>在这种情况下，你将身份函数应用于其余参数。Identity 返回它所给的参数而不改变它。休息参数是以列表形式存储的，所以函数应用返回所有参数的列表。</p>
<p>如果你需要写一个简单的匿名函数，使用这种风格是最好的，因为它在视觉上很紧凑。另一方面，如果你要写一个更长、更复杂的函数，它很容易变得不可读。如果是这种情况，请使用<code>fn</code>。</p>
<h3 id=返回函数>返回函数<a hidden class=anchor aria-hidden=true href=#返回函数>#</a></h3>
<p>现在你已经看到，函数可以返回其他函数。返回的函数是<em>closures</em>，这意味着它们可以访问函数创建时在范围内的所有变量。下面是一个标准的例子。</p>
<pre tabindex=0><code>(defn inc-maker
  &quot;Create a custom incrementor&quot;
  [inc-by]
  #(+ % inc-by))

(def inc3 (inc-maker 3))

(inc3 7)
; =&gt; 10
</code></pre><p>这里，<code>inc-by</code>在范围内，所以即使返回的函数在<code>inc-maker</code>之外使用，也可以访问它。</p>
<h2 id=把这一切拉到一起>把这一切拉到一起<a hidden class=anchor aria-hidden=true href=#把这一切拉到一起>#</a></h2>
<p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/do-things/model-hobbit.png alt=img>
</p>
<p>好了! 是时候把你新发现的知识用于一个崇高的目的了：打倒霍比特人! 要打一个霍比特人，你首先要建立它的身体部位模型。每个身体部位都将包括其相对大小，以表明该部位被击中的可能性有多大。为了避免重复，霍比特人的模型将只包括<em>左**脚</em>，<em>左**耳</em>的条目，以此类推。因此，你需要一个函数来完全对称该模型，创建<em>右**脚</em>，<em>右**耳</em>，等等。最后，你将创建一个函数，迭代身体各部分，并随机选择击中的部分。在这一过程中，你将了解到一些新的 Clojure 工具。<code>let</code>表达式，循环，和正则表达式。有趣的是!</p>
<h3 id=夏尔的下一个顶级模型>夏尔的下一个顶级模型<a hidden class=anchor aria-hidden=true href=#夏尔的下一个顶级模型>#</a></h3>
<p>对于我们的霍比特人模型，我们将避开霍比特人的特征，如活泼和调皮，只关注霍比特人的小身板。下面是霍比特人的模型。</p>
<pre tabindex=0><code>(def asym-hobbit-body-parts [{:name &quot;head&quot; :size 3}
                             {:name &quot;left-eye&quot; :size 1}
                             {:name &quot;left-ear&quot; :size 1}
                             {:name &quot;mouth&quot; :size 1}
                             {:name &quot;nose&quot; :size 1}
                             {:name &quot;neck&quot; :size 2}
                             {:name &quot;left-shoulder&quot; :size 3}
                             {:name &quot;left-upper-arm&quot; :size 3}
                             {:name &quot;chest&quot; :size 10}
                             {:name &quot;back&quot; :size 10}
                             {:name &quot;left-forearm&quot; :size 3}
                             {:name &quot;abdomen&quot; :size 6}
                             {:name &quot;left-kidney&quot; :size 1}
                             {:name &quot;left-hand&quot; :size 2}
                             {:name &quot;left-knee&quot; :size 2}
                             {:name &quot;left-thigh&quot; :size 4}
                             {:name &quot;left-lower-leg&quot; :size 3}
                             {:name &quot;left-achilles&quot; :size 1}
                             {:name &quot;left-foot&quot; :size 2}])
</code></pre><p>这是一个 Map 的向量。每个 Map 都有身体部位的名称和身体部位的相对大小。(我知道只有动漫人物的眼睛是头部的三分之一大小，但就这样吧，好吗？)</p>
<p>明显缺少的是霍比特人的右侧。让我们来解决这个问题。清单 3-1 是到目前为止你看到的最复杂的代码，它引入了一些新的想法。但是不要担心，因为我们将详细地研究它。</p>
<pre tabindex=0><code>(defn matching-part
  [part]
  {:name (clojure.string/replace (:name part) #&quot;^left-&quot; &quot;right-&quot;)
   :size (:size part)})

(defn symmetrize-body-parts
  &quot;Expects a seq of maps that have a :name and :size&quot;
  [asym-body-parts]
  (loop [remaining-asym-parts asym-body-parts
         final-body-parts []]
    (if (empty? remaining-asym-parts)
      final-body-parts
      (let [[part &amp; remaining] remaining-asym-parts]
        (recur remaining
               (into final-body-parts
                     (set [part (matching-part part)])))))))
</code></pre><ol>
<li>3-1. 匹配-部分和对称-身体-部分的函数</li>
</ol>
<p>当我们对<code>asym-hobbit-body-parts</code>调用函数<code>symmetriz-body-parts</code>时，我们得到一个完全对称的霍比特人。</p>
<pre tabindex=0><code>(symmetrize-body-parts asym-hobbit-body-parts)
; =&gt; [{:name &quot;head&quot;, :size 3}
      {:name &quot;left-eye&quot;, :size 1}
      {:name &quot;right-eye&quot;, :size 1}
      {:name &quot;left-ear&quot;, :size 1}
      {:name &quot;right-ear&quot;, :size 1}
      {:name &quot;mouth&quot;, :size 1}
      {:name &quot;nose&quot;, :size 1}
      {:name &quot;neck&quot;, :size 2}
      {:name &quot;left-shoulder&quot;, :size 3}
      {:name &quot;right-shoulder&quot;, :size 3}
      {:name &quot;left-upper-arm&quot;, :size 3}
      {:name &quot;right-upper-arm&quot;, :size 3}
      {:name &quot;chest&quot;, :size 10}
      {:name &quot;back&quot;, :size 10}
      {:name &quot;left-forearm&quot;, :size 3}
      {:name &quot;right-forearm&quot;, :size 3}
      {:name &quot;abdomen&quot;, :size 6}
      {:name &quot;left-kidney&quot;, :size 1}
      {:name &quot;right-kidney&quot;, :size 1}
      {:name &quot;left-hand&quot;, :size 2}
      {:name &quot;right-hand&quot;, :size 2}
      {:name &quot;left-knee&quot;, :size 2}
      {:name &quot;right-knee&quot;, :size 2}
      {:name &quot;left-thigh&quot;, :size 4}
      {:name &quot;right-thigh&quot;, :size 4}
      {:name &quot;left-lower-leg&quot;, :size 3}
      {:name &quot;right-lower-leg&quot;, :size 3}
      {:name &quot;left-achilles&quot;, :size 1}
      {:name &quot;right-achilles&quot;, :size 1}
      {:name &quot;left-foot&quot;, :size 2}
      {:name &quot;right-foot&quot;, :size 2}]
</code></pre><p>让我们来分析一下这段代码!</p>
<h3 id=let>let<a hidden class=anchor aria-hidden=true href=#let>#</a></h3>
<p>在清单 3-1 的大量疯狂中，你可以看到结构<code>(let ...)</code>的形式。让我们通过一个例子来建立对<code>let</code>的理解，当我们熟悉了所有的部分后，再来检查程序中的完整例子。</p>
<p><code>let</code>将名字与值绑定。你可以认为<code>let</code>是<em>let</em> <em>it</em> <em>be</em>的缩写，这也是披头士乐队关于编程的一首优美的歌曲。这里有一个例子。</p>
<pre tabindex=0><code>(让 [x 3]
  x)
; =&gt; 3

(def dalmatian-list
  [&quot;Pongo&quot; &quot;Perdita&quot; &quot;Puppy 1&quot; &quot;Puppy 2&quot;] )
(让 [dalmatians (take 2 dalmatian-list)])
  达尔马提亚人)
; =&gt; (&quot;Pongo&quot; &quot;Perdita&quot;)
</code></pre><p>在第一个例子中，你将名字<code>x</code>与值<code>3</code>绑定。在第二个例子中，你把名字<code>dalmatians</code>绑定到表达式<code>(取2</code>dalmatian<code>-list)</code>的结果，也就是列表<code>("Pongo" "Perdita")</code>。<code>let</code>还引入了一个新的*范围。</p>
<pre tabindex=0><code>(def x 0)
(let [x 1] x)
; =&gt; 1
</code></pre><p>这里，你首先使用<code>def</code>将名字<code>x</code>绑定到值<code>0</code>上。然后，<code>let</code>创建了一个新的作用域，在这个作用域中，名字<code>x</code>被绑定到值<code>1</code>上。我认为范围是指事物的上下文。例如，在 &ldquo;请清理这些烟头 &ldquo;这句话中，<em>烟头</em>的含义是不同的，这取决于你是在产科病房工作还是在香烟制造商大会的监管人员工作。在这个代码片段中，你在说：&ldquo;我希望<code>x'在全局上下文中是</code>0'，但在这个<code>let'表达式的上下文中，它应该是</code>1'。&rdquo;</p>
<p>你可以在你的<code>let</code>绑定中引用现有的绑定。</p>
<pre tabindex=0><code>(def x 0)
(let [x (inc x)] x)
; =&gt; 1
</code></pre><p>在这个例子中，<code>(inc x)</code>中的<code>x</code>是指由<code>(def x 0)</code>创建的绑定。结果是<code>1'，然后在</code>let&rsquo;创建的新作用域中与名称<code>x'绑定。在</code>let<code>表单的范围内，</code>x<code>指的是</code>1<code>，而不是</code>0`。</p>
<p>你也可以在<code>let</code>中使用休息参数，就像你在函数中一样。</p>
<pre tabindex=0><code>(let [[Pongo &amp; dalmatians] dalmatian-list] [Pongo dalmatians])
  [Pongo dalmatians])
; =&gt; [&quot;Pongo&quot; (&quot;Perdita&quot; &quot;Puppy 1&quot; &quot;Puppy 2&quot;) ]
</code></pre><p>注意，<code>let</code>表单的值是其主体中最后被评估的表单。<code>let</code>形式遵循所有在<a href=https://www.braveclojure.com/do-things/#Anchor>&ldquo;调用函数 &ldquo;第 48 页</a>中介绍的析构规则。在这个例子中，<code>[pongo & dalmatians]</code>解构了<code>dalmatian-list'，将字符串</code>&ldquo;Pongo &ldquo;绑定到名称<code>pongo'上，将其余的dalmatians列表绑定到</code>dalmatians<code>上。向量</code>[pongo dalmatians]<code>是</code>let<code>的最后一个表达式，所以它是</code>let`形式的值。</p>
<p><code>let</code>形式有两个主要用途。首先，它们通过允许你对事物进行命名来提供清晰度。其次，它们允许你只评估一个表达式，并重复使用其结果。当你需要重复使用一个昂贵的函数调用的结果时，这一点特别重要，比如网络 API 调用。当表达式有副作用时，这也很重要。</p>
<p>让我们再看一下我们的对称函数中的<code>let</code>形式，这样我们就能明白到底发生了什么。</p>
<pre tabindex=0><code>(let [[part &amp; remaining] remaining-asym-parts])
  (recur remaining
         (in into final-body-parts
               (set [part (matching-part part part)]))))    
</code></pre><p>这段代码告诉 Clojure，&ldquo;创建一个新的范围。在它里面，将<code>part</code>与<code>remaining-asym-parts</code>的第一个元素相关联。将<code>remaining</code>与<code>remaining-asym-parts</code>中的其他元素联系起来&rdquo;。</p>
<p>至于<code>let</code>表达式的主体，你将在下一节中了解到<code>recur</code>的含义。函数调用</p>
<pre tabindex=0><code>(in into final-body-parts
  (set [part (matching-part part part)] ))
</code></pre><p>首先告诉 Clojure, &ldquo;使用<code>set'函数创建一个由</code>part&rsquo;和它的匹配部分组成的集合。然后使用函数<code>into</code>将该集合的元素添加到向量<code>final-body-parts</code>中&rdquo;。你在这里创建一个集合，以确保你向<code>final-body-parts</code>添加唯一的元素，因为<code>part</code>和<code>(matching-part part)</code>有时是同一个东西，正如你将在接下来的正则表达式部分看到的。下面是一个简化的例子。</p>
<pre tabindex=0><code>(into [] (set [:a :a]))
; =&gt; [:a]
</code></pre><p>首先，<code>(set [:a :a])</code>返回集合<code>#{:a}</code>，因为集合不包含重复的元素。然后<code>(into [] #{:a})</code>返回向量<code>[:a]</code>。</p>
<p>回到<code>let'：注意</code>part&rsquo;在<code>let'的主体中被多次使用。如果我们使用原来的表达式，而不是使用</code>part<code>和</code>remaining`的名字，那将是一个混乱的局面! 下面是一个例子。</p>
<pre tabindex=0><code>(recur (rest remaining-asym-parts)
       (in into final-body-parts
             (set [(first remaining-asym-parts) (matching-part (first remaining-asym-parts)) ]))
</code></pre><p>所以，<code>let</code>是一种方便的方法，可以为值引入本地名称，这有助于简化代码。</p>
<h3 id=循环>循环<a hidden class=anchor aria-hidden=true href=#循环>#</a></h3>
<p>在我们的<code>symmetrize-body-parts</code>函数中，我们使用了<code>loop</code>，它提供了另一种在 Clojure 中进行递归的方法。让我们看看一个简单的例子。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>loop </span>[iteration <span style=color:#ae81ff>0</span>]
  (println (str <span style=color:#e6db74>&#34;Iteration &#34;</span> iteration))
  (<span style=color:#66d9ef>if </span>(&gt; iteration <span style=color:#ae81ff>3</span>)
    (println <span style=color:#e6db74>&#34;Goodbye!&#34;</span>)
    (<span style=color:#a6e22e>recur</span> (inc iteration))))
<span style=color:#75715e>; =&gt; Iteration 0</span>
<span style=color:#75715e>; =&gt; Iteration 1</span>
<span style=color:#75715e>; =&gt; Iteration 2</span>
<span style=color:#75715e>; =&gt; Iteration 3</span>
<span style=color:#75715e>; =&gt; Iteration 4</span>
<span style=color:#75715e>; =&gt; Goodbye!</span>
</code></pre></div><p>第一行，<code>loop [iteration 0]</code>，开始了循环并引入了一个初始值的绑定。在循环的第一次传递中，<code>iteration</code>的值为 0.接下来，它打印一个短消息。然后，它检查<code>iteration</code>的值。如果该值大于 3，那么是时候说再见了。否则，我们就 &ldquo;重来&rdquo;。这就好比<code>loop</code>创建了一个匿名函数，其参数名为<code>iteration</code>，而<code>recur</code>允许你从其内部调用该函数，传递参数<code>(inc iteration)</code>。</p>
<p>事实上，你可以通过使用一个普通的函数定义来完成同样的事情。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>recursive-printer
  ([]
     (<span style=color:#a6e22e>recursive-printer</span> <span style=color:#ae81ff>0</span>))
  ([iteration]
     (println iteration)
     (<span style=color:#66d9ef>if </span>(&gt; iteration <span style=color:#ae81ff>3</span>)
       (println <span style=color:#e6db74>&#34;Goodbye!&#34;</span>)
       (<span style=color:#a6e22e>recursive-printer</span> (inc iteration)))))
(<span style=color:#a6e22e>recursive-printer</span>)
<span style=color:#75715e>; =&gt; Iteration 0</span>
<span style=color:#75715e>; =&gt; Iteration 1</span>
<span style=color:#75715e>; =&gt; Iteration 2</span>
<span style=color:#75715e>; =&gt; Iteration 3</span>
<span style=color:#75715e>; =&gt; Iteration 4</span>
<span style=color:#75715e>; =&gt; Goodbye!</span>
</code></pre></div><p>但正如你所看到的，这是个比较啰嗦的方法。而且，<code>loop</code>有更好的性能。在我们的对称化函数中，我们将使用<code>loop</code>遍历不对称的身体部位列表中的每个元素。</p>
<h3 id=正则表达式>正则表达式<a hidden class=anchor aria-hidden=true href=#正则表达式>#</a></h3>
<p><em>正则表达式</em>是对文本进行模式匹配的工具。正则表达式的文字符号是将表达式放在哈希标记后的引号中。</p>
<pre tabindex=0><code>#&quot;regular-expression&quot;
</code></pre><p>在清单 3-1 中的函数<code>matching-part</code>中，<code>clojure.string/replace</code>使用正则表达式<code>#"^left-"</code>来匹配以<code>"left-"</code>开头的字符串，以便用<code>"right-"</code>替换<code>"left-"</code>。卡特，<code>^</code>，是正则表达式发出的信号，即只有当文本<code>"left-"</code>位于字符串的开头时，它才会匹配，这就确保了像<code>"cleft-chin"</code>这样的字符串不会匹配。你可以用<code>re-find</code>来测试，它检查一个字符串是否与正则表达式描述的模式相匹配，如果不匹配，则返回匹配的文本或<code>nil</code>。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(re-find <span style=color:#f92672>#</span><span style=color:#e6db74>&#34;^left-&#34;</span> <span style=color:#e6db74>&#34;left-eye&#34;</span>)
<span style=color:#75715e>; =&gt; &#34;left-&#34;</span>

(re-find <span style=color:#f92672>#</span><span style=color:#e6db74>&#34;^left-&#34;</span> <span style=color:#e6db74>&#34;cleft-chin&#34;</span>)
<span style=color:#75715e>; =&gt; nil</span>

(re-find <span style=color:#f92672>#</span><span style=color:#e6db74>&#34;^left-&#34;</span> <span style=color:#e6db74>&#34;wongleblart&#34;</span>)
<span style=color:#75715e>; =&gt; nil</span>
</code></pre></div><p>下面是几个<code>matching-part'的例子，使用一个重词将</code>&ldquo;left-&ldquo;替换为`&ldquo;right-"。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>matching-part
  [part]
  {<span style=color:#e6db74>:name</span> (<span style=color:#a6e22e>clojure.string/replace</span> (<span style=color:#e6db74>:name</span> part) <span style=color:#f92672>#</span><span style=color:#e6db74>&#34;^left-&#34;</span> <span style=color:#e6db74>&#34;right-&#34;</span>)
   <span style=color:#e6db74>:size</span> (<span style=color:#e6db74>:size</span> part)})
(<span style=color:#a6e22e>matching-part</span> {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;left-eye&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>1</span>})
<span style=color:#75715e>; =&gt; {:name &#34;right-eye&#34; :size 1}]</span>

(<span style=color:#a6e22e>matching-part</span> {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;head&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>3</span>})
<span style=color:#75715e>; =&gt; {:name &#34;head&#34; :size 3}]</span>
</code></pre></div><p>请注意，名称 &ldquo;head&rdquo; &ldquo;是原样返回的。</p>
<h3 id=对称器>对称器<a hidden class=anchor aria-hidden=true href=#对称器>#</a></h3>
<p>现在让我们回到完整的对称器，对其进行更详细的分析。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>def </span>asym-hobbit-body-parts [{<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;head&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>3</span>}
                             {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;left-eye&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>1</span>}
                             {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;left-ear&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>1</span>}
                             {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;mouth&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>1</span>}
                             {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;nose&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>1</span>}
                             {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;neck&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>2</span>}
                             {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;left-shoulder&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>3</span>}
                             {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;left-upper-arm&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>3</span>}
                             {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;chest&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>10</span>}
                             {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;back&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>10</span>}
                             {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;left-forearm&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>3</span>}
                             {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;abdomen&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>6</span>}
                             {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;left-kidney&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>1</span>}
                             {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;left-hand&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>2</span>}
                             {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;left-knee&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>2</span>}
                             {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;left-thigh&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>4</span>}
                             {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;left-lower-leg&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>3</span>}
                             {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;left-achilles&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>1</span>}
                             {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;left-foot&#34;</span> <span style=color:#e6db74>:size</span> <span style=color:#ae81ff>2</span>}])


(<span style=color:#66d9ef>defn </span>matching-part
  [part]
  {<span style=color:#e6db74>:name</span> (<span style=color:#a6e22e>clojure.string/replace</span> (<span style=color:#e6db74>:name</span> part) <span style=color:#f92672>#</span><span style=color:#e6db74>&#34;^left-&#34;</span> <span style=color:#e6db74>&#34;right-&#34;</span>)
   <span style=color:#e6db74>:size</span> (<span style=color:#e6db74>:size</span> part)})

<span style=color:#960050;background-color:#1e0010>➊</span> (<span style=color:#66d9ef>defn </span>symmetrize-body-parts
  <span style=color:#e6db74>&#34;Expects a seq of maps that have a :name and :size&#34;</span>
  [asym-body-parts]
<span style=color:#960050;background-color:#1e0010>➋</span>   (<span style=color:#66d9ef>loop </span>[remaining-asym-parts asym-body-parts 
         final-body-parts []]
<span style=color:#960050;background-color:#1e0010>➌</span>     (<span style=color:#66d9ef>if </span>(<span style=color:#a6e22e>empty?</span> remaining-asym-parts) 
      final-body-parts
<span style=color:#960050;background-color:#1e0010>➍</span>       (<span style=color:#66d9ef>let </span>[[part <span style=color:#f92672>&amp;</span> remaining] remaining-asym-parts] 
<span style=color:#960050;background-color:#1e0010>➎</span>         (<span style=color:#a6e22e>recur</span> remaining 
               (into final-body-parts
                     (set [part (<span style=color:#a6e22e>matching-part</span> part)])))))))
</code></pre></div><p><code>symmetriz-body-parts</code>函数（从➊开始）采用了函数式编程中常见的一般策略。给定一个序列（在本例中，是一个身体部位及其尺寸的向量），该函数连续地将该序列分割成<em>head</em>和<em>尾</em>。然后，它处理头部，将其添加到某个结果中，并使用递归来继续处理尾部的过程。</p>
<p>我们在➋处开始循环处理主体部分。序列的尾部将被绑定到<code>remaining-asym-parts</code>。最初，它被绑定到传递给函数的完整序列：<code>asym-body-parts'。我们还创建了一个结果序列，</code>final-body-parts`；它的初始值是一个空向量。</p>
<p>如果<code>remaining-asym-parts</code>在➌处是空的，这意味着我们已经处理了整个序列，可以返回结果，<code>final-body-parts</code>。否则，在➍，我们将列表分成头，<code>部分</code>，和尾，<code>剩余</code>。</p>
<p>在➎处，我们用<code>remaining</code>进行循环，这个列表在循环的每一次迭代中都会缩短一个元素，还有<code>(in)</code>表达式，它建立了对称的身体部分的向量。</p>
<p>如果你是这种编程的新手，这段代码可能需要一些时间来解决。请坚持下去! 一旦你理解了正在发生的事情，你会觉得自己像个百万富翁!</p>
<h3 id=更好的对称器与-reduce>更好的对称器与 reduce<a hidden class=anchor aria-hidden=true href=#更好的对称器与-reduce>#</a></h3>
<p>处理********************************************的模式非常普遍，以至于有一个内置的函数叫做<code>reduce</code>。下面是一个简单的例子。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>
<span style=color:#75715e>;; sum with reduce</span>
(reduce + [<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span>])
<span style=color:#75715e>; =&gt; 10</span>

</code></pre></div><p>这就像告诉 Clojure 这样做。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>
(+ (+ (+ <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span>) <span style=color:#ae81ff>3</span>) <span style=color:#ae81ff>4</span>)

</code></pre></div><p><code>reduce</code>函数按照以下步骤工作。</p>
<ol>
<li>将给定的函数应用于一个序列的前两个元素。这就是<code>(+ 1 2)</code>的由来。</li>
<li>将给定的函数应用于结果和序列的下一个元素。在本例中，步骤 1 的结果是<code>3</code>，序列的下一个元素也是<code>3</code>。所以最后的结果是`(+3 3)'。</li>
<li>对序列中剩下的每个元素重复第 2 步。</li>
</ol>
<p><code>reduce</code>也需要一个可选的初始值。这里的初始值是<code>15</code>。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>
(reduce + <span style=color:#ae81ff>15</span> [<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span>])

</code></pre></div><p>如果你提供了一个初始值，<code>reduce</code>就会开始对初始值和序列的第一个元素应用给定的函数，而不是序列的前两个元素。</p>
<p>需要注意的一个细节是，在这些例子中，<code>reduce</code>接收一个元素的集合，<code>[1 2 3 4]</code>，并返回一个单一的数字。虽然程序员经常这样使用<code>reduce</code>，但你也可以使用<code>reduce</code>来返回一个比你开始时更大的集合，就像我们在<code>symmetrize</code>-body-parts<code>中尝试做的那样。</code>reduce<code>抽象了 "处理一个集合并建立一个结果 "的任务，它对返回的结果类型是不确定的。为了进一步了解</code>reduce`的工作原理，这里有一种方法可以实现它。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>my-reduce
  ([f initial coll]
   (<span style=color:#66d9ef>loop </span>[result initial
          remaining coll]
     (<span style=color:#66d9ef>if </span>(<span style=color:#a6e22e>empty?</span> remaining)
       result
       (<span style=color:#a6e22e>recur</span> (<span style=color:#a6e22e>f</span> result (first remaining)) (rest remaining)))))
  ([f [head <span style=color:#f92672>&amp;</span> tail]]
   (<span style=color:#a6e22e>my-reduce</span> f head tail)))
</code></pre></div><p>我们可以重新实现我们的对称器，如下所示。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>better-symmetrize-body-parts
  <span style=color:#e6db74>&#34;Expects a seq of maps that have a :name and :size&#34;</span>
  [asym-body-parts]
  (reduce (<span style=color:#66d9ef>fn </span>[final-body-parts part]
            (into final-body-parts (set [part (<span style=color:#a6e22e>matching-part</span> part)])))
          []
          asym-body-parts))
</code></pre></div><p>真棒! 使用<code>reduce</code>的一个显而易见的好处是，你写的代码总体上更少。你传递给<code>reduce</code>的匿名函数只专注于处理一个元素和建立一个结果。原因是<code>reduce</code>处理了底层的机制，即跟踪哪些元素已经被处理，并决定是否返回一个最终结果或递归。</p>
<p>使用<code>reduce</code>也更有表现力。如果你的代码的读者遇到 &ldquo;loop&rdquo;，如果不阅读所有的代码，他们将不能确定这个循环到底在做什么。但是如果他们看到<code>reduce</code>，他们会立即知道代码的目的是处理一个集合的元素以建立一个结果。</p>
<p>最后，通过将 &ldquo;reduce &ldquo;过程抽象为一个以另一个函数为参数的函数，你的程序变得更有可塑性。例如，你可以将<code>reduce</code>函数作为一个参数传递给其他函数。你还可以创建一个更通用的 &ldquo;对称体-部件 &ldquo;版本，例如 &ldquo;扩展体-部件&rdquo;。除了身体部位的列表外，它还可以接受一个<em>扩展器</em>函数，并让你的模型不仅仅是霍比特人。例如，你可以有一个蜘蛛扩展器，可以增加眼睛和腿的数量。我会让你自己来写，因为我是邪恶的。</p>
<h3 id=霍比特人的暴力>霍比特人的暴力<a hidden class=anchor aria-hidden=true href=#霍比特人的暴力>#</a></h3>
<p>我的话，这真是为勇敢和真实的人准备的 Clojure! 为了给你的工作画上句号，这里有一个函数可以确定霍比特人的哪个部分被击中。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>hit
  [asym-body-parts]
  (<span style=color:#66d9ef>let </span>[sym-parts (<span style=color:#960050;background-color:#1e0010>➊</span>better-symmetrize-body-parts asym-body-parts)
        <span style=color:#960050;background-color:#1e0010>➋</span>body-part-size-sum (reduce + (map <span style=color:#e6db74>:size</span> sym-parts))
        target (rand body-part-size-sum)]
    <span style=color:#960050;background-color:#1e0010>➌</span>(<span style=color:#66d9ef>loop </span>[[part <span style=color:#f92672>&amp;</span> remaining] sym-parts
           accumulated-size (<span style=color:#e6db74>:size</span> part)]
      (<span style=color:#66d9ef>if </span>(&gt; accumulated-size target)
        part
        (<span style=color:#a6e22e>recur</span> remaining (+ accumulated-size (<span style=color:#e6db74>:size</span> (first remaining))))))))
</code></pre></div><p><code>hit</code>的工作原理是取一个不对称的身体部位的向量，在➊处对称，然后在➋处将各部位的大小相加。一旦我们将这些尺寸相加，就好像从 1 到<code>身体部位尺寸之和</code>的每个数字都对应于一个身体部位；1 可能对应于左眼，而 2、3、4 可能对应于头部。这使得当你击中一个身体部位时（通过在这个范围内选择一个随机数字），特定身体部位被击中的可能性将取决于身体部位的大小。</p>
<p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/do-things/hobbit-hit-line.png alt=img>
</p>
<p>图 3-1：身体部位与数字的范围相对应，如果目标在这个范围内，就会被击中。</p>
<p>最后，这些数字中的一个被随机选择，然后我们在➌处使用<code>loop</code>来寻找并返回与该数字对应的身体部位。循环是通过跟踪我们已经检查过的部分的累计大小，并检查累计大小是否大于目标值来实现的。我把这个过程想象成用一排编号的槽来排列身体部位。在我排完一个身体部位后，我问自己：&ldquo;我已经达到目标了吗？&rdquo; 如果我达到了，这意味着我刚刚排好的身体部位就是被击中的那个部位。否则，我就继续排查这些部位。</p>
<p>例如，假设你的零件清单是<em>头</em>、<em>左眼</em>和<em>左手</em>，如图 3-1。在取完第一个部分，即头部后，累计大小为 3。当累计大小超过目标时，身体部分就被击中，所以如果目标小于 3，那么头部就被击中了。否则，你取下下一个部分，即左眼，并将累积大小增加到 4，如果目标大于或等于 3 且小于 4，则产生一个命中。</p>
<p>下面是一些<code>hit</code>函数的运行样本。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>hit</span> asym-hobbit-body-parts)
<span style=color:#75715e>; =&gt; {:name &#34;right-upper-arm&#34;, :size 3}</span>

(<span style=color:#a6e22e>hit</span> asym-hobbit-body-parts)
<span style=color:#75715e>; =&gt; {:name &#34;chest&#34;, :size 10}</span>

(<span style=color:#a6e22e>hit</span> asym-hobbit-body-parts)
<span style=color:#75715e>; =&gt; {:name &#34;left-eye&#34;, :size 1}</span>
</code></pre></div><p>哦，我的上帝，那个可怜的霍比特人！你这个怪物！"。你这个怪物!</p>
<h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2>
<p>本章让你对如何在 Clojure 中<em>做</em>事有了一个旋风式的了解。你现在知道了如何用字符串、数字、Map、关键字、向量、列表和集合来表示信息，以及如何用<code>def</code>和<code>let</code>来命名这些表示法。你已经了解了函数的灵活性以及如何创建你自己的函数。此外，你还了解了 Clojure 的简洁哲学，包括其统一的语法和强调在原始数据类型上使用大型函数库。</p>
<p>第 4 章将带你详细考察 Clojure 的核心函数，第 5 章解释了函数式编程的思维模式。本章向你展示了如何编写 Clojure 代码&ndash;接下来的两章将向你展示如何编写 Clojure*好。</p>
<p>在这一点上，我建议你开始写代码，我的每一根纤维都是这样。没有比这更好的方法来巩固你的 Clojure 知识了。Clojure Cheat Sheet（<em><a href=http://clojure.org/api/cheatsheet>http://clojure.org/api/cheatsheet</a></em>）是一个很好的参考资料，它列出了所有在本章中涉及的数据结构上操作的内置函数。</p>
<p>下面的练习会让你的大脑非常兴奋。如果你想更多地测试你的新技能，可以在*<a href=http://www.projecteuler.net/>http://www.projecteuler.net/</a><em>尝试一些 Project Euler 挑战。你还可以看看 4Clojure（</em><a href=http://www.4clojure.com/problems/>http://www.4clojure.com/problems/</a>*），这是一套在线的 Clojure 问题，旨在测试你的知识。写点什么吧!</p>
<h2 id=练习>练习<a hidden class=anchor aria-hidden=true href=#练习>#</a></h2>
<p>这些练习是为了测试你的 Clojure 知识和学习更多的 Clojure 函数，是一种有趣的方式。前三个可以只用本章介绍的信息来完成，但后三个需要你使用到目前为止还没有涉及的函数。如果你真的很想写更多的代码并探索 Clojure 的标准库，那么就去解决后三个问题。如果你觉得这些练习太难了，可以在读完第 4 章和第 5 章后再来看看，你会发现它们要容易得多。</p>
<ol>
<li>
<p>使用<code>str</code>, <code>vector</code>, <code>list</code>, <code>hash-map</code>, 和<code>hash-set</code>函数。</p>
</li>
<li>
<p>编写一个函数，接收一个数字，并向其添加 100。</p>
</li>
<li>
<p>写一个函数。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>dec-maker
</code></pre></div><p>，其工作原理与函数</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>inc-maker
</code></pre></div><p>除了用减法。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>def </span>dec9 (<span style=color:#a6e22e>dec-maker</span> <span style=color:#ae81ff>9</span>))
(<span style=color:#a6e22e>dec9</span> <span style=color:#ae81ff>10</span>)
<span style=color:#75715e>; =&gt; 1</span>
</code></pre></div></li>
<li>
<p>写一个函数。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>mapset
</code></pre></div><p>，它的工作原理是</p>
<pre tabindex=0><code>map
</code></pre><p>除了返回值是一个集合。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>mapset</span> inc [<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>2</span>])
<span style=color:#75715e>; =&gt; #{2 3}</span>
</code></pre></div></li>
<li>
<p>创建一个类似于<code>symmetriz-body-parts</code>的函数，只是它必须与具有径向对称性的奇怪的太空外星人一起工作。他们没有两只眼睛、胳膊、腿等等，而是有五只。</p>
</li>
<li>
<p>创建一个函数，将`symmetriz-body-parts&rsquo;和你在练习 5 中创建的函数通用化。这个新的函数应该接受一个身体部位的集合，以及要增加的匹配身体部位的数量。如果你对 Lisp 语言和函数式编程是完全陌生的，那么如何做到这一点可能并不明显。如果你被卡住了，只需转到下一章，以后再重温这个问题。</p>
</li>
</ol>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://zhenfeng-zhu.github.io/tags/clojure/>clojure</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://zhenfeng-zhu.github.io/posts/chapter4/>
<span class=title>« Prev Page</span>
<br>
<span>Chapter4 核心函数的深入研究</span>
</a>
<a class=next href=https://zhenfeng-zhu.github.io/posts/chapter2/>
<span class=title>Next Page »</span>
<br>
<span>Chapter2 如何使用 Emacs，一个优秀的 Clojure 编辑器</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter3 Clojure 速成班 on twitter" href="https://twitter.com/intent/tweet/?text=Chapter3%20Clojure%20%e9%80%9f%e6%88%90%e7%8f%ad&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f&hashtags=clojure"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter3 Clojure 速成班 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f&title=Chapter3%20Clojure%20%e9%80%9f%e6%88%90%e7%8f%ad&summary=Chapter3%20Clojure%20%e9%80%9f%e6%88%90%e7%8f%ad&source=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter3 Clojure 速成班 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f&title=Chapter3%20Clojure%20%e9%80%9f%e6%88%90%e7%8f%ad"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter3 Clojure 速成班 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter3 Clojure 速成班 on whatsapp" href="https://api.whatsapp.com/send?text=Chapter3%20Clojure%20%e9%80%9f%e6%88%90%e7%8f%ad%20-%20https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter3 Clojure 速成班 on telegram" href="https://telegram.me/share/url?text=Chapter3%20Clojure%20%e9%80%9f%e6%88%90%e7%8f%ad&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer><script src=https://utteranc.es/client.js repo=zhenfeng-zhu/zhenfeng-zhu.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://zhenfeng-zhu.github.io>Awesome Fenix</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>