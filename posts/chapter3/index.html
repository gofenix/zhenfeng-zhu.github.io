<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Chapter3 | Awesome Fenix</title>
<meta name=keywords content="clojure">
<meta name=description content="做事情：Clojure 速成班 是时候学习如何用 Clojure 真正地做事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。
在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!
当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!
语法 Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。
形式 所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。
 数据结构的字面表示（如数字、字符串、Map 和向量） 操作  我们使用术语form来指代有效的代码。我有时也会用表达式来指代 Clojure 形式。但不要太纠结于术语。Clojure 评价每一个表单，以产生一个值。这些字面表达都是有效的形式。
1 &#34;a string&#34; [&#34;a&#34; &#34;vector&#34; &#34;of&#34; &#34;strings&#34;] 当然，你的代码很少包含自由浮动的字元，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你做事情的方式。所有操作的形式都是：*开括号，*操作符，*操作数，闭括号。
(operator operand1 operand2 ... operandn) 请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。
(+ 1 2 3) ; => 6 (str &#34;It was the panda &#34; &#34;in the library &#34; &#34;with a dust buster&#34;) ; => &#34;It was the panda in the library with a dust buster&#34; 在第一个操作中，运算符+将操作数1、2和3相加。在第二个操作中，运算符str将三个字符串连接起来，形成一个新的字符串。这两种形式都是有效的。这里有一个不是形式的东西，因为它没有一个结束的小括号。">
<meta name=author content="Fenix">
<link rel=canonical href=https://zhenfeng-zhu.github.io/posts/chapter3/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zhenfeng-zhu.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://zhenfeng-zhu.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://zhenfeng-zhu.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://zhenfeng-zhu.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://zhenfeng-zhu.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-216295420-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Chapter3">
<meta property="og:description" content="做事情：Clojure 速成班 是时候学习如何用 Clojure 真正地做事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。
在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!
当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!
语法 Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。
形式 所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。
 数据结构的字面表示（如数字、字符串、Map 和向量） 操作  我们使用术语form来指代有效的代码。我有时也会用表达式来指代 Clojure 形式。但不要太纠结于术语。Clojure 评价每一个表单，以产生一个值。这些字面表达都是有效的形式。
1 &#34;a string&#34; [&#34;a&#34; &#34;vector&#34; &#34;of&#34; &#34;strings&#34;] 当然，你的代码很少包含自由浮动的字元，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你做事情的方式。所有操作的形式都是：*开括号，*操作符，*操作数，闭括号。
(operator operand1 operand2 ... operandn) 请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。
(+ 1 2 3) ; => 6 (str &#34;It was the panda &#34; &#34;in the library &#34; &#34;with a dust buster&#34;) ; => &#34;It was the panda in the library with a dust buster&#34; 在第一个操作中，运算符+将操作数1、2和3相加。在第二个操作中，运算符str将三个字符串连接起来，形成一个新的字符串。这两种形式都是有效的。这里有一个不是形式的东西，因为它没有一个结束的小括号。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhenfeng-zhu.github.io/posts/chapter3/"><meta property="og:image" content="https://zhenfeng-zhu.github.io/papermod-cover.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-13T11:12:19+08:00">
<meta property="article:modified_time" content="2022-01-13T11:12:19+08:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhenfeng-zhu.github.io/papermod-cover.png">
<meta name=twitter:title content="Chapter3">
<meta name=twitter:description content="做事情：Clojure 速成班 是时候学习如何用 Clojure 真正地做事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。
在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!
当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!
语法 Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。
形式 所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。
 数据结构的字面表示（如数字、字符串、Map 和向量） 操作  我们使用术语form来指代有效的代码。我有时也会用表达式来指代 Clojure 形式。但不要太纠结于术语。Clojure 评价每一个表单，以产生一个值。这些字面表达都是有效的形式。
1 &#34;a string&#34; [&#34;a&#34; &#34;vector&#34; &#34;of&#34; &#34;strings&#34;] 当然，你的代码很少包含自由浮动的字元，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你做事情的方式。所有操作的形式都是：*开括号，*操作符，*操作数，闭括号。
(operator operand1 operand2 ... operandn) 请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。
(+ 1 2 3) ; => 6 (str &#34;It was the panda &#34; &#34;in the library &#34; &#34;with a dust buster&#34;) ; => &#34;It was the panda in the library with a dust buster&#34; 在第一个操作中，运算符+将操作数1、2和3相加。在第二个操作中，运算符str将三个字符串连接起来，形成一个新的字符串。这两种形式都是有效的。这里有一个不是形式的东西，因为它没有一个结束的小括号。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://zhenfeng-zhu.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Chapter3","item":"https://zhenfeng-zhu.github.io/posts/chapter3/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Chapter3","name":"Chapter3","description":"做事情：Clojure 速成班 是时候学习如何用 Clojure 真正地做事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。\n在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!\n当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!\n语法 Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。\n形式 所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。\n 数据结构的字面表示（如数字、字符串、Map 和向量） 操作  我们使用术语form来指代有效的代码。我有时也会用表达式来指代 Clojure 形式。但不要太纠结于术语。Clojure 评价每一个表单，以产生一个值。这些字面表达都是有效的形式。\n1 \u0026quot;a string\u0026quot; [\u0026quot;a\u0026quot; \u0026quot;vector\u0026quot; \u0026quot;of\u0026quot; \u0026quot;strings\u0026quot;] 当然，你的代码很少包含自由浮动的字元，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你做事情的方式。所有操作的形式都是：*开括号，*操作符，*操作数，闭括号。\n(operator operand1 operand2 ... operandn) 请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。\n(+ 1 2 3) ; =\u0026gt; 6 (str \u0026quot;It was the panda \u0026quot; \u0026quot;in the library \u0026quot; \u0026quot;with a dust buster\u0026quot;) ; =\u0026gt; \u0026quot;It was the panda in the library with a dust buster\u0026quot; 在第一个操作中，运算符+将操作数1、2和3相加。在第二个操作中，运算符str将三个字符串连接起来，形成一个新的字符串。这两种形式都是有效的。这里有一个不是形式的东西，因为它没有一个结束的小括号。","keywords":["clojure"],"articleBody":"做事情：Clojure 速成班 是时候学习如何用 Clojure 真正地做事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。\n在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!\n当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!\n语法 Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。\n形式 所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。\n 数据结构的字面表示（如数字、字符串、Map 和向量） 操作  我们使用术语form来指代有效的代码。我有时也会用表达式来指代 Clojure 形式。但不要太纠结于术语。Clojure 评价每一个表单，以产生一个值。这些字面表达都是有效的形式。\n1 \"a string\" [\"a\" \"vector\" \"of\" \"strings\"] 当然，你的代码很少包含自由浮动的字元，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你做事情的方式。所有操作的形式都是：*开括号，*操作符，*操作数，闭括号。\n(operator operand1 operand2 ... operandn) 请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。\n(+ 1 2 3) ; = 6 (str \"It was the panda \" \"in the library \" \"with a dust buster\") ; = \"It was the panda in the library with a dust buster\" 在第一个操作中，运算符+将操作数1、2和3相加。在第二个操作中，运算符str将三个字符串连接起来，形成一个新的字符串。这两种形式都是有效的。这里有一个不是形式的东西，因为它没有一个结束的小括号。\n(+ Clojure 的结构统一性可能与你所习惯的不同。在其他语言中，不同的操作可能有不同的结构，这取决于操作符和操作数。例如，JavaScript 采用的是 infix 符号、点运算符和小括号的大杂烩。\n1 + 2 + 3 \"It was the panda \".concat(\"in the library \", \"with a dust buster\") 相比之下，Clojure 的结构是非常简单和一致的。无论你使用哪种运算符，或对哪种数据进行操作，其结构都是一样的。\n控制流 让我们来看看三个基本的控制流操作符。if, do, 和when。在本书中，你会遇到更多的操作，但这些操作可以让你开始。\nif 这是一个 “if “表达式的一般结构。\n(if boolean-form then-form optional-else-form) 布尔形式只是一个评估为真值或假值的形式。你会在下一节中了解到真实性和虚假性。下面是几个`if’的例子。\n(if true \"By Zeus's hammer!\" \"By Aquaman's trident!\") ; = \"By Zeus's hammer!\" (if false \"By Zeus's hammer!\" \"By Aquaman's trident!\") ; = \"By Aquaman's trident!\" 第一个例子返回 “靠宙斯的锤子！\"，因为其布尔形式评估为 “true”，是一个真实的值；第二个例子返回 “靠阿卡曼的三叉戟！\"，因为其布尔形式 “false”，评估为一个错误的值。\n你也可以省略else分支。如果你这样做，并且布尔表达式是假的，Clojure 会返回nil，就像这样。\n(if false \"By Odin's Elbow!\") ; = nil 注意if使用操作数位置将操作数与then和else分支联系起来：第一个操作数是then分支，第二个操作数是（可选）else分支。因此，每个分支只能有一种形式。这与大多数语言不同。例如，你可以在 Ruby 中这样写。\nif true doer.do_thing(1) doer.do_thing(2) else other_doer.do_thing(1) other_doer.do_thing(2) end 为了绕过这个明显的限制，你可以使用do操作符。\ndo do操作符可以让你在括号中包裹起多个表单，并运行其中的每一个。在你的 REPL 中尝试以下操作。\n(if true (do (println \"Success!\") \"By Zeus's hammer!\") (do (println \"Failure!\") \"By Aquaman's trident!\")) ; = Success! ; = \"By Zeus's hammer!\" 这个操作符让你在if表达式的每个分支中做多件事情。在这种情况下，会发生两件事。成功！被打印在 REPL 中，\"通过宙斯的锤子！\"被作为整个if表达式的值返回。\nwhen when操作符就像if和do的组合，但没有else分支。下面是一个例子。\n(when true (println \"Success!\") \"abra cadabra\") ; = Success! ; = \"abra cadabra\" 如果你想在某个条件为真时做多件事，而你总是想在条件为假时返回nil'，请使用when`。\nnil, true, false, Truthiness, Equality, and Boolean Expressions Clojure 有true和false值。nil在 Clojure 中用来表示没有值。你可以用适当命名的nil?函数来检查一个值是否为nil。\n(nil? 1) ; = false (nil? nil) ; = true nil和false都是用来表示逻辑上的虚假性，而所有其他的值都是逻辑上的真实性。Truthy和falsey指的是在布尔表达式中如何处理一个值，比如传递给if的第一个表达式。\n(if \"bears eat beets\" \"bears beets Battlestar Galactica\") ; = \"bears beets Battlestar Galactica\" (if nil \"This won't be the result because nil is falsey\" \"nil is falsey\") ; = \"nil is falsey\" 在第一个例子中，字符串\"熊吃甜菜\"被认为是真实的，所以if表达式评估为\"熊吃甜菜Battlestar Galactica\"。第二个例子显示一个假值是假的。\nClojure 的平等运算符是=。\n(= 1 1) ; = true (= nil nil) ; = true (= 1 2) ; = false 其他一些语言要求你在比较不同类型的值时使用不同的运算符。例如，你可能不得不使用某种专门为字符串制作的特殊字符串平等运算符。但在使用 Clojure 的内置数据结构时，你不需要像这样奇怪或繁琐的东西来测试平等性。\nClojure 使用布尔运算符or和and。or返回第一个真值或最后一个值。and返回第一个错误的值，如果没有错误的值，则返回最后一个真实的值。让我们先看一下or。\n(or false nil :large_I_mean_venti :why_cant_I_just_say_large) ; = :large_I_mean_venti (or (= 0 1) (= \"yes\" \"no\")) ; = false (or nil) ; = nil 在第一个例子中，返回值是:large_I_mean_venti，因为它是第一个真值。第二个例子没有真值，所以or返回最后一个值，即false。在最后一个例子中，同样没有真值存在，or返回最后一个值，即nil。现在我们来看看and。\n(and :free_wifi :hot_coffee) ; = :hot_coffee (and :feelin_super_cool nil false) ; = nil 在第一个例子中，and返回最后一个真值，:hot_coffee。在第二个例子中, and返回nil, 这是第一个错误的值.\n用 def 命名数值 在 Clojure 中, 你可以使用def将一个名字与一个值结合起来:\n(def failed-protagonist-names [\"Larry Potter\" \"Doreen the Explorer\" \"The Incredible Bulk\"]) failed-protagonist-names ; = [\"Larry Potter\" \"Doreen the Explorer\" \"The Incredible Bulk\"] 在这个例子中，你把名字failed-protagonist-names绑定到一个包含三个字符串的向量（你将在“向量 “第 45 页中了解向量）。\n请注意，我使用的是 “绑定 “一词，而在其他语言中，你会说你是在给一个变量赋值。那些其他语言通常鼓励你对同一个变量进行多次赋值。\n例如，在 Ruby 中，你可以对一个变量进行多次赋值，以建立它的值。\nseverity = :mild error_message = \"OH GOD! IT'S A DISASTER! WE'RE \" if severity == :mild error_message = error_message + \"MILDLY INCONVENIENCED!\" else error_message = error_message + \"DOOOOOOOMED!\" end 你可能想在 Clojure 中做类似的事情。\n(def severity :mild) (def error-message \"OH GOD! IT'S A DISASTER! WE'RE \") (if (= severity :mild) (def error-message (str error-message \"MILDLY INCONVENIENCED!\")) (def error-message (str error-message \"DOOOOOOOMED!\"))) 然而，像这样改变与名字相关的值会使你更难理解你的程序的行为，因为更难知道哪个值是与名字相关的，或者为什么这个值可能已经改变了。Clojure 有一套处理变化的工具，你会在第 10 章中了解到。随着你对 Clojure 的学习，你会发现你很少需要改变一个名字/值的关联。下面是你写前面代码的一种方式。\n(defn error-message [severity] (str \"OH GOD! IT'S A DISASTER! WE'RE \" (if (= severity :mild) \"MILDLY INCONVENIENCED!\" \"DOOOOOOOMED!\"))) (error-message :mild) ; = \"OH GOD! IT'S A DISASTER! WE'RE MILDLY INCONVENIENCED!\" 这里，你创建了一个函数，error-message，它接受一个参数，severity，并使用它来决定返回哪个字符串。然后你用:mild作为严重程度来调用这个函数。你将在“函数 “第 48 页中学习所有关于创建函数的知识；与此同时，你应该把def当作定义常量。在接下来的几章中，你将学习如何通过接受函数式编程范式来处理这个明显的限制。 使用 www.DeepL.com/Translator 翻译（免费版）\n数据结构 Clojure 带有少量的数据结构，你在大多数时候都会用到。如果你来自面向对象的背景，你会惊讶于你可以用这里介绍的看似基本的类型做很多事情。\nClojure 的所有数据结构都是不可改变的，这意味着你不能在原地改变它们。例如，在 Ruby 中，你可以做以下事情来重新分配索引为 0 的失败主角的名字。\nfailed_protagonist_names = [ \"Larry Potter\", \"Doreen the Explorer\", \"The Incredible Bulk\" ] failed_protagonist_names[0] = \"Gary Potter\" failed_protagonist_names # = [ # \"Gary Potter\", # \"Doreen the Explorer\", # \"The Incredible Bulk\" # ] Clojure 没有与之对应的东西。你会在第 10 章中了解到更多关于 Clojure 这样实现的原因，但现在只学习如何做事情，而不考虑所有的哲学问题，这很有趣。不多说了，让我们来看看 Clojure 中的数字。\n数字 Clojure 有相当复杂的数字支持。我不会花太多时间纠缠于无聊的技术细节（比如强制和传染），因为那会妨碍做事情。如果你对这些枯燥的细节感兴趣，请查看*http://clojure.org/data_**structures#Data%20Structures-Numbers*的文档。可以说，Clojure 会很高兴地处理你扔给它的几乎所有东西。\n在此期间，我们将使用整数和浮点数。我们还将使用比率，Clojure 可以直接表示这些比率。下面分别是一个整数、一个浮点数和一个比率。\n93 1.2 1/5 字符串 字符串代表文本。这个名字来自于古代腓尼基人，他们在一次涉及纱线的事故后，有一天发明了字母表。下面是一些字符串字面的例子。\n\"Lord Voldemort\" \"\\\"He who must not be named\\\"\" \"\\\"Great cow of Moscow!\\\" - Hermes Conrad\" 注意，Clojure 只允许用双引号来划分字符串。例如，“Lord Voldemort “就不是一个有效的字符串。还要注意，Clojure 没有字符串插值。它只允许通过str函数进行连接。\n(def name \"Chewbacca\") (str \"\\\"Uggllglglglglglll\\\" - \" name) ; = \"Uggllglglglglglll\" - Chewbacca Map Map 类似于其他语言中的字典或哈希值。它们是一种将一些值与另一些值联系起来的方式。Clojure 中的两种 Map 是哈希 Map 和排序 Map。我将只介绍更基本的哈希图。让我们来看看 Map 字面的一些例子。这里有一个空 Map。\n{} 在这个例子中，:first-name和:last-name是关键字（我将在下一节介绍这些）。\n{:first-name \"Charlie\" :last-name \"McFishwich\"} 这里我们把\"string-key\"和+函数联系起来。\n{\"string-key\" +} Map 可以被嵌套。\n{:name {:first \"John\" :middle \"Jacob\" :last \"Jingleheimerschmidt\"}}. 注意，Map 的值可以是任何类型–字符串、数字、Map、向量，甚至函数。Clojure 并不关心这个问题。\n除了使用 map 字面，你还可以使用hash-map函数来创建一个 map。\n(hash-map :a 1 :b 2) ; = {:a 1 :b 2}. 你可以用get函数在 Map 中查询数值。\n(get {:a 0 :b 1} :b) ; = 1 (get {:a 0 :b {:c \"ho hum\"}} :b) ; = {:c \"ho hum\"} 在这两个例子中，我们向get询问给定 Map 中:b键的值–在第一个例子中，它返回1，而在第二个例子中，它返回嵌套 Map{:c \"ho hum\"}。\n如果没有找到你的键，get将返回nil'，或者你可以给它一个默认值，例如“独角兽？\"`。\n(get {:a 0 :b 1} :c) ; = nil (get {:a 0 :b 1} :c \"unicorns?\") ; = \"unicorns?\" get-in函数可以让你在嵌套 Map 中查询数值。\n(get-in {:a 0 :b {:c \"ho hum\"}} [:b :c]) ; = \"ho hum\" 另一种在 Map 中查询数值的方法是把 Map 当作一个以键为参数的函数。\n({:name \"The Human Coffeepot\"} :name) ; = \"The Human Coffeepot\" 你可以用 Map 做的另一件很酷的事情是把关键词作为函数来查询它们的值，这就引出了下一个主题，关键词。 使用 www.DeepL.com/Translator 翻译（免费版）\n","wordCount":"720","inLanguage":"en","datePublished":"2022-01-13T11:12:19+08:00","dateModified":"2022-01-13T11:12:19+08:00","author":{"@type":"Person","name":"Fenix"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhenfeng-zhu.github.io/posts/chapter3/"},"publisher":{"@type":"Organization","name":"Awesome Fenix","logo":{"@type":"ImageObject","url":"https://zhenfeng-zhu.github.io/favicon.ico"}}}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8502076734034112" crossorigin=anonymous></script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhenfeng-zhu.github.io accesskey=h title="Awesome Fenix (Alt + H)">Awesome Fenix</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://zhenfeng-zhu.github.io/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/about title=About>
<span>About</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/search/ title=🔍>
<span>🔍</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://zhenfeng-zhu.github.io>Home</a>&nbsp;»&nbsp;<a href=https://zhenfeng-zhu.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Chapter3
</h1>
<div class=post-meta><span title="2022-01-13 11:12:19 +0800 +0800">January 13, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Fenix&nbsp;|&nbsp;<a href=https://github.com/zhenfeng-zhu/zhenfeng-zhu.github.io/tree/main/content/posts/Chapter3.md rel="noopener noreferrer" target=_blank>修改本文章</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e5%81%9a%e4%ba%8b%e6%83%85clojure-%e9%80%9f%e6%88%90%e7%8f%ad aria-label="做事情：Clojure 速成班">做事情：Clojure 速成班</a><ul>
<li>
<a href=#%e8%af%ad%e6%b3%95 aria-label=语法>语法</a><ul>
<li>
<a href=#%e5%bd%a2%e5%bc%8f aria-label=形式>形式</a></li>
<li>
<a href=#%e6%8e%a7%e5%88%b6%e6%b5%81 aria-label=控制流>控制流</a><ul>
<li>
<a href=#if aria-label=if>if</a></li>
<li>
<a href=#do aria-label=do>do</a></li>
<li>
<a href=#when aria-label=when>when</a></li>
<li>
<a href=#nil-true-false-truthiness-equality-and-boolean-expressions aria-label="nil, true, false, Truthiness, Equality, and Boolean Expressions">nil, true, false, Truthiness, Equality, and Boolean Expressions</a></li></ul>
</li>
<li>
<a href=#%e7%94%a8-def-%e5%91%bd%e5%90%8d%e6%95%b0%e5%80%bc aria-label="用 def 命名数值">用 def 命名数值</a></li></ul>
</li>
<li>
<a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=数据结构>数据结构</a><ul>
<li>
<a href=#%e6%95%b0%e5%ad%97 aria-label=数字>数字</a></li>
<li>
<a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label=字符串>字符串</a></li>
<li>
<a href=#map aria-label=Map>Map</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=做事情clojure-速成班>做事情：Clojure 速成班<a hidden class=anchor aria-hidden=true href=#做事情clojure-速成班>#</a></h1>
<p>是时候学习如何用 Clojure 真正地<em>做</em>事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。</p>
<p>在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!</p>
<p>当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!</p>
<h2 id=语法>语法<a hidden class=anchor aria-hidden=true href=#语法>#</a></h2>
<p>Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。</p>
<h3 id=形式>形式<a hidden class=anchor aria-hidden=true href=#形式>#</a></h3>
<p>所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。</p>
<ul>
<li>数据结构的字面表示（如数字、字符串、Map 和向量）</li>
<li>操作</li>
</ul>
<p>我们使用术语<em>form</em>来指代有效的代码。我有时也会用<em>表达式</em>来指代 Clojure 形式。但不要太纠结于术语。Clojure <em>评价</em>每一个表单，以产生一个值。这些字面表达都是有效的形式。</p>
<pre tabindex=0><code>1
&quot;a string&quot;
[&quot;a&quot; &quot;vector&quot; &quot;of&quot; &quot;strings&quot;]
</code></pre><p>当然，你的代码很少包含自由浮动的字元，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你<em>做</em>事情的方式。所有操作的形式都是：*开括号，*操作符，*操作数，<em>闭括号</em>。</p>
<pre tabindex=0><code>(operator operand1 operand2 ... operandn)
</code></pre><p>请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。</p>
<pre tabindex=0><code>(+ 1 2 3)
; =&gt; 6

(str &quot;It was the panda &quot; &quot;in the library &quot; &quot;with a dust buster&quot;)
; =&gt; &quot;It was the panda in the library with a dust buster&quot;
</code></pre><p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/do-things/panda.png alt=img>
</p>
<p>在第一个操作中，运算符<code>+</code>将操作数<code>1</code>、<code>2</code>和<code>3</code>相加。在第二个操作中，运算符<code>str</code>将三个字符串连接起来，形成一个新的字符串。这两种形式都是有效的。这里有一个不是形式的东西，因为它没有一个结束的小括号。</p>
<pre tabindex=0><code>(+
</code></pre><p>Clojure 的结构统一性可能与你所习惯的不同。在其他语言中，不同的操作可能有不同的结构，这取决于操作符和操作数。例如，JavaScript 采用的是 infix 符号、点运算符和小括号的大杂烩。</p>
<pre tabindex=0><code>1 + 2 + 3
&quot;It was the panda &quot;.concat(&quot;in the library &quot;, &quot;with a dust buster&quot;)
</code></pre><p>相比之下，Clojure 的结构是非常简单和一致的。无论你使用哪种运算符，或对哪种数据进行操作，其结构都是一样的。</p>
<h3 id=控制流>控制流<a hidden class=anchor aria-hidden=true href=#控制流>#</a></h3>
<p>让我们来看看三个基本的控制流操作符。<code>if</code>, <code>do</code>, 和<code>when</code>。在本书中，你会遇到更多的操作，但这些操作可以让你开始。</p>
<h4 id=if>if<a hidden class=anchor aria-hidden=true href=#if>#</a></h4>
<p>这是一个 &ldquo;if &ldquo;表达式的一般结构。</p>
<pre tabindex=0><code>(if boolean-form
  then-form
  optional-else-form)
</code></pre><p>布尔形式只是一个评估为真值或假值的形式。你会在下一节中了解到真实性和虚假性。下面是几个`if&rsquo;的例子。</p>
<pre tabindex=0><code>(if true
  &quot;By Zeus's hammer!&quot;
  &quot;By Aquaman's trident!&quot;)
; =&gt; &quot;By Zeus's hammer!&quot;

(if false
  &quot;By Zeus's hammer!&quot;
  &quot;By Aquaman's trident!&quot;)
; =&gt; &quot;By Aquaman's trident!&quot;
</code></pre><p>第一个例子返回 &ldquo;靠宙斯的锤子！"，因为其布尔形式评估为 &ldquo;true&rdquo;，是一个真实的值；第二个例子返回 &ldquo;靠阿卡曼的三叉戟！"，因为其布尔形式 &ldquo;false&rdquo;，评估为一个错误的值。</p>
<p>你也可以省略<code>else</code>分支。如果你这样做，并且布尔表达式是假的，Clojure 会返回<code>nil</code>，就像这样。</p>
<pre tabindex=0><code>(if false
  &quot;By Odin's Elbow!&quot;)
; =&gt; nil
</code></pre><p>注意<code>if</code>使用操作数位置将操作数与<code>then</code>和<code>else</code>分支联系起来：第一个操作数是<code>then</code>分支，第二个操作数是（可选）<code>else</code>分支。因此，每个分支只能有一种形式。这与大多数语言不同。例如，你可以在 Ruby 中这样写。</p>
<pre tabindex=0><code>if true
  doer.do_thing(1)
  doer.do_thing(2)
else
  other_doer.do_thing(1)
  other_doer.do_thing(2)
end
</code></pre><p>为了绕过这个明显的限制，你可以使用<code>do</code>操作符。</p>
<h4 id=do>do<a hidden class=anchor aria-hidden=true href=#do>#</a></h4>
<p><code>do</code>操作符可以让你在括号中<em>包裹</em>起多个表单，并运行其中的每一个。在你的 REPL 中尝试以下操作。</p>
<pre tabindex=0><code>(if true
  (do (println &quot;Success!&quot;)
      &quot;By Zeus's hammer!&quot;)
  (do (println &quot;Failure!&quot;)
      &quot;By Aquaman's trident!&quot;))
; =&gt; Success!
; =&gt; &quot;By Zeus's hammer!&quot;
</code></pre><p>这个操作符让你在<code>if</code>表达式的每个分支中做多件事情。在这种情况下，会发生两件事。<code>成功！</code>被打印在 REPL 中，<code>"</code>通过宙斯的锤子！<code>"</code>被作为整个<code>if</code>表达式的值返回。</p>
<h4 id=when>when<a hidden class=anchor aria-hidden=true href=#when>#</a></h4>
<p><code>when</code>操作符就像<code>if</code>和<code>do</code>的组合，但没有<code>else</code>分支。下面是一个例子。</p>
<pre tabindex=0><code>(when true
  (println &quot;Success!&quot;)
  &quot;abra cadabra&quot;)
; =&gt; Success!
; =&gt; &quot;abra cadabra&quot;
</code></pre><p>如果你想在某个条件为真时做多件事，而你总是想在条件为假时返回<code>nil'，请使用</code>when`。</p>
<h4 id=nil-true-false-truthiness-equality-and-boolean-expressions>nil, true, false, Truthiness, Equality, and Boolean Expressions<a hidden class=anchor aria-hidden=true href=#nil-true-false-truthiness-equality-and-boolean-expressions>#</a></h4>
<p>Clojure 有<code>true</code>和<code>false</code>值。<code>nil</code>在 Clojure 中用来表示<em>没有</em>值。你可以用适当命名的<code>nil?</code>函数来检查一个值是否为<code>nil</code>。</p>
<pre tabindex=0><code>(nil? 1)
; =&gt; false

(nil? nil)
; =&gt; true
</code></pre><p><code>nil</code>和<code>false</code>都是用来表示逻辑上的虚假性，而所有其他的值都是逻辑上的真实性。<em>Truthy</em>和<em>falsey</em>指的是在布尔表达式中如何处理一个值，比如传递给<code>if</code>的第一个表达式。</p>
<pre tabindex=0><code>(if &quot;bears eat beets&quot;
  &quot;bears beets Battlestar Galactica&quot;)
; =&gt; &quot;bears beets Battlestar Galactica&quot;

(if nil
  &quot;This won't be the result because nil is falsey&quot;
  &quot;nil is falsey&quot;)
; =&gt; &quot;nil is falsey&quot;
</code></pre><p>在第一个例子中，字符串<code>"熊吃甜菜"</code>被认为是真实的，所以<code>if</code>表达式评估为<code>"熊吃甜菜Battlestar Galactica"</code>。第二个例子显示一个假值是假的。</p>
<p>Clojure 的平等运算符是<code>=</code>。</p>
<pre tabindex=0><code>(= 1 1)
; =&gt; true

(= nil nil)
; =&gt; true

(= 1 2)
; =&gt; false
</code></pre><p>其他一些语言要求你在比较不同类型的值时使用不同的运算符。例如，你可能不得不使用某种专门为字符串制作的特殊字符串平等运算符。但在使用 Clojure 的内置数据结构时，你不需要像这样奇怪或繁琐的东西来测试平等性。</p>
<p>Clojure 使用布尔运算符<code>or</code>和<code>and</code>。<code>or</code>返回第一个真值或最后一个值。<code>and</code>返回第一个错误的值，如果没有错误的值，则返回最后一个真实的值。让我们先看一下<code>or</code>。</p>
<pre tabindex=0><code>(or false nil :large_I_mean_venti :why_cant_I_just_say_large)
; =&gt; :large_I_mean_venti

(or (= 0 1) (= &quot;yes&quot; &quot;no&quot;))
; =&gt; false

(or nil)
; =&gt; nil
</code></pre><p>在第一个例子中，返回值是<code>:large_I_mean_venti</code>，因为它是第一个真值。第二个例子没有真值，所以<code>or</code>返回最后一个值，即<code>false</code>。在最后一个例子中，同样没有真值存在，<code>or</code>返回最后一个值，即<code>nil</code>。现在我们来看看<code>and</code>。</p>
<pre tabindex=0><code>(and :free_wifi :hot_coffee)
; =&gt; :hot_coffee

(and :feelin_super_cool nil false)
; =&gt; nil
</code></pre><p>在第一个例子中，<code>and</code>返回最后一个真值，<code>:hot_coffee</code>。在第二个例子中, <code>and</code>返回<code>nil</code>, 这是第一个错误的值.</p>
<h3 id=用-def-命名数值>用 def 命名数值<a hidden class=anchor aria-hidden=true href=#用-def-命名数值>#</a></h3>
<p>在 Clojure 中, 你可以使用<code>def</code>将一个名字与一个值结合起来:</p>
<pre tabindex=0><code>(def failed-protagonist-names
  [&quot;Larry Potter&quot; &quot;Doreen the Explorer&quot; &quot;The Incredible Bulk&quot;])

failed-protagonist-names
; =&gt; [&quot;Larry Potter&quot; &quot;Doreen the Explorer&quot; &quot;The Incredible Bulk&quot;]
</code></pre><p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/do-things/larry-potter.png alt=img>
</p>
<p>在这个例子中，你把名字<code>failed-protagonist-names</code>绑定到一个包含三个字符串的向量（你将在<a href=https://www.braveclojure.com/do-things/#Anchor-3>&ldquo;向量 &ldquo;第 45 页</a>中了解向量）。</p>
<p>请注意，我使用的是 &ldquo;绑定 &ldquo;一词，而在其他语言中，你会说你是在给一个<em>变量</em>赋值。那些其他语言通常鼓励你对同一个变量进行多次赋值。</p>
<p>例如，在 Ruby 中，你可以对一个变量进行多次赋值，以建立它的值。</p>
<pre tabindex=0><code>severity = :mild
error_message = &quot;OH GOD! IT'S A DISASTER! WE'RE &quot;
if severity == :mild
  error_message = error_message + &quot;MILDLY INCONVENIENCED!&quot;
else
  error_message = error_message + &quot;DOOOOOOOMED!&quot;
end
</code></pre><p>你可能想在 Clojure 中做类似的事情。</p>
<pre tabindex=0><code>(def severity :mild)
(def error-message &quot;OH GOD! IT'S A DISASTER! WE'RE &quot;)
(if (= severity :mild)
  (def error-message (str error-message &quot;MILDLY INCONVENIENCED!&quot;))
  (def error-message (str error-message &quot;DOOOOOOOMED!&quot;)))
</code></pre><p>然而，像这样改变与名字相关的值会使你更难理解你的程序的行为，因为更难知道哪个值是与名字相关的，或者为什么这个值可能已经改变了。Clojure 有一套处理变化的工具，你会在第 10 章中了解到。随着你对 Clojure 的学习，你会发现你很少需要改变一个名字/值的关联。下面是你写前面代码的一种方式。</p>
<pre tabindex=0><code>(defn error-message
  [severity]
  (str &quot;OH GOD! IT'S A DISASTER! WE'RE &quot;
       (if (= severity :mild)
         &quot;MILDLY INCONVENIENCED!&quot;
         &quot;DOOOOOOOMED!&quot;)))

(error-message :mild)
; =&gt; &quot;OH GOD! IT'S A DISASTER! WE'RE MILDLY INCONVENIENCED!&quot;
</code></pre><p>这里，你创建了一个函数，<code>error-message</code>，它接受一个参数，<code>severity</code>，并使用它来决定返回哪个字符串。然后你用<code>:mild</code>作为严重程度来调用这个函数。你将在<a href=https://www.braveclojure.com/do-things/#Anchor-4>&ldquo;函数 &ldquo;第 48 页</a>中学习所有关于创建函数的知识；与此同时，你应该把<code>def</code>当作定义常量。在接下来的几章中，你将学习如何通过接受函数式编程范式来处理这个明显的限制。 使用 <a href=http://www.DeepL.com/Translator>www.DeepL.com/Translator</a> 翻译（免费版）</p>
<h2 id=数据结构>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构>#</a></h2>
<p>Clojure 带有少量的数据结构，你在大多数时候都会用到。如果你来自面向对象的背景，你会惊讶于你可以用这里介绍的看似基本的类型做很多事情。</p>
<p>Clojure 的所有数据结构都是不可改变的，这意味着你不能在原地改变它们。例如，在 Ruby 中，你可以做以下事情来重新分配索引为 0 的失败主角的名字。</p>
<pre tabindex=0><code>failed_protagonist_names = [
  &quot;Larry Potter&quot;,
  &quot;Doreen the Explorer&quot;,
  &quot;The Incredible Bulk&quot;
]
failed_protagonist_names[0] = &quot;Gary Potter&quot;

failed_protagonist_names
# =&gt; [
#   &quot;Gary Potter&quot;,
#   &quot;Doreen the Explorer&quot;,
#   &quot;The Incredible Bulk&quot;
# ]
</code></pre><p>Clojure 没有与之对应的东西。你会在第 10 章中了解到更多关于 Clojure 这样实现的原因，但现在只学习如何做事情，而不考虑所有的哲学问题，这很有趣。不多说了，让我们来看看 Clojure 中的数字。</p>
<h3 id=数字>数字<a hidden class=anchor aria-hidden=true href=#数字>#</a></h3>
<p>Clojure 有相当复杂的数字支持。我不会花太多时间纠缠于无聊的技术细节（比如强制和传染），因为那会妨碍<em>做事情</em>。如果你对这些枯燥的细节感兴趣，请查看*<a href=http://clojure.org/data_**structures#Data%20Structures-Numbers>http://clojure.org/data_**structures#Data%20Structures-Numbers</a>*的文档。可以说，Clojure 会很高兴地处理你扔给它的几乎所有东西。</p>
<p>在此期间，我们将使用整数和浮点数。我们还将使用比率，Clojure 可以直接表示这些比率。下面分别是一个整数、一个浮点数和一个比率。</p>
<pre tabindex=0><code>93
1.2
1/5
</code></pre><h3 id=字符串>字符串<a hidden class=anchor aria-hidden=true href=#字符串>#</a></h3>
<p>字符串代表文本。这个名字来自于古代腓尼基人，他们在一次涉及纱线的事故后，有一天发明了字母表。下面是一些字符串字面的例子。</p>
<pre tabindex=0><code>&quot;Lord Voldemort&quot;
&quot;\&quot;He who must not be named\&quot;&quot;
&quot;\&quot;Great cow of Moscow!\&quot; - Hermes Conrad&quot;
</code></pre><p><img loading=lazy src=https://www.braveclojure.com/assets/images/cftbat/do-things/wookie.png alt=img>
</p>
<p>注意，Clojure 只允许用双引号来划分字符串。例如，&ldquo;Lord Voldemort &ldquo;就不是一个有效的字符串。还要注意，Clojure 没有字符串插值。它只允许通过<code>str</code>函数进行连接。</p>
<pre tabindex=0><code>(def name &quot;Chewbacca&quot;)
(str &quot;\&quot;Uggllglglglglglll\&quot; - &quot; name)
; =&gt; &quot;Uggllglglglglglll&quot; - Chewbacca
</code></pre><h3 id=map>Map<a hidden class=anchor aria-hidden=true href=#map>#</a></h3>
<p>Map 类似于其他语言中的字典或哈希值。它们是一种将一些值与另一些值联系起来的方式。Clojure 中的两种 Map 是哈希 Map 和排序 Map。我将只介绍更基本的哈希图。让我们来看看 Map 字面的一些例子。这里有一个空 Map。</p>
<pre tabindex=0><code>{}
</code></pre><p>在这个例子中，<code>:first-name</code>和<code>:last-name</code>是关键字（我将在下一节介绍这些）。</p>
<pre tabindex=0><code>{:first-name &quot;Charlie&quot;
 :last-name &quot;McFishwich&quot;}
</code></pre><p>这里我们把<code>"string-key"</code>和<code>+</code>函数联系起来。</p>
<pre tabindex=0><code>{&quot;string-key&quot; +}
</code></pre><p>Map 可以被嵌套。</p>
<pre tabindex=0><code>{:name {:first &quot;John&quot; :middle &quot;Jacob&quot; :last &quot;Jingleheimerschmidt&quot;}}.
</code></pre><p>注意，Map 的值可以是任何类型&ndash;字符串、数字、Map、向量，甚至函数。Clojure 并不关心这个问题。</p>
<p>除了使用 map 字面，你还可以使用<code>hash-map</code>函数来创建一个 map。</p>
<pre tabindex=0><code>(hash-map :a 1 :b 2)
; =&gt; {:a 1 :b 2}.
</code></pre><p>你可以用<code>get</code>函数在 Map 中查询数值。</p>
<pre tabindex=0><code>(get {:a 0 :b 1} :b)
; =&gt; 1

(get {:a 0 :b {:c &quot;ho hum&quot;}} :b)
; =&gt; {:c &quot;ho hum&quot;}
</code></pre><p>在这两个例子中，我们向<code>get</code>询问给定 Map 中<code>:b</code>键的值&ndash;在第一个例子中，它返回<code>1</code>，而在第二个例子中，它返回嵌套 Map<code>{:c "ho hum"}</code>。</p>
<p>如果没有找到你的键，<code>get</code>将返回<code>nil'，或者你可以给它一个默认值，例如</code>&ldquo;独角兽？"`。</p>
<pre tabindex=0><code>(get {:a 0 :b 1} :c)
; =&gt; nil

(get {:a 0 :b 1} :c &quot;unicorns?&quot;)
; =&gt; &quot;unicorns?&quot;
</code></pre><p><code>get-in</code>函数可以让你在嵌套 Map 中查询数值。</p>
<pre tabindex=0><code>(get-in {:a 0 :b {:c &quot;ho hum&quot;}} [:b :c])
; =&gt; &quot;ho hum&quot;
</code></pre><p>另一种在 Map 中查询数值的方法是把 Map 当作一个以键为参数的函数。</p>
<pre tabindex=0><code>({:name &quot;The Human Coffeepot&quot;} :name)
; =&gt; &quot;The Human Coffeepot&quot;
</code></pre><p>你可以用 Map 做的另一件很酷的事情是把关键词作为函数来查询它们的值，这就引出了下一个主题，关键词。 使用 <a href=http://www.DeepL.com/Translator>www.DeepL.com/Translator</a> 翻译（免费版）</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://zhenfeng-zhu.github.io/tags/clojure/>clojure</a></li>
</ul>
<nav class=paginav>
<a class=next href=https://zhenfeng-zhu.github.io/posts/chapter2/>
<span class=title>Next Page »</span>
<br>
<span>Chapter2</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter3 on twitter" href="https://twitter.com/intent/tweet/?text=Chapter3&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f&hashtags=clojure"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter3 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f&title=Chapter3&summary=Chapter3&source=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter3 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f&title=Chapter3"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter3 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter3 on whatsapp" href="https://api.whatsapp.com/send?text=Chapter3%20-%20https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Chapter3 on telegram" href="https://telegram.me/share/url?text=Chapter3&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fchapter3%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer><script src=https://utteranc.es/client.js repo=zhenfeng-zhu/zhenfeng-zhu.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://zhenfeng-zhu.github.io>Awesome Fenix</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>