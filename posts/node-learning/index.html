<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>node学习笔记 | Go Data</title><meta name=keywords content><meta name=description content="写node也有一段时间了，整理一下学习笔记，共同进步
什么是node？ 首先看一下什么是node.js
 Node 是一个服务器端 JavaScript Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效 Node.js 的包管理器 npm，是全球最大的开源库生态系统  模块系统是node最基本也是最常用的。一般可以分为四类：
 原生模块 文件模块 第三方模块 自定义模块  node社区崇尚DRY文化，即Don&rsquo;t repeate yourself。这种文化使得node的生态异常繁荣，同样也由于某些包的质量低下引来了一些诟病。
谈谈自定义模块 我们在写node程序的时候，一般都是在写自定义模块。
  创建模块
// b.js function FunA(){ return &#34;hello world&#34;; } // 暴露方法FunA module.exports = FunA;   加载模块
// a.js const FunA=require('./b.js'); // 运行FunA const name=FunA(); console.log(name);   在做模块到处的时候有两种方式：
  module.exports
module.exports 就 Node."><meta name=author content="Lucas"><link rel=canonical href=https://zhenfeng-zhu.github.io/posts/node-learning/><link href=/assets/css/stylesheet.min.3839cf02b87f30309470412461116907caabd1b3ec3f5d015df618da2d034992.css integrity="sha256-ODnPArh/MDCUcEEkYRFpB8qr0bPsP10BXfYY2i0DSZI=" rel="preload stylesheet" as=style><link rel=icon href=https://zhenfeng-zhu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zhenfeng-zhu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zhenfeng-zhu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zhenfeng-zhu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zhenfeng-zhu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><meta property="og:title" content="node学习笔记"><meta property="og:description" content="写node也有一段时间了，整理一下学习笔记，共同进步
什么是node？ 首先看一下什么是node.js
 Node 是一个服务器端 JavaScript Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效 Node.js 的包管理器 npm，是全球最大的开源库生态系统  模块系统是node最基本也是最常用的。一般可以分为四类：
 原生模块 文件模块 第三方模块 自定义模块  node社区崇尚DRY文化，即Don&rsquo;t repeate yourself。这种文化使得node的生态异常繁荣，同样也由于某些包的质量低下引来了一些诟病。
谈谈自定义模块 我们在写node程序的时候，一般都是在写自定义模块。
  创建模块
// b.js function FunA(){ return &#34;hello world&#34;; } // 暴露方法FunA module.exports = FunA;   加载模块
// a.js const FunA=require('./b.js'); // 运行FunA const name=FunA(); console.log(name);   在做模块到处的时候有两种方式：
  module.exports
module.exports 就 Node."><meta property="og:type" content="article"><meta property="og:url" content="https://zhenfeng-zhu.github.io/posts/node-learning/"><meta property="og:image" content="https://zhenfeng-zhu.github.io/papermod-cover.png"><meta property="article:published_time" content="2018-04-22T15:41:21+00:00"><meta property="article:modified_time" content="2018-04-22T15:41:21+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zhenfeng-zhu.github.io/papermod-cover.png"><meta name=twitter:title content="node学习笔记"><meta name=twitter:description content="写node也有一段时间了，整理一下学习笔记，共同进步
什么是node？ 首先看一下什么是node.js
 Node 是一个服务器端 JavaScript Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效 Node.js 的包管理器 npm，是全球最大的开源库生态系统  模块系统是node最基本也是最常用的。一般可以分为四类：
 原生模块 文件模块 第三方模块 自定义模块  node社区崇尚DRY文化，即Don&rsquo;t repeate yourself。这种文化使得node的生态异常繁荣，同样也由于某些包的质量低下引来了一些诟病。
谈谈自定义模块 我们在写node程序的时候，一般都是在写自定义模块。
  创建模块
// b.js function FunA(){ return &#34;hello world&#34;; } // 暴露方法FunA module.exports = FunA;   加载模块
// a.js const FunA=require('./b.js'); // 运行FunA const name=FunA(); console.log(name);   在做模块到处的时候有两种方式：
  module.exports
module.exports 就 Node."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://zhenfeng-zhu.github.io/posts/"},{"@type":"ListItem","position":3,"name":"node学习笔记","item":"https://zhenfeng-zhu.github.io/posts/node-learning/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"node学习笔记","name":"node学习笔记","description":"写node也有一段时间了，整理一下学习笔记，共同进步\n什么是node？ 首先看一下什么是node.js\n Node 是一个服务器端 JavaScript Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效 Node.js 的包管理器 npm，是全 …","keywords":[],"articleBody":"写node也有一段时间了，整理一下学习笔记，共同进步\n什么是node？ 首先看一下什么是node.js\n Node 是一个服务器端 JavaScript Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效 Node.js 的包管理器 npm，是全球最大的开源库生态系统  模块系统是node最基本也是最常用的。一般可以分为四类：\n 原生模块 文件模块 第三方模块 自定义模块  node社区崇尚DRY文化，即Don’t repeate yourself。这种文化使得node的生态异常繁荣，同样也由于某些包的质量低下引来了一些诟病。\n谈谈自定义模块 我们在写node程序的时候，一般都是在写自定义模块。\n  创建模块\n// b.js function FunA(){ return \"hello world\"; } // 暴露方法FunA module.exports = FunA;   加载模块\n// a.js const FunA=require('./b.js'); // 运行FunA const name=FunA(); console.log(name);   在做模块到处的时候有两种方式：\n  module.exports\nmodule.exports 就 Node.js 用于对外暴露，或者说对外开放指定访问权限的一个对象。\n一个模块中有且仅有一个 module.exports，如果有多个那后面的则会覆盖前面的。\n  exports\nexports 是 module 对象的一个属性，同时它也是一个对象。在很多时候一个 js 文件有多个需要暴露的方法或是对象，module.exports 又只能暴露一个，那这个时候就要用到 exports:\nfunction FunA(){ return 'Tom'; } function FunB(){ return 'Sam'; } exports.FunA = FunA; exports.FunB = FunB; //FunA = exports,exports 是一个对象 var FunA = require('./b.js'); var name1 = FunA.FunA();// 运行 FunA，name = 'Tom' var name2 = FunA.FunB();// 运行 FunB，name = 'Sam' console.log(name1); console.log(name2); 当然在引入的时候也可以这样写：\n//FunA = exports,exports 是一个对象 var {FunA, FunB} = require('./b.js'); var name1 = FunA();// 运行 FunA，name = 'Tom' var name2 = FunB();// 运行 FunB，name = 'Sam' console.log(name1); console.log(name2);   常用的原生模块 常用的原生模块有如下四个：\n http url queryString fs  http 所有后端的语言要想运行起来，都得有服务器。node通过原生的http模块来搭建服务器：\n 加载 http 模块 调用 http.createServer() 方法创建服务，方法接受一个回调函数，回调函数中有两个参数，第一个是请求体，第二个是响应体。 在回调函数中一定要使用 response.end() 方法，用于结束当前请求，不然当前请求会一直处在等待的状态。 调用 listen 监听一个端口。  //原生模块 var http = require('http'); http.createServer(function(reqeust, response){ response.end('Hello Node'); }).listen(8080); 处理参数\n  get\n当get请求的时候，服务器通过request.method来判断当前的请求方式并通过request.url来获取当前的请求参数：\nvar http = require('http'); var url = require('url'); http.createServer(function(req, res){ var params = url.parse(req.url, true).query; res.end(params); }).listen(3000);   post\npost请求则不能通过url来获取，这时候就得对请求体进行事件监听。\nvar http = require('http'); var util = require('util'); var querystring = require('querystring'); http.createServer(function(req, res){ // 定义了一个post变量，用于暂存请求体的信息 var post = ''; // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中 req.on('data', function(chunk){ post += chunk; }); // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。 req.on('end', function(){ post = querystring.parse(post); res.end(util.inspect(post)); }); }).listen(3000);   url url和http是配合使用的。一般情况下url都是字符串类型的，包含的信息也比较多，比如有：协议、主机名、端口、路径、参数、锚点等。如果是对字符串进行直接解析的话，相当麻烦，node提供的url模块便可轻松解决这一类的问题。\n字符串转对象  格式：url.parse(urlstring, boolean) 参数  urlstring：字符串格式的 url boolean：在 url 中有参数，默认参数为字符串，如果此参数为 true，则会自动将参数转转对象   常用属性  href： 解析前的完整原始 URL，协议名和主机名已转为小写 protocol： 请求协议，小写 host： url 主机名，包括端口信息，小写 hostname: 主机名，小写 port: 主机的端口号 pathname: URL中路径，下面例子的 /one search: 查询对象，即：queryString，包括之前的问号“?” path: pathname 和 search的合集 query: 查询字符串中的参数部分（问号后面部分字符串），或者使用 querystring.parse() 解析后返回的对象 hash: 锚点部分（即：“#”及其后的部分）    对象转字符串  格式：url.format(urlObj) 参数 urlObj 在格式化的时候会做如下处理  href: 会被忽略，不做处理 protocol：无论末尾是否有冒号都会处理，协议包括 http, https, ftp, gopher, file 后缀是 :// (冒号-斜杠-斜杠) hostname：如果 host 属性没被定义，则会使用此属性 port：如果 host 属性没被定义，则会使用此属性 host：优先使用，将会替代 hostname 和port pathname：将会同样处理无论结尾是否有/ (斜杠) search：将会替代 query属性，无论前面是否有 ? (问号)，都会同样的处理 query：(object类型; 详细请看 querystring) 如果没有 search,将会使用此属性. hash：无论前面是否有# (井号, 锚点)，都会同样处理    拼接 当有多个 url 需要拼接处理的时候，可以用到 url.resolve\nvar url = require('url'); url.resolve('http://dk-lan.com/', '/one')// 'http://dk-lan.com/one' querystring url是对url字符串的处理，而querystring就是仅针对参数的处理。\n字符串转对象 var str = 'firstname=dk\u0026url=http%3A%2F%2Fdk-lan.com\u0026lastname=tom\u0026passowrd=123456'; var param = querystring.parse(param); //结果 //{firstname:\"dk\", url:\"http://dk-lan.com\", lastname: 'tom', passowrd: 123456}; 对象转字符串 var querystring = require('querystring'); var obj = {firstname:\"dk\", url:\"http://dk-lan.com\", lastname: 'tom', passowrd: 123456}; //将对象转换成字符串 var param = querystring.stringify(obj); //结果 //firstname=dk\u0026url=http%3A%2F%2Fdk-lan.com\u0026lastname=tom\u0026passowrd=123456 fs 任何服务端语言都不能缺失文件的读写操作。\n读取文本 – 异步读取 var fs = require('fs'); // 异步读取 // 参数1：文件路径， // 参数2：读取文件后的回调 fs.readFile('demoFile.txt', function (err, data) { if (err) { return console.error(err); } console.log(\"异步读取: \" + data.toString()); }); 读取文本 – 同步读取 var fs = require('fs'); var data = fs.readFileSync('demoFile.txt'); console.log(\"同步读取: \" + data.toString()); 写入文本 – 覆盖写入 var fs = require('fs'); //每次写入文本都会覆盖之前的文本内容 fs.writeFile('input.txt', '抵制一切不利于中国和世界和平的动机！', function(err) { if (err) { return console.error(err); } console.log(\"数据写入成功！\"); console.log(\"--------我是分割线-------------\") console.log(\"读取写入的数据！\"); fs.readFile('input.txt', function (err, data) { if (err) { return console.error(err); } console.log(\"异步读取文件数据: \" + data.toString()); }); }); 写入文本 – 追加写入 var fs = require('fs'); fs.appendFile('input.txt', '愿世界和平！', function (err) { if (err) { return console.error(err); } console.log(\"数据写入成功！\"); console.log(\"--------我是分割线-------------\") console.log(\"读取写入的数据！\"); fs.readFile('input.txt', function (err, data) { if (err) { return console.error(err); } console.log(\"异步读取文件数据: \" + data.toString()); }); }); 图片读取 图片读取不同于文本，因为文本读出来可以直接用 console.log() 打印，但图片则需要在浏览器中显示，所以需要先搭建 web 服务，然后把以字节方式读取的图片在浏览器中渲染。\n 图片读取是以字节的方式 图片在浏览器的渲染因为没有 img 标签，所以需要设置响应头为 image  var http = require('http'); var fs = require('fs'); var content = fs.readFileSync('001.jpg', \"binary\"); http.createServer(function(request, response){ response.writeHead(200, {'Content-Type': 'image/jpeg'}); response.write(content, \"binary\"); response.end(); }).listen(8888); console.log('Server running at http://127.0.0.1:8888/'); stream流处理 对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。往往用于打开大型的文本文件，创建一个读取操作的数据流。所谓大型文本文件，指的是文本文件的体积很大，读取操作的缓存装不下，只能分成几次发送，每次发送会触发一个data事件，发送结束会触发end事件。\n主要分为\n 读取流 写入流 管道流 链式流  这几种流都是fs的一部分。\n路由 在BS架构中，路由的概念都是一样的，可以理解为根据客户端请求的url映射到不同的方法实现。一般web框架中都会有相应的路由模块。但是在原生node中去处理的话只能是解析url来进行映射，实现起来不够简洁。\nfetch axios是一种对ajax的封装，fetch是一种浏览器原生实现的请求方式，跟ajax对等。\n在现在发起http请求里，都是通过fetch来发送请求，和ajax类似。\nconst fetch=require('isomorphic-fetch'); const options={ header:{}, body:JSON.strify({}), method: '' } try{ const res=await fetch('url', options); }catch(err){ } Async Node.js 是一个异步机制的服务端语言，在大量异步的场景下需要按顺序执行，那正常做法就是回调嵌套回调，回调嵌套太多的问题被称之回调地狱。\nNode.js 为解决这一问题推出了异步控制流 ———— Async\nAsync/Await\nAsync/Await 就 ES7 的方案，结合 ES6 的 Promise 对象，使用前请确定 Node.js 的版本是 7.6 以上。\nAsync/await的主要益处是可以避免回调地狱（callback hell），且以最接近同步代码的方式编写异步代码。\n基本规则\n async 表示这是一个async函数，await只能用在这个函数里面。 await 表示在这里等待promise返回结果了，再继续执行。 await 后面跟着的应该是一个promise对象  express框架 使用node，都绕不开express。\n简单使用 express的使用比较简单，由于我最早接触的是spring那套web框架，所以在使用到express的时候觉得node的web特别轻量简单。\n加载模块\nconst express=require('express'); const app=express(); 监听端口8080\napp.listen(3000, ()=consloe.log('running')); 路由 express对路由的处理特别简单，配合中间件body parser，很方便的提供rest接口：\napp.get('/', (req, res)={ res.send('hello world'); }) response.send() 可理解为 response.end()，其中一个不同点在于 response.send() 参数可为对象。\nNode.js 默认是不能访问静态资源文件（.html、.js、.css、.jpg 等），如果要访问服务端的静态资源文件则要用到方法 sendFile\n__dirname 为 Node.js 的系统变量，指向文件的绝对路径。\napp.get('/index.html', function (req, res) { res.sendFile( __dirname + \"/\" + \"index.html\" ); }); Express – GET 参数接收之路径方式\n访问地址：http://localhost:8080/getusers/admin/18，可通过 request.params 来获取参数\napp.get('/getUsers/:username/:age', function(request, response){ var params = { username: request.params.username, age: request.params.age } response.send(params); }) Express – POST\n post 参数接收，可依赖第三方模块 body-parser 进行转换会更方便、更简单，该模块用于处理 JSON, Raw, Text 和 URL 编码的数据。 安装 body-parser npm install body-parser 参数接受和 GET 基本一样，不同的在于 GET 是 request.query 而 POST 的是 request.body  var bodyParser = require('body-parser'); // 创建 application/x-www-form-urlencoded 编码解析 var urlencodedParser = bodyParser.urlencoded({ extended: false }) app.post('/getUsers', urlencodedParser, function (request, response) { var params = { username: request.body.username, age: request.body.age } response.send(params); }); Express – 跨域支持(放在最前面)\napp.all('*', function(req, res, next) { res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"Content-Type,Content-Length, Authorization, Accept,X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\",' 3.2.1') if(req.method==\"OPTIONS\") { res.send(200);/*让options请求快速返回*/ } else{ next(); } }); 中间件 express的中间件编写——过滤器\n简单使用\nconst express = require('express') const app = express(); let filter = (req, res, next) = { if(req.params.name == 'admin' \u0026\u0026 req.params.pwd == 'admin'){ next() } else { next('用户名密码不正确') } } app.get('/:name/:pwd', filter, (req, res) = { res.send('ok') }).listen(88) 这里写了一个filter方法，有一个next参数。在路由的时候，把filter作为一个参数，则就可以先执行filter函数，然后执行路由的逻辑。\n如果想要全局使用的话，就直接使用use方法即可。\napp.use(filter); 文件上传 前面说到的body-parser不支持文件上传，那么使用multer则可以实现。\n操作数据库 node一般会使用mongo和mysql，使用下面这个例子即可：\n操作 MongoDB 官方 api http://mongodb.github.io/node-mongodb-native/\nvar mongodb = require('mongodb'); var MongoClient = mongodb.MongoClient; var db; MongoClient.connect(\"mongodb://localhost:27017/test1705candel\", function(err, database) { if(err) throw err; db = database; }); module.exports = { insert: function(_collection, _data, _callback){ var i = db.collection(_collection).insert(_data).then(function(result){ _callback(result); }); }, select: function(_collection, _condition, _callback){ var i = db.collection(_collection).find(_condition || {}).toArray(function(error, dataset){ _callback({status: true, data: dataset}); }) } } 操作 MySql var mysql = require('mysql'); //创建连接池 var pool = mysql.createPool({ host : 'localhost', user : 'root', password : 'root', port: 3306, database: '1000phone', multipleStatements: true }); module.exports = { select: function(tsql, callback){ pool.query(tsql, function(error, rows){ if(rows.length  1){ callback({rowsCount: rows[1][0]['rowsCount'], data: rows[0]}); } else { callback(rows); } }) } } session Session 是一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而 Session 保存在服务器上的进程中。\n客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 Session。客户端浏览器再次访问时只需要从该 Session 中查找该客户的状态就可以了。\n如果说 Cookie 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 Session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。\nSession 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。\nSession 不能跨域。\nnode操作session和cookie也很简单，也是通过中间件的形式。\nconst express = require('express') const path = require('path') const app = express(); const bodyParser = require('body-parser'); const cp = require('cookie-parser'); const session = require('express-session'); app.use(cp()); app.use(session({ secret: '12345',//用来对session数据进行加密的字符串.这个属性值为必须指定的属性 name: 'testapp', //这里的name值得是cookie的name，默认cookie的name是：connect.sid cookie: {maxAge: 5000 }, //设置maxAge是5000ms，即5s后session和相应的cookie失效过期 resave: false, saveUninitialized: true, })) app.use(bodyParser.urlencoded({extended: false})); app.use(express.static(path.join(__dirname, '/'))); app.get('/setsession', (request, response) = { request.session.user = {username: 'admin'}; response.send('set session success'); }) app.get('/getsession', (request, response) = { response.send(request.session.user); }) app.get('/delsession', (request, response) = { delete reqeust.session.user; response.send(request.session.user); }) app.listen(88) Token Token的特点\n 随机性 不可预测性 时效性 无状态、可扩展 跨域  基于Token的身份验证场景\n 客户端使用用户名和密码请求登录 服务端收到请求，验证登录是否成功 验证成功后，服务端会返回一个 Token 给客户端，反之，返回身份验证失败的信息 客户端收到 Token 后把 Token 用一种方式(cookie/localstorage/sessionstorage/其他)存储起来 客户端每次发起请求时都选哦将 Token 发给服务端 服务端收到请求后，验证Token的合法性，合法就返回客户端所需数据，反之，返回验证失败的信息  Token 身份验证实现 —— jsonwebtoken\n先安装第三方模块 jsonwebtoken npm install jsonwebtoken\nconst express = require('express') const path = require('path') const app = express(); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); app.use(bodyParser.urlencoded({extended: false})); app.use(express.static(path.join(__dirname, '/'))); app.all('*', function(req, res, next) { res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"Content-Type,Content-Length, Auth, Accept,X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\",' 3.2.1') if(req.method==\"OPTIONS\") { res.sendStatus(200);/*让options请求快速返回*/ } else{ next(); } }); app.get('/createtoken', (request, response) = { //要生成 token 的主题信息 let user = { username: 'admin', } //这是加密的 key（密钥） let secret = 'dktoken'; //生成 Token let token = jwt.sign(user, secret, { 'expiresIn': 60*60*24 // 设置过期时间, 24 小时 }) response.send({status: true, token}); }) app.post('/verifytoken', (request, response) = { //这是加密的 key（密钥），和生成 token 时的必须一样 let secret = 'dktoken'; let token = request.headers['auth']; if(!token){ response.send({status: false, message: 'token不能为空'}); } jwt.verify(token, secret, (error, result) = { if(error){ response.send({status: false}); } else { response.send({status: true, data: result}); } }) }) app.listen(88) web socket HTTP 协议可以总结几个特点：\n 一次性的、无状态的短连接：客户端发起请求、服务端响应、结束。 被动性响应：只有当客户端请求时才被执行，给予响应，不能主动向客户端发起响应。 信息安全性：得在服务器添加 SSL 证书，访问时用 HTTPS。 跨域：服务器默认不支持跨域，可在服务端设置支持跨域的代码或对应的配置。  TCP 协议可以总结几个特点：\n 有状态的长连接：客户端发起连接请求，服务端响应并建立连接，连接会一直保持直到一方主动断开。 主动性：建立起与客户端的连接后，服务端可主动向客户端发起调用。 信息安全性：同样可以使用 SSL 证书进行信息加密，访问时用 WSS 。 跨域：默认支持跨域。  安装第三方模块 ws：npm install ws\n开启一个 WebSocket 的服务器，端口为 8080\nvar socketServer = require('ws').Server; var wss = new socketServer({ port: 8080 }); 也可以利用 Express 来开启 WebSocket 的服务器\nvar app = require('express')(); var server = require('http').Server(app); var socketServer = require('ws').Server; var wss = new socketServer({server: server, port: 8080});  用 on 来进行事件监听 connection：连接监听，当客户端连接到服务端时触发该事件 close：连接断开监听，当客户端断开与服务器的连接时触发 message：消息接受监听，当客户端向服务端发送信息时触发该事件 send: 向客户端推送信息  soket.io 可以理解为对 WebSocket 的一种封装。好比前端的 jQuery 对原生 javascript 的封装。 soket.io 依靠事件驱动的模式，灵活的使用了自定义事件和调用事件来完成更多的场景，不必依赖过多的原生事件。\n 安装第三方模块 npm install express socket.io 开户 Socket 服务器，端口为 88  var express = require('express'); var app = express(); var http = require('http').Server(app); var io = require('socket.io')(http); http.listen(88);  用 on 来进行事件监听和定义事件 connection：监听客户端连接,回调函数会传递本次连接的socket emit：触发用客户端的事件  io.on('connection', function(client){ //把当前登录的用户保存到对象 onlinePersons，并向所有在线的用户发起上线提示 //serverLogin 为自定义事件，供客户端调用 client.on('serverLogin', function(_person){ var _personObj = JSON.parse(_person); onlinePersons[_personObj.id] = _personObj; //向所有在线的用户发起上线提示 //触发客户端的 clientTips 事件 //clientTips 为客户端的自定义事件 io.emit('clientTips', JSON.stringify(onlinePersons)); }) //当监听到客户端有用户在移动，就向所有在线用户发起移动信息，触发客户端 clientMove 事件 //serverMove 为自定义事件，供客户端调用 client.on('serverMove', function(_person){ var _personObj = JSON.parse(_person); onlinePersons[_personObj.id] = _personObj; console.log('serverLogin', onlinePersons); //clientTips 为客户端的自定义事件 io.emit('clientMove', _person); }); }) kafka-node node也可以去读写kafka，而且很简单。只需要引入kafka的库即可。\nyarn add kafka-node 具体api可以看文档：https://github.com/SOHU-Co/kafka-node\n生产者\nvar kafka = require('..'); var Producer = kafka.Producer; var KeyedMessage = kafka.KeyedMessage; var Client = kafka.Client; var client = new Client('localhost:2181'); var argv = require('optimist').argv; var topic = argv.topic || 'topic1'; var p = argv.p || 0; var a = argv.a || 0; var producer = new Producer(client, { requireAcks: 1 }); producer.on('ready', function () { var message = 'a message'; var keyedMessage = new KeyedMessage('keyed', 'a keyed message'); producer.send([ { topic: topic, partition: p, messages: [message, keyedMessage], attributes: a } ], function (err, result) { console.log(err || result); process.exit(); }); }); producer.on('error', function (err) { console.log('error', err); }); 消费者\n'use strict'; var kafka = require('..'); var Consumer = kafka.Consumer; var Offset = kafka.Offset; var Client = kafka.Client; var argv = require('optimist').argv; var topic = argv.topic || 'topic1'; var client = new Client('localhost:2181'); var topics = [{ topic: topic, partition: 1 }, { topic: topic, partition: 0 }]; var options = { autoCommit: false, fetchMaxWaitMs: 1000, fetchMaxBytes: 1024 * 1024 }; var consumer = new Consumer(client, topics, options); var offset = new Offset(client); consumer.on('message', function (message) { console.log(message); }); consumer.on('error', function (err) { console.log('error', err); }); /* * If consumer get `offsetOutOfRange` event, fetch data from the smallest(oldest) offset */ consumer.on('offsetOutOfRange', function (topic) { topic.maxNum = 2; offset.fetch([topic], function (err, offsets) { if (err) { return console.error(err); } var min = Math.min.apply(null, offsets[topic.topic][topic.partition]); consumer.setOffset(topic.topic, topic.partition, min); }); }); Node单元测试 以function为最小单位，验证特定情况下的input和output是否正确。\n 防止改A坏B，避免不能跑的代码比能跑的还多。 明确指出问题所在、告知正确的行为是什么，减少debug的时间。  对于node来说，单元测试也很容易做。\n测试主要分为两种，TDD和BDD。\nTDD VS. BDD 比较TDD 与BDD 的差异。\n    TDD BDD     全名 测试驱动开发Test-Driven Development 行为驱动开发Behavior Driven Development   定义 在开发前先撰写测试程式，以确保程式码品质与符合验收规格。 TDD的进化版。除了实作前先写测试外，还要写一份「可以执行的规格」。   特性 从测试去思考程式如何实作。强调小步前进、快速且持续回馈、拥抱变化、重视沟通、满足需求。 从用户的需求出发，强调系统行为。使用自然语言描述测试案例，以减少使用者和工程师的沟通成本。测试后的输出结果可以直接做为文件阅读。    从代码层面来看：\nTDD\nsuite('Array', ()={ setup(()={ }); test('equal -1 when index beyond array length', ()={ assert.equal(-1, [1,2,3].indexOf(4)); }); }) BDD\ndescribe('Array', function() { before(function() { }); it('should return -1 when no such index', function() { [1,2,3].indexOf(4).should.equal(-1); }); }); 对比了这两种类型的语法之后，我选择了BDD。\n测试框架实践 在node社区，比较成熟的是mocha。mocha本身是不提供断言库的，一般来说断言库比较常用的是chai。mocha和chai，合起来就被戏称为抹茶。\nmocha一般需要全局安装，chai安装到项目目录下即可。\nyarn global add mocha yarn add chai mocha 语法说明  describe()：描述场景或圈出特定区块，例如：标明测试的功能或function。 it()：撰写测试案例（Test Case）。 before()：在所有测试开始前会执行的代码。 after()：在所有测试结束后会执行的代码。 beforeEach()：在每个Test Case 开始前执行的代码。 afterEach()：在每个Test Case 结束后执行的代码。  代码示例 describe('hooks', function() { before(function() { }); after(function() { }); beforeEach(function() { }); afterEach(function() { }); it('should ...', function() { }); }); chai assert assert(expression, message)：测试这个项目的expression是否为真，若为假则显示错误消息message。\nExpect / Should 预期3 等于（===）2。这是使用可串连的操作符 来完成断言。这些可串联的有to、is、have 等。它很像英文，用很口语的方式做判断。\n覆盖率 既然是给功能代码写单元测试，那就应该有个指标去衡量单元测试覆盖了哪些功能代码，这就是接下来要介绍的测试覆盖率。\n在 Node.js 中，我们使用 istanbul 作为覆盖率统计的工具，istanbul 可以帮助我们统计到代码的语句覆盖率、分支覆盖率、函数覆盖率以及行覆盖率。\n全局安装：\nyarn global add istanbul 只需要使用istanbul cover就可以得到覆盖率。\nistanbul cover simple.js 可以和mocha配合使用：\nisbuntal cover _mocha test/simple-test.js mocha 和 _mocha 是两个不同的命令，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。\n引入typescript typescript其实就是加了类型的js。\n所谓类型，就是约定变量的内存布局。js作为一个动态弱类型的语言，在开发大型项目的时候，不免可能出现问题，所以有类型的语言可以在编译期就能检测到错误，减少debug的时间。\n安装 yarn global add typescript 新项目引入ts 现在新建文件server.ts：\nimport * as http from 'http'; const server = http.createServer(function (req, res) { res.end('Hello, world'); }); server.listen(3000, function () { console.log('server is listening'); }); 为了能执行此文件，需要通过 tsc 命令来编译该 TypeScript 源码：\ntsc server.ts 如果没有什么意外的话，此时控制台会打印出以下的出错信息：\nserver.ts(1,23): error TS2307: Cannot find module 'http'. 这表示没有找到http这个模块定义（TyprScript 编译时是通过查找模块的 typings 声明文件来判断模块是否存在的，而不是根据真实的 js 文件，下文会详细解释），但是我们当前目录下还是生成了一个新的文件server.js，我们可以试着执行它：\nnode server.js 如果一切顺利，那么控制台将会打印出 server is listening 这样的信息，并且我们在浏览器中访问 http://127.0.0.1:3000时也能看到正确的结果：Hello, world\n现在再回过头来看看刚才的编译错误信息。由于这是一个 Node.js 项目，typescript 语言中并没有定义http这个模块，所以我们需要安装 Node.js 运行环境的声明文件：\nyarn global add @types/node 安装完毕之后，再重复上文的编译过程，此时 tsc 不再报错了。\n大多数时候，为了方便我们可以直接使用 ts-node 命令执行 TypeScript 源文件而不需要预先编译。首先执行以下命令安装 ts-node：\nyarn global add -g ts-node 然后使用 ts-node 命令执行即可：\nts-node --no-cache server.ts 说明：使用 ts-node 执行 TypeScript 程序时，为了提高编译速度，默认会缓存未修改过的 .ts 文件，但有时候会导致一些 Bug，所以建议启动时加上 --no-cache 参数。\ntsconfig.json 配置文件 每个 TypeScript 项目都需要一个 tsconfig.json 文件来指定相关的配置，比如告诉 TypeScript 编译器要将代码转换成 ES5 还是 ES6 代码等。\n可以使用tsc命令生成。\ntsc --init 使用第三方模块 一般情况下在 TypeScript 中是不能”直接“使用 npm 上的模块的，比如我们要使用 express 模块，先执行以下命令安装：\nyarn add express 然后新建文件 server.ts :\nimport * as express from 'express'; const app = express(); app.get('/', function (req, res) { res.end('hello, world'); }) app.listen(3000, function () { console.log('server is listening'); }); 然后使用以下命令执行：\nts-node server.ts 如果不出意外，我们将会看到这样的报错信息：\nsrc/server.ts(1,26): error TS7016: Could not find a declaration file for module 'express'. 报错的信息表明没有找到express模块的声明文件。由于 TypeScript 项目最终会编译成 JavaScript 代码执行，当我们在 TypeScript 源码中引入这些被编译成 JavaScript 的模块时，它需要相应的声明文件（.d.ts文件）来知道该模块类型信息，这些声明文件可以通过设置tsconfig.json中的declaration: true来自动生成。而那些不是使用 TypeScript 编写的模块，也可以通过手动编写声明文件来兼容 TypeScript。\n当遇到缺少模块声明文件的情况，开发者可以尝试通过 yarn addl @types/xxx 来安装模块声明文件即可。\n现在我们尝试执行以下命令安装 express 模块的声明文件：\nyarn add @types/express 没有意外，果然能成功安装。现在再通过 ts-node 来执行的时候，发现已经没有报错了。\n单元测试 直接使用mocha和chai，进行ts的测试。\n旧项目迁移 通常来说这个过程包括了以下步骤：\n 添加 tsconfig.json 将你的源代码文件扩展名从 .js 改成 .ts。使用 any 来开始抑止错误。 使用 TypeScript 来编写新的代码并且尽可能少地使用 any。 返回到旧代码里并且开始加入类型标注和解决发现的 bugs。 为第三方 JavaScript 代码使用环境定义。  ","wordCount":"1918","inLanguage":"en","datePublished":"2018-04-22T15:41:21Z","dateModified":"2018-04-22T15:41:21Z","author":{"@type":"Person","name":"Lucas"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhenfeng-zhu.github.io/posts/node-learning/"},"publisher":{"@type":"Organization","name":"Go Data","logo":{"@type":"ImageObject","url":"https://zhenfeng-zhu.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://zhenfeng-zhu.github.io accesskey=h title="Go Data (Alt + H)">Go Data</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://zhenfeng-zhu.github.io/about title=About><span>About</span></a></li><li><a href=https://zhenfeng-zhu.github.io/search/ title=🔍><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zhenfeng-zhu.github.io>Home</a>&nbsp;»&nbsp;<a href=https://zhenfeng-zhu.github.io/posts/>Posts</a></div><h1 class=post-title>node学习笔记</h1><div class=post-meta>April 22, 2018&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Lucas</div></header><div class=post-content><p>写node也有一段时间了，整理一下学习笔记，共同进步</p><h1 id=什么是node>什么是node？<a hidden class=anchor aria-hidden=true href=#什么是node>#</a></h1><p>首先看一下什么是node.js</p><ul><li>Node 是一个服务器端 JavaScript</li><li>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境</li><li>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效</li><li>Node.js 的包管理器 npm，是全球最大的开源库生态系统</li></ul><p>模块系统是node最基本也是最常用的。一般可以分为四类：</p><ul><li>原生模块</li><li>文件模块</li><li>第三方模块</li><li>自定义模块</li></ul><p>node社区崇尚DRY文化，即Don&rsquo;t repeate yourself。这种文化使得node的生态异常繁荣，同样也由于某些包的质量低下引来了一些诟病。</p><h1 id=谈谈自定义模块>谈谈自定义模块<a hidden class=anchor aria-hidden=true href=#谈谈自定义模块>#</a></h1><p>我们在写node程序的时候，一般都是在写自定义模块。</p><ul><li><p>创建模块</p><pre><code>// b.js
function FunA(){
    return &quot;hello world&quot;;
}

// 暴露方法FunA
module.exports = FunA;
</code></pre></li><li><p>加载模块</p><pre><code>// a.js
const FunA=require('./b.js');

// 运行FunA
const name=FunA();
console.log(name);
</code></pre></li></ul><p>在做模块到处的时候有两种方式：</p><ul><li><p>module.exports</p><p>module.exports 就 Node.js 用于对外暴露，或者说对外开放指定访问权限的一个对象。</p><p>一个模块中有且仅有一个 module.exports，如果有多个那后面的则会覆盖前面的。</p></li><li><p>exports</p><p>exports 是 module 对象的一个属性，同时它也是一个对象。在很多时候一个 js 文件有多个需要暴露的方法或是对象，module.exports 又只能暴露一个，那这个时候就要用到 exports:</p><pre><code>function FunA(){
    return 'Tom';
}

function FunB(){
    return 'Sam';
}

exports.FunA = FunA;
exports.FunB = FunB;
</code></pre><pre><code>//FunA = exports,exports 是一个对象
var FunA = require('./b.js');
var name1 = FunA.FunA();// 运行 FunA，name = 'Tom'
var name2 = FunA.FunB();// 运行 FunB，name = 'Sam'
console.log(name1);
console.log(name2);
</code></pre><p>当然在引入的时候也可以这样写：</p><pre><code>//FunA = exports,exports 是一个对象
var {FunA, FunB} = require('./b.js');
var name1 = FunA();// 运行 FunA，name = 'Tom'
var name2 = FunB();// 运行 FunB，name = 'Sam'
console.log(name1);
console.log(name2);
</code></pre></li></ul><h1 id=常用的原生模块>常用的原生模块<a hidden class=anchor aria-hidden=true href=#常用的原生模块>#</a></h1><p>常用的原生模块有如下四个：</p><ul><li>http</li><li>url</li><li>queryString</li><li>fs</li></ul><h2 id=http>http<a hidden class=anchor aria-hidden=true href=#http>#</a></h2><p>所有后端的语言要想运行起来，都得有服务器。node通过原生的http模块来搭建服务器：</p><ol><li>加载 http 模块</li><li>调用 http.createServer() 方法创建服务，方法接受一个回调函数，回调函数中有两个参数，第一个是请求体，第二个是响应体。</li><li>在回调函数中一定要使用 response.end() 方法，用于结束当前请求，不然当前请求会一直处在等待的状态。</li><li>调用 listen 监听一个端口。</li></ol><pre><code>//原生模块
var http = require('http');

http.createServer(function(reqeust, response){
    response.end('Hello Node');
}).listen(8080);
</code></pre><p>处理参数</p><ul><li><p>get</p><p>当get请求的时候，服务器通过request.method来判断当前的请求方式并通过request.url来获取当前的请求参数：</p><pre><code>var http = require('http');
var url = require('url');
   
http.createServer(function(req, res){
    var params = url.parse(req.url, true).query;
    res.end(params);
   
}).listen(3000);
</code></pre></li><li><p>post</p><p>post请求则不能通过url来获取，这时候就得对请求体进行事件监听。</p><pre><code>var http = require('http');
var util = require('util');
var querystring = require('querystring');
   
http.createServer(function(req, res){
    // 定义了一个post变量，用于暂存请求体的信息
    var post = '';     
   
    // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中
    req.on('data', function(chunk){    
        post += chunk;
    });
   
    // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。
    req.on('end', function(){    
        post = querystring.parse(post);
        res.end(util.inspect(post));
    });
}).listen(3000);
</code></pre></li></ul><h2 id=url>url<a hidden class=anchor aria-hidden=true href=#url>#</a></h2><p>url和http是配合使用的。一般情况下url都是字符串类型的，包含的信息也比较多，比如有：协议、主机名、端口、路径、参数、锚点等。如果是对字符串进行直接解析的话，相当麻烦，node提供的url模块便可轻松解决这一类的问题。</p><h3 id=字符串转对象>字符串转对象<a hidden class=anchor aria-hidden=true href=#字符串转对象>#</a></h3><ul><li>格式：url.parse(urlstring, boolean)</li><li>参数<ul><li>urlstring：字符串格式的 url</li><li>boolean：在 url 中有参数，默认参数为字符串，如果此参数为 true，则会自动将参数转转对象</li></ul></li><li>常用属性<ul><li>href： 解析前的完整原始 URL，协议名和主机名已转为小写</li><li>protocol： 请求协议，小写</li><li>host： url 主机名，包括端口信息，小写</li><li>hostname: 主机名，小写</li><li>port: 主机的端口号</li><li>pathname: URL中路径，下面例子的 /one</li><li>search: 查询对象，即：queryString，包括之前的问号“?”</li><li>path: pathname 和 search的合集</li><li>query: 查询字符串中的参数部分（问号后面部分字符串），或者使用 querystring.parse() 解析后返回的对象</li><li>hash: 锚点部分（即：“#”及其后的部分）</li></ul></li></ul><h3 id=对象转字符串>对象转字符串<a hidden class=anchor aria-hidden=true href=#对象转字符串>#</a></h3><ul><li>格式：url.format(urlObj)</li><li>参数 urlObj 在格式化的时候会做如下处理<ul><li>href: 会被忽略，不做处理</li><li>protocol：无论末尾是否有冒号都会处理，协议包括 http, https, ftp, gopher, file 后缀是 :// (冒号-斜杠-斜杠)</li><li>hostname：如果 host 属性没被定义，则会使用此属性</li><li>port：如果 host 属性没被定义，则会使用此属性</li><li>host：优先使用，将会替代 hostname 和port</li><li>pathname：将会同样处理无论结尾是否有/ (斜杠)</li><li>search：将会替代 query属性，无论前面是否有 ? (问号)，都会同样的处理</li><li>query：(object类型; 详细请看 querystring) 如果没有 search,将会使用此属性.</li><li>hash：无论前面是否有# (井号, 锚点)，都会同样处理</li></ul></li></ul><h3 id=拼接>拼接<a hidden class=anchor aria-hidden=true href=#拼接>#</a></h3><p>当有多个 url 需要拼接处理的时候，可以用到 url.resolve</p><pre><code>var url = require('url');
url.resolve('http://dk-lan.com/', '/one')// 'http://dk-lan.com/one'
</code></pre><h2 id=querystring>querystring<a hidden class=anchor aria-hidden=true href=#querystring>#</a></h2><p>url是对url字符串的处理，而querystring就是仅针对参数的处理。</p><h3 id=字符串转对象-1>字符串转对象<a hidden class=anchor aria-hidden=true href=#字符串转对象-1>#</a></h3><pre><code>var str = 'firstname=dk&amp;url=http%3A%2F%2Fdk-lan.com&amp;lastname=tom&amp;passowrd=123456';
var param = querystring.parse(param);
//结果
//{firstname:&quot;dk&quot;, url:&quot;http://dk-lan.com&quot;, lastname: 'tom', passowrd: 123456};
</code></pre><h3 id=对象转字符串-1>对象转字符串<a hidden class=anchor aria-hidden=true href=#对象转字符串-1>#</a></h3><pre><code>var querystring = require('querystring');

var obj = {firstname:&quot;dk&quot;, url:&quot;http://dk-lan.com&quot;, lastname: 'tom', passowrd: 123456};
//将对象转换成字符串
var param = querystring.stringify(obj);
//结果
//firstname=dk&amp;url=http%3A%2F%2Fdk-lan.com&amp;lastname=tom&amp;passowrd=123456
</code></pre><h2 id=fs>fs<a hidden class=anchor aria-hidden=true href=#fs>#</a></h2><p>任何服务端语言都不能缺失文件的读写操作。</p><h3 id=读取文本----异步读取>读取文本 &ndash; 异步读取<a hidden class=anchor aria-hidden=true href=#读取文本----异步读取>#</a></h3><pre><code>var fs = require('fs');
// 异步读取
// 参数1：文件路径，
// 参数2：读取文件后的回调
fs.readFile('demoFile.txt', function (err, data) {
   if (err) {
       return console.error(err);
   }
   console.log(&quot;异步读取: &quot; + data.toString());
});
</code></pre><h3 id=读取文本----同步读取>读取文本 &ndash; 同步读取<a hidden class=anchor aria-hidden=true href=#读取文本----同步读取>#</a></h3><pre><code>var fs = require('fs');
var data = fs.readFileSync('demoFile.txt');
console.log(&quot;同步读取: &quot; + data.toString());
</code></pre><h3 id=写入文本----覆盖写入>写入文本 &ndash; 覆盖写入<a hidden class=anchor aria-hidden=true href=#写入文本----覆盖写入>#</a></h3><pre><code>var fs = require('fs');
//每次写入文本都会覆盖之前的文本内容
fs.writeFile('input.txt', '抵制一切不利于中国和世界和平的动机！',  function(err) {
   if (err) {
       return console.error(err);
   }
   console.log(&quot;数据写入成功！&quot;);
   console.log(&quot;--------我是分割线-------------&quot;)
   console.log(&quot;读取写入的数据！&quot;);
   fs.readFile('input.txt', function (err, data) {
      if (err) {
         return console.error(err);
      }
      console.log(&quot;异步读取文件数据: &quot; + data.toString());
   });
});
</code></pre><h3 id=写入文本----追加写入>写入文本 &ndash; 追加写入<a hidden class=anchor aria-hidden=true href=#写入文本----追加写入>#</a></h3><pre><code>var fs = require('fs');
fs.appendFile('input.txt', '愿世界和平！', function (err) {
   if (err) {
       return console.error(err);
   }
   console.log(&quot;数据写入成功！&quot;);
   console.log(&quot;--------我是分割线-------------&quot;)
   console.log(&quot;读取写入的数据！&quot;);
   fs.readFile('input.txt', function (err, data) {
      if (err) {
         return console.error(err);
      }
      console.log(&quot;异步读取文件数据: &quot; + data.toString());
   });
});
</code></pre><h3 id=图片读取>图片读取<a hidden class=anchor aria-hidden=true href=#图片读取>#</a></h3><p>图片读取不同于文本，因为文本读出来可以直接用 console.log() 打印，但图片则需要在浏览器中显示，所以需要先搭建 web 服务，然后把以字节方式读取的图片在浏览器中渲染。</p><ol><li>图片读取是以字节的方式</li><li>图片在浏览器的渲染因为没有 img 标签，所以需要设置响应头为 image</li></ol><pre><code>var http = require('http');
var fs = require('fs');
var content =  fs.readFileSync('001.jpg', &quot;binary&quot;);

http.createServer(function(request, response){
    response.writeHead(200, {'Content-Type': 'image/jpeg'});
    response.write(content, &quot;binary&quot;);
    response.end();
}).listen(8888);

console.log('Server running at http://127.0.0.1:8888/');
</code></pre><h2 id=stream流处理>stream流处理<a hidden class=anchor aria-hidden=true href=#stream流处理>#</a></h2><p>对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。往往用于打开大型的文本文件，创建一个读取操作的数据流。所谓大型文本文件，指的是文本文件的体积很大，读取操作的缓存装不下，只能分成几次发送，每次发送会触发一个data事件，发送结束会触发end事件。</p><p>主要分为</p><ul><li>读取流</li><li>写入流</li><li>管道流</li><li>链式流</li></ul><p>这几种流都是fs的一部分。</p><h2 id=路由>路由<a hidden class=anchor aria-hidden=true href=#路由>#</a></h2><p>在BS架构中，路由的概念都是一样的，可以理解为根据客户端请求的url映射到不同的方法实现。一般web框架中都会有相应的路由模块。但是在原生node中去处理的话只能是解析url来进行映射，实现起来不够简洁。</p><h1 id=fetch>fetch<a hidden class=anchor aria-hidden=true href=#fetch>#</a></h1><p>axios是一种对ajax的封装，fetch是一种浏览器原生实现的请求方式，跟ajax对等。</p><p>在现在发起http请求里，都是通过fetch来发送请求，和ajax类似。</p><pre><code>const fetch=require('isomorphic-fetch');

const options={
    header:{},
    body:JSON.strify({}),
    method: ''
}

try{
    const res=await fetch('url', options);
}catch(err){
    
}
</code></pre><h1 id=async>Async<a hidden class=anchor aria-hidden=true href=#async>#</a></h1><p>Node.js 是一个异步机制的服务端语言，在大量异步的场景下需要按顺序执行，那正常做法就是回调嵌套回调，回调嵌套太多的问题被称之回调地狱。</p><p>Node.js 为解决这一问题推出了异步控制流 ———— Async</p><p>Async/Await</p><p>Async/Await 就 ES7 的方案，结合 ES6 的 Promise 对象，使用前请确定 Node.js 的版本是 7.6 以上。</p><p>Async/await的主要益处是可以避免回调地狱（callback hell），且以最接近同步代码的方式编写异步代码。</p><p>基本规则</p><ul><li>async 表示这是一个async函数，await只能用在这个函数里面。</li><li>await 表示在这里等待promise返回结果了，再继续执行。</li><li>await 后面跟着的应该是一个promise对象</li></ul><h1 id=express框架>express框架<a hidden class=anchor aria-hidden=true href=#express框架>#</a></h1><p>使用node，都绕不开express。</p><h2 id=简单使用>简单使用<a hidden class=anchor aria-hidden=true href=#简单使用>#</a></h2><p>express的使用比较简单，由于我最早接触的是spring那套web框架，所以在使用到express的时候觉得node的web特别轻量简单。</p><p>加载模块</p><pre><code>const express=require('express');
const app=express();
</code></pre><p>监听端口8080</p><pre><code>app.listen(3000, ()=&gt;consloe.log('running'));
</code></pre><h2 id=路由-1>路由<a hidden class=anchor aria-hidden=true href=#路由-1>#</a></h2><p>express对路由的处理特别简单，配合中间件body parser，很方便的提供rest接口：</p><pre><code>app.get('/', (req, res)=&gt;{
    res.send('hello world');
})
</code></pre><p><code>response.send()</code> 可理解为 <code>response.end()</code>，其中一个不同点在于 <code>response.send()</code> 参数可为对象。</p><p>Node.js 默认是不能访问静态资源文件（<em>.html、</em>.js、<em>.css、</em>.jpg 等），如果要访问服务端的静态资源文件则要用到方法 <code>sendFile</code></p><p>__dirname 为 Node.js 的系统变量，指向文件的绝对路径。</p><pre><code>app.get('/index.html', function (req, res) {
   res.sendFile( __dirname + &quot;/&quot; + &quot;index.html&quot; );
});
</code></pre><p>Express &ndash; GET 参数接收之路径方式</p><p>访问地址：<code>http://localhost:8080/getusers/admin/18</code>，可通过 <code>request.params</code> 来获取参数</p><pre><code>app.get('/getUsers/:username/:age', function(request, response){
    var params = {
        username: request.params.username,
        age: request.params.age
    }
    response.send(params);
})
</code></pre><p>Express &ndash; POST</p><ul><li>post 参数接收，可依赖第三方模块 body-parser 进行转换会更方便、更简单，该模块用于处理 JSON, Raw, Text 和 URL 编码的数据。</li><li>安装 body-parser <code>npm install body-parser</code></li><li>参数接受和 GET 基本一样，不同的在于 GET 是 <code>request.query</code> 而 POST 的是 <code>request.body</code></li></ul><pre><code>var bodyParser = require('body-parser');
// 创建 application/x-www-form-urlencoded 编码解析
var urlencodedParser = bodyParser.urlencoded({ extended: false })
app.post('/getUsers', urlencodedParser, function (request, response) {
    var params = {
        username: request.body.username,
        age: request.body.age
    }
   response.send(params);
});
</code></pre><p>Express &ndash; 跨域支持(放在最前面)</p><pre><code>app.all('*', function(req, res, next) {
    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);
    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,Content-Length, Authorization, Accept,X-Requested-With&quot;);
    res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);
    res.header(&quot;X-Powered-By&quot;,' 3.2.1')
    if(req.method==&quot;OPTIONS&quot;) {
      res.send(200);/*让options请求快速返回*/
    } else{
      next();
    }
});
</code></pre><h2 id=中间件>中间件<a hidden class=anchor aria-hidden=true href=#中间件>#</a></h2><p>express的中间件编写——过滤器</p><p>简单使用</p><pre><code>const express = require('express')
const app = express();

let filter = (req, res, next) =&gt; {
    if(req.params.name == 'admin' &amp;&amp; req.params.pwd == 'admin'){
        next()
    } else {
        next('用户名密码不正确')
    }
    
}

app.get('/:name/:pwd', filter, (req, res) =&gt; {
    res.send('ok')
}).listen(88)
</code></pre><p>这里写了一个filter方法，有一个next参数。在路由的时候，把filter作为一个参数，则就可以先执行filter函数，然后执行路由的逻辑。</p><p>如果想要全局使用的话，就直接使用use方法即可。</p><pre><code>app.use(filter);
</code></pre><h2 id=文件上传>文件上传<a hidden class=anchor aria-hidden=true href=#文件上传>#</a></h2><p>前面说到的body-parser不支持文件上传，那么使用multer则可以实现。</p><h1 id=操作数据库>操作数据库<a hidden class=anchor aria-hidden=true href=#操作数据库>#</a></h1><p>node一般会使用mongo和mysql，使用下面这个例子即可：</p><h2 id=操作-mongodb>操作 MongoDB<a hidden class=anchor aria-hidden=true href=#操作-mongodb>#</a></h2><p>官方 api <code>http://mongodb.github.io/node-mongodb-native/</code></p><pre><code>var mongodb = require('mongodb');
var MongoClient = mongodb.MongoClient;
var db;

MongoClient.connect(&quot;mongodb://localhost:27017/test1705candel&quot;, function(err, database) {
  if(err) throw err;

  db = database;
});

module.exports = {
    insert: function(_collection, _data, _callback){
        var i = db.collection(_collection).insert(_data).then(function(result){
            _callback(result);
        });
    },
    select: function(_collection, _condition, _callback){
        var i = db.collection(_collection).find(_condition || {}).toArray(function(error, dataset){
            _callback({status: true, data: dataset});
        })
    }
}
</code></pre><h2 id=操作-mysql>操作 MySql<a hidden class=anchor aria-hidden=true href=#操作-mysql>#</a></h2><pre><code>var mysql = require('mysql');

//创建连接池
var pool  = mysql.createPool({
  host     : 'localhost',
  user     : 'root',
  password : 'root',
  port: 3306,
  database: '1000phone',
  multipleStatements: true
});


module.exports = {
    select: function(tsql, callback){
        pool.query(tsql, function(error, rows){
      if(rows.length &gt; 1){
        callback({rowsCount: rows[1][0]['rowsCount'], data: rows[0]});
      } else {
        callback(rows);
      }
        })
    }
}
</code></pre><h1 id=session>session<a hidden class=anchor aria-hidden=true href=#session>#</a></h1><p>Session 是一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而 Session 保存在服务器上的进程中。</p><p>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 Session。客户端浏览器再次访问时只需要从该 Session 中查找该客户的状态就可以了。</p><p>如果说 Cookie 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 Session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。</p><p>Session 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</p><p>Session 不能跨域。</p><p>node操作session和cookie也很简单，也是通过中间件的形式。</p><pre><code>const express = require('express')
const path = require('path')
const app = express();

const bodyParser = require('body-parser');

const cp = require('cookie-parser');
const session = require('express-session');

app.use(cp());
app.use(session({
    secret: '12345',//用来对session数据进行加密的字符串.这个属性值为必须指定的属性
    name: 'testapp',   //这里的name值得是cookie的name，默认cookie的name是：connect.sid
    cookie: {maxAge: 5000 },  //设置maxAge是5000ms，即5s后session和相应的cookie失效过期
    resave: false,
    saveUninitialized: true,    
}))
app.use(bodyParser.urlencoded({extended: false}));
app.use(express.static(path.join(__dirname, '/')));

app.get('/setsession', (request, response) =&gt; {
    request.session.user = {username: 'admin'};
    response.send('set session success');
})

app.get('/getsession', (request, response) =&gt; {
    response.send(request.session.user);
})

app.get('/delsession', (request, response) =&gt; {
    delete reqeust.session.user;
    response.send(request.session.user);
})

app.listen(88)
</code></pre><h1 id=token>Token<a hidden class=anchor aria-hidden=true href=#token>#</a></h1><p>Token的特点</p><ul><li>随机性</li><li>不可预测性</li><li>时效性</li><li>无状态、可扩展</li><li>跨域</li></ul><p>基于Token的身份验证场景</p><ol><li>客户端使用用户名和密码请求登录</li><li>服务端收到请求，验证登录是否成功</li><li>验证成功后，服务端会返回一个 Token 给客户端，反之，返回身份验证失败的信息</li><li>客户端收到 Token 后把 Token 用一种方式(cookie/localstorage/sessionstorage/其他)存储起来</li><li>客户端每次发起请求时都选哦将 Token 发给服务端</li><li>服务端收到请求后，验证Token的合法性，合法就返回客户端所需数据，反之，返回验证失败的信息</li></ol><p>Token 身份验证实现 —— jsonwebtoken</p><p>先安装第三方模块 jsonwebtoken <code>npm install jsonwebtoken</code></p><pre><code>const express = require('express')
const path = require('path')
const app = express();
const bodyParser = require('body-parser');
const jwt = require('jsonwebtoken');

app.use(bodyParser.urlencoded({extended: false}));
app.use(express.static(path.join(__dirname, '/')));

app.all('*', function(req, res, next) {
    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);
    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,Content-Length, Auth, Accept,X-Requested-With&quot;);
    res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);
    res.header(&quot;X-Powered-By&quot;,' 3.2.1')
    if(req.method==&quot;OPTIONS&quot;) {
          res.sendStatus(200);/*让options请求快速返回*/
    } else{
          next();
    }
});


app.get('/createtoken', (request, response) =&gt; {
    //要生成 token 的主题信息
    let user = {
        username: 'admin',
    }
    //这是加密的 key（密钥）
    let secret = 'dktoken';
    //生成 Token
    let token = jwt.sign(user, secret, {
        'expiresIn': 60*60*24 // 设置过期时间, 24 小时
    })      
    response.send({status: true, token});
})

app.post('/verifytoken', (request, response) =&gt; {
    //这是加密的 key（密钥），和生成 token 时的必须一样
    let secret = 'dktoken';
    let token = request.headers['auth'];
    if(!token){
        response.send({status: false, message: 'token不能为空'});
    }
    jwt.verify(token, secret, (error, result) =&gt; {
        if(error){
            response.send({status: false});
        } else {
            response.send({status: true, data: result});
        }
    })
})

app.listen(88)
</code></pre><h1 id=web-socket>web socket<a hidden class=anchor aria-hidden=true href=#web-socket>#</a></h1><p>HTTP 协议可以总结几个特点：</p><ul><li>一次性的、无状态的短连接：客户端发起请求、服务端响应、结束。</li><li>被动性响应：只有当客户端请求时才被执行，给予响应，不能主动向客户端发起响应。</li><li>信息安全性：得在服务器添加 SSL 证书，访问时用 HTTPS。</li><li>跨域：服务器默认不支持跨域，可在服务端设置支持跨域的代码或对应的配置。</li></ul><p>TCP 协议可以总结几个特点：</p><ul><li>有状态的长连接：客户端发起连接请求，服务端响应并建立连接，连接会一直保持直到一方主动断开。</li><li>主动性：建立起与客户端的连接后，服务端可主动向客户端发起调用。</li><li>信息安全性：同样可以使用 SSL 证书进行信息加密，访问时用 WSS 。</li><li>跨域：默认支持跨域。</li></ul><p>安装第三方模块 ws：<code>npm install ws</code></p><p>开启一个 WebSocket 的服务器，端口为 8080</p><pre><code>var socketServer = require('ws').Server;
var wss = new socketServer({
    port: 8080
});
</code></pre><p>也可以利用 Express 来开启 WebSocket 的服务器</p><pre><code>var app = require('express')();
var server = require('http').Server(app);

var socketServer = require('ws').Server;
var wss = new socketServer({server: server, port: 8080});
</code></pre><ul><li>用 on 来进行事件监听</li><li>connection：连接监听，当客户端连接到服务端时触发该事件</li><li>close：连接断开监听，当客户端断开与服务器的连接时触发</li><li>message：消息接受监听，当客户端向服务端发送信息时触发该事件</li><li>send: 向客户端推送信息</li></ul><p>soket.io 可以理解为对 WebSocket 的一种封装。好比前端的 jQuery 对原生 javascript 的封装。
soket.io 依靠事件驱动的模式，灵活的使用了自定义事件和调用事件来完成更多的场景，不必依赖过多的原生事件。</p><ul><li>安装第三方模块 <code>npm install express socket.io</code></li><li>开户 Socket 服务器，端口为 88</li></ul><pre><code>var express = require('express');
var app = express();
var http = require('http').Server(app);
var io = require('socket.io')(http);
http.listen(88);
</code></pre><ul><li>用 on 来进行事件监听和定义事件</li><li>connection：监听客户端连接,回调函数会传递本次连接的socket</li><li>emit：触发用客户端的事件</li></ul><pre><code>io.on('connection', function(client){
    //把当前登录的用户保存到对象 onlinePersons，并向所有在线的用户发起上线提示
    //serverLogin 为自定义事件，供客户端调用
    client.on('serverLogin', function(_person){
        var _personObj = JSON.parse(_person);
        onlinePersons[_personObj.id] = _personObj;
        //向所有在线的用户发起上线提示
        //触发客户端的 clientTips 事件
        //clientTips 为客户端的自定义事件
        io.emit('clientTips', JSON.stringify(onlinePersons));
    })

    //当监听到客户端有用户在移动，就向所有在线用户发起移动信息，触发客户端 clientMove 事件
    //serverMove 为自定义事件，供客户端调用
    client.on('serverMove', function(_person){
        var _personObj = JSON.parse(_person);
        onlinePersons[_personObj.id] = _personObj;
        console.log('serverLogin', onlinePersons);
        //clientTips 为客户端的自定义事件
        io.emit('clientMove', _person);
    });
})
</code></pre><h1 id=kafka-node>kafka-node<a hidden class=anchor aria-hidden=true href=#kafka-node>#</a></h1><p>node也可以去读写kafka，而且很简单。只需要引入kafka的库即可。</p><pre><code>yarn add kafka-node
</code></pre><p>具体api可以看文档：https://github.com/SOHU-Co/kafka-node</p><p>生产者</p><pre><code>var kafka = require('..');
var Producer = kafka.Producer;
var KeyedMessage = kafka.KeyedMessage;
var Client = kafka.Client;
var client = new Client('localhost:2181');
var argv = require('optimist').argv;
var topic = argv.topic || 'topic1';
var p = argv.p || 0;
var a = argv.a || 0;
var producer = new Producer(client, { requireAcks: 1 });

producer.on('ready', function () {
  var message = 'a message';
  var keyedMessage = new KeyedMessage('keyed', 'a keyed message');

  producer.send([
    { topic: topic, partition: p, messages: [message, keyedMessage], attributes: a }
  ], function (err, result) {
    console.log(err || result);
    process.exit();
  });
});

producer.on('error', function (err) {
  console.log('error', err);
});
</code></pre><p>消费者</p><pre><code>'use strict';

var kafka = require('..');
var Consumer = kafka.Consumer;
var Offset = kafka.Offset;
var Client = kafka.Client;
var argv = require('optimist').argv;
var topic = argv.topic || 'topic1';

var client = new Client('localhost:2181');
var topics = [{ topic: topic, partition: 1 }, { topic: topic, partition: 0 }];
var options = { autoCommit: false, fetchMaxWaitMs: 1000, fetchMaxBytes: 1024 * 1024 };

var consumer = new Consumer(client, topics, options);
var offset = new Offset(client);

consumer.on('message', function (message) {
  console.log(message);
});

consumer.on('error', function (err) {
  console.log('error', err);
});

/*
* If consumer get `offsetOutOfRange` event, fetch data from the smallest(oldest) offset
*/
consumer.on('offsetOutOfRange', function (topic) {
  topic.maxNum = 2;
  offset.fetch([topic], function (err, offsets) {
    if (err) {
      return console.error(err);
    }
    var min = Math.min.apply(null, offsets[topic.topic][topic.partition]);
    consumer.setOffset(topic.topic, topic.partition, min);
  });
});
</code></pre><h1 id=node单元测试>Node单元测试<a hidden class=anchor aria-hidden=true href=#node单元测试>#</a></h1><p>以function为最小单位，验证特定情况下的input和output是否正确。</p><ul><li>防止改A坏B，避免不能跑的代码比能跑的还多。</li><li>明确指出问题所在、告知正确的行为是什么，减少debug的时间。</li></ul><p>对于node来说，单元测试也很容易做。</p><p>测试主要分为两种，TDD和BDD。</p><h2 id=tdd-vs-bdd>TDD VS. BDD<a hidden class=anchor aria-hidden=true href=#tdd-vs-bdd>#</a></h2><p>比较TDD 与BDD 的差异。</p><table><thead><tr><th></th><th>TDD</th><th>BDD</th></tr></thead><tbody><tr><td>全名</td><td>测试驱动开发Test-Driven Development</td><td>行为驱动开发Behavior Driven Development</td></tr><tr><td>定义</td><td>在开发前先撰写测试程式，以确保程式码品质与符合验收规格。</td><td>TDD的进化版。除了实作前先写测试外，还要写一份「可以执行的规格」。</td></tr><tr><td>特性</td><td>从测试去思考程式如何实作。强调小步前进、快速且持续回馈、拥抱变化、重视沟通、满足需求。</td><td>从用户的需求出发，强调系统行为。使用自然语言描述测试案例，以减少使用者和工程师的沟通成本。测试后的输出结果可以直接做为文件阅读。</td></tr></tbody></table><p>从代码层面来看：</p><p>TDD</p><pre><code>suite('Array', ()=&gt;{
    setup(()={
        
    });
    
    test('equal -1 when index beyond array length', ()=&gt;{
       assert.equal(-1, [1,2,3].indexOf(4)); 
    });
})
</code></pre><p>BDD</p><pre><code>describe('Array', function() {
  before(function() {
  });

  it('should return -1 when no such index', function() {
    [1,2,3].indexOf(4).should.equal(-1);
  });
});
</code></pre><p>对比了这两种类型的语法之后，我选择了BDD。</p><h2 id=测试框架实践>测试框架实践<a hidden class=anchor aria-hidden=true href=#测试框架实践>#</a></h2><p>在node社区，比较成熟的是mocha。mocha本身是不提供断言库的，一般来说断言库比较常用的是chai。mocha和chai，合起来就被戏称为抹茶。</p><p>mocha一般需要全局安装，chai安装到项目目录下即可。</p><pre><code>yarn global add mocha

yarn add chai
</code></pre><h3 id=mocha>mocha<a hidden class=anchor aria-hidden=true href=#mocha>#</a></h3><h4 id=语法说明>语法说明<a hidden class=anchor aria-hidden=true href=#语法说明>#</a></h4><ul><li><code>describe()</code>：描述场景或圈出特定区块，例如：标明测试的功能或function。</li><li><code>it()</code>：撰写测试案例（Test Case）。</li><li><code>before()</code>：在所有测试开始前会执行的代码。</li><li><code>after()</code>：在所有测试结束后会执行的代码。</li><li><code>beforeEach()</code>：在每个Test Case 开始前执行的代码。</li><li><code>afterEach()</code>：在每个Test Case 结束后执行的代码。</li></ul><h4 id=代码示例>代码示例<a hidden class=anchor aria-hidden=true href=#代码示例>#</a></h4><pre><code>describe('hooks', function() { 
  before(function() {
    
  });

  after(function() {
    
  });

  beforeEach(function() {
    
  });

  afterEach(function() {
    
  });

  
  it('should ...', function() {
    
  });
});

</code></pre><h3 id=chai>chai<a hidden class=anchor aria-hidden=true href=#chai>#</a></h3><h4 id=assert>assert<a hidden class=anchor aria-hidden=true href=#assert>#</a></h4><p>assert(expression, message)：测试这个项目的expression是否为真，若为假则显示错误消息message。</p><h4 id=expect--should>Expect / Should<a hidden class=anchor aria-hidden=true href=#expect--should>#</a></h4><p>预期3 等于（===）2。这是使用可串连的操作符 来完成断言。这些可串联的有to、is、have 等。它很像英文，用很口语的方式做判断。</p><h2 id=覆盖率>覆盖率<a hidden class=anchor aria-hidden=true href=#覆盖率>#</a></h2><p>既然是给功能代码写单元测试，那就应该有个指标去衡量单元测试覆盖了哪些功能代码，这就是接下来要介绍的测试覆盖率。</p><p>在 Node.js 中，我们使用 istanbul 作为覆盖率统计的工具，istanbul 可以帮助我们统计到代码的语句覆盖率、分支覆盖率、函数覆盖率以及行覆盖率。</p><p>全局安装：</p><pre><code>yarn global add istanbul
</code></pre><p>只需要使用istanbul cover就可以得到覆盖率。</p><pre><code>istanbul cover simple.js
</code></pre><p>可以和mocha配合使用：</p><pre><code>isbuntal cover _mocha test/simple-test.js
</code></pre><p>mocha 和 _mocha 是两个不同的命令，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。</p><h1 id=引入typescript>引入typescript<a hidden class=anchor aria-hidden=true href=#引入typescript>#</a></h1><p>typescript其实就是加了类型的js。</p><p>所谓类型，就是约定变量的内存布局。js作为一个动态弱类型的语言，在开发大型项目的时候，不免可能出现问题，所以有类型的语言可以在编译期就能检测到错误，减少debug的时间。</p><h2 id=安装>安装<a hidden class=anchor aria-hidden=true href=#安装>#</a></h2><pre><code>yarn global add typescript
</code></pre><h2 id=新项目引入ts>新项目引入ts<a hidden class=anchor aria-hidden=true href=#新项目引入ts>#</a></h2><p>现在新建文件<code>server.ts</code>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>import</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>as</span> <span style=color:#a6e22e>http</span> <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;http&#39;</span>;

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>server</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>createServer</span>(<span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) {
  <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>end</span>(<span style=color:#e6db74>&#39;Hello, world&#39;</span>);
});

<span style=color:#a6e22e>server</span>.<span style=color:#a6e22e>listen</span>(<span style=color:#ae81ff>3000</span>, <span style=color:#66d9ef>function</span> () {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;server is listening&#39;</span>);
});
</code></pre></div><p>为了能执行此文件，需要通过 <strong>tsc</strong> 命令来编译该 TypeScript 源码：</p><pre><code>tsc server.ts
</code></pre><p>如果没有什么意外的话，此时控制台会打印出以下的出错信息：</p><pre><code>server.ts(1,23): error TS2307: Cannot find module 'http'.
</code></pre><p>这表示没有找到<code>http</code>这个模块定义（TyprScript 编译时是通过查找模块的 typings 声明文件来判断模块是否存在的，而不是根据真实的 js 文件，下文会详细解释），但是我们当前目录下还是生成了一个新的文件<code>server.js</code>，我们可以试着执行它：</p><pre><code>node server.js
</code></pre><p>如果一切顺利，那么控制台将会打印出 <strong>server is listening</strong> 这样的信息，并且我们在浏览器中访问 <a href=http://127.0.0.1:3000/>http://127.0.0.1:3000</a>时也能看到正确的结果：<strong>Hello, world</strong></p><p>现在再回过头来看看刚才的编译错误信息。由于这是一个 Node.js 项目，typescript 语言中并没有定义<code>http</code>这个模块，所以我们需要安装 Node.js 运行环境的声明文件：</p><pre><code>yarn global add @types/node 
</code></pre><p>安装完毕之后，再重复上文的编译过程，此时 <strong>tsc</strong> 不再报错了。</p><p>大多数时候，为了方便我们可以直接使用 <strong>ts-node</strong> 命令执行 TypeScript 源文件而不需要预先编译。首先执行以下命令安装 <strong>ts-node</strong>：</p><pre><code>yarn global add -g ts-node
</code></pre><p>然后使用 <strong>ts-node</strong> 命令执行即可：</p><pre><code>ts-node --no-cache server.ts
</code></pre><p>说明：使用 <strong>ts-node</strong> 执行 TypeScript 程序时，为了提高编译速度，默认会缓存未修改过的 <strong>.ts</strong> 文件，但有时候会导致一些 Bug，所以建议启动时加上 <code>--no-cache</code> 参数。</p><h3 id=tsconfigjson-配置文件>tsconfig.json 配置文件<a hidden class=anchor aria-hidden=true href=#tsconfigjson-配置文件>#</a></h3><p>每个 TypeScript 项目都需要一个 <strong>tsconfig.json</strong> 文件来指定相关的配置，比如告诉 TypeScript 编译器要将代码转换成 ES5 还是 ES6 代码等。</p><p>可以使用tsc命令生成。</p><pre><code>tsc --init
</code></pre><h3 id=使用第三方模块>使用第三方模块<a hidden class=anchor aria-hidden=true href=#使用第三方模块>#</a></h3><p>一般情况下在 TypeScript 中是不能”<em>直接</em>“使用 npm 上的模块的，比如我们要使用 express 模块，先执行以下命令安装：</p><pre><code>yarn add express
</code></pre><p>然后新建文件 <code>server.ts</code> :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>import</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>as</span> <span style=color:#a6e22e>express</span> <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;express&#39;</span>;

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>app</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>express</span>();
<span style=color:#a6e22e>app</span>.<span style=color:#66d9ef>get</span>(<span style=color:#e6db74>&#39;/&#39;</span>, <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) {
  <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>end</span>(<span style=color:#e6db74>&#39;hello, world&#39;</span>);
})

<span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>listen</span>(<span style=color:#ae81ff>3000</span>, <span style=color:#66d9ef>function</span> () {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;server is listening&#39;</span>);
});
</code></pre></div><p>然后使用以下命令执行：</p><pre><code>ts-node server.ts
</code></pre><p>如果不出意外，我们将会看到这样的报错信息：</p><pre><code>src/server.ts(1,26): error TS7016: Could not find a declaration file for module 'express'.
</code></pre><p>报错的信息表明没有找到<code>express</code>模块的声明文件。由于 TypeScript 项目最终会编译成 JavaScript 代码执行，当我们在 TypeScript 源码中引入这些被编译成 JavaScript 的模块时，它需要相应的声明文件（<strong>.d.ts</strong>文件）来知道该模块类型信息，这些声明文件可以通过设置<code>tsconfig.json</code>中的<code>declaration: true</code>来自动生成。而那些不是使用 TypeScript 编写的模块，也可以通过手动编写声明文件来兼容 TypeScript。</p><p>当遇到缺少模块声明文件的情况，开发者可以尝试通过 yarn addl @types/xxx 来安装模块声明文件即可。</p><p>现在我们尝试执行以下命令安装 <strong>express</strong> 模块的声明文件：</p><pre><code>yarn add @types/express
</code></pre><p>没有意外，果然能成功安装。现在再通过 <strong>ts-node</strong> 来执行的时候，发现已经没有报错了。</p><h3 id=单元测试>单元测试<a hidden class=anchor aria-hidden=true href=#单元测试>#</a></h3><p>直接使用mocha和chai，进行ts的测试。</p><h2 id=旧项目迁移>旧项目迁移<a hidden class=anchor aria-hidden=true href=#旧项目迁移>#</a></h2><p>通常来说这个过程包括了以下步骤：</p><ul><li>添加 <code>tsconfig.json</code></li><li>将你的源代码文件扩展名从 <code>.js</code> 改成 <code>.ts</code>。使用 <code>any</code> 来开始<em>抑止</em>错误。</li><li>使用 TypeScript 来编写新的代码并且尽可能少地使用 <code>any</code>。</li><li>返回到旧代码里并且开始加入类型标注和解决发现的 bugs。</li><li>为第三方 JavaScript 代码使用环境定义。</li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://zhenfeng-zhu.github.io/posts/node%E8%B8%A9%E5%9D%91/><span class=title>« Prev Page</span><br><span>node踩坑</span></a>
<a class=next href=https://zhenfeng-zhu.github.io/posts/node%E7%9A%84redis%E5%AE%9E%E6%88%98/><span class=title>Next Page »</span><br><span>node的redis实战</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share node学习笔记 on twitter" href="https://twitter.com/intent/tweet/?text=node%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fnode-learning%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share node学习笔记 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fnode-learning%2f&title=node%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0&summary=node%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0&source=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fnode-learning%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share node学习笔记 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fnode-learning%2f&title=node%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share node学习笔记 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fnode-learning%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share node学习笔记 on whatsapp" href="https://api.whatsapp.com/send?text=node%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%20-%20https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fnode-learning%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share node学习笔记 on telegram" href="https://telegram.me/share/url?text=node%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fnode-learning%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://zhenfeng-zhu.github.io>Go Data</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>