<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Posts | Awesome Fenix</title>
<meta name=keywords content>
<meta name=description content="Posts - Awesome Fenix">
<meta name=author content="Fenix">
<link rel=canonical href=https://zhenfeng-zhu.github.io/posts/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<link rel=icon href=https://zhenfeng-zhu.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://zhenfeng-zhu.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://zhenfeng-zhu.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://zhenfeng-zhu.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://zhenfeng-zhu.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.91.2">
<link rel=alternate type=application/rss+xml href=https://zhenfeng-zhu.github.io/posts/index.xml>
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-216295420-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Posts">
<meta property="og:description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod">
<meta property="og:type" content="website">
<meta property="og:url" content="https://zhenfeng-zhu.github.io/posts/"><meta property="og:image" content="https://zhenfeng-zhu.github.io/papermod-cover.png">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhenfeng-zhu.github.io/papermod-cover.png">
<meta name=twitter:title content="Posts">
<meta name=twitter:description content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://zhenfeng-zhu.github.io/posts/"}]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8502076734034112" crossorigin=anonymous></script>
</head>
<body class=list id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhenfeng-zhu.github.io accesskey=h title="Awesome Fenix (Alt + H)">Awesome Fenix</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://zhenfeng-zhu.github.io/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/about title=About>
<span>About</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/search/ title=🔍>
<span>🔍</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<header class=page-header><div class=breadcrumbs><a href=https://zhenfeng-zhu.github.io>Home</a></div>
<h1>Posts</h1>
</header>
<article class=post-entry>
<figure class=entry-cover><img loading=lazy src=https://github.com/openfaas/media/raw/master/OpenFaaS_Magnet_3_1_png.png alt>
</figure>
<header class=entry-header>
<h2>Openfaas Workshop Lab11
</h2>
</header>
<section class=entry-content>
<p>Lab 11 - 高级函数 - 使用 HMAC 的信任 前言 用于微服务的传统认证策略与函数的工作原理完全相同。在这个实验室中，我们将讨论使用共享秘密和基于哈希的消息验证码（HMAC）的几种可用方法之一。有关其他认证策略和想法，请参见。openfaas-function-auth
这绝不是一个广泛的清单，安全和认证是一个复杂的领域，最好留给专家使用经过试验的方法。
准备好你的环境 在开始这个实验之前，创建一个新的文件夹
mkdir -p lab11\`bash && cd lab11 也要确保你的faas-cli'版本是0.7.4’或以上，使用以下命令。
$ faas-cli version 什么是 HMAC 如果没有任何形式的认证或信任，我们的函数可能会暴露给任何能猜到其 URL 的人。如果我们的函数可以在互联网或本地网络上访问，那么它们就可能被坏的行为者调用。默认情况下，函数会对任何请求做出响应。然而，如果我们想控制对函数的访问，我们可以使用基于哈希的消息验证码（HMAC）来验证信息的来源。
来自[alexellis/hmac]（https://github.com/alexellis/hmac）。
HMAC 使用发送方/接收方提前共享的对称密钥。发送方在想要传输信息时将产生一个哈希值–该数据与有效载荷一起发送。然后，收件人将用共享密钥签署有效载荷，如果哈希值匹配，则假定有效载荷来自发件人。
这样我们就可以避免我们的函数被无效的甚至是危险的信息所调用。
使用 HMAC 我们将使用 faas-cli 提供的--sign标志来包含一个头，其中包含使用我们用--key标志提供的共享密钥创建的散列信息。
注意: --sign和--key必须同时存在。
让我们首先通过部署-env函数来检查该标志的作用，该函数将打印函数中可访问的所有环境变量。
$ faas-cli deploy --name env --fprocess="env" --image="function/alpine:new" 调用不带--sign标志的函数。 $ echo "The message" | faas-cli invoke env PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/sbin:/bin HOSTNAME=d2c1a2cb20c2 fprocess=env HOME=/root Http_X_Call_Id=b84947c6-2970-4fcf-ba3b-66dde6943999 Http_X_Forwarded_For=10.255.0.2:34974 Http_X_Forwarded_Host=127.0.0.1:8080 Http_Content_Length=0 Http_Accept_Encoding=gzip Http_Content_Type=text/plain Http_User_Agent=Go-http-client/1....</p>
</section>
<footer class=entry-footer><span title="2022-01-04 13:44:15 +0800 +0800">January 4, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to Openfaas Workshop Lab11" href=https://zhenfeng-zhu.github.io/posts/openfaas-workshop-lab11/></a>
</article>
<article class=post-entry>
<figure class=entry-cover><img loading=lazy src=https://github.com/openfaas/media/raw/master/OpenFaaS_Magnet_3_1_png.png alt>
</figure>
<header class=entry-header>
<h2>Openfaas Workshop Lab10
</h2>
</header>
<section class=entry-content>
<p>Lab 10 - 高级函数 - 秘密 在开始本实验室之前，为你的文件创建一个新的文件夹。由于本实验室是建立在先前的实验室基础上的，因此请复制 lab5。
$ cp -r lab5 lab10\ && cd lab10 使用秘密 实验室 5研究了issue-bot如何从环境变量（auth_token）获得 GitHub 的*个人访问令牌。 另一种方法是使用机密来存储敏感信息。
来自 Docker 文档。
… 秘密是一团数据，如密码、SSH 私钥、SSL 证书或其他数据，不应通过网络传输或未经加密存储在 Docker 文件或应用程序的源代码中。
这是一个比环境变量更安全的选择。环境变量更容易使用，但最适合于非保密的配置项目。 似乎很适合用于存储auth_token值。
请参阅docs中关于秘密的更多信息和它的设计。
创建一个秘密 秘密名称必须遵循 DNS-1123 惯例，由小写字母数字字符或'-‘组成，并且必须以一个字母数字字符开始和结束
从一个终端运行以下命令。
$ echo -n &lt;auth_token> | faas-cli secret create auth-token 测试秘密是否被创建。
$ faas-cli secret ls 注意：请记住，-g标志可以在网关之间轻松切换。 这也适用于秘密。
kubectl get secret auth-token -n openfaas-fn -o json 注意：如果你在远程网关上部署你的函数，确保你在你用于网关的虚拟机上创建你的秘密。...</p>
</section>
<footer class=entry-footer><span title="2022-01-04 13:44:12 +0800 +0800">January 4, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to Openfaas Workshop Lab10" href=https://zhenfeng-zhu.github.io/posts/openfaas-workshop-lab10/></a>
</article>
<article class=post-entry>
<figure class=entry-cover><img loading=lazy src=https://github.com/openfaas/media/raw/master/OpenFaaS_Magnet_3_1_png.png alt>
</figure>
<header class=entry-header>
<h2>Openfaas Workshop Lab9
</h2>
</header>
<section class=entry-content>
<p>Lab 9 - 高级函数 - 自动缩放 自动缩放函数的应用 正如文档中描述的那样，OpenFaaS 带有自动扩展函数。在这个实验室中，我们将看看自动扩展是如何运作的。
前提条件 在完成了Lab 1中对 OpenFaaS 的设置后，你将拥有触发自动扩展所需的一切。
多个工具可以用来创建足够的流量来触发自动扩展 - 在这个例子中，`curl’将被使用，因为它很容易在 Mac 和 Linux 上使用，并在 Windows 上与 Git Bash 打包。
自动扩展的背景 开箱即用的 OpenFaaS 是这样配置的，它将根据 Prometheus 测量的 每秒请求指标进行自动扩展。 这个指标是在流量通过 API 网关的时候捕获的。如果超过了定义的 每秒请求的阈值，AlertManager 就会启动。这个阈值应该被重新配置为适合生产使用的水平，因为在这个例子中，为了演示，它被设置为一个低值。
在文档网站中找到更多关于自动缩放的信息。
每次警报被 AlertManager 触发时，API 网关将把你的函数的一定数量的副本添加到集群中。OpenFaaS 有两个配置选项，允许指定复制的起始/最低数量，也允许停止复制的最大数量。
你可以通过设置com.openfaas.scale.min来控制函数的最小复制量，目前默认值为1。
你可以通过设置com.openfaas.scale.max来控制一个函数可以产生的最大复制量，目前默认值是20。
注意: 如果你把com.openfaas.scale.min和com.openfaas.scale.max设置成相同的值，你就会禁用自动缩放函数。
查看 Prometheus 你需要运行这个端口转发命令，以便能够在http://127.0.0.1:9090访问 Prometheus。
$ kubectl port-forward deployment/prometheus 9090:9090 -n openfaas 现在添加一个所有成功调用部署的函数的图。我们可以通过执行rate( gateway_function_invocation_total{code="200"} [20s])作为查询来实现。导致一个看起来像这样的页面。...</p>
</section>
<footer class=entry-footer><span title="2022-01-04 13:44:09 +0800 +0800">January 4, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to Openfaas Workshop Lab9" href=https://zhenfeng-zhu.github.io/posts/openfaas-workshop-lab9/></a>
</article>
<article class=post-entry>
<figure class=entry-cover><img loading=lazy src=https://github.com/openfaas/media/raw/master/OpenFaaS_Magnet_3_1_png.png alt>
</figure>
<header class=entry-header>
<h2>Openfaas Workshop Lab8
</h2>
</header>
<section class=entry-content>
<p>Lab 8 - 高级函数 - 超时 在开始这个实验之前，为你的文件创建一个新的文件夹。
$ mkdir -p lab8 \ && cd lab8 用read_timeout扩展超时时间 timeout对应于一个函数可以运行多长时间，直到被执行。它对防止分布式系统中的误操作很重要。
有几个地方可以为你的函数配置超时，在每个地方都可以通过使用环境变量来完成。
函数超时
read_timeout - 允许函数通过 HTTP 读取一个请求的时间
write_timeout - 允许函数在 HTTP 上写一个响应的时间
exec_timeout - 一个函数在被终止前可以运行的最大时间。
API 网关的默认时间是 20 秒，所以我们来测试一下在一个函数上设置一个更短的超时时间。
$ faas-cli new --lang python3 sleep-for --prefix="&lt;your-docker-username-here>" 编辑handler.py。
import time import os def handle(req): """handle a request to the function Args: req (str): request body """ sleep_duration = int(os....</p>
</section>
<footer class=entry-footer><span title="2022-01-04 13:44:05 +0800 +0800">January 4, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to Openfaas Workshop Lab8" href=https://zhenfeng-zhu.github.io/posts/openfaas-workshop-lab8/></a>
</article>
<article class=post-entry>
<figure class=entry-cover><img loading=lazy src=https://github.com/openfaas/media/raw/master/OpenFaaS_Magnet_3_1_png.png alt>
</figure>
<header class=entry-header>
<h2>Openfaas Workshop Lab7
</h2>
</header>
<section class=entry-content>
<p>实验 7–异步函数 在开始这个实验之前，为你的文件创建一个新的文件夹。
$ mkdir -p lab7 \ && cd lab7 同步与异步地调用一个函数 当你同步调用一个函数时，一个连接会通过网关连接到你的函数，并且在整个执行过程中保持开放。同步调用是*阻塞的，所以你应该看到你的客户端暂停，变得不活跃，直到该函数完成其任务。
网关使用的路由是。/function/&lt;function_name>。 你必须等待，直到它完成 你在调用后得到结果 你知道它是通过还是失败 异步任务以类似的方式运行，但有一些区别。
网关使用不同的路由：/async-function/&lt;function_name>。 客户端从网关得到一个立即的202 接受的响应。 该函数稍后使用一个队列工作器来调用 默认情况下，结果被丢弃 让我们试一试快速演示。
$ faas-cli new --lang dockerfile long-task --prefix="&lt;your-docker-username-here>" 编辑long-task/Dockerfile并将 fprocess 改为sleep 1。
现在构建、部署并同步调用你的函数 10 次，像这样。
echo -n "" | faas-cli invoke long-task echo -n "" | faas-cli invoke long-task echo -n "" | faas-cli invoke long-task echo -n "" | faas-cli invoke long-task echo -n "" | faas-cli invoke long-task echo -n "" | faas-cli invoke long-task echo -n "" | faas-cli invoke long-task echo -n "" | faas-cli invoke long-task echo -n "" | faas-cli invoke long-task echo -n "" | faas-cli invoke long-task 现在异步调用该函数 10 次。...</p>
</section>
<footer class=entry-footer><span title="2022-01-04 13:44:02 +0800 +0800">January 4, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to Openfaas Workshop Lab7" href=https://zhenfeng-zhu.github.io/posts/openfaas-workshop-lab7/></a>
</article>
<article class=post-entry>
<figure class=entry-cover><img loading=lazy src=https://github.com/openfaas/media/raw/master/OpenFaaS_Magnet_3_1_png.png alt>
</figure>
<header class=entry-header>
<h2>Openfaas Workshop Lab6
</h2>
</header>
<section class=entry-content>
<p>实验 6–你的函数的 HTML 在开始这个实验之前，为你的文件创建一个新的文件夹。
$ mkdir -p lab6\ && cd lab6 从一个函数中生成并返回基本的 HTML 函数可以返回 HTML，并将Content-Type设置为text/html。因此，函数返回的 HTML 可以通过浏览器进行渲染。让我们创建一个简单的函数，生成并返回一个基本的 HTML。
$ faas-cli new --lang python3 show-html --prefix="&lt;your-docker-username-here>" 编辑handler.py。
def handle(req): """handle a request to the function Args: req (str): request body """ html = '&lt;html>&lt;h2>Hi, from your function!&lt;/h2>&lt;/html>' return html 这将返回 HTML 给调用者。 还有一件事我们应该做的是设置响应的Content-Type'。我们100%确定这个函数将返回一个HTML，所以Content-Type应该总是text/html。我们可以利用show-html.yml文件中的environment`部分来设置。
编辑show-html.yml。
provider: name: openfaas gateway: http://127.0.0.1:8080 functions: show-html: lang: python3 handler: ./show-html image: &lt;your-docker-username-here>/show-html environment: content_type: text/html environment中的content_type键将设置响应的Content-Type。...</p>
</section>
<footer class=entry-footer><span title="2022-01-04 13:43:59 +0800 +0800">January 4, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to Openfaas Workshop Lab6" href=https://zhenfeng-zhu.github.io/posts/openfaas-workshop-lab6/></a>
</article>
<article class=post-entry>
<figure class=entry-cover><img loading=lazy src=https://github.com/openfaas/media/raw/master/OpenFaaS_Magnet_3_1_png.png alt>
</figure>
<header class=entry-header>
<h2>Openfaas Workshop Lab5
</h2>
</header>
<section class=entry-content>
<p>Lab 5 - 创建一个 GitHub 机器人 在开始这个实验之前，为你的文件创建一个新的文件夹。
$ mkdir -p lab5\ && cd lab5 我们将使用 OpenFaaS 的函数来创建一个名为 issue-bot的 GitHub 机器人。
问题机器人的工作是通过分析 描述 字段的情绪来分流新的问题，然后它将应用一个积极或审查的标签。这将有助于维护者在繁忙的工作中，可以优先考虑哪些问题需要首先处理。
问题机器人的图示](./diagram/issue-bot.png)
获取一个 GitHub 账户 注册一个GitHub 账户，如果你还没有一个账户。
创建一个新的仓库，并将其称为bot-test。
注意：我们将只使用这个仓库作为创建问题的测试场所。你不需要在那里提交任何代码。
建立一个带有入口的隧道 你需要接收来自 GitHub 的 webhooks。幸运的是，inlets 让这一切变得非常快速和简单。它可以按月或按年订阅，所以如果你不确定是否全年都需要它，你可以只付一个月的钱。
inlets 有一个叫做 inlets-operator 的 Kubernetes 集成。你可以用它来设置 LoadBalancers 或带有 TLS 的 Ingress。它的工作原理是为你创建一个云虚拟机，并在那里运行一个隧道服务器，然后为你运行一个隧道客户端作为一个 Pod，你就可以获得传入流量。
在你喜欢的云提供商（如 DigitalOcean）的 API 页面下创建一个写入访问令牌，然后将内容保存到digital-ocean-api-token.txt。
设置完订阅后，将你的密钥保存到$HOME/.inlets/LICENSE，然后运行以下程序。
arkade install inlets-operator \ --provider digitalocean \ --region lon1 \ --token-file $HOME/digital-ocean-api-token....</p>
</section>
<footer class=entry-footer><span title="2022-01-04 13:43:56 +0800 +0800">January 4, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to Openfaas Workshop Lab5" href=https://zhenfeng-zhu.github.io/posts/openfaas-workshop-lab5/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Blockchain 数据结构分析
</h2>
</header>
<section class=entry-content>
<p>区块 想要了解区块到底是什么，最简单快捷的方法就是分析它的数据结构，以 bitcoin 种的区块为例：
{ "hash":"00000000000000000018b0a6ae560fa33c469b6528bc9e0fb0c669319a186c33", "confirmations":1009, "strippedsize":956228, "size":1112639, "weight":3981323, "height":514095, "version":536870912, "versionHex":"20000000", "merkleroot":"5f8f8e053fd4c0c3175c10ac5189c15e6ba218909319850936fe54934dcbfeac", "tx":[ // ... 　], "time":1521380124, "mediantime":1521377506, "nonce":3001236454, "bits":"17514a49", "difficulty":3462542391191.563, "chainwork":"0000000000000000000000000000000000000000014d2b41a340e60b72292430", "previousblockhash":"000000000000000000481ab128418847dc25db4dafec464baa5a33e66490990b", "nextblockhash":"0000000000000000000c74966205813839ad1c6d55d75f95c9c5f821db9c3510" } 在这个 Block 的结构体中，previousblockhash 和 merkleroot 是两个最重要的字段；前者是一个哈希指针，它其实是前一个 Block 的哈希，通过 previousblockhash 我们能递归地找到全部的 Block，也就是整条主链，后者是一个 Merkle 树的根，Merkle 树中包含整个 Block 中的全部交易，通过保存 merkleroot，我们可以保证当前 Block 中任意交易都不会被修改。 Ethereum 的区块链模型虽然与 Bitcoin 有非常大的不同，但是它的 Block 结构中也有着类似的信息：
{ "jsonrpc":"2.0", "result":{ "author":"0x00d8ae40d9a06d0e7a2877b62e32eb959afbe16d", "difficulty":"0x785042b0", "extraData":"0x414952412f7630", "gasLimit":"0x47b784", "gasUsed":"0x44218a", "hash":"0x4de91e4af8d135e061d50ddd6d0d6f4119cd0f7062ebe8ff2d79c5af0e8344b9", "logsBloom":"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "miner":"0x00d8ae40d9a06d0e7a2877b62e32eb959afbe16d", "mixHash":"0xb8155224974967443d8b83e484402fb6e1e18ff69a8fc5acdda32f2bcc6dd443", "nonce":"0xad14fb6803147c7c", "number":"0x2000f1", "parentHash":"0x31919e2bf29306778f50bbc376bd490a7d056ddfd5b1f615752e79f32c7f1a38", "receiptsRoot":"0xa2a7af5e3b9e1bbb6252ba82a09302321b8f0eea7ec8e3bb977401e4f473e672", "sealFields":[ "0xa0b8155224974967443d8b83e484402fb6e1e18ff69a8fc5acdda32f2bcc6dd443", "0x88ad14fb6803147c7c" ], "sha3Uncles":"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347", "size":"0x276", "stateRoot":"0x87e7e54cf229003014f453d64f0344e2ba4fc7ee3b95c7dd2642cca389fa1efe", "timestamp":"0x5a10968a", "totalDifficulty":"0x1804de0c47ffe1", "transactions":[....</p>
</section>
<footer class=entry-footer><span title="2022-01-04 10:04:05 +0800 +0800">January 4, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to Blockchain 数据结构分析" href=https://zhenfeng-zhu.github.io/posts/blockchain-schema/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>轻服务 nodejs 助力爬虫 web3
</h2>
</header>
<section class=entry-content>
<p>周末的时候，写了一个简单的小项目，用来抓取 web3 的文章，然后存到本地。最后选取了公司对外的轻服务：https://qingfuwu.cn/docs/nodejs/
整项目用到了两个库
axios：用来做 http 请求 cheerio：用来解析 html 观察目标网页的格式 我们以巴比特为例：https://www.8btc.com/web3.0，打开控制台，定位到正文的 div，可以发现是 article-list。
右键复制一下 selector，然后在代码中这样实现就可以了。
抓取网页信息 const cheerio = require('cheerio').default const axios = require('axios').default async function getData() { const data = await (await axios.get('https://www.8btc.com/web3.0', { headers: { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36' } })).data const $ = cheerio.load(data) let list = [] $('#news > div.articles-list').find('.article-info').each( (item, elem) => { const href = $(elem)....</p>
</section>
<footer class=entry-footer><span title="2021-12-20 09:58:58 +0800 +0800">December 20, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to 轻服务 nodejs 助力爬虫 web3" href=https://zhenfeng-zhu.github.io/posts/how-to-crawl-a-web-in-nodejs/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Crystal Roadmap
</h2>
</header>
<section class=entry-content>
<p>This roadmap defines the things that we want to have in the language and plan to do.
Language Stuff that has to do with the language syntax, semantic and runtime.
Concurrency Finalize multithreading support, so fibers can run on multiple threads.
Windows support Finalize support for Windows platform. The compiler already works, but some stdlib features like concurrency support are still missing. Ongoing efforts on #5430.
Type system review Make a review and possible formalisation of Crystal’s type system, with a strong emphasis on generics, type restrictions and the meta-model in general....</p>
</section>
<footer class=entry-footer><span title="2021-10-28 10:11:41 +0800 +0800">October 28, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to Crystal Roadmap" href=https://zhenfeng-zhu.github.io/posts/crystal_roadmap/></a>
</article>
<footer class=page-footer>
<nav class=pagination>
<a class=next href=https://zhenfeng-zhu.github.io/posts/page/2/>Next Page »</a>
</nav>
</footer>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://zhenfeng-zhu.github.io>Awesome Fenix</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>