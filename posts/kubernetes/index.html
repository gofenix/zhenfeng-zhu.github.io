<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>kubernetes | Awesome Fenix</title>
<meta name=keywords content>
<meta name=description content="docker 利用 Linux 的 cgroups 和 namespace，构建一个沙箱运行环境。
docker 镜像 其实就是一个压缩包，这个压缩包是由一个完整的操作系统的所有文件目录构成，包含了这个应用运行所需要的所有依赖，所以本地开发环境和测试环境是一样的。
解决了应用打包的根本性问题。
容器编排 对 Docker 容器的一系列定义、配置和创建动作的管理
 容器本身没有价值，有价值的是“容器编排”。
 原理 容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造一个“边界”。
在创建一个容器进程的时候，指定了这个进程所需要启动的一组 Namespace 参数，这样容器就只能看到当前 Namespace 所限定的资源、文件、设备、状态或配置。
Cgroups 主要作用是为一个进程组设置资源上限，如 CPU、内存、磁盘和带宽等。也可以设置进程优先级，审计，挂起，重启等。
因此，一个正在运行的 Docker 容器，其实就是一个启用了多个 Namespace 的应用进程，而这个进程能够使用的资源是由 Cgroups 来限制。
挂载在容器根目录上，用来为容器进程提供隔离后执行环境的文件系统，就是容器镜像，rootfs。
 启动 Namespace 配置 设置 Cgroups 参数 切换进程根目录 rootf  docker 镜像设计时，引入了层（layer），用户制作镜像的每一步操作都会生成一个层，也就是一个增量的 rootfs。AuFS，所以就有了共享层，镜像不用那么大。
一个进程，可以选择加入到某个进程已有的 Namespace 当中，从而达到进入这个进程所在的容器的目的，这正是 docker exec 的实现原理。
volume 机制，允许你将宿主机上指定的目录或文件，挂载到容器里面进行读取和修改操作。
主要依赖 Linux 依赖三大技术  Namespace Cgroups rootfs  和虚拟机比较 虚拟机是通过硬件虚拟化功能，模拟一套操作系统所需要的各种硬件，如 CPU、内存、IO 设备等，然后安装一个新的操作系统。
docker 是利用 Linux 的 Namespace 原理，帮助用户启动的还是系统的应用进程，只是加了一些参数，限制其能看到的资源。因此相对于虚拟机资源消耗更小，而且轻量级，敏捷高性能。">
<meta name=author content="Fenix">
<link rel=canonical href=https://zhenfeng-zhu.github.io/posts/kubernetes/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zhenfeng-zhu.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://zhenfeng-zhu.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://zhenfeng-zhu.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://zhenfeng-zhu.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://zhenfeng-zhu.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-216295420-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="kubernetes">
<meta property="og:description" content="docker 利用 Linux 的 cgroups 和 namespace，构建一个沙箱运行环境。
docker 镜像 其实就是一个压缩包，这个压缩包是由一个完整的操作系统的所有文件目录构成，包含了这个应用运行所需要的所有依赖，所以本地开发环境和测试环境是一样的。
解决了应用打包的根本性问题。
容器编排 对 Docker 容器的一系列定义、配置和创建动作的管理
 容器本身没有价值，有价值的是“容器编排”。
 原理 容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造一个“边界”。
在创建一个容器进程的时候，指定了这个进程所需要启动的一组 Namespace 参数，这样容器就只能看到当前 Namespace 所限定的资源、文件、设备、状态或配置。
Cgroups 主要作用是为一个进程组设置资源上限，如 CPU、内存、磁盘和带宽等。也可以设置进程优先级，审计，挂起，重启等。
因此，一个正在运行的 Docker 容器，其实就是一个启用了多个 Namespace 的应用进程，而这个进程能够使用的资源是由 Cgroups 来限制。
挂载在容器根目录上，用来为容器进程提供隔离后执行环境的文件系统，就是容器镜像，rootfs。
 启动 Namespace 配置 设置 Cgroups 参数 切换进程根目录 rootf  docker 镜像设计时，引入了层（layer），用户制作镜像的每一步操作都会生成一个层，也就是一个增量的 rootfs。AuFS，所以就有了共享层，镜像不用那么大。
一个进程，可以选择加入到某个进程已有的 Namespace 当中，从而达到进入这个进程所在的容器的目的，这正是 docker exec 的实现原理。
volume 机制，允许你将宿主机上指定的目录或文件，挂载到容器里面进行读取和修改操作。
主要依赖 Linux 依赖三大技术  Namespace Cgroups rootfs  和虚拟机比较 虚拟机是通过硬件虚拟化功能，模拟一套操作系统所需要的各种硬件，如 CPU、内存、IO 设备等，然后安装一个新的操作系统。
docker 是利用 Linux 的 Namespace 原理，帮助用户启动的还是系统的应用进程，只是加了一些参数，限制其能看到的资源。因此相对于虚拟机资源消耗更小，而且轻量级，敏捷高性能。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhenfeng-zhu.github.io/posts/kubernetes/"><meta property="og:image" content="https://zhenfeng-zhu.github.io/papermod-cover.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-10-08T15:29:21+00:00">
<meta property="article:modified_time" content="2018-10-08T15:29:21+00:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhenfeng-zhu.github.io/papermod-cover.png">
<meta name=twitter:title content="kubernetes">
<meta name=twitter:description content="docker 利用 Linux 的 cgroups 和 namespace，构建一个沙箱运行环境。
docker 镜像 其实就是一个压缩包，这个压缩包是由一个完整的操作系统的所有文件目录构成，包含了这个应用运行所需要的所有依赖，所以本地开发环境和测试环境是一样的。
解决了应用打包的根本性问题。
容器编排 对 Docker 容器的一系列定义、配置和创建动作的管理
 容器本身没有价值，有价值的是“容器编排”。
 原理 容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造一个“边界”。
在创建一个容器进程的时候，指定了这个进程所需要启动的一组 Namespace 参数，这样容器就只能看到当前 Namespace 所限定的资源、文件、设备、状态或配置。
Cgroups 主要作用是为一个进程组设置资源上限，如 CPU、内存、磁盘和带宽等。也可以设置进程优先级，审计，挂起，重启等。
因此，一个正在运行的 Docker 容器，其实就是一个启用了多个 Namespace 的应用进程，而这个进程能够使用的资源是由 Cgroups 来限制。
挂载在容器根目录上，用来为容器进程提供隔离后执行环境的文件系统，就是容器镜像，rootfs。
 启动 Namespace 配置 设置 Cgroups 参数 切换进程根目录 rootf  docker 镜像设计时，引入了层（layer），用户制作镜像的每一步操作都会生成一个层，也就是一个增量的 rootfs。AuFS，所以就有了共享层，镜像不用那么大。
一个进程，可以选择加入到某个进程已有的 Namespace 当中，从而达到进入这个进程所在的容器的目的，这正是 docker exec 的实现原理。
volume 机制，允许你将宿主机上指定的目录或文件，挂载到容器里面进行读取和修改操作。
主要依赖 Linux 依赖三大技术  Namespace Cgroups rootfs  和虚拟机比较 虚拟机是通过硬件虚拟化功能，模拟一套操作系统所需要的各种硬件，如 CPU、内存、IO 设备等，然后安装一个新的操作系统。
docker 是利用 Linux 的 Namespace 原理，帮助用户启动的还是系统的应用进程，只是加了一些参数，限制其能看到的资源。因此相对于虚拟机资源消耗更小，而且轻量级，敏捷高性能。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://zhenfeng-zhu.github.io/posts/"},{"@type":"ListItem","position":3,"name":"kubernetes","item":"https://zhenfeng-zhu.github.io/posts/kubernetes/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"kubernetes","name":"kubernetes","description":"docker 利用 Linux 的 cgroups 和 namespace，构建一个沙箱运行环境。\ndocker 镜像 其实就是一个压缩包，这个压缩包是由一个完整的操作系统的所有文件目录构成，包含了这个应用运行所需要的所有依赖，所以本地开发环境和测试环境是一样的。\n解决了应用打包的根本性问题。\n容器编排 对 Docker 容器的一系列定义、配置和创建动作的管理\n 容器本身没有价值，有价值的是“容器编排”。\n 原理 容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造一个“边界”。\n在创建一个容器进程的时候，指定了这个进程所需要启动的一组 Namespace 参数，这样容器就只能看到当前 Namespace 所限定的资源、文件、设备、状态或配置。\nCgroups 主要作用是为一个进程组设置资源上限，如 CPU、内存、磁盘和带宽等。也可以设置进程优先级，审计，挂起，重启等。\n因此，一个正在运行的 Docker 容器，其实就是一个启用了多个 Namespace 的应用进程，而这个进程能够使用的资源是由 Cgroups 来限制。\n挂载在容器根目录上，用来为容器进程提供隔离后执行环境的文件系统，就是容器镜像，rootfs。\n 启动 Namespace 配置 设置 Cgroups 参数 切换进程根目录 rootf  docker 镜像设计时，引入了层（layer），用户制作镜像的每一步操作都会生成一个层，也就是一个增量的 rootfs。AuFS，所以就有了共享层，镜像不用那么大。\n一个进程，可以选择加入到某个进程已有的 Namespace 当中，从而达到进入这个进程所在的容器的目的，这正是 docker exec 的实现原理。\nvolume 机制，允许你将宿主机上指定的目录或文件，挂载到容器里面进行读取和修改操作。\n主要依赖 Linux 依赖三大技术  Namespace Cgroups rootfs  和虚拟机比较 虚拟机是通过硬件虚拟化功能，模拟一套操作系统所需要的各种硬件，如 CPU、内存、IO 设备等，然后安装一个新的操作系统。\ndocker 是利用 Linux 的 Namespace 原理，帮助用户启动的还是系统的应用进程，只是加了一些参数，限制其能看到的资源。因此相对于虚拟机资源消耗更小，而且轻量级，敏捷高性能。","keywords":[],"articleBody":"docker 利用 Linux 的 cgroups 和 namespace，构建一个沙箱运行环境。\ndocker 镜像 其实就是一个压缩包，这个压缩包是由一个完整的操作系统的所有文件目录构成，包含了这个应用运行所需要的所有依赖，所以本地开发环境和测试环境是一样的。\n解决了应用打包的根本性问题。\n容器编排 对 Docker 容器的一系列定义、配置和创建动作的管理\n 容器本身没有价值，有价值的是“容器编排”。\n 原理 容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造一个“边界”。\n在创建一个容器进程的时候，指定了这个进程所需要启动的一组 Namespace 参数，这样容器就只能看到当前 Namespace 所限定的资源、文件、设备、状态或配置。\nCgroups 主要作用是为一个进程组设置资源上限，如 CPU、内存、磁盘和带宽等。也可以设置进程优先级，审计，挂起，重启等。\n因此，一个正在运行的 Docker 容器，其实就是一个启用了多个 Namespace 的应用进程，而这个进程能够使用的资源是由 Cgroups 来限制。\n挂载在容器根目录上，用来为容器进程提供隔离后执行环境的文件系统，就是容器镜像，rootfs。\n 启动 Namespace 配置 设置 Cgroups 参数 切换进程根目录 rootf  docker 镜像设计时，引入了层（layer），用户制作镜像的每一步操作都会生成一个层，也就是一个增量的 rootfs。AuFS，所以就有了共享层，镜像不用那么大。\n一个进程，可以选择加入到某个进程已有的 Namespace 当中，从而达到进入这个进程所在的容器的目的，这正是 docker exec 的实现原理。\nvolume 机制，允许你将宿主机上指定的目录或文件，挂载到容器里面进行读取和修改操作。\n主要依赖 Linux 依赖三大技术  Namespace Cgroups rootfs  和虚拟机比较 虚拟机是通过硬件虚拟化功能，模拟一套操作系统所需要的各种硬件，如 CPU、内存、IO 设备等，然后安装一个新的操作系统。\ndocker 是利用 Linux 的 Namespace 原理，帮助用户启动的还是系统的应用进程，只是加了一些参数，限制其能看到的资源。因此相对于虚拟机资源消耗更小，而且轻量级，敏捷高性能。\n不过缺点就是隔离不彻底，多个容器进程公用宿主机操作系统内核。有些资源和对象不可以被 Namespace 化的，如时间。\nkubernetes 要解决的问题\n编排？调度？容器云？集群管理？\n master  kube-apiserver：API 服务 kube-scheduler：调度 kube-controller-manager：编排   node  kubelet：同容器运行时打交道。依赖于 CRI（container runtime interface 容器运行接口）远程调用接口，这个接口定义了容器运行时的各项核心操作。   etcd  运行在大规模集群中的各种任务之间，实际存在各种各样的关系。这些关系的处理，才是作业编排和管理系统最困难的地方。\nsudo\n 首先，通过一个编排对象，如 pod，job 或 cronjob 等，来描述你试图管理的应用； 然后，再为它定义一些服务对象，如 service，secret，autoscaler 等。这些对象，会负责具体的平台级功能。  这种使用方法，就是所谓的“声明式 API”。这种 API 对应的编排对象和服务对象，都是 k8s 项目中的 API 对象。\n简单使用 kubectl create -f 我的配置文件 pod 就是 k8s 世界中的应用，而一个应用可以由多个容器组成。\n使用一个 API 对象管理另一个 API 对象的方法，叫控制器模式。\n每个 API 对象都有一个 metadata 字段，这个字段是 API 对象的标识，即元数据。主要用到的是 labels，spec.selector.matchLabels 就是 k8s 过滤的规则。与 labels 同层级的是 annotations，这是由 k8s 所感兴趣的，而不是用户。\n一个 k8s 的 API 对象都有 metadata 和 spec 两个部分。前者放的是对象的元数据，对所有 API 对象来讲，这部分的字段和格式基本一样；而后者存放的是属于这个对象独有的定义，用来描述它所要表达的功能。\n$ kubectl create -f nginx-deployment.yaml $ kubectl get pods -l app=nginx NAME READY STATUS RESTARTS AGE nginx-deployment-67594d6bf6-9gdvr 1/1 Running 0 10m nginx-deployment-67594d6bf6-v6j7w 1/1 Running 0 10m $ kubectl describe pod nginx-deployment-67594d6bf6-9gdvr Name: nginx-deployment-67594d6bf6-9gdvr Namespace: default Priority: 0 PriorityClassName:  Node: node-1/10.168.0.3 Start Time: Thu, 16 Aug 2018 08:48:42 +0000 Labels: app=nginx pod-template-hash=2315082692 Annotations:  Status: Running IP: 10.32.0.23 Controlled By: ReplicaSet/nginx-deployment-67594d6bf6 ... Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled 1m default-scheduler Successfully assigned default/nginx-deployment-67594d6bf6-9gdvr to node-1 Normal Pulling 25s kubelet, node-1 pulling image \"nginx:1.7.9\" Normal Pulled 17s kubelet, node-1 Successfully pulled image \"nginx:1.7.9\" Normal Created 17s kubelet, node-1 Created container Normal Started 17s kubelet, node-1 Started container $ kubectl apply -f nginx-deployment.yaml # 修改 nginx-deployment.yaml 的内容 $ kubectl apply -f nginx-deployment.yaml 在命令行中，所有 key-value 格式的参数，都使用“=“而不是”：“表示。\n在 k8s 执行过程中，对 API 对象的所有重要操作，都会被记录在这个对象的 events 中。\n在线业务\nDeployment\nStatefunSet\nDaemonSet\n离线业务\nJob\nrestartPolicy 在 job 对象里只被允许设置为 never 和 onFailure；而在 Deployment 对象中，只被允许设置为 always。\n声明式 API 和 Kubernetes 编程范式 创建一个两个 Nginx 容器的步骤：\n首先写一个 Deployment 的 yaml 文件：\napiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment spec: selector: matchLabels: app: nginx replicas: 2 template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx ports: - containerPort: 80 然后使用 kubectl create 命令在 Kubernetes 中创建一个 Deployment 对象：\nkubectl create -f nginx.yaml 这样两个 Nginx pod 就运行起来了。\n如果要更新的话，只需要修改 yaml 文件，然后使用 kubectl apply 命令更新，触发了滚动更新。\n这个 apply 命令就是声明式 API。\nistio 项目中，最根本的组件是运行在每个 pod 里的 envoy 容器。这个代理服务以 sidecar 容器的方式，把整个 pod 的进出流量接管下来。istio 的控制层的 pilot 组件，通过调用每个 envoy 的 API，实现微服务的治理。\n利用 Kubernetes 的 Admission Control，也叫：Initializer，先创建一个 Pod，然后 istio 就是在 pod 的 yaml 给 Kubernetes 之后，自动加上 envoy 的配置。\n 所谓的声明式，指的就是我只需要提交一个定义好的 API 对象来声明我所期望的状态是什么样子。 其次，声明式 API 允许有多个 API 写端，以 PATCH 的方式对 API 对象进行修改，而无需关心原始的 YAML 文件的内容。 最后，Kubernetes 基于对 API 对象的增删改查，在无需外界干预的情况下，完成对实际状态和期望状态的调谐。  一个 API 对象在 etcd 中完整路径是由：group（API 组），version（API 版本）和 Resource（API 资源类型）三个部分组成的。\napiVersion: batch/v2 kind: CronJob batch 是组，v2 是版本，CronJob 是类型。\n对于核心 API 对象：Pod，Node 等，不需要 group 的。非核心对象是需要组。\n匹配规则就是：\n/apis/batch/v2/CronJob\n  首先 yaml 文件被提交给了 APIServer\n过滤，授权，超时处理或审计等\n  进入路由流程\n根据 yaml，按照匹配规则去找\n  根据定义，按照 yaml 中的字段，创建一个对象\n  进行 Amission 和 Validation。\n  把验证过的对象，序列化存到 etcd 中\n  RBAC 基于角色的控制\nrole：角色，一组规则，定义 Kubernetes API 对象的操作权限\nsubject：被作用者，可以是人，也可以是机器，也可以是 Kubernetes 定义的用户\nrolebinding：定义被作用者和角色的绑定关系\nServiceAccount，会被自动创建分配一个 secret 对象。\n所谓角色就是一组权限规则列表，而我们分配这些权限的方式，就是通过创建 rolebinding 对象，将被作用者和权限列表进行绑定。\n另外，与之对应的 ClusterRole 和 ClusterRoleBinding，则是 Kubernetes 集群级别的 Role 和 RoleBinding，它们的作用范围不受 Namespace 限制。\n尽管被作用者有很多种（如 User、Group），但在我们平常使用的时候，最普遍的还是 ServiceAccount。\n网络模型 Veth Pair 常常被用作连接不同 Network Namespace 的网线。veth pair 虚拟设备。总是以两张虚拟网卡形式成对出现。并且，从一个网卡中发出的数据包，可以直接出现在另一张网卡上，哪怕这两个网卡在不同的 network Namespace 里。\n一旦一张虚拟网卡被插在网桥上，他就会变成该网桥的从设备。从设备会降级成为网桥的一个端口，不能处理数据包，只能接收流入的数据包交给对应的网桥。\n两个容器的虚拟网卡都插在宿主机的一个网桥上，这个网桥就扮演一个交换机的角色。当两个容器进行网络交互时，从一个容器的发出请求到宿主机，由于 Veth Pair 的机制，另一个容器就看到有数据流入。\n因此默认情况下，被限制在 network Namespace 的容器进程，实际就是通过 veth pair 设备+宿主机网桥的方式，实现了跟其他容器的数据交换。\n跨主通信，需要有一个集群公用的网桥，所有容器都连接到该网桥上，就可以相互通信，这就是 overlay network（覆盖网络）\n","wordCount":"518","inLanguage":"en","datePublished":"2018-10-08T15:29:21Z","dateModified":"2018-10-08T15:29:21Z","author":{"@type":"Person","name":"Fenix"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhenfeng-zhu.github.io/posts/kubernetes/"},"publisher":{"@type":"Organization","name":"Awesome Fenix","logo":{"@type":"ImageObject","url":"https://zhenfeng-zhu.github.io/favicon.ico"}}}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8502076734034112" crossorigin=anonymous></script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhenfeng-zhu.github.io accesskey=h title="Awesome Fenix (Alt + H)">Awesome Fenix</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://zhenfeng-zhu.github.io/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/about title=About>
<span>About</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/search/ title=🔍>
<span>🔍</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://zhenfeng-zhu.github.io>Home</a>&nbsp;»&nbsp;<a href=https://zhenfeng-zhu.github.io/posts/>Posts</a></div>
<h1 class=post-title>
kubernetes
</h1>
<div class=post-meta><span title="2018-10-08 15:29:21 +0000 UTC">October 8, 2018</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Fenix&nbsp;|&nbsp;<a href=https://github.com/zhenfeng-zhu/zhenfeng-zhu.github.io/tree/main/content/posts/kubernetes.md rel="noopener noreferrer" target=_blank>修改本文章</a>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul><ul>
<li>
<a href=#docker aria-label=docker>docker</a></li>
<li>
<a href=#docker-%e9%95%9c%e5%83%8f aria-label="docker 镜像">docker 镜像</a></li>
<li>
<a href=#%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92 aria-label=容器编排>容器编排</a></li>
<li>
<a href=#%e5%8e%9f%e7%90%86 aria-label=原理>原理</a></li>
<li>
<a href=#%e4%b8%bb%e8%a6%81%e4%be%9d%e8%b5%96-linux-%e4%be%9d%e8%b5%96%e4%b8%89%e5%a4%a7%e6%8a%80%e6%9c%af aria-label="主要依赖 Linux 依赖三大技术">主要依赖 Linux 依赖三大技术</a></li>
<li>
<a href=#%e5%92%8c%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%af%94%e8%be%83 aria-label=和虚拟机比较>和虚拟机比较</a></li></ul>
<li>
<a href=#%e7%ae%80%e5%8d%95%e4%bd%bf%e7%94%a8 aria-label=简单使用>简单使用</a><ul>
<li>
<a href=#%e5%a3%b0%e6%98%8e%e5%bc%8f-api-%e5%92%8c-kubernetes-%e7%bc%96%e7%a8%8b%e8%8c%83%e5%bc%8f aria-label="声明式 API 和 Kubernetes 编程范式">声明式 API 和 Kubernetes 编程范式</a></li>
<li>
<a href=#rbac aria-label=RBAC>RBAC</a></li>
<li>
<a href=#%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b aria-label=网络模型>网络模型</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h3 id=docker>docker<a hidden class=anchor aria-hidden=true href=#docker>#</a></h3>
<p>利用 Linux 的 cgroups 和 namespace，构建一个沙箱运行环境。</p>
<h3 id=docker-镜像>docker 镜像<a hidden class=anchor aria-hidden=true href=#docker-镜像>#</a></h3>
<p>其实就是一个压缩包，这个压缩包是由一个完整的操作系统的所有文件目录构成，包含了这个应用运行所需要的所有依赖，所以本地开发环境和测试环境是一样的。</p>
<p>解决了应用打包的根本性问题。</p>
<h3 id=容器编排>容器编排<a hidden class=anchor aria-hidden=true href=#容器编排>#</a></h3>
<p>对 Docker 容器的一系列定义、配置和创建动作的管理</p>
<blockquote>
<p>容器本身没有价值，有价值的是“容器编排”。</p>
</blockquote>
<h3 id=原理>原理<a hidden class=anchor aria-hidden=true href=#原理>#</a></h3>
<p>容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造一个“边界”。</p>
<p>在创建一个容器进程的时候，指定了这个进程所需要启动的一组 Namespace 参数，这样容器就只能看到当前 Namespace 所限定的资源、文件、设备、状态或配置。</p>
<p>Cgroups 主要作用是为一个进程组设置资源上限，如 CPU、内存、磁盘和带宽等。也可以设置进程优先级，审计，挂起，重启等。</p>
<p>因此，一个正在运行的 Docker 容器，其实就是一个启用了多个 Namespace 的应用进程，而这个进程能够使用的资源是由 Cgroups 来限制。</p>
<p>挂载在容器根目录上，用来为容器进程提供隔离后执行环境的文件系统，就是容器镜像，rootfs。</p>
<ul>
<li>启动 Namespace 配置</li>
<li>设置 Cgroups 参数</li>
<li>切换进程根目录 rootf</li>
</ul>
<p>docker 镜像设计时，引入了层（layer），用户制作镜像的每一步操作都会生成一个层，也就是一个增量的 rootfs。AuFS，所以就有了共享层，镜像不用那么大。</p>
<p>一个进程，可以选择加入到某个进程已有的 Namespace 当中，从而达到进入这个进程所在的容器的目的，这正是 docker exec 的实现原理。</p>
<p>volume 机制，允许你将宿主机上指定的目录或文件，挂载到容器里面进行读取和修改操作。</p>
<h3 id=主要依赖-linux-依赖三大技术>主要依赖 Linux 依赖三大技术<a hidden class=anchor aria-hidden=true href=#主要依赖-linux-依赖三大技术>#</a></h3>
<ul>
<li>Namespace</li>
<li>Cgroups</li>
<li>rootfs</li>
</ul>
<h3 id=和虚拟机比较>和虚拟机比较<a hidden class=anchor aria-hidden=true href=#和虚拟机比较>#</a></h3>
<p>虚拟机是通过硬件虚拟化功能，模拟一套操作系统所需要的各种硬件，如 CPU、内存、IO 设备等，然后安装一个新的操作系统。</p>
<p>docker 是利用 Linux 的 Namespace 原理，帮助用户启动的还是系统的应用进程，只是加了一些参数，限制其能看到的资源。因此相对于虚拟机资源消耗更小，而且轻量级，敏捷高性能。</p>
<p>不过缺点就是隔离不彻底，多个容器进程公用宿主机操作系统内核。有些资源和对象不可以被 Namespace 化的，如时间。</p>
<p>kubernetes 要解决的问题</p>
<p>编排？调度？容器云？集群管理？</p>
<p><img loading=lazy src=https://ws3.sinaimg.cn/large/006tNbRwgy1fw117whrc6j31hc0u0gq5.jpg alt>
</p>
<ul>
<li>master
<ul>
<li>kube-apiserver：API 服务</li>
<li>kube-scheduler：调度</li>
<li>kube-controller-manager：编排</li>
</ul>
</li>
<li>node
<ul>
<li>kubelet：同容器运行时打交道。依赖于 CRI（container runtime interface 容器运行接口）远程调用接口，这个接口定义了容器运行时的各项核心操作。</li>
</ul>
</li>
<li>etcd</li>
</ul>
<p>运行在大规模集群中的各种任务之间，实际存在各种各样的关系。这些关系的处理，才是作业编排和管理系统最困难的地方。</p>
<p>sudo</p>
<ul>
<li>首先，通过一个编排对象，如 pod，job 或 cronjob 等，来描述你试图管理的应用；</li>
<li>然后，再为它定义一些服务对象，如 service，secret，autoscaler 等。这些对象，会负责具体的平台级功能。</li>
</ul>
<p>这种使用方法，就是所谓的“声明式 API”。这种 API 对应的编排对象和服务对象，都是 k8s 项目中的 API 对象。</p>
<h2 id=简单使用>简单使用<a hidden class=anchor aria-hidden=true href=#简单使用>#</a></h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain>kubectl create -f 我的配置文件
</code></pre></div><p>pod 就是 k8s 世界中的应用，而一个应用可以由多个容器组成。</p>
<p>使用一个 API 对象管理另一个 API 对象的方法，叫控制器模式。</p>
<p>每个 API 对象都有一个 metadata 字段，这个字段是 API 对象的标识，即元数据。主要用到的是 labels，spec.selector.matchLabels 就是 k8s 过滤的规则。与 labels 同层级的是 annotations，这是由 k8s 所感兴趣的，而不是用户。</p>
<p>一个 k8s 的 API 对象都有 metadata 和 spec 两个部分。前者放的是对象的元数据，对所有 API 对象来讲，这部分的字段和格式基本一样；而后者存放的是属于这个对象独有的定义，用来描述它所要表达的功能。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain>$ kubectl create -f nginx-deployment.yaml

$ kubectl get pods -l app=nginx
NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-67594d6bf6-9gdvr   1/1       Running   0          10m
nginx-deployment-67594d6bf6-v6j7w   1/1       Running   0          10m

$ kubectl describe pod nginx-deployment-67594d6bf6-9gdvr
Name:               nginx-deployment-67594d6bf6-9gdvr
Namespace:          default
Priority:           0
PriorityClassName:  &lt;none&gt;
Node:               node-1/10.168.0.3
Start Time:         Thu, 16 Aug 2018 08:48:42 +0000
Labels:             app=nginx
                    pod-template-hash=2315082692
Annotations:        &lt;none&gt;
Status:             Running
IP:                 10.32.0.23
Controlled By:      ReplicaSet/nginx-deployment-67594d6bf6
...
Events:

  Type     Reason                  Age                From               Message

  ----     ------                  ----               ----               -------
  
  Normal   Scheduled               1m                 default-scheduler  Successfully assigned default/nginx-deployment-67594d6bf6-9gdvr to node-1
  Normal   Pulling                 25s                kubelet, node-1    pulling image &#34;nginx:1.7.9&#34;
  Normal   Pulled                  17s                kubelet, node-1    Successfully pulled image &#34;nginx:1.7.9&#34;
  Normal   Created                 17s                kubelet, node-1    Created container
  Normal   Started                 17s                kubelet, node-1    Started container


$ kubectl apply -f nginx-deployment.yaml

# 修改 nginx-deployment.yaml 的内容

$ kubectl apply -f nginx-deployment.yaml

</code></pre></div><p>在命令行中，所有 key-value 格式的参数，都使用“=“而不是”：“表示。</p>
<p>在 k8s 执行过程中，对 API 对象的所有重要操作，都会被记录在这个对象的 events 中。</p>
<p>在线业务</p>
<p>Deployment</p>
<p>StatefunSet</p>
<p>DaemonSet</p>
<p>离线业务</p>
<p>Job</p>
<p>restartPolicy 在 job 对象里只被允许设置为 never 和 onFailure；而在 Deployment 对象中，只被允许设置为 always。</p>
<h3 id=声明式-api-和-kubernetes-编程范式>声明式 API 和 Kubernetes 编程范式<a hidden class=anchor aria-hidden=true href=#声明式-api-和-kubernetes-编程范式>#</a></h3>
<p>创建一个两个 Nginx 容器的步骤：</p>
<p>首先写一个 Deployment 的 yaml 文件：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-deployment</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#f92672>selector</span>:
    <span style=color:#f92672>matchLabels</span>:
      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>2</span>
  <span style=color:#f92672>template</span>:
    <span style=color:#f92672>metadata</span>:
      <span style=color:#f92672>labels</span>:
        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
    <span style=color:#f92672>spec</span>:
      <span style=color:#f92672>containers</span>:
      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx</span>
        <span style=color:#f92672>ports</span>:
        - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>80</span>

</code></pre></div><p>然后使用 kubectl create 命令在 Kubernetes 中创建一个 Deployment 对象：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain>kubectl create -f nginx.yaml
</code></pre></div><p>这样两个 Nginx pod 就运行起来了。</p>
<p>如果要更新的话，只需要修改 yaml 文件，然后使用 kubectl apply 命令更新，触发了滚动更新。</p>
<p>这个 apply 命令就是声明式 API。</p>
<p><img loading=lazy src=https://ws1.sinaimg.cn/large/006tNbRwgy1fwzjwny2o8j31hc0u0abg.jpg alt>
</p>
<p>istio 项目中，最根本的组件是运行在每个 pod 里的 envoy 容器。这个代理服务以 sidecar 容器的方式，把整个 pod 的进出流量接管下来。istio 的控制层的 pilot 组件，通过调用每个 envoy 的 API，实现微服务的治理。</p>
<p>利用 Kubernetes 的 Admission Control，也叫：Initializer，先创建一个 Pod，然后 istio 就是在 pod 的 yaml 给 Kubernetes 之后，自动加上 envoy 的配置。</p>
<ul>
<li>所谓的声明式，指的就是我只需要提交一个定义好的 API 对象来声明我所期望的状态是什么样子。</li>
<li>其次，声明式 API 允许有多个 API 写端，以 PATCH 的方式对 API 对象进行修改，而无需关心原始的 YAML 文件的内容。</li>
<li>最后，Kubernetes 基于对 API 对象的增删改查，在无需外界干预的情况下，完成对实际状态和期望状态的调谐。</li>
</ul>
<p>一个 API 对象在 etcd 中完整路径是由：group（API 组），version（API 版本）和 Resource（API 资源类型）三个部分组成的。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>batch/v2</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>CronJob</span>
</code></pre></div><p>batch 是组，v2 是版本，CronJob 是类型。</p>
<p>对于核心 API 对象：Pod，Node 等，不需要 group 的。非核心对象是需要组。</p>
<p>匹配规则就是：</p>
<p>/apis/batch/v2/CronJob</p>
<ul>
<li>
<p>首先 yaml 文件被提交给了 APIServer</p>
<p>过滤，授权，超时处理或审计等</p>
</li>
<li>
<p>进入路由流程</p>
<p>根据 yaml，按照匹配规则去找</p>
</li>
<li>
<p>根据定义，按照 yaml 中的字段，创建一个对象</p>
</li>
<li>
<p>进行 Amission 和 Validation。</p>
</li>
<li>
<p>把验证过的对象，序列化存到 etcd 中</p>
</li>
</ul>
<h3 id=rbac>RBAC<a hidden class=anchor aria-hidden=true href=#rbac>#</a></h3>
<p>基于角色的控制</p>
<p>role：角色，一组规则，定义 Kubernetes API 对象的操作权限</p>
<p>subject：被作用者，可以是人，也可以是机器，也可以是 Kubernetes 定义的用户</p>
<p>rolebinding：定义被作用者和角色的绑定关系</p>
<p>ServiceAccount，会被自动创建分配一个 secret 对象。</p>
<p>所谓角色就是一组权限规则列表，而我们分配这些权限的方式，就是通过创建 rolebinding 对象，将被作用者和权限列表进行绑定。</p>
<p>另外，与之对应的 ClusterRole 和 ClusterRoleBinding，则是 Kubernetes 集群级别的 Role 和 RoleBinding，它们的作用范围不受 Namespace 限制。</p>
<p>尽管被作用者有很多种（如 User、Group），但在我们平常使用的时候，最普遍的还是 ServiceAccount。</p>
<h3 id=网络模型>网络模型<a hidden class=anchor aria-hidden=true href=#网络模型>#</a></h3>
<p>Veth Pair 常常被用作连接不同 Network Namespace 的网线。veth pair 虚拟设备。总是以两张虚拟网卡形式成对出现。并且，从一个网卡中发出的数据包，可以直接出现在另一张网卡上，哪怕这两个网卡在不同的 network Namespace 里。</p>
<p>一旦一张虚拟网卡被插在网桥上，他就会变成该网桥的从设备。从设备会降级成为网桥的一个端口，不能处理数据包，只能接收流入的数据包交给对应的网桥。</p>
<p>两个容器的虚拟网卡都插在宿主机的一个网桥上，这个网桥就扮演一个交换机的角色。当两个容器进行网络交互时，从一个容器的发出请求到宿主机，由于 Veth Pair 的机制，另一个容器就看到有数据流入。</p>
<p>因此默认情况下，被限制在 network Namespace 的容器进程，实际就是通过 veth pair 设备+宿主机网桥的方式，实现了跟其他容器的数据交换。</p>
<p><img loading=lazy src=https://ws1.sinaimg.cn/large/006tNbRwgy1fwzjwayfppj31bn0rngn5.jpg alt=img>
</p>
<p>跨主通信，需要有一个集群公用的网桥，所有容器都连接到该网桥上，就可以相互通信，这就是 overlay network（覆盖网络）</p>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=https://zhenfeng-zhu.github.io/posts/go-best-practice/>
<span class=title>« Prev Page</span>
<br>
<span>go-best-practice</span>
</a>
<a class=next href=https://zhenfeng-zhu.github.io/posts/watchdog/>
<span class=title>Next Page »</span>
<br>
<span>watchdog</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share kubernetes on twitter" href="https://twitter.com/intent/tweet/?text=kubernetes&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fkubernetes%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share kubernetes on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fkubernetes%2f&title=kubernetes&summary=kubernetes&source=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fkubernetes%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share kubernetes on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fkubernetes%2f&title=kubernetes"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share kubernetes on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fkubernetes%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share kubernetes on whatsapp" href="https://api.whatsapp.com/send?text=kubernetes%20-%20https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fkubernetes%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share kubernetes on telegram" href="https://telegram.me/share/url?text=kubernetes&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fposts%2fkubernetes%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer><script src=https://utteranc.es/client.js repo=zhenfeng-zhu/zhenfeng-zhu.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://zhenfeng-zhu.github.io>Awesome Fenix</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>