<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Awesome Fenix</title><meta name=keywords content><meta name=description content="Posts - Awesome Fenix"><meta name=author content="Fenix"><link rel=canonical href=https://zhenfeng-zhu.github.io/post/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><link rel=icon href=https://zhenfeng-zhu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zhenfeng-zhu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zhenfeng-zhu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zhenfeng-zhu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zhenfeng-zhu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.98.0"><link rel=alternate type=application/rss+xml href=https://zhenfeng-zhu.github.io/post/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-216295420-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Posts"><meta property="og:description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod"><meta property="og:type" content="website"><meta property="og:url" content="https://zhenfeng-zhu.github.io/post/"><meta property="og:image" content="https://zhenfeng-zhu.github.io/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zhenfeng-zhu.github.io/papermod-cover.png"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://zhenfeng-zhu.github.io/post/"}]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8502076734034112" crossorigin=anonymous></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8502076734034112" crossorigin=anonymous></script><header class=header><nav class=nav><div class=logo><a href=https://zhenfeng-zhu.github.io accesskey=h title="Awesome Fenix (Alt + H)">Awesome Fenix</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://zhenfeng-zhu.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zhenfeng-zhu.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zhenfeng-zhu.github.io/about title=About><span>About</span></a></li><li><a href=https://zhenfeng-zhu.github.io/search/ title=🔍><span>🔍</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://zhenfeng-zhu.github.io>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>以太坊开发总结</h2></header><section class=entry-content><p>最近因公司项目需要，做为一个打杂工程师，操起键盘和笔记本开始了以太坊的踩坑之旅。以太坊的开发比较新，变化也比较多，还好有@cctanfujun的手把手带领下，半只脚踏入了以太坊的开发的大门。
在这篇文章中，我将会简单介绍一下以太坊的基本概念，以及我现在用到的一些工具，还有具体的一个开发流程。因为我还没有接触到如何上主链，所以这些都是基于测试链讲解。希望能给大家带来一些帮助。
什么是区块链
相信大家对区块链都有自己的理解，不仅仅是互联网公司，传统企业也在“币改转型”。
**简言之，区块链就是数据库。**它是特定数据的数据库，里面的数据不断增长，具有非凡特性：
一旦数据存储于数据库，永远都无法被修改或删除。区块链上的每个记录会被永久保存下来。 没有单独的个人或组织能维护该数据库。必须要上千个人才行，每个人都有数据库的副本。 什么是以太坊？
以太坊（英语：Ethereum）是一个开源的有智能合约功能的公共区块链平台[1][2]。通过其专用加密货币以太币（Ether，又称“以太币”）提供去中心化的虚拟机（称为“以太虚拟机”Ethereum Virtual Machine）来处理点对点合约。
为什么选择以太坊？
智能合约
代币
资料相对完善，相对容易开发
大佬对以太坊比较熟悉
大佬对以太坊比较熟悉
大佬对以太坊比较熟悉
重要的事情说三遍，有一个经验丰富的人带领，做东西肯定事半功倍。
自己动手写区块链
这里提供两个教程，一个是书，一个是视频。其中视频和书是对应的，不清楚是不是同一个作者。
Blockchain Tutorial
私有区块链，我们一起 GO
以太坊开发
由于我是专注于后端的开发，现在的技术栈是
node go 正式进入以太坊的开发。这是我这段时间接触到的一些资源：
go-ethereum：也就是 geth，官方的 go 版本的客户端
solidity：智能合约编程语言
truffle：智能合约的编程框架，基于 nodejs
Ganache：启动了多个节点本地私链
Rinkeby：以太坊测试链
Etherscan：以太坊区块链浏览器，可以查询交易...</p></section><footer class=entry-footer><span title="2018-08-10 18:57:09 +0000 UTC">August 10, 2018</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to 以太坊开发总结" href=https://zhenfeng-zhu.github.io/post/eth-tools/></a></article><article class=post-entry><header class=entry-header><h2>以太坊</h2></header><section class=entry-content><p>参与了公司的一个项目，上了以太坊，这里简单记录一下踩坑。
首先先把 go 的依赖下载下来：
1 go get -u -v github.com/ethereum/go-ethereum 有时候下载的很慢，可以从 github 上拉下来代码。
账户 以太坊的地址在离线状态下也可以创建到。
创建账户有两种方式：
以公钥和私钥的形式创建 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func CreateAccount() (string, error) { key, err := crypto.GenerateKey() if err != nil { log.Fatalln(err) return "", nil } address := crypto.PubkeyToAddress(key.PublicKey).Hex() log.Println("address: ", address) privateKey := hex....</p></section><footer class=entry-footer><span title="2018-08-07 20:09:26 +0000 UTC">August 7, 2018</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to 以太坊" href=https://zhenfeng-zhu.github.io/post/%E4%BB%A5%E5%A4%AA%E5%9D%8A/></a></article><article class=post-entry><header class=entry-header><h2>contract</h2></header><section class=entry-content><p>类型 Solidity 是静态类型的语言。
值类型 bool int/uint fixed/unfixed address balance 和 transfer send call, callcode 和 delegatecall byte bytes 和 string 十六进制 hex"0012" enum function 引用类型 数组
uint[]
结构体
struct
Map
mapping(key => value)
单元和全局变量 以太币的单位
在数字后面加上 wei、 finney、 szabo 或 ether。默认是 wei
时间单位
数字后面带有 seconds、 minutes、 hours、 days、 weeks 和 years。默认是秒。
区块和交易...</p></section><footer class=entry-footer><span title="2018-08-03 14:32:03 +0000 UTC">August 3, 2018</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to contract" href=https://zhenfeng-zhu.github.io/post/contract/></a></article><article class=post-entry><header class=entry-header><h2>faas-provider</h2></header><section class=entry-content><p>faas-provider 是一个模板，只要实现了这个模板的接口，就可以自定义实现自己的 provider。
faas-provider OpenFaaS 官方提供了两套后台 provider：
Docker Swarm Kubernetes 这两者在部署和调用函数的时候流程图如下：
部署一个函数
调用一个函数
provider 要提供的一些 API 有：
List / Create / Delete 一个函数 /system/functions
方法: GET / POST / DELETE
获取一个函数 /system/function/{name:[-a-zA-Z_0-9]+}
方法: GET
伸缩一个函数 /system/scale-function/{name:[-a-zA-Z_0-9]+}
方法: POST
调用一个函数 /function/{name:[-a-zA-Z_0-9]+}
方法: POST
在 provider 的 server.go 的 serve 方法，可以看到这个 serve 方法创建了几个路由，接受一个 FaaSHandler 对象。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Serve load your handlers into the correct OpenFaaS route spec....</p></section><footer class=entry-footer><span title="2018-08-01 19:53:23 +0000 UTC">August 1, 2018</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to faas-provider" href=https://zhenfeng-zhu.github.io/post/faas-provider/></a></article><article class=post-entry><header class=entry-header><h2>gateway-reading</h2></header><section class=entry-content><p>OpenFaaS 的 Gateway 是一个 golang 实现的请求转发的网关，在这个网关服务中，主要有以下几个功能：
UI 部署函数 监控 自动伸缩 架构分析 从图中可以发现，当 Gateway 作为一个入口，当 CLI 或者 web 页面发来要部署或者调用一个函数的时候，Gateway 会将请求转发给 Provider，同时会将监控指标发给 Prometheus。AlterManager 会根据需求，调用 API 自动伸缩函数。
源码分析 依赖 1 2 3 4 5 6 7 github.com/gorilla/mux github.com/nats-io/go-nats-streaming github.com/nats-io/go-nats github.com/openfaas/nats-queue-worker github.com/prometheus/client_golang mux 是一个用来执行 http 请求的路由和分发的第三方扩展包。
go-nats-streaming，go-nats，nats-queue-worker 这三个依赖是异步函数的时候才会用到，在分析 queue-worker 的时候有说到 Gateway 也是一个发布者。
client_golang 是 Prometheus 的客户端。
项目结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 ├── Dockerfile ├── Dockerfile....</p></section><footer class=entry-footer><span title="2018-08-01 09:15:35 +0000 UTC">August 1, 2018</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to gateway-reading" href=https://zhenfeng-zhu.github.io/post/gateway-reading/></a></article><article class=post-entry><header class=entry-header><h2>NATS streaming</h2></header><section class=entry-content><p>市面上常见到的和 Nats 功能类似的消息通信系统有：
ActiveMQ（Java 编写）、KafKa（Scala 编写）、RabbitMq（Ruby 编写）、Nats（之前是 Ruby 编写现已修改为 Go）、Redis（C 语言编写）、Kestrel（Scala 编写不常用）、NSQ（Go 语言编写），这些消息通信系统在 Broker 吞吐量方面的比较：
可以看到 NATS 的吞吐量特别高， NATS 原来是使用 Ruby 编写，可以实现每秒 150k 消息，后来使用 Go 语言重写，能够达到每秒 8-11 百万个消息，整个程序很小只有 3M Docker image，它不支持持久化消息，如果你离线，你就不能获得消息。关于 NATS 的详细介绍，请参考上篇文章：NATS 简介
NATS Streaming NATS Streaming 是由 NATS 驱动的数据流系统，也是由 go 语言写成的，在保证吞吐量和时延的基础上，解决了 Nats 消息投递一致性的问题。nats streaming 可以和核心 nats 平台无缝嵌入，扩展和互动。
功能 除了 nats 平台的一些功能，nats streaming 还支持以下的：
增强的消息协议 消息/事件持久化 至少一次投递 发布者速率限制 每个订阅者的速率匹配/限制 可重复消费 持久订阅 使用 首先安装 nats-streaming-server 服务，有多种方式，这里介绍两种：
homebrew...</p></section><footer class=entry-footer><span title="2018-07-30 14:51:26 +0000 UTC">July 30, 2018</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to NATS streaming" href=https://zhenfeng-zhu.github.io/post/nats-streaming/></a></article><article class=post-entry><header class=entry-header><h2>nats 简介</h2></header><section class=entry-content><p>nats 是一个开源的，云原生的消息系统。Apcera，百度，西门子，VMware，HTC 和爱立信等公司都有在使用。
核心基于 EventMachine 开发，原理是基于消息发布订阅机制，每台服务器上的每个模块会根据自己的消息类别向 MessageBus 发布多个消息主题，而同时也向自己需要交互的模块，按照需要的主题订阅消息。能够达到每秒 8-11 百万个消息，整个程序很小只有 3M Docker image，它不支持持久化消息，如果你离线，你就不能获得消息。使用 nats streaming 可以做到持久化，缓存等功能。
NATS server nats 提供了一个 go 编写的轻量级服务器。发行版包括二进制和 docker 镜像
NATS clients
nats 官方提供的客户端有 Go，Node，Ruby，Java，C，C＃，NGINX 等。
NATS 设计目标
核心原则是性能，可伸缩和易用性。
高效 始终在线和可用 非常轻巧 支持多种质量的服务 支持各种消息传递模型和使用场景 NATS 使用场景 nats 是一个简单且强大的消息系统，为支持现代云原生架构设计。由于可伸缩性的复杂性，nats 旨在容易使用和实现，且能提供多种质量的服务。
一些适用 nats 的场景有：
高吞吐量的消息分散 —— 少数的生产者需要将数据发送给很多的消费者。 寻址和发现 —— 将数据发送给特定的应用实例，设备或者用户，也可用于发现并连接到基础架构中的实例，设备或用户。 命令和控制（控制面板）—— 向程序或设备发送指令，并从程序/设备中接收状态，如 SCADA，卫星遥感，物联网等。 负载均衡 —— 主要应用于程序会生成大量的请求，且可动态伸缩程序实例。 N 路可扩展性 —— 通信基础架构能够充分利用 go 的高效并发/调度机制，以增强水平和垂直的扩展性。 位置透明 —— 程序在各个地理位置上分布者大量实例，且你无法了解到程序之间的端点配置详情，及他们所生产或消费的数据。 容错 使用 nats-streaming 的附加场景有：...</p></section><footer class=entry-footer><span title="2018-07-30 11:15:39 +0000 UTC">July 30, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to nats 简介" href=https://zhenfeng-zhu.github.io/post/nats/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://github.com/openfaas/media/raw/master/OpenFaaS_Magnet_3_1_png.png alt></figure><header class=entry-header><h2>overview-of-openfaas</h2></header><section class=entry-content><p>OpenFaaS 概览 无服务器函数变得简单。
函数监视器 你可以通过添加函数监视器 (一个小型的 Golang HTTP 服务)把任何一个 Docker 镜像变成无服务器函数。 函数监视器是允许 HTTP 请求通过 STDIN 转发到目标进程的入口点。响应会从你应用写入 STDOUT 返回给调用者。 API 网关/UI 门户 API 网关为你的函数提供外部路由，并通过 Prometheus 收集云原生指标。 你的 API 网关将会根据需求更改 Docker Swarm 或 Kubernetes API 中的服务副本数来实现伸缩性。 UI 是允许你在浏览器中调用函数或者根据需要创建新的函数。 API 网关是一个 RESTful 形式的微服务，你可以在这里查看Swagger 文档。
命令行 Docker 中的任何容器或者进程都可以是 FaaS 中的一个无服务器函数。使用FaaS CLI ，你可以快速的部署函数。
可以从 Node.js, Python, Go 或者更多的语言模板中创建新的函数。如果你无法找到一个合适的模板，甚至可以使用一个 Dockerfile。
CLI 实际上是 API 网关的一个 RESTful 客户端。
在配置好 OpenFaaS 之后，你可以在这里开始学习 CLI开始学习 CLI...</p></section><footer class=entry-footer><span title="2018-07-26 17:41:33 +0000 UTC">July 26, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to overview-of-openfaas" href=https://zhenfeng-zhu.github.io/post/overview-of-openfaas/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://github.com/openfaas/media/raw/master/OpenFaaS_Magnet_3_1_png.png alt></figure><header class=entry-header><h2>OpenFaaS on Rancher 2.0</h2></header><section class=entry-content><p>这是一篇关于如何在 Rancher 2.0 上创建 OpenFaaS 栈的文章。我假设你已经准备好了 Rancher 2.0 集群，如果没有请按照官方文档创建一个。
下面的视频展示了如何创建 OpenFaaS 栈，并在实际中使用：
https://www.youtube.com/watch?v=kX8mXv5d1qg&feature=youtu.be
这里是创建栈的compose.yml文件：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 version: "2" services: alertmanager: image: functions/alertmanager:latest labels: io....</p></section><footer class=entry-footer><span title="2018-07-26 09:50:46 +0000 UTC">July 26, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to OpenFaaS on Rancher 2.0" href=https://zhenfeng-zhu.github.io/post/openfaas-on-rancher/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://github.com/openfaas/media/raw/master/OpenFaaS_Magnet_3_1_png.png alt></figure><header class=entry-header><h2>openfaas-workshop-lab4</h2></header><section class=entry-content><p>实验 4–更深入地使用函数 在开始本实验之前，为你的文件创建一个新的文件夹。由于本实验是建立在早期实验的基础上的，所以请复制 lab3。
1 2 $ cp -r lab3 lab4\ && cd lab4 通过环境变量注入配置 能够控制一个函数在运行时的行为方式是很有用的，我们至少可以通过两种方式来实现这一点。
在部署时 *在部署时设置环境变量
我们在Lab 3中用write_debug做了这个 - 你也可以在这里设置任何你想要的自定义环境变量 - 例如，如果你想为你的hello world函数配置一种语言，你可以引入一个spoken_language变量。
使用 HTTP 上下文–querystring / headers *使用 querystring 和 HTTP headers
另一个更动态的、可以在每个请求层面上改变的选项是使用查询字符串和 HTTP 头信息，两者都可以通过faas-cli或curl传递。
这些头信息通过环境变量暴露出来，所以它们很容易在你的函数中被使用。所以任何头信息都以Http_为前缀，所有-连字符都被替换成_下划线。
让我们用 querystring 和一个列出所有环境变量的函数来试试。
使用 BusyBox 的内置命令，部署一个打印环境变量的函数。 1 faas-cli deploy --name env --fprocess="env" --image="function/alpine:latest" 用一个查询字符串调用该函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ echo "" | faas-cli invoke env --query workshop=1 PATH=/usr/local/bin:/usr/local/bin:/usr/bin:/sbin:/bin HOSTNAME=05e8db360c5a fprocess=env HOME=/root Http_Connection=close Http_Content_Type=text/plain Http_X_Call_Id=cdbed396-a20a-43fe-9123-1d5a122c976d Http_X_Forwarded_For=10....</p></section><footer class=entry-footer><span title="2018-07-02 09:32:59 +0000 UTC">July 2, 2018</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to openfaas-workshop-lab4" href=https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab4/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://zhenfeng-zhu.github.io/post/page/13/>« Prev Page</a>
<a class=next href=https://zhenfeng-zhu.github.io/post/page/15/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=https://zhenfeng-zhu.github.io>Awesome Fenix</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>