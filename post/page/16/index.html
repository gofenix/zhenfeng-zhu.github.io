<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Awesome Fenix</title><meta name=keywords content><meta name=description content="Posts - Awesome Fenix"><meta name=author content="Fenix"><link rel=canonical href=https://zhenfeng-zhu.github.io/post/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><link rel=icon href=https://zhenfeng-zhu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zhenfeng-zhu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zhenfeng-zhu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zhenfeng-zhu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zhenfeng-zhu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.98.0"><link rel=alternate type=application/rss+xml href=https://zhenfeng-zhu.github.io/post/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-216295420-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Posts"><meta property="og:description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod"><meta property="og:type" content="website"><meta property="og:url" content="https://zhenfeng-zhu.github.io/post/"><meta property="og:image" content="https://zhenfeng-zhu.github.io/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zhenfeng-zhu.github.io/papermod-cover.png"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://zhenfeng-zhu.github.io/post/"}]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8502076734034112" crossorigin=anonymous></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8502076734034112" crossorigin=anonymous></script><header class=header><nav class=nav><div class=logo><a href=https://zhenfeng-zhu.github.io accesskey=h title="Awesome Fenix (Alt + H)">Awesome Fenix</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://zhenfeng-zhu.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zhenfeng-zhu.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zhenfeng-zhu.github.io/about title=About><span>About</span></a></li><li><a href=https://zhenfeng-zhu.github.io/search/ title=🔍><span>🔍</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://zhenfeng-zhu.github.io>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>node 的 cluster</h2></header><section class=entry-content><p>我们知道 js 是运行单线程的，也就是说一个 node 进程只能运行在一个 cpu 上。那么如果用 node 来做 web server 的话，就无法享受到多核运算的好处。
一个问题就是：
1 如何榨干服务器资源，利用多核CPU的并发优势。 node 官方提供的解决方案是 cluster。
1 cluster 是什么 简单来说：
在服务器上同时启动多个进程。 每个进程都跑的是同一份源码。 这些进程可以同时监听一个端口。 其中：
负责启动其他进程的叫做 master 进程，不做具体工作，只负责启动其他进程。 其他被启动的叫 worker 进程。他们接收请求，对外提供服务。 worker 进程的数量一般根据服务器的 cpu 核数来决定，这样就可以完美利用多核资源。 以下是官方文档的一个例子：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 const cluster = require('cluster'); const http = require('http'); const numCPUs = require('os')....</p></section><footer class=entry-footer><span title="2018-05-05 15:45:47 +0000 UTC">May 5, 2018</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to node 的 cluster" href=https://zhenfeng-zhu.github.io/post/node%E7%9A%84cluster/></a></article><article class=post-entry><header class=entry-header><h2>node 踩坑</h2></header><section class=entry-content><p>module 首先第一个就是 es6 的 module。
看到别人写的
1 import { a } from "./module"; 所以自己也想要这么写，但是每次运行的时候都会报错。
1 2 3 4 5 6 7 8 9 // demo2.js export const a = "hello"; //demo1.js import { a } from "./demo2"; function hello() { console.log(a); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 zhuzhenfengdeMacBook-Pro :: node/node-example » node demo1....</p></section><footer class=entry-footer><span title="2018-05-05 15:32:59 +0000 UTC">May 5, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to node 踩坑" href=https://zhenfeng-zhu.github.io/post/node%E8%B8%A9%E5%9D%91/></a></article><article class=post-entry><header class=entry-header><h2>node 学习笔记</h2></header><section class=entry-content><p>写 node 也有一段时间了，整理一下学习笔记，共同进步
什么是 node 首先看一下什么是 node.js
Node 是一个服务器端 JavaScript Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效 Node.js 的包管理器 npm，是全球最大的开源库生态系统 模块系统是 node 最基本也是最常用的。一般可以分为四类：
原生模块 文件模块 第三方模块 自定义模块 node 社区崇尚 DRY 文化，即 Don’t repeate yourself。这种文化使得 node 的生态异常繁荣，同样也由于某些包的质量低下引来了一些诟病。
谈谈自定义模块 我们在写 node 程序的时候，一般都是在写自定义模块。
创建模块
1 2 3 4 5 6 7 // b.js function FunA(){ return "hello world"; } // 暴露方法FunA module....</p></section><footer class=entry-footer><span title="2018-04-22 15:41:21 +0000 UTC">April 22, 2018</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to node 学习笔记" href=https://zhenfeng-zhu.github.io/post/node-learning/></a></article><article class=post-entry><header class=entry-header><h2>node 的 redis 实战</h2></header><section class=entry-content><p>Node.js Redis 客户端模块 为了追新，这里我使用的 yarn，毕竟我是 HDD（面向热点编程）编程实践者。
模块安装
1 yarn add redis 模块使用实例
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const redis = require('redis') const client = redis.createClient('6379', '127.0.0.1') client.on("error", function (err) { console.log("Error " + err); }); client.set("string key", "string val", redis.print); client.hset("hash key", "hashtest 1", "some value", redis.print); client.hset(["hash key", "hashtest 2", "some other value"], redis....</p></section><footer class=entry-footer><span title="2018-04-13 10:00:12 +0000 UTC">April 13, 2018</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to node 的 redis 实战" href=https://zhenfeng-zhu.github.io/post/node%E7%9A%84redis%E5%AE%9E%E6%88%98/></a></article><article class=post-entry><header class=entry-header><h2>谈谈 web 框架</h2></header><section class=entry-content><p>这篇文章打的标签比较多，也基本涵盖了我所了解的一些知识，归纳总结一下自己对 web 框架的理解。自己了解的也不是很多，也请多多指教。
写程序免不了要做 web 相关的，现在由于前后端的分离，后端一般只提供 rest 接口，前端一般使用 node 来做渲染。在之前使用 jsp 那一套的时候，基本上都要写 html+js 的前端的一套，也要写后端 java 的 CRUD。
我理解的 web 框架中，大致是分为这么两类：
router 框架 mvc 框架 mvc 类框架 mvc，初级程序员面试笔试的时候必考的一个知识点。model-view-controller，即模型-视图-控制器。
m，模型主要用于封装与应用程序相关的数据以及对数据的处理方法。 v，在 View 中一般没有程序上的逻辑。为了实现 View 上的刷新功能，View 需要访问它监视的数据模型（Model），因此应该事先在被它监视的数据那里注册。 c，用于控制应用程序的流程。 我了解比较多的 mvc 框架是 spring mvc。spring、spring mvc 和 spring boot 等，他们并不是一个概念，也不是仅仅用于 web 开发。但是在这里我就不分那么细，统一用 spring 来代替。这里所说的 spring 都是指狭义上的 web 开发方面。
在做 web 开发的时候，项目目录一般是这样的：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $ tree [16:23:43] ....</p></section><footer class=entry-footer><span title="2018-04-08 16:01:48 +0000 UTC">April 8, 2018</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to 谈谈 web 框架" href=https://zhenfeng-zhu.github.io/post/%E8%B0%88%E8%B0%88web%E6%A1%86%E6%9E%B6/></a></article><article class=post-entry><header class=entry-header><h2>技术栈</h2></header><section class=entry-content><p>创业公司真的比较锻炼人，接触了很多的东西，视野开阔了，但是在某些时候自己疲于奔命，每个东西都是接触了一点点就被赶鸭子上架开始开发了。
技术栈 Docker docker 是一个容器，以前就看过 docker 相关的东西，但是没有仔细研究，docker 的命令会用一些，在工作中使用了，看了一本 docker 的书，能够编写 docker 的 compose 文件。
rancher rancher 是一个做容器管理的。我们把主机添加到 rancher 中，他就可以自动做到 LB，服务的发现编排。我们部署的时候只需要编写 catalog，他就可以自动发现 docker 应用，然后拉取镜像，部署到相关的机器上，很是方便。
aws 近期主要是对 aws 的进行公司服务的部署，搭建一套 rancher 的环境。aws 的服务特别多，ec2 是实例主机，就和虚拟机一样，VPC 就像机房，ec2 依托于 VPC 而存在，在这基础上又了解了子网、DHCP 弹性 IP 等等。
kotlin 之前自己用 kotlin 开发过一个博客，对 kotlin 的感觉是有些东西写的很爽，但是还是觉得 java 好用一些，对 kotlin 的态度是用不用都无所谓。
guice 这个我之前都读错了，我读成了盖斯，其实是和果汁的英文发音很像，ju 斯。只是一个依赖注入框架，只是单纯的去做 DI，比 spring 更轻量级一些。
需要我们编写 AppModule.java 去手动配置哪个类注入哪个类。
rxjava rxjava 我都没有找到一个系统的教程，不知道该从哪里学习。...</p></section><footer class=entry-footer><span title="2018-04-05 09:49:06 +0000 UTC">April 5, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to 技术栈" href=https://zhenfeng-zhu.github.io/post/%E6%8A%80%E6%9C%AF%E6%A0%88/></a></article><article class=post-entry><header class=entry-header><h2>同步一个 fork</h2></header><section class=entry-content><p>具体方法 Configuring a remote for a fork 给 fork 配置一个 remote 主要使用 git remote -v 查看远程状态。 1 2 3 git remote -v # origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) # origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) 添加一个将被同步给 fork 远程的上游仓库 1 git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git 再次查看状态确认是否配置成功。 1 2 3 4 5 git remote -v # origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) # origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) # upstream https://github....</p></section><footer class=entry-footer><span title="2018-04-04 16:01:31 +0000 UTC">April 4, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to 同步一个 fork" href=https://zhenfeng-zhu.github.io/post/%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA-fork/></a></article><article class=post-entry><header class=entry-header><h2>Go 语言体会</h2></header><section class=entry-content><p>最近公司要统一技术栈，在 kotlin 和 go 之间选。我心里是比较倾向 go 的，主要有如下几点体会。
语言简单，上手快。 gorotuine 易发布 垃圾回收 约定大于配置 我最早听说协程，是在大三找实习的时候，那个时候面试会问线程和进程的关系，问的深一些就是协程和线程的区别。游戏公司基本都用 lua，看了 lua 的资料后，对协程有了一些自己的了解，随后就是在做 Unity 相关的开发，在 unity 中使用了很多的协程，但是在 unity 中使用的协程好像跟主流的不太一样，在看了 go 之后，豁然开朗。
goroutine 使用的内存比线程更少，go 在运行的时候会自动在配置的一组逻辑处理器上调度执行。比如：
1 2 3 4 5 func log(msg string){ ... } go log("") 使用关键字 go，即可让 log 函数在一个 goroutine 里执行了。
并发最难的部分是要确保其他并发运行的进程、线程或者 goroutine 不会以外的修改数据。go 使用了 Channel 的方式来解决这个问题。对于通道模式，保证同一时刻只会有一个 goroutine 修改数据。
说起 go 的语言简单，其实主要是他的类型比较简单。go 使用的是组合模式，只需要将一个类型嵌入到另外一个类型就可以复用所有的功能。而且 go 还具有独特的接口实现机制，允许用户对行为进行建模，在 go 中不需要声明某个类型实现了某个接口，编译器会自动判断一个实例是使用什么接口。
对于 java 来说，所有的设计都是围绕着接口展开，于是在设计模式中，就是面向接口编程：...</p></section><footer class=entry-footer><span title="2018-04-04 13:48:57 +0000 UTC">April 4, 2018</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to Go 语言体会" href=https://zhenfeng-zhu.github.io/post/go%E8%AF%AD%E8%A8%80%E4%BD%93%E4%BC%9A/></a></article><article class=post-entry><header class=entry-header><h2>关于时间管理</h2></header><section class=entry-content><p>主动管理时间，敢于说不。
有目标向前看，没目标向钱看。</p></section><footer class=entry-footer><span title="2018-03-25 20:28:42 +0000 UTC">March 25, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to 关于时间管理" href=https://zhenfeng-zhu.github.io/post/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/></a></article><article class=post-entry><header class=entry-header><h2>一致性哈希算法</h2></header><section class=entry-content><p>当我们在做数据库分库分表或者做分布式缓存的时候，不可避免的都会遇到一个问题：
如何将数据均匀的分散到各个节点中，并且尽量的在加减节点的时能使受影响的数据最少。
1 hash 取模 随机放置就不多说了。通常最容易想到的方案是哈希取模了。
可以将传入的 key 按照 $$ index=hash(key) % N $$ 这样来计算出需要存放的节点。
这样可以满足数据的均匀分配，但是这个算法的容错性和扩展性比较差。比如增加或者删除一个节点的时候，所有的 key 都要重新计算，显然这样的成本比较高，为此需要一个算法来满足均匀的同时也要有良好的容错性和扩展性。
2 一致性 hash 算法 一致性 hash 算法是将所有的哈希值构成了一个环，其范围是 0~2^32-1。如图：
之后将各个服务器节点散列到这个环上，可以用节点的 IP，hostname 这样唯一性的字段作为 key 进行 hash。散列之后如下：
之后需要将数据定位到对应的节点上，使用同样的 hash 函数将 key 也映射到这个环上。
这样就按照顺时针方向就可以将 k1 定位到 N1 节点，k2 定位到 N3 节点，k3 定位到 N2 节点。
2.1 容错性 假设 N1 宕机了：
依然根据顺时针方向，k2 和 k3 保持不变，只有 k1 被重新映射到了 N3。这样就很好的保证了容错性，当一个节点宕机时只会影响到少部分数据。
2.2 扩展性 当新增一个节点时：
在 N2 和 N3 之间新增了一个节点 N4，这时受影响的数据只有 k3，其余的数据也是保持不变。...</p></section><footer class=entry-footer><span title="2018-03-24 19:03:58 +0000 UTC">March 24, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix</footer><a class=entry-link aria-label="post link to 一致性哈希算法" href=https://zhenfeng-zhu.github.io/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://zhenfeng-zhu.github.io/post/page/15/>« Prev Page</a>
<a class=next href=https://zhenfeng-zhu.github.io/post/page/17/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=https://zhenfeng-zhu.github.io>Awesome Fenix</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>