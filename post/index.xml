<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Awesome Fenix</title>
    <link>https://zhenfeng-zhu.github.io/post/</link>
    <description>Recent content in Posts on Awesome Fenix</description>
    <image>
      <url>https://zhenfeng-zhu.github.io/papermod-cover.png</url>
      <link>https://zhenfeng-zhu.github.io/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 01 May 2022 13:09:23 +0800</lastBuildDate><atom:link href="https://zhenfeng-zhu.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Lsp Practice</title>
      <link>https://zhenfeng-zhu.github.io/post/lsp-practice/</link>
      <pubDate>Sun, 01 May 2022 13:09:23 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/lsp-practice/</guid>
      <description>我们在上一节主要讲了 lsp 的一些基本介绍和官网的例子，在这一讲中，我们自己来实现一个语言服务器。
准备工作 首先安装 yo 和 generator-code，他们是 vscode 扩展开发的脚手架。
1  npm install -g yo generator-code   然后
1  yo code   选择 ts 模板，进行开发。
修改 package.json 然后再 package.json 中这样改：
1 2 3  &amp;#34;activationEvents&amp;#34;: [  &amp;#34;onLanguage:plaintext&amp;#34; ]   这段的意思就是在检测到时文本类型文件的时候，就启动插件。
然后是设置 configuration：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25   &amp;#34;contributes&amp;#34;: {  &amp;#34;configuration&amp;#34;: {  &amp;#34;type&amp;#34;: &amp;#34;object&amp;#34;,  &amp;#34;title&amp;#34;: &amp;#34;Example configuration&amp;#34;,  &amp;#34;properties&amp;#34;: {  &amp;#34;languageServerExample.</description>
    </item>
    
    <item>
      <title>Lsp Intro</title>
      <link>https://zhenfeng-zhu.github.io/post/lsp-intro/</link>
      <pubDate>Sat, 30 Apr 2022 18:53:11 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/lsp-intro/</guid>
      <description>为什么是语言服务器 语言服务器是一种特殊的 Visual Studio Code 扩展，为许多编程语言的编辑体验提供动力。通过语言服务器，你可以实现自动完成、错误检查（诊断）、跳转到定义，以及 VS Code 中支持的许多其他语言功能。
然而，在实现对 VS Code 中语言功能的支持时，我们发现了三个常见的问题:
首先，语言服务器通常是用他们的本地编程语言实现的，这给他们与具有 Node.js 运行时间的 VS Code 集成带来了挑战。
此外，语言功能可能是资源密集型的。例如，为了正确验证一个文件，语言服务器需要解析大量的文件，为它们建立抽象语法树并进行静态程序分析。这些操作可能会产生大量的 CPU 和内存占用，我们需要确保 VS Code 的性能不受影响。
最后，将多种语言工具与多种代码编辑器整合在一起，可能会涉及大量的工作。从语言工具的角度来看，他们需要适应具有不同 API 的代码编辑器。从代码编辑器的角度来看，他们不能期望从语言工具中获得任何统一的 API。这使得在 N 个代码编辑器中实现对 M 种语言的语言支持成为 M*N 的工作。
为了解决这些问题，微软制定了语言服务器协议，它使语言工具和代码编辑器之间的通信标准化。这样，语言服务器可以用任何语言实现，并在自己的进程中运行，以避免性能成本，因为它们通过语言服务器协议与代码编辑器通信。此外，任何符合 LSP 的语言工具都可以与多个符合 LSP 的代码编辑器集成，任何符合 LSP 的代码编辑器都可以轻易地接上多个符合 LSP 的语言工具。LSP 对于语言工具供应商和代码编辑器供应商来说都是一种共赢。
实现一个语言服务器 概述 在 VS Code 中，一个语言服务器有两个部分：
 语言客户端。一个用 JavaScript/TypeScript 编写的普通 VS Code 扩展。这个扩展可以访问所有 VS Code 的命名空间 API。 语言服务器。一个在独立进程中运行的语言分析工具。  如上所述，在一个单独的进程中运行语言服务器有两个好处：
 分析工具可以用任何语言实现，只要它能按照语言服务器协议与语言客户端通信。 由于语言分析工具通常对 CPU 和内存的使用率很高，在单独的进程中运行它们可以避免性能成本。  下面是一个 VS Code 运行两个语言服务器扩展的例子：</description>
    </item>
    
    <item>
      <title>Crystal 1.4.0</title>
      <link>https://zhenfeng-zhu.github.io/post/crystal-1.4.0/</link>
      <pubDate>Sat, 23 Apr 2022 17:21:00 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/crystal-1.4.0/</guid>
      <description>为了庆祝我们心爱的语言的 1.X 系列的第一年，我们提供了一个新的版本，其中有几个 bug 的修复和改进。
下面我们列出了最重要或最有趣的变化，但没有提到几个错误的修复和较小的改进。欲了解更多细节，请访问更新日志。那些对新的解释器感到兴奋的人可能会高兴地发现正在进行的改进工作。
预建包可以在 GitHub Releases 和我们的官方发布渠道上找到。安装说明见 crystal-lang.org/install。
像往常一样，突破性的改动会用⚠️标记。
统计资料 在这个版本中，我们包含了自 1.3.2 版本以来由 31 位贡献者所做的 132 项修改。我们感谢所有为改进语言所做的努力 ❤️
对 WASM 的支持 1.4.0 版目前只支持编译成 WebAssembly（将程序与基于 WASI 的 LibC 连接）。有几个重要的部分缺失；请查看#10870 了解详情。最新的试用说明是。
写一个简单的 crystal 程序，比方说。
1  puts &amp;#34;Hello WebAssembly!&amp;#34;   并将其命名为 main.cr。你也可以尝试更复杂的程序，但请记住，这仍然是实验性的，还没有准备好用于生产。
你需要在你的系统上安装 wasm-ld，它是来自 LLVM 的 WebAssembly 连接程序。在一些系统上，它是通过安装 ld 来实现的。通过使用 wasm-ld &amp;ndash;version 确认它已经安装。也请检查它的版本是否与 Crystal 的 LLVM 版本相似（ crystal &amp;ndash;version）。
你将需要 libc 和 libpcre 编译到 wasm32-wasi 目标上。你可以在这里获取它们的预编译版本。检查 wasm32-wasi-libs.tar.gz 资产，下载并解压它。</description>
    </item>
    
    <item>
      <title>谷爱凌：我承认，我爱上了恐惧</title>
      <link>https://zhenfeng-zhu.github.io/post/%E6%88%91%E6%89%BF%E8%AE%A4%E6%88%91%E7%88%B1%E4%B8%8A%E4%BA%86%E6%81%90%E6%83%A7/</link>
      <pubDate>Sun, 27 Feb 2022 18:39:35 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E6%88%91%E6%89%BF%E8%AE%A4%E6%88%91%E7%88%B1%E4%B8%8A%E4%BA%86%E6%81%90%E6%83%A7/</guid>
      <description>在我迄今 18 年人生的后 10 年里，我一直在追寻着的是一种纷乱的、充满恐惧的爱。我是一名专业的自由式滑雪运动员，脚上的一双雪板、22 英尺长的 u 型池和各种特技动作是我肾上腺素的主要来源，也是极限运动中真正令人上瘾的核心要素。
正如所有那些能迷倒常人的恋人一样（至少是像我从小说中读到的那些一样，因为现实生活中我还缺乏相应的经验），你这个重要的另一半有时可能会很……反复无常。实际上，“恐惧”可以算是三种不同感觉的总称，那就是兴奋、不确定和压力。
我已经发现，如果这些感觉能被识别和积极地利用，那么每一种感觉中都有一些微妙的指标可以帮助你成功，而如果其原理被忽视，那么这些感觉可能就会是你受伤的前兆。
虽然从事极限运动的运动员很容易被贴上“无畏”或“任性”的标签，但无论是我为构思技巧而花费的无数个小时，还是在泡沫坑(泡沫粒子到处都是的那种)里和安全气囊上度过的无数时间都可以表明情况并非如此。
我们要违反自己的生物直觉，把自己置于风险之中。虽然我们会尽一切努力做好身体上的准备，但再多的安全网模拟训练也无法等同于我们从陡坡上起飞、把身体抛到空中并即将落地时所将面对的雪坡，它是不会讲情面的。
我们并非无视恐惧，而是要培养深刻的自我意识，并进行深思熟虑的风险评估，从而与恐惧建立起独特的关系。
这项工作的第一步叫做具象化：在我尝试一个新的技巧动作之前，我会感到胸腔（准确地说，是在我的喉咙底部和膈肌顶部之间）有一种紧张感。
我深吸一口气，闭上眼睛。当我爬上巨大的起飞坡道时，我会在想象中伸展我的双腿以最大限度地提高升力。然后，我要在脑海中描绘如何以相反的方向扭转我的上半身，产生扭矩，然后再让它朝另一个方向弹回来。
现在，在我的意识里，我已经是飞在空中的状态了。
我在跃起后第一时间就会看到自己的背后，然后身体旋转会把我的视线拽向头顶万里无云的天空。风声如同我耳朵里的一种音乐，每一个 360 度的旋转都在为我的运动提供音乐般的节拍。
当我的脚在我的身体下面时，我就可以在把身体拉到第二个空翻前的一瞬间发现最终落地的地点。当我回到可以面向前方的位置时，我会想象着我的腿在我的脚下摆动，并让雪鞋的前端承载着我的重量碰到地面。
我露出微笑，然后睁开眼睛，一个 1440 度的翻转动作就完成了。
在完成“具象化”的几秒之后，我胸腔中的紧迫感会有一阵上下的波动，然后开始扩散——这个时候，我们已经来到破茧成蝶的关键阶段。
兴奋感是肾上腺素的产物，也是我所酷爱和着迷的存在。我既有着对自己安全创造奇迹的信心，也会产生对即将到来的不可预知体验的兴奋感，二者的平衡非常不稳定。我听说这个状态可以被称为“入境（zone）”，去年秋天，当我成为历史上第一个完成 1440 度偏轴转体动作的的女性双板滑雪运动员时，我就曾体会过这样的心境。
不幸的是，你心中的不确定感往往很容易就会压倒自信心。
不完美的准备会使我的手心出汗，并使得我之前所说的那个感到紧张的位置被转移到自己的胃里，从而使你的每次呼吸都比上一次更浅。这种感觉不是恐慌，而是某种类似于畏惧的感觉。危险的信号会激发出进化的本能。
如果我选择忽略这个安全机制，我的身体可能会在空中不由自主地行动，旋转会失去控制，并迫使我为即将遭受的冲击做好准备，因为这个时候的我真的要恐惧了：如果完全投入这个动作，可能会产生灾难性的后果。
每个自由式滑雪运动员都要以识别出兴奋感和不确定感之间的细微差别为目标，以便在最大限度地发挥能力的同时，把受伤的风险减少到最小。
最后要讲的就是压力。这是一种用途可能会很广泛的能量源。在本文提到的与恐惧相关的几个方面中，压力是最主观的一个面。也就是说，一个人对于压力的体验会受到自身实践经验和思想观点的影响。
家人和朋友的期望，激烈竞争的时段，乃至于可能获得赞助的机遇，都可能为一个高压的外在环境提供支撑。对于那些能把握分寸的赛手来说，压力可以变成一种帮他们迎接挑战的积极力量。但压力也可能会凭借一己之力就让你一败涂地。
不过，对于这种埋藏在心底的、渴望“证明自己”的感觉，运动员既可能会选择压制它，也可能选择强化它，而这很大程度上要取决于他们的自信心。
作为一个刚刚成年的女运动员，我对于这方面还是很有些自豪的，我可以增强自己的自尊，并尽量减少自己对于外界期待的需求，从而控制我身边的压力。
无论孤身一人还是面向整个世界，我都专注于感恩当下、判断当下，并享受体育带给我的快乐。
虽说我个人和这个世界的视角总会随着时间的推移而演变，但有一件事是不会变的：无论时间过了多久，在恐惧面前的我都会是一个无可救药的浪漫主义者。</description>
    </item>
    
    <item>
      <title>如何提升沟通技能</title>
      <link>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E6%B2%9F%E9%80%9A%E6%8A%80%E8%83%BD/</link>
      <pubDate>Sun, 20 Feb 2022 20:42:37 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E6%B2%9F%E9%80%9A%E6%8A%80%E8%83%BD/</guid>
      <description>我们先来看一个真实案例：
（背景）某项目原定于 6 月 7 日完成，可是实际到 6 月 9 日才完成，于是研发经理刘备就找负责的工程师张飞沟通。
  刘备说：“咱们这个项目按计划 7 号完成，你 delay 了两天也不跟我说一声，我是最后一个知道的！”
  张飞说：“我跟负责项目的产品经理孔明说了啊，他也觉得没问题，大家没有异议就行了呗，项目不是成功发布了吗！”
  刘备说：“那也应该提前跟我说一声啊，我如果提前知道就会让子龙来帮你，最后也不至于 delay 两天。”
  张飞说：“我觉得我能搞定，你不要动不动就让子龙来帮我，这是对我的不信任。要不是最近孩子生病我也不会 delay。即便 delay 了，我也和合作方都沟通好了，什么事都没耽误。而且我已经尽最大努力了啊，你还要怎么样呢？信不过我的话，下次这样的项目你交给二哥去做吧！”
  刘备说：“我就是想让你提前告诉我一声，你急啥！”
  张飞说：“你先急的好不好！”
  ……
  你觉得接下来会发生什么事情呢？如果你是其中的刘备或者张飞，接下来你会怎么沟通呢？
在日常的沟通中，类似的场景数不胜数。有的会互怼下去，僵持不下；也有的会选择逃避，敷衍了事。但是这都达不到彼此沟通的意图和目的。那么，怎么沟通才能达到彼此的目的呢？
下面，我介绍一个工具，在沟通中，我们可以使用它来对齐彼此的信息、感受和意图，具体如下所示：
  事实（FACT）
 列举事实信息 确认对方的客观情况    感受（FEELING）
 对方对『事实』的感受和态度 双方对『事实』的论断是否一致    意图（FOCUS）
 对方的焦点在哪里，我的焦点在哪里 对方的意图是什么，我的意图是什么    共识
 是否达成共识，并确认一致 接下来怎么做    这个工具的前三步，其实就是“3F”倾听，只是在相互倾听的基础之上，又走到了第四步，去确认有没有达成共识。</description>
    </item>
    
    <item>
      <title>打造好用的 win 上开发体验</title>
      <link>https://zhenfeng-zhu.github.io/post/%E6%89%93%E9%80%A0%E5%A5%BD%E7%94%A8%E7%9A%84win%E4%B8%8A%E5%BC%80%E5%8F%91%E4%BD%93%E9%AA%8C/</link>
      <pubDate>Sat, 12 Feb 2022 22:22:28 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E6%89%93%E9%80%A0%E5%A5%BD%E7%94%A8%E7%9A%84win%E4%B8%8A%E5%BC%80%E5%8F%91%E4%BD%93%E9%AA%8C/</guid>
      <description>0x00：科学上网 如果不能够科学上网的话，整个开发体验将大打折扣。
此过程较为敏感，所以需要大家自行选择科学上网的方式。
0x01：基本可用的终端 https://gitforwindows.org/
git for windows 内嵌了 git bash，git bash 的使用体验和 linux 或 mac 的体验类似。
安装好之后，需要进入到 home 目录，编辑 .bashrc 文件，使终端也可以科学上网：
1 2  cd vim .bashrc   配置如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  function proxy_on(){  git config --global https.</description>
    </item>
    
    <item>
      <title>Flutter RatingBar</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_ratingbar/</link>
      <pubDate>Tue, 01 Feb 2022 21:01:17 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_ratingbar/</guid>
      <description>The RatingBar widget is used to show a rating or collect ratings from users (this is an interactive RatingBar). For example, you can use the RatingBar widget inside an e-commerce app to show ratings for a product.</description>
    </item>
    
    <item>
      <title>Flutter RatioButton</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_ratiobutton/</link>
      <pubDate>Tue, 01 Feb 2022 21:00:30 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_ratiobutton/</guid>
      <description>The RadioButton widget is used to allow a user to select one option from multiple selections. You can use the RadioButton widget for implementing a single selection such as gender selection, notification preferences, etc.</description>
    </item>
    
    <item>
      <title>Flutter Dropdown</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_dropdown/</link>
      <pubDate>Tue, 01 Feb 2022 20:59:39 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_dropdown/</guid>
      <description>The DropDown widget is used to allow a user to select from a list of items. The DropDown widget shows the currently selected item and opens up a list of options when you click on it. You can use the Dropdown widget for implementing a single selection such as language selection, shirt size, etc.</description>
    </item>
    
    <item>
      <title>Flutter TextField</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_textfield/</link>
      <pubDate>Tue, 01 Feb 2022 20:58:49 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_textfield/</guid>
      <description>The TextField widget allows users to input text into your app. You can use the TextField widget for building forms, send messages, dialogs, search, etc.</description>
    </item>
    
    <item>
      <title>Flutter ToggleIcon</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_toggleicon/</link>
      <pubDate>Tue, 01 Feb 2022 20:57:42 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_toggleicon/</guid>
      <description>The ToggleIcon widget is used to allow a user to switch between two icons that represent two different states. You can use the ToggleIcon widget to implement a feature such as an on-off button, like button, etc.</description>
    </item>
    
    <item>
      <title>Flutter CheckboxListTitle</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_checkboxlisttitle/</link>
      <pubDate>Tue, 01 Feb 2022 20:55:43 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_checkboxlisttitle/</guid>
      <description>The CheckboxListTile is a combination of Checkbox and ListTile. Tapping anywhere on the CheckboxListTile toggles the checkbox. You can use the CheckboxListTile to show a list of ToDo items to mark them as complete.</description>
    </item>
    
    <item>
      <title>Flutter SlidableListTitle</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_slidablelisttitle/</link>
      <pubDate>Tue, 01 Feb 2022 20:54:54 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_slidablelisttitle/</guid>
      <description>The SlidableListTile is a special type of ListTile widget that reveals a list of actions that can be taken on a ListTile when a user swipes right.</description>
    </item>
    
    <item>
      <title>Flutter ListTitle</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_listtitle/</link>
      <pubDate>Tue, 01 Feb 2022 20:54:13 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_listtitle/</guid>
      <description>The ListTile widget contains a Title, Subtitle, Leading Icon, and Trailing Icon. The ListTile widget is typically used to populate a ListView. For example, you can use the ListTile to show a list of To Do items or emails.</description>
    </item>
    
    <item>
      <title>Flutter ChoiceChips</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_choicechips/</link>
      <pubDate>Tue, 01 Feb 2022 20:53:02 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_choicechips/</guid>
      <description>The ChoiceChips widget is used to allow the selection of a single chip from a group of chips. Each chip represents has an icon and text. You can use the ChoiceChips widget to show the options that can be used to filter a list or to change the UI based on selection.</description>
    </item>
    
    <item>
      <title>Flutter Icon</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_icon/</link>
      <pubDate>Tue, 01 Feb 2022 20:52:09 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_icon/</guid>
      <description>The Icon widget is used to show a small image or a symbol. You can use the Icon widget to let users quickly understand the meaning of the text. For example, placing a location icon ( ) before the numbers such as 23.35, 79.57 helps users identify that the values are a latitude and longitude.</description>
    </item>
    
    <item>
      <title>Flutter IconButton</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_iconbutton/</link>
      <pubDate>Tue, 01 Feb 2022 20:44:57 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_iconbutton/</guid>
      <description>The IconButton widget allows users to take action with a single tap. Unlike the regular Button widget, an IconButton shows a small image or a symbol and does not include text. You can use the Icon widget to let users quickly understand the meaning of an action. For example, the delete action can be easily conveyed using the trash can icon which looks like this ( )</description>
    </item>
    
    <item>
      <title>Flutter Button</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_button/</link>
      <pubDate>Tue, 01 Feb 2022 20:44:14 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_button/</guid>
      <description>The Button widget allows users to take an action such as saving data, opening a new page, etc. It is one of the most widely used widgets in Flutter. You can use the Button widget in forms, dialogs, cards, etc.</description>
    </item>
    
    <item>
      <title>Flutter CircleImage</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_circleimage/</link>
      <pubDate>Tue, 01 Feb 2022 20:43:18 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_circleimage/</guid>
      <description>The CircleImage widget is used to show a circular image from uploaded assets or the URL link. The CircleImage widget can display the different types of images such as JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP.</description>
    </item>
    
    <item>
      <title>Flutter Image</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_image/</link>
      <pubDate>Tue, 01 Feb 2022 20:42:22 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_image/</guid>
      <description>The Image widget is used to show an image from uploaded assets or the URL link. The Image widget can display the different types of images such as JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP.</description>
    </item>
    
    <item>
      <title>Flutter Text</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_text/</link>
      <pubDate>Tue, 01 Feb 2022 20:41:31 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_text/</guid>
      <description>The Text widget is used to show text on the screen. It is one of the most frequently used widgets.</description>
    </item>
    
    <item>
      <title>Flutter FAB</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_fab/</link>
      <pubDate>Tue, 01 Feb 2022 20:40:30 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_fab/</guid>
      <description>The FloatingActionButton widget (also known as FAB) floats above the content on the screen and is tied to an action. The FAB widget is circular in shape and resides in the bottom right corner of the screen. You can use the FAB widget to perform the primary action on the screen, such as Add, Create, etc.</description>
    </item>
    
    <item>
      <title>Flutter EndDrawer</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_enddrawer/</link>
      <pubDate>Tue, 01 Feb 2022 20:39:17 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_enddrawer/</guid>
      <description>The EndDrawer is typically used to provide navigation to other pages. The EndDrawer opens up from the right side of the screen by swiping right-to-left or clicking the menu icon in the AppBar. The EndDrawer can be closed by clicking outside of the EndDrawer or by swiping left-to-right. You can use the EndDrawer widget when the space for showing the navigation options is not sufficient.</description>
    </item>
    
    <item>
      <title>Flutter Drawer</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_drawer/</link>
      <pubDate>Tue, 01 Feb 2022 20:38:17 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_drawer/</guid>
      <description>The Drawer widget is used to provide navigation to other pages. The Drawer opens up from the left side of the screen by swiping left-to-right or clicking the menu icon in the AppBar. The Drawer can be closed by clicking outside of the Drawer or by swiping left-to-right. You can use the Drawer widget when the space for showing the navigation options is not sufficient.</description>
    </item>
    
    <item>
      <title>Flutter AppBar</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_appbar/</link>
      <pubDate>Tue, 01 Feb 2022 20:36:43 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_appbar/</guid>
      <description>The AppBar widget is used to show the information and actions related to the current page. You can use the AppBar widget to display the menu icon, back button, page title, various actions such as share, search, delete, and so on.
The AppBar widget consists of three sections, Leading, Title, and Actions. The Leading section is typically used to show a clickable widget such as the back button, cancel icon, profile icon, menu icon, etc.</description>
    </item>
    
    <item>
      <title>Flutter Wrap</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_wrap/</link>
      <pubDate>Tue, 01 Feb 2022 20:35:59 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_wrap/</guid>
      <description>The Wrap widget is similar to Row and Column as it shows its children one after another. If there is not enough space to show your item, the Wrap widget will automatically place it in a new row or column.</description>
    </item>
    
    <item>
      <title>Flutter Container</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_container/</link>
      <pubDate>Tue, 01 Feb 2022 20:35:05 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_container/</guid>
      <description>The Container widget is like a box that allows you to add a background color, rounded corners, or set some size constraints to a child widget. You can use Containers to help create your UI structure. Containers can be helpful in dividing the screen into smaller logical parts.</description>
    </item>
    
    <item>
      <title>Flutter Divider</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_divider/</link>
      <pubDate>Tue, 01 Feb 2022 20:34:26 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_divider/</guid>
      <description>The Divider widget is a horizontal line that is used to visually separate widgets. You can use the Divider widget to create some space between a group of widgets or between the items in a ListView.</description>
    </item>
    
    <item>
      <title>Flutter PageView</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_pageview/</link>
      <pubDate>Tue, 01 Feb 2022 20:33:32 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_pageview/</guid>
      <description>The PageView widget is used to create swipeable pages. It contains a list of scrollable pages that you can swipe either horizontally or vertically. For example, you can use the PageView widget to create onboarding screens, an app that shows a short video on swipe up or down just like Instagram, TikTok, Youtube shorts, etc.</description>
    </item>
    
    <item>
      <title>Flutter TabBar</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_tabbar/</link>
      <pubDate>Tue, 01 Feb 2022 20:32:28 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_tabbar/</guid>
      <description>The TabBar widget is used to show different categories of content. You can use the TabBar widget to quickly glance at each option and move between the categories by swiping or clicking on the Tab.</description>
    </item>
    
    <item>
      <title>Flutter Spacer</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_spacer/</link>
      <pubDate>Tue, 01 Feb 2022 20:31:30 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_spacer/</guid>
      <description>The Spacer widget is used to insert a flexible empty space between the children of the Column and Row widget. If you want even space between your child widgets, you can add space by setting the Main Axis Alignment to Space Around, Space Evenly, and Space Between. If you want a more customized space between your child widgets (example below), you should use the Spacer Widget.
 The Spacer widget takes all of the available space so the Spacer Widget will have no effect on a Column or Row where the Main Axis Alignment is set to Space Around, Space Evenly, and Space Between.</description>
    </item>
    
    <item>
      <title>Flutter Card</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_card/</link>
      <pubDate>Tue, 01 Feb 2022 18:37:32 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_card/</guid>
      <description>The Card widget is used to represent some related information. For example, you can use a Card widget to show a Business card, restaurant information, movie details, etc. The Card widget is frequently used with a List to display the item information for a specific record.</description>
    </item>
    
    <item>
      <title>Flutter Gridview</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_gridview/</link>
      <pubDate>Tue, 01 Feb 2022 18:36:56 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_gridview/</guid>
      <description>The GridView widget is used to display a list of items in a grid or 2- dimensions (Both vertically and horizontally at the same time.) For example, you can use GridView to show a list of photos or a list of products.</description>
    </item>
    
    <item>
      <title>Flutter ListView</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_listview/</link>
      <pubDate>Tue, 01 Feb 2022 18:36:15 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_listview/</guid>
      <description>The ListView widget is used to show a large number of items as a scrollable list. ListView is an advanced version of the Column widget that automatically provides scrolling when the list of items won&amp;rsquo;t fit on the screen. You can use the ListView to show the list of items either vertically or horizontally.</description>
    </item>
    
    <item>
      <title>Flutter Stack</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_stack/</link>
      <pubDate>Tue, 01 Feb 2022 18:34:51 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_stack/</guid>
      <description>The Stack widget allows child widgets to overlap on top of each other. The last child of the Stack stays on top. Sometimes basic widgets such as Column and Row are not sufficient for creating a complex UI. For example, if want to show text on top of an image - you should consider using the Stack widget. The following figure helps you understand how the Stack widget is different from other widgets.</description>
    </item>
    
    <item>
      <title>Flutter Row</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_row/</link>
      <pubDate>Tue, 01 Feb 2022 18:32:45 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_row/</guid>
      <description>The Row widget is used to create a horizontal layout. It is one of the most used widgets. Here’s how the Row arranges its children:
As shown in the figure above, the Main Axis and the Cross Axis are two important properties of the Row. For a Row, the Main Axis runs horizontally and the Cross Axis runs vertically. By default, all the children inside of the Row will be arranged in a horizontal fashion.</description>
    </item>
    
    <item>
      <title>Flutter Columns</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_columns/</link>
      <pubDate>Tue, 01 Feb 2022 18:31:19 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_columns/</guid>
      <description>The Column widget is one of the most used widgets and is essential in creating a vertical layout for any UI. Here’s how the column arranges its children:
As shown in the figure above, the Main Axis and the Cross Axis are two important properties of the column. For a column, the Main Axis runs vertically and the Cross Axis runs horizontally. By default, all the children inside of the column will be arranged in a vertical fashion.</description>
    </item>
    
    <item>
      <title>打造文档</title>
      <link>https://zhenfeng-zhu.github.io/post/%E6%89%93%E9%80%A0%E6%96%87%E6%A1%A3/</link>
      <pubDate>Sun, 30 Jan 2022 15:26:35 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E6%89%93%E9%80%A0%E6%96%87%E6%A1%A3/</guid>
      <description>两种文档视角：需求视角和供给视角 需求视角：想想你的受众是谁，了解他们的期望值 管理者
 汇报上级
  业务整体情况 战略重心和资源投入 面临问题和解决办法  协作者
 业务流程节点中的一环，你的工作会影响 ta，或者 ta 的工作会影响你。
  业务整体情况 接下来你的哪些事情会影响到我的事情？我该怎么配合？  信息同步者
 他们大部分时间并不在业务流程节点中。
  业务整体情况，我就是想知道一下。  供给视角：把我做了什么展示给你看  特点：文档的整体结构和业务的二级部门架构高度相似，各个二级部门负责写一小块，最后找 PMO 缝合在一起。 陷阱：很容易失去重点，变成工作的流水账，春晚式汇报 缺点：对不熟悉的人来说，这些耦合关系和业务逻辑理解成本比较高，很容易听晕，但又不好意思现场提问，会后一知半解。 优点：事无巨细，面面俱到。  【总结】
 公司双月会：需求视角优先 内部 review：供给视角优先  聚焦：怎么把一块儿业务说清楚、讲明白 解法：用 2.5 个维度来叙述业务  维度 1：业务主线，概括性质的东西，偏粗 维度 2：从一个或几个维度对业务的 break down，让大家看到增长或下降的归因 维度 2.5：选一个最值得拿出来说的单点，往下钻，展开来说，增加信息丰富度，以小见大。  维度 1：业务整体状况，如何在最短的时间内让大家了解这个业务的进展  for 负责人：如果每天只有一分钟，你会关注哪些指标和事情进展？ for 三种角色：假设有且只有三个问题，你会问关于这个业务的什么问题？  想明白上述的两个问题，答案呼之欲出；想不出来，就继续想，和上级讨论，和协作方讨论，直到得出让你很踏实和自信的答案。
要求简单直接，让人秒懂。
维度 2：找到业务的增长公式，拆解开来看 深刻理解业务是起点，针对维度 1 里面的关键指标，把他们分解成一级增长公式。</description>
    </item>
    
    <item>
      <title>书单</title>
      <link>https://zhenfeng-zhu.github.io/post/%E4%B9%A6%E5%8D%95/</link>
      <pubDate>Sun, 30 Jan 2022 15:18:30 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E4%B9%A6%E5%8D%95/</guid>
      <description>一、理解自己之生理与心理健康
 肥胖代码 正念的奇迹 冥想的原理与实践进阶  二、理解自己之巅峰时刻
 跨越不可能 纳瓦尔宝典：财富和幸福指南 巨人的工具书  三、理解世界之复杂科学
 巴拉巴西成功定律 规模 直觉泵 如何解决复杂问题  四、理解世界之金融、投资、经济
 财富的起源 技术革命与金融资本 技术的本质 复杂经济学：经济思想的新框架 文明-现代化价值投资与中国 大衰退年代  五、理解世界之生活
 置身事内：中国政府与经济发展 中国的选择：中美博弈与战略抉择 中国的宗教  七、两本传记
 富兰克林传 乔布斯传  </description>
    </item>
    
    <item>
      <title>学习上瘾</title>
      <link>https://zhenfeng-zhu.github.io/post/%E5%AD%A6%E4%B9%A0%E4%B8%8A%E7%98%BE/</link>
      <pubDate>Sun, 30 Jan 2022 15:10:35 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E5%AD%A6%E4%B9%A0%E4%B8%8A%E7%98%BE/</guid>
      <description>最近两年，深感越来越多人患上了“毒鸡汤被迫害妄想症”，当别人抛出一个论点后，你下意识的将其归为“鸡汤”、“装逼”、“假正经”，虽然内心一时站上了道德高地并沾沾自喜，但长期坚持下来，你已经擅长了百毒不侵，这非常好，但这也是另一种自我绝食。
我倒是认为，放低一点对自我智识高地的维护，认真对待那些让你下意识心生厌恶的观点，会让自己心里少点戾气，顺便找到一些未来的机会。
不要试图自律 keep 的 slogan 叫“自律给我自由”，可现实生活中有多少人真的能坚持自律？
我问过很多坚持健身的人，他们并不是每天很痛苦的去健身房，而是每天迫不及待的去健身房，因为那里会让他们很爽。要是不信的话，你可以去找身边的人问问。
要了解“自律”这种意识看似很虚无缥缈，但所有的意识都是被大脑神经递质所控制的，我们应该从大脑神经递质层面，看该如何利用它们，而不是抵抗他们。
我们看一下这些神经递质是如何起作用的：
 多巴胺是大脑中最主要的奖励化学物质，催产素紧随其后，然而血清素、内啡肽、去甲肾上腺素和花生四烯乙醇胺也发挥着作用。 这些化学物质中的每一种所产生的愉悦感都会驱使我们采取行动，如果行动成功便有了正反馈，就会在记忆中强化该行为。
 正确的学习方式，不是依靠自律，而是要借助这些神经递质发挥作用。
为什么喜欢刷抖音和 B 站而不想刷学习 是那些让你产生好奇心的标题，比如那些人人都听过、没人真的懂的事情。
好奇心是生物学设计的起点。这是你对某事的基本兴趣，在神经化学上由一点去甲肾上腺素和多巴胺支撑。而好奇心本身就是一个强大的动力，同时它也是激情的基础成分，是一个更大的动力。
那什么样的内容让你看完后也觉得很爽呢？
太简单的内容会让你觉得好无聊，太复杂的内容又很枯燥看不懂，是那些你既有一些了解但又出乎你意料的内容，同时叙事手法又富有节奏感，不停的引发你情绪变化的内容。
利用好奇心让自己开始一次学习，利用心流让我们沉浸，最后用自洽的逻辑和结论完成终极暴击。
正确的刷学习方式 1、如何利用好奇心开始
学习就和刷视频一样，首先，你要有个让你好奇心的问题。
这一步可能是最难到大家的，毕竟学生时代的我们，习惯了在别人规定好的框架内看书、答题，早就没了好奇心。
对此，我的观点是，你不是失去了好奇心，只是找不到了好奇心，兴趣也不是天生的，而是后天培养的。
这的确挺难，在身边朋友中实践过一个可行的办法。
 1 拿一张纸，把你生活中感兴趣的事情全部列上去，大事小事都可以列； 2 找到这些事情的交叉点，以及弄清楚某个特定的交叉点是否真的足够有趣，这些交叉点，往往蕴含了可能爆发的好奇心； 3 怎么知道一个交叉点是完美的？去这些交叉点上“玩一玩”，真是是找一些东西玩一玩，而不是学一学。 4 用“公开的成功”激励再深入一点，人类是一种社会动物，我们要利用好身边人的正反馈，哪怕是发个朋友圈分享一下。
 上面的过程看似有些无趣，但请完整的把这四部流程走几遍，相信我，会或多或少的开启一点的。
2、如何利用心流让我们沉浸
心流是一个特别复杂的话题，这里推荐一本彻底讲清楚心流的书《the art of impossible》，但这里，只讲一个最核心的理论：心流区间。
前面提过，太简单的内容让人无聊，太难的内容让人痛苦，这就是心流区间的来源。
我们要解决的是那些不太难又不太容易的困惑，即你已经模模糊糊知道思路，但又不完全清楚解法的困惑。这样的困惑最容易让你体会到”学习过程的乐趣“。
而看书，是一个很容易产生心流状态的事情，但很多人明明启动了看书，但看不进去，核心原因是：你的书选错了。
记住这一点：任何让你看不进去的书，要么是书本身写的太烂了（就像一个电影选题很好但编剧太烂一样），要么就是你的知识结构还不足以支撑看懂这本书。
比如一个没有任何经济学概念的人去学习经济学原理，他是很难读下去的，即便勉强读下去是痛苦且很少输入的读下去。这种“硬骨头”应该赶紧放下，再选一本你感兴趣的书，找一本书能让你看的爽的书。
这也是《The Motivation Myth 动力神话》一书里的核心观点：小成功形成动力，动力促成更大的成功，这就是一个正反馈连锁反应。一般的改变思想和信念都是不可靠的。
相信脑科学的力量，你会读下去的。
3、利用正反馈让我们获得情绪的高潮
正反馈主要来源于两方面：
第一，大脑天性喜欢圆满、自洽、秩序、确定性。
整整齐齐的桌面让人爽心悦目，确定性的收获让人有安全感，其实，人的大脑也会因为困惑的问题被安插一个合理的逻辑而愉悦，这就是自洽，我们总想为一个问题找到其解释理由。
这也是所谓 aha ha moment 的魅力，持续的“学习→搞清楚问题”会持续的分泌多巴胺，进而会产生“学习上瘾”的感觉，就像“吸烟→烟被吸进和呼出” 的上瘾一样。这是大脑爱学习的原因之一。
大部分人非但没有上瘾，反而觉得很枯燥，核心是因为：没有品尝过“学习→搞清楚问题” 这一过程的正反馈快感，就像刚开始抽烟都觉得很恶心，而不是很爽。
所以在心流区间里看完一本解答你困惑的书，本身就是生理性的爽。
第二，通过公开的正反馈让你更爽
我知道很多人低调，厌恶高调的炫耀，但你要做的不是炫耀，而你要做的，是真诚的分享。</description>
    </item>
    
    <item>
      <title>如何让自己不忙不卷还有成长</title>
      <link>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B8%8D%E5%BF%99%E4%B8%8D%E5%8D%B7%E8%BF%98%E6%9C%89%E6%88%90%E9%95%BF/</link>
      <pubDate>Sun, 30 Jan 2022 14:39:04 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B8%8D%E5%BF%99%E4%B8%8D%E5%8D%B7%E8%BF%98%E6%9C%89%E6%88%90%E9%95%BF/</guid>
      <description>检查你是否落入了这些坏习惯 1、喜欢干事而不喜欢想事 （突然想起好像是王兴说的一句话，大多数人为了逃避真正的思考，愿意做任何事情。）
2、没搞清服务对象到底是谁 （你觉得是谁？为什么是 ta？你在帮 ta 解决什么问题？解决了能怎样？帮 ta 解决问题是不是你的最终目标？）
3、理念情怀主导，从感性和善意出发，但认识世界不够客观，科学分析缺失，问题和解法都禁不起捶问
4、平衡中庸，默认服从“程序正确”、“政治正确”，表面上平等尊重温情脉脉，实际缺少层层递进的、探求问题本质的讨论，追求和谐、不要出错&amp;gt; 制定正确清晰的目标并竭尽所能（逐渐变成“凑合”）
上面这些习惯，如果让你特别有感觉，那就要小心了！ 如果你一个感觉都没有，那更要小心了！！！（因为这些都是很常见的无意识的坏习惯，很容易陷入其中而不自知，需要有意识的训练自己的觉察能力）
超越问题，让问题不再是问题 管理的问题、组织的问题从来都不是有明确“单因单果”的问题，而是存在于错综复杂的组织系统，乃至更广泛的外部社会系统中的问题，基本上所有的工作、项目，都是一个“探索真问题的过程”，在这个过程里，持续、有意识地做深度思考和学习是比撸起袖子干事更重要的，如果疏于付出思考上的努力，题找错了、方向偏了，后面的也就别想了。
架在错误的问题上，项目即使没做坏，但也做不到多好。往坏了说，你错过了一个成功解决有价值问题的机会，浪费了你的时间、才华和资源。
至于我们为什么容易不自知地忽视这些“真思考”：
 从生理上讲，大脑是很不喜欢费力气思考的，因此我们往往会陷入快速基于主观思维惯性下结论的错误之中而不自知（take for granted）。除了那些天赋和修为极高的人，如果普通人想让成长更快，就需要有一个靠谱的科学方法论来指引自己。 从组织角度，在一个大组织里解决问题，似乎每个人对问题负有的责任也同时被稀释了，“我想了又有什么用？”，“这个问题该我去想吗？”，leader 觉得做事情的下属应该要主动想，下属觉得 leader 比我更负有思考的责任，再加上每个人都有很多事情在牵扯精力，“深度思考”渐渐似乎变少了。  一切从找对问题出发 让我们从常见的误区开始
偏差一：我们的问题 vs 目标对象的问题 第一种常见的偏差是，人们往往无法将自己认为的问题与目标服务对象认为的问题区分开，这是一个特别容易定位错误的地方，参考下图：
大家都懂，我们应该在我们自己和目标对象都认为是问题的地方采取行动，但实际工作起来，还是往往被“我们认为是问题，客户不认为是问题的问题”绊住。
 就像家长要求孩子好好吃饭，为 ta 不能好好吃饭而生气，可孩子可能就是零食吃多了，真的不饿也吃不下去 我们觉得某些地方存在不公平的问题，可在客户眼里，是不是那么公平可能并不重要也并不关键 我们觉得需要做某项能力提升的项目，可客户现在面临其他比能力提升更重要、更要紧的问题  这个时候，我们不是要费劲去给客户洗脑，而是应该仔细聆听对方的声音，以及更多相关方的声音，找出“真问题”以及背后的原因，对问题“去伪存真”，找到其中的逻辑关系，然后再决定要怎么办。
另外，有时我们确实能够看见真问题，但客户不够认同，这时候最应该做的事情，是寻找那些持有相同认知的人，然后和他们一起工作，一边做出一定成绩，一边启发和带动更多人。不用把精力纠结在为什么对方不认同这个事情上，然后让自己和团队消耗在这个不认同上。
偏差二：过程对象 vs 最终对象 第二种常见的偏差是，不能分辨“过程对象”和“最终对象”，容易在关注过程对象中迷失，不见初衷。
 上好大学是过程对象，人的充分发展是最终对象 学英语是过程对象，无障碍的交流、接触更多思想是最终对象 薪酬公平和有效激励是过程对象，让优秀的员工愿意和公司一起长期发展是最终对象 在商业组织里，业务的成功是最终对象，员工的满意度和员工的能力提升是过程对象。但人天然对距离自己更近和自己更相关的事物敏感，对远距离的目标不敏感。我们要关注员工的满意度和员工成长，这没有错，但不要疏忽了大家聚在一个公司里的目的是为解决某种问题提供商业服务，这是我们的首要目标和首要责任。  并不是说不应该从过程对象入手，而是我们始终不能忽略掉服务的最终对象是谁。
偏差三：笼统对象 vs 具体对象 第三种常见的偏差是，将问题概括化、笼统化，很多抽象的概念和大词，但具体是谁、遇到了什么问题，不得而知。这些词不一定是黑话，但和黑话效果类似，都阻碍了我们直达真正的问题。
尤其对管理问题的描述，太容易滑向笼统了。
 需要从文化和意识上，强调不要内卷 员工的安全感需要提升 我们需要平衡效率和质量、效率和公平的矛盾  如果我们对问题的界定过于笼统，解决思路也必然走向“宏大”，就没有办法做到小处着手，也难以得出禁得起拷问的、可操作的、逻辑上正确的行动。
偏差四：主观判断 vs 客观现象 我们几乎对看到的事实问题都会快速得出一个主观的判断和结论，但我们需要意识到，当我们把这些主观判断当成问题的时候，我们就已经犯了偏离问题本身的错误。</description>
    </item>
    
    <item>
      <title>如何增强做事的动机</title>
      <link>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E5%A2%9E%E5%BC%BA%E5%81%9A%E4%BA%8B%E7%9A%84%E5%8A%A8%E6%9C%BA/</link>
      <pubDate>Sun, 30 Jan 2022 14:33:12 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E5%A2%9E%E5%BC%BA%E5%81%9A%E4%BA%8B%E7%9A%84%E5%8A%A8%E6%9C%BA/</guid>
      <description>动机是一种强大的情感激励因素
动机=动力=自驱力=自我驱动力
动机=好奇心+激情+目标+自主性+掌控感。
自主的动机才是真动机 自主性是对追求你的激情和目的所需的渴望。
这种渴望的动机分为外在动机和内在动机，外在动机是你必须要做的工作，内在动机又称为自主动机，有研究发现，任何情况下，自主动机都会扼杀外在动机。自主动机是一种更强大的动力
好奇心、激情、目标是最大化自主性的基础 当我们因为&amp;quot;好奇心、激情、目标&amp;quot;而做我们正在做的事情时，我们正在正确地挖掘自主性。换句话说，寻求系统喜欢掌控自己究竟在寻求什么样的资源。这也是为什么我们从好奇心、激情和目标开始探索驱动力的原因。这三重奏建立了兴趣和享受&amp;ndash;通过好奇心和激情，然后通过目标来巩固核心信念和价值观。换句话说，好奇心、激情、目标是最大化自主性的基础。
自主性将我们变成一个更有效的自己 工作中增加自主性 谷歌用 20%的时间来挖掘这个驱动力，这意味着他们每周给人们 8 个小时的时间来追求一个他们热衷的想法。然而 3M 公司仅用 15%的时间就获得了惊人的成果，也就是每周只有一个下午的时间。
获得自主性提供的驱动力的提升，你需要自由控制你的睡眠、工作和运动时间表。你还需要自主地定期通过自己选择的活动来追逐心流。
理想的情况是，你的工作时间将用于促进你的目的的活动，而产生心流的活动类似于冲浪意味着它实际上是工作的休息。
如果这在你今天的生活中是不可能的，那么就从 3M 计划开始：将 15%的时间用于一个与你的核心激情和目的相一致的项目。15%大约是每周一个下午的时间，不过你可以很容易地把这个时间分成一对两个半小时的区块，得到类似的结果。</description>
    </item>
    
    <item>
      <title>如何增强掌控感</title>
      <link>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E5%A2%9E%E5%BC%BA%E6%8E%8C%E6%8E%A7%E6%84%9F/</link>
      <pubDate>Sun, 30 Jan 2022 11:56:28 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E5%A2%9E%E5%BC%BA%E6%8E%8C%E6%8E%A7%E6%84%9F/</guid>
      <description>15%的自主时间 人类最喜欢的就是把小胜利叠加在小胜利之上，再叠加在小胜利之上。在神经化学上，这些胜利会产生多巴胺。
要想真正驾驭掌控力作为一种动力，就把你生命中为自己划出的 15%的时间&amp;ndash;称之为你的自主时间&amp;ndash;花在推动挑战与技能的平衡上，努力在一些与好奇心、激情和目标一致的事情上做得更好一些。 开始追逐渐进式改进的高境界。迷上进步的多巴胺循环。
试着让今天更好一点，试着让明天更好一点。然后重复。再重复。
小成功促进动力 人是无法欺骗自己的下意识的。
很多时候拖延，不愿意做某件事情，是因为下意识觉得这个东西麻烦枯燥或者非常困难，但如果能够把事情拆解细分，能够理解每个阶段大概会有什么样的期待，什么时候会得到什么奖励，一旦理解通了，马上行动的动力就会强大很多。
所以缺乏行动力，很多时候本质还是来源于大脑对细节一无所知，缺乏一个相对细化的理解和期待。这时候不应当着急蛮干，而应当先尽量获取更多信息，获得对短期更加清晰的期待值，这样才能激励自己动起来。
如果不能集中注意力做自己有兴趣的事情，稍微松散下来，非理性大脑的一些负面情绪或者思考会偷偷的涌现到台前。这种负面情绪有它的平衡作用，但是负面情绪太多了，会降低人的内在动力，时间长了形成恶性循环，甚至出现忧郁情绪。所以不断寻找可以激发自己兴趣的事情去做，是提高生活质量的重要议题。
这就是《The Motivation Myth 动力神话》一书里的核心观点：小成功形成动力，动力促成更大的成功，这就是一个正反馈连锁反应。一般的改变思想和信念都是不可靠的。
所以把自己打造成一个多面手，更容易找到局部小成功，而给自己新的动力继续前进。从事非常狭隘的单一工作，容易卡壳，长期缺乏正反馈而气馁，或因太枯燥而没事找事弄得更糟（股市频繁交易）。</description>
    </item>
    
    <item>
      <title>抱怨</title>
      <link>https://zhenfeng-zhu.github.io/post/%E6%8A%B1%E6%80%A8/</link>
      <pubDate>Sun, 30 Jan 2022 11:32:47 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E6%8A%B1%E6%80%A8/</guid>
      <description>对问题或困境的无能为力，对他人有所渴求和寄托，期望他人帮助解决问题。同时，渴望别人读懂自己，亲近自己。
抱怨，其实是“要抱抱”。抱怨还经常伴有轻微的愤怒和对他人的攻击。不爱抱怨的人，在面对挫折和无法解决的问题时，他们能对自己的无能为力加以接纳，能明确地感知道自己哪些方面是有价值的，哪些方面是没有价值的，不需要求诸于他人的肯定和理解。
抱怨传递的信号是，将太多个人的价值需求寄托到了别人身上，没有试图去寻找自己应对问题的策略，需要加强个人解决问题的行动力和个人价值感。（说白了，人还是得靠自己呀！）</description>
    </item>
    
    <item>
      <title>嫉妒</title>
      <link>https://zhenfeng-zhu.github.io/post/%E5%AB%89%E5%A6%92/</link>
      <pubDate>Sun, 30 Jan 2022 11:32:43 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E5%AB%89%E5%A6%92/</guid>
      <description>嫉妒是，你有而我没有，让我觉得自己很没有价值。
自我价值感越完善，嫉妒出现的概率越低，也不倾向于通过和他人比较，来填补自己的价值感。如果倾向于总是和别人比较，本质原因是自我意识与他人分化不够，自我边界不清晰，而大部分人的自我意识都不是很完善，我们与他人之间的分化做得并不好，因为分化不够，导致我们经常与他人发生混淆。
嫉妒情绪其实是自我评定系统出了问题，对自己没有客观的认识，不能准确地提炼出自我需求和自我意识，当我们有一条自己坚信的自我价值实现的道路，我们也就无需嫉妒他人。嫉妒可以升华为羡慕和崇拜，这是建设性的积极的转化。通过羡慕和崇拜他人，促使我们向他人学习，实现自我价值的提升。
嫉妒情绪提醒我们，混淆了自己与他人的边界，应该试图去建立自己独特的价值感，将自己与他人区别开。</description>
    </item>
    
    <item>
      <title>愤怒</title>
      <link>https://zhenfeng-zhu.github.io/post/%E6%84%A4%E6%80%92/</link>
      <pubDate>Sun, 30 Jan 2022 11:32:38 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E6%84%A4%E6%80%92/</guid>
      <description>一种具有强烈刺激性的情绪，由刺激事件引发了心理上极度的挫折感，体现在价值感和安全感都丧失了，引发了强烈的不满，进而让人爆发出反抗他人的本能反应。（有一句话，愤怒的背后是虚弱。）
愤怒会让人暂时失去理智。
愤怒情绪表现为：强烈的对外攻击性、破坏性、伴随有肢体语言，行为突然失控，瞬间失去理智，有时还有对内的攻击性。愤怒的对内攻击可以理解为自我伤害，是把对外的愤怒转化为对自己的愤怒，通过自我攻击自我伤害来达到伤害对方的效果。
愤怒的核心是「恐惧情绪的蔓延」，意图用一种转变爆发的方式来释放恐惧情绪，出于对安全感被伤害的保护。
愤怒情绪告诉我们：面对当前的问题的力量是不足的。我们的力量不足以支撑我们的自尊和自信，需要调动体内更大的力量来应对问题。
 易激惹状态： 人在爆发前的状态，表现是一点小事就情绪激动了，提示的信号是，你的情绪容量已经满了，急需释放一些情绪，并且尽量不要再受到刺激。情绪爆发也是一种情绪释放的方式，但杀伤力有点大，不是最好的方式。检视一下自己内在的情绪都有什么，然后一一将其用正常的渠道、杀伤力小一点的方式排遣掉。
 提前觉察自己的情绪临界点，当达到易激惹状态之后迅速寻找办法解决，不让自己失去理智地爆发。当然，更好的方式是再提前一点，不要让自己发展到易激惹状态。</description>
    </item>
    
    <item>
      <title>恐惧</title>
      <link>https://zhenfeng-zhu.github.io/post/%E6%81%90%E6%83%A7/</link>
      <pubDate>Sun, 30 Jan 2022 11:32:32 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E6%81%90%E6%83%A7/</guid>
      <description>恐惧的本质是自我安全感受到了威胁，而理性脑无法解决这种威胁，于是代之以情绪的方法来应对。
 恐惧的根源是人的失策或失能，人在面对一种状况时失去了应对的策略和能力，这种失策和失能让人的焦虑情绪无法化解，进而演变成或逃避或攻击的行为（逃避，也是一种“攻击”）。通过攻击，人们能够营造一种臆想中强大的自己来获得自己内心的安全感。（此处@经常发脾气的同学，该做觉察和反思了）
恐惧带给我们的信息是，你当前解决问题的资源、力量或策略是不够的，你需要组织资源，调整策略、调动力量来重新解决问题。
承认自己的害怕和需要帮助，其实是一种强大的表现，不丢人。</description>
    </item>
    
    <item>
      <title>抑郁</title>
      <link>https://zhenfeng-zhu.github.io/post/%E6%8A%91%E9%83%81/</link>
      <pubDate>Sun, 30 Jan 2022 11:28:47 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E6%8A%91%E9%83%81/</guid>
      <description>抑郁情绪是在对现实毫无对策的时候出现的，它在提醒我们当前解决问题的策略是无效的，我们需要寻找另外一种有效的应对策略。
 抑郁产生的模式是，我们付出努力了➡️对事情的期待没有得到满足、产生失落➡️失落无法排遣，产生一种无助➡️无助给自己内心带来冲击，产生自我怀疑和自我抛弃➡️最终认定自身没价值，努力没有价值，事情没有价值，一切都没有价值，陷入抑郁。
抑郁的核心是价值感和意义感的缺失。
抑郁的表现：认知消极（“这都什么玩意儿”），情绪低落（“没意思，一切都没意思”），意志力减退，对任务的启动困难（思维迟钝），记忆力和判断力减退，自我隔离。
抑郁传递的信息：你当前正面对着严重的问题，而且，你解决问题的方法是无效的❌。你必须更换解决问题的策略，尤其是正视问题的存在，并迫使自己更加灵活地面对问题。（通常固执的人更容易抑郁，而思维比较灵活的人，即使抑郁了，也容易走出来。让自己不再那么“刚”，弹性一点。）
抑郁的易感性和自恋水平也有一定的关系，如果我们放低一点“自恋水平”，就更不容易被挫败，保持对世界、对自我清晰准确的评估和认识，能够让我们不那么容易抑郁。从精神分析角度，“抑郁”和“超我”太过于强大有关，一个强大的“超我”总在告诉我们“你应该怎样怎样”，不停地向内攻击，所以，如果现在有感觉到抑郁的朋友，对自己好一些，停止评价和攻击自己。同时，尝试用“多元价值体系”来看一看自己，我们的价值不仅仅体现在一件事情上，不要过度放大一件事情对于我们的价值。
如果你觉得抑郁让你很难受了，请及时就医检查。
对了，人如果一直在发挥“功能”而不得休息，也会引发抑郁，所以一定要让自己有什么都不图、不发挥功能、让自己作为一个人恢复的时间。</description>
    </item>
    
    <item>
      <title>焦虑</title>
      <link>https://zhenfeng-zhu.github.io/post/%E7%84%A6%E8%99%91/</link>
      <pubDate>Sun, 30 Jan 2022 11:25:21 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E7%84%A6%E8%99%91/</guid>
      <description> 焦虑来自个体努力追求生存，以及维持和肯定自我存在、安全感和价值感的过程，焦虑感是人生中不可避免的问题。
 焦虑是我们的大脑对抗潜在危机的积极行为，是一种自我保护机制，当你感觉到自我的价值受到质疑，或者感觉到不安时大脑就会启动这个机制，让我们表现出焦虑不安。
焦虑情绪可以分为 3 类：存在性焦虑，目标缺失的焦虑，有明确指向的焦虑。
 存在性焦虑：我们每个人都有链接别人、影响别人、保持影响力的需求（精神分析中有一句话，自我是存在于关系之中的），如果这些需求得不到满足，我们个人存在的价值就会被削弱（感受不到自己的存在），就会产生焦虑，例如孤独焦虑，价值焦虑，只要是人，或多或少都有存在性焦虑，存在性焦虑无法根除，只要不是特别顽固地挥之不去，也不会对人造成多大伤害。  如果你觉得你现在有比较严重的存在性焦虑，可能能缓解的方式是做一些能让你感受到自己存在的事情，e.g. 去爱，去工作，去寻找你的目标，去发展你的爱好，去大自然里待着，感受阳光照在你身上，去写作，去和别人闲聊，当然，也可以训练自己什么都不干，就好好地和自己待着。
目标缺失的焦虑：不知道自己因为什么而焦虑，弥漫性焦虑，精力很难集中，感觉身心疲惫，不知道自己每天应该干什么，焦虑从一个点，一个时间段弥漫到整个生活，这种焦虑是目标缺失导致的。提醒我们需要为自己寻找一个目标，它就像一个信号，告诉你“你得干点什么了”，当你成功捕捉到这个信号，并试着用自己的方式去解决它之后，焦虑也会缓解。当你为自己找到一个目标并真的踏踏实实去做一些事情之后，会感到身心无比轻松。  另外，如果我们现在虽然有短期要做的目标，但如果这种目标和我们的长期目标不匹配，也会引起焦虑。比如，每天工作忙忙碌碌，但依然焦虑，其实可能反映出我们长期目标的缺失（在潜意识中对未来没有安全感
有明确指向的焦虑（现实性焦虑）：因为某件事情引起，恐惧事情带来的后果，例如该做的事情还没有做，考试焦虑（害怕考砸），“双月焦虑”，来到新环境的焦虑等。有明确指向的焦虑其实指向的是恐惧，大多数恐惧情绪也是伴随焦虑出现的。焦虑水平与现实威胁的程度成正比。  解决这类焦虑的方法，要么逃跑，要么战斗——「降低对目标对象的重视程度和期待」和「提升自己掌握目标的能力。」说大白话，要么我们经过权衡思考之后，让自己离开压力源，要么和它战斗，心理上告诉自己，这个事情没有你想的那么重要/那么着急，同时找到有效的策略，让自己能够胜任这个事情。
 总结一下，焦虑作为一种信号：
  如果它不是由于具体事情引起的，则提醒我们需要为自己寻找目标做点什么了；
  如果有具体原因，要么选择远离压力源，要么降低对焦虑对象的期待（例如，放低一点对质量的要求、给多一点时间）并提升自己掌握它的能力（分解成可执行的行为并去执行）。
   </description>
    </item>
    
    <item>
      <title>如何更好地理解我们的情绪</title>
      <link>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E7%90%86%E8%A7%A3%E6%88%91%E4%BB%AC%E7%9A%84%E6%83%85%E7%BB%AA/</link>
      <pubDate>Sun, 30 Jan 2022 11:14:39 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E7%90%86%E8%A7%A3%E6%88%91%E4%BB%AC%E7%9A%84%E6%83%85%E7%BB%AA/</guid>
      <description>  情绪是来帮我们的，是为我们送信号的内在小孩，如果我们看不见它、不搭理它、压抑它、甚至和它对着干，总有一天它会「吃掉我们」（被情绪反噬）。
  情绪不是，也不应该被理解为是“坏东西”，提升我们对各种情绪的理解力和耐受力，当情绪来临的时候，别评价它（不用因为有情绪而自责），不用害怕的躲开，也不用着急出来，或者把它一拳打回去，可以陪它待一会儿，和那个情绪下的自己待一会儿，问问 “嘿，你咋啦？”。（这是我们难得的，看见自己和感受自己存在的机会）
  我们其实不太能“控制情绪”，已经产生的情绪很难被控制，只能被疏解。我们能选择的，是以何种姿态应对一个事情的发生。
  情绪是我们在受到外部刺激后产生的近乎自动的反应，是一种“症状”和“结果”。有一种解释情绪的 ABC 模型，首先一个诱发事件发生，然后我们怎么看待这个事件的态度/信念，导致我们产生不同的情绪和行为。
每个人都有各种情绪，它揭示的是我们内心的各种信念。当负面情绪出来的时候，是在提醒我们，“告诉你哦，哪里出了什么问题”，提醒我们有一些重要的事情没有解决、有重要的需求没有被满足，该做思考和检查了。
 刻意练习时刻
当你下次有情绪的时候，可以试试“情绪言语话”，就是通过语言，把自己的情绪说出来，句式可以是“发生了什么事情/别人对我做了什么，我感觉到什么，我的哪些需求没有被满足，我很……”
也可以通过写作，整理表达自己的情绪，在微信公众号“暂停实验室”有提供正念和情绪书写训练营。通过这种刻意的过程，能够帮助我们识别和看见自己的各种感受，在刺激事件和我们的反应之间按下一个暂停键，从而增加对情绪的掌控力，而不是作出自动化的反应。
 如果我们能够把情绪的信号解读出来，不但可以平复情绪，还能够对我们当前的行为和状态进行及时的矫正（变成了一个更好的人呢）。如果情绪没有得到照顾和平复，内在自我求救的信号没有被感知到，它就会持续存在下去，甚至会带着我们做出一些失控的行为，即便有时暂时被压抑，也会堆积在我们的心里，或者走向我们的身体（生病）。
我们做“情绪管理”，并不是要压抑已经出来的情绪，而是要一方面在情绪有苗头的时候就觉察到自己的反应，及时作出调整；或者通过已经出现的情绪，更好地看看在自己身上发生了什么，内心的哪些想法和环境产生冲突了，然后再“修通”一下——调整当前的应对策略，或调整我们的想法，让内心世界与外界不再冲突。
 “在刺激和反应之间，有一片空间。在那片空间里，我们有自由、有能力选择自己的反应”。
 </description>
    </item>
    
    <item>
      <title>感受自己的力量</title>
      <link>https://zhenfeng-zhu.github.io/post/%E6%84%9F%E5%8F%97%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8A%9B%E9%87%8F/</link>
      <pubDate>Sun, 30 Jan 2022 11:10:13 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E6%84%9F%E5%8F%97%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8A%9B%E9%87%8F/</guid>
      <description>萨特说：憎恨的本质就是承认了他人的自由
 这句话怎么理解？
我们羡慕的人，他们自由度太高以至于有合理预期；
我们嫉妒的人，他们只是稍稍压我们一头；
而我们恨的人，是那些实力差不多，但因为他们过于自由自在，让我们产生“我不行”的感觉，哲学中，称为“丧失了自我主体性”，翻译成大白话就是“感受不到自己的力量”。
很多负面的情绪，都来源于我们感受不到自己所蕴含的能量；而你最开心的情绪，也都来源你你感受到了自己的力量：
 冥想，让你观察到自己情绪的力量； 运动，让你感受到自己身体的力量； 游戏，让你感受到自己使用某个英雄的力量； 跟朋友唠嗑，让你感受到自己连接他人的力量； 养娃吸猫，让你感受到自己能够抚养生命的力量； &amp;hellip;  这种力量感，也有人称为掌控感、自由感，需要自己给自己。
可是，打工人下班后，真的没有力气运动、没有注意力冥想了，这种情况下，需要认认真真反思一下你在工作里的主体性了，如果工作中没有自主权，人们就会有“自己不能做决定，无法做选择”的感觉，这种感觉会减少人们激励自己，从而也减少了锻炼的动机。
在高压力、没有自主控制权的环境里，人会变得对生活都没有干劲了。
这是一种很可怕的恶性循环，也是一种很严重的情绪伤害，工作中，要时刻警惕自己珍贵的情绪被破坏，情绪被生理性的破坏，带来的后果还挺严重的。
记得当你情绪不好的时候，多尝试感受一下下自己的力量。</description>
    </item>
    
    <item>
      <title>如何通过“三叶草”模型抢救你的工作状态</title>
      <link>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%B8%89%E5%8F%B6%E8%8D%89%E6%A8%A1%E5%9E%8B%E6%8A%A2%E6%95%91%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81/</link>
      <pubDate>Sun, 30 Jan 2022 10:57:28 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%B8%89%E5%8F%B6%E8%8D%89%E6%A8%A1%E5%9E%8B%E6%8A%A2%E6%95%91%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81/</guid>
      <description>什么是三叶草模型 工作的本质是，通过价值创造完成价值兑现。我们能够进行价值创造的前提是对所从事的工作内容有兴趣，兴趣加上持续的投入，让我们具备完成工作所需要的能力。通过能力创造价值，我们可以获得物质回报和精神回报，这些东西让我们感受到价值感和满足感，从而有更强的兴趣投入到工作中，这样形成一个闭环。
所以完美的工作应该包含兴趣、能力、价值三个方面。
 我们感兴趣的； 我们有能力胜任的； 能够回馈给我们价值的，与我们当下所追求的价值观相符的。  当以上三个方面都获得满足时，我们体验到的是快乐、对工作有热情、有成就感和掌控感、觉得工作有意义、有价值。相反，如果当某一方面得不到满足时，我们会产生负面的体验和情绪。
三叶草模型，可以通过我们在工作中表现出的情绪状态，来帮助我们进行自我觉察，或者帮助别人判断当下职业发展的状态是什么，哪里存在问题，应该从何处着手解决问题，促进发展。
不理想的职业状态和典型特征
 兴趣缺失：厌倦，易感人群：工作 3 年以上，或同一个岗位工作 2 年以上，已经度过了起步适应阶段，在发展期出现工作倦怠  心理反应：厌倦，记忆力下降，反应速度变慢，长时间的厌倦容易演化为抑郁 身体反应：手脚冰凉，发冷，头疼，注意力涣散，行动速度下降   能力缺失：焦虑，易感人群：刚进入职场、刚晋升、刚进入新的岗位、工作挑战大时  心理反应：易怒，暴躁，说话声音快，容易情绪激动 身体反应：失眠，发烧，胃病，头疼   价值缺失：失落，易感人群：工作得不到回报和认可时、所做事情与自己的价值观发生冲突时  心理反应：短期会有抱怨和愤怒的表现，工作没动力 身体反应：行动速度下降    如何使用 当我们自己或者其他人陷入到不理想的工作状态中，找到我们寻求帮助时，可以通过以下步骤来识别问题并作出努力改善。
步骤 1：状态评估   对于工作状态看起来比较好的人可以这样提问：“你觉得现在的工作状态对你来说，在新鲜感、掌控感和满足感方面分别可以打多少分（1-10 分）？可以根据你自己的真实感受，在这三方面打个分。”
 感到工作新鲜、快乐有趣； 对工作有掌控感，能体验到成就感； 工作给你带来满足感和幸福感；    对于工作状态看起来不好的人可以这样提问：“情绪可以反映我们在工作中面临的问题，我们可以通过情绪的自评，了解我们工作中的主要问题在哪里，可以根据你现在的真实感受，在以下三个情绪方面分别打个分（1-10 分）。”
 对工作感到厌倦、提不起来兴趣； 对工作感到焦虑、缺少掌控感、经常感到不安； 对工作感到失落、缺少价值感；    典型打分组合&amp;amp;状态判断
 兴趣高，能力低，价值还可以：处于起步发展期，因为兴趣是在的，意味着愿意持续地投入和学习，未来仍有较大发展空间，当下需要重点做的是关注能力的提升。 兴趣低，但是能力和价值回报相对高：处于平台期，很多职场老员工会有这样的感觉，兴趣一般，但是能 hold 住当前的工作，价值回报也不错，通常这个时候员工短期会相对稳定，因为工作中能够拿到自己想要的价值，因此暂时不会有变化，但因为对工作已经产生了倦怠的感觉，职业发展会陷入一段停滞的阶段，未来的上升和成长会相对受限制，需要撬动新的兴趣和价值增长点，才能进阶到新的阶段。 兴趣高，能力也还可以，但价值低：虽然对工作有兴趣也能胜任，但得到的价值无法令自己满足或者说与自己内心真实想要的有一定差距，这个价值不一定指物质回报，也指精神和心理需求上的满足，比如是否有意义感，是否被认可，是否能够体验到自己想要的人际关系。这个时候通常需要澄清下自己想要的价值是什么，然后再根据自己想要的价值尝试转换方向，或者在原有的工作上链接、撬动更多价值。  划重点： 好的职业生涯是能够持续不断地找到兴趣、提升能力、兑换价值，通常 2-3 年是一个循环，然后既有事情对我们的吸引力会下降，这是客观规律，我们要不断找到新的事情、新的兴趣点和价值增长点，让每个阶段积累和修炼的能力都是在为下个阶段铺路。这个过程是我们不断反思自己、并且和周围环境互动、并且在互动中持续调适自己的过程。</description>
    </item>
    
    <item>
      <title>成长的本质是潜力兑现的过程</title>
      <link>https://zhenfeng-zhu.github.io/post/what_is_growth/</link>
      <pubDate>Sat, 29 Jan 2022 15:38:05 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/what_is_growth/</guid>
      <description>成长的本质是潜力兑现的过程 任何人都有潜力，潜力有高有低，有大有小。
潜力是很大，每个人都有很大的潜力，只是大部分人还没有达到自己潜力兑现的下限，更别说上限。
软素质 软素质分为三类：
 一类是态度  它很多时候是意识的体现，比如主动性、责任心、坦诚、追求极致，这些本质上都是是一个态度。
第二个是特质  特质是每个人的性格特点，有些可以改变的，有些是比较固化的。这个人是乐观还是悲观，有韧性，还是有野心还是相对佛一点，是不是聪明等。
其实特质没有好和坏，每个人都有自己擅长的地方和自己不擅长的地方，主要看自己能否清醒认识到。
最后是能力  能力是学习能力技术判断力沟通表达能力，这些可以通过训练提高的。
软素质决定我们的上下限 下限，意思就是说潜力最少可以兑现出来的东西；上限是理论的最高值，也就是我们常说的天花板。
我们的软素质，有些决定下限有些决定上限。我们要清醒的意识到所谓的软素质的东西，哪些是基础决定下限要保证好，哪些是上限的东西要挖掘好。
下限的软素质 正直、诚信和责任心强。
走正道而不走偏门，守正初心，扎扎实实把事情做好；责任心强，交给你的事情是不是努力做好，足够自律。能做到上述几点，潜力兑现基本没有问题。另外还有偏特质一些的聪明和热爱技术，能不能通过主动积极有责任心，并且用正确非投机的方式把事情做好。
如果都扎扎实实的做好，下限都是比较高的。
上限的软素质  第一个追求极致。  这句话提起来很简单，做起来很难很难，我们能不能突破天花板，就是追求极致。但极致不等于完美，不等于过度设计。极致是在当前有限情况下你是不是努力把这件事想得更好，还有没有做到更好的地方，努力想优化空间在哪里，。
哪个阶段做哪个事情收益是最高的，短期中期长期各自的解释是什么，怎么平衡好，去努力判断当前更优解是什么。
 第二，主动积极。这句话听起来很简单，实际过程中主动积极有野心的人和相对佛的人，最终你会发现时间拉长一点，大家发展区别会非常大。
  剩下就是好奇心有韧性独立思考开放清晰，对成功的渴望，关注长期格局这些都是上限。
  </description>
    </item>
    
    <item>
      <title>Flutter 地理位置插件使用指南</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_geolocation/</link>
      <pubDate>Thu, 27 Jan 2022 10:09:20 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_geolocation/</guid>
      <description>geolocator 是一个 flutter 的地理位置插件，同时支持 Android、iOS、web 和 macos。
安装 1  flutter pub add geolocator   使用方式 定义一个基础的骨架
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  class NewGeoRoute extends StatefulWidget {  @override  State&amp;lt;StatefulWidget&amp;gt; createState() {  return NewGeoRouteState();  } }  class NewGeoRouteState extends State&amp;lt;NewGeoRoute&amp;gt; {  String _pos = &amp;#34;&amp;#34;;   Future&amp;lt;Position&amp;gt; _determinLocation() async {   }   @override  void initState() {  super.</description>
    </item>
    
    <item>
      <title>Flutter WeChat Camera Picker 使用</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_wechat_camera_picker/</link>
      <pubDate>Tue, 25 Jan 2022 10:36:39 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_wechat_camera_picker/</guid>
      <description>Flutter WeChat Camera Picker 仿微信资源选择器 的扩展。 基于 camera 实现相机相关功能，photo_manager 实现资源相关内容。
https://pub.flutter-io.cn/packages/wechat_camera_picker/example
引入包 在 pubspec.yaml 中引入依赖
1  wechat_camera_picker: any   代码 demo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  class NewPictureRoute extends StatefulWidget {  @override  State&amp;lt;StatefulWidget&amp;gt; createState() {  // TODO: implement createState  return NewPictureRouteState();  } }  class NewPictureRouteState extends State&amp;lt;NewPictureRoute&amp;gt; {  AssetEntity?</description>
    </item>
    
    <item>
      <title>Flutter 常用工具</title>
      <link>https://zhenfeng-zhu.github.io/post/flutter_tools/</link>
      <pubDate>Mon, 24 Jan 2022 20:31:03 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutter_tools/</guid>
      <description>摄像： https://pub.flutter-io.cn/packages/wechat_camera_picker
录音： https://pub.flutter-io.cn/packages/flutter_sound_lite
定位： https://pub.flutter-io.cn/packages/geolocator
很多用起来比原生还简单方便很多，而且还不用写两份代码</description>
    </item>
    
    <item>
      <title>Flutter 常见问题记录</title>
      <link>https://zhenfeng-zhu.github.io/post/flutters/</link>
      <pubDate>Mon, 24 Jan 2022 10:52:44 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/flutters/</guid>
      <description>第一个问题  Cannot run with sound null safety because dependencies don&amp;rsquo;t support null safety
 First, you should read through the guide to understand unsound null safety. If you are sure that you want to run your application with unsound null safety, you can use the following command:
flutter run &amp;ndash;no-sound-null-safety
The &amp;ndash;no-sound-null-safety option is not documented in the article, however, I have not experienced any problems with it for the last few months (and especially not since the whole Flutter framework has been migrated to null safety).</description>
    </item>
    
    <item>
      <title>Farewell 永别了</title>
      <link>https://zhenfeng-zhu.github.io/post/farewell/</link>
      <pubDate>Sat, 15 Jan 2022 21:45:17 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/farewell/</guid>
      <description>永别了 正如 Semisonic 在 90 年代的热门歌曲 &amp;ldquo;Closing Time &amp;ldquo;所告诉我们的那样，每一个新的开始都来自于其他一些开始的结束。恭喜你，高贵的读者，完成了这次 Clojure 之旅。我希望你发现它是有价值的，我也希望你期待着更多的东西！相信我，还有更多的东西等着你。
相信我，还有很多东西。我最喜欢 Clojure 的一点是，它有一个完整的世界可以探索。逻辑编程、解析器、类型系统……只要你能说出计算机科学的一个有趣领域，你就可以用 Clojure 来研究它。我把我对下一步要去哪里的建议留给你。
如果你想对 Clojure 生态系统有一个广泛的了解，请查看The Clojure Toolbox，它列出了数百个 Clojure 项目，并按照它们所解决的问题进行组织。
如果你对网络编程感兴趣，一个很好的开始是 Luminus 框架（Luminus - 一个 Clojure 网络框架）。它的文档非常好，你很快就会有一个网站在运行。
要想了解 Clojure 的最新动态，Eric Normand 的 Clojure Gazzette 是一个很好的资源（注册每周功能编程通讯）。当然，还有 Clojure 邮件列表（https://groups.google.com/forum/#!forum/clojure）和 Clojure subreddit 也是一个有用的、友好的地方（http://www.reddit.com/r/clojure）。
如果 Twitter 是你选择的社交媒体，那么@swannodette (David Nolen), @gigasquid (Carin Meier), @puredanger (Alex Miller), @ztellman (Zach Tellman), @bbatsov (Bozidar Batsov) 和 @stuartsierra (Stuart Sierra) 是你的小红帽。你也可以关注我，@nonrecursive!
再见了，小茶杯，祝你 Clojuring 愉快</description>
    </item>
    
    <item>
      <title>AppendixB 花哨的 Boot</title>
      <link>https://zhenfeng-zhu.github.io/post/appendixb/</link>
      <pubDate>Sat, 15 Jan 2022 21:41:09 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/appendixb/</guid>
      <description>Boot，花哨的 Clojure 构建框架 Boot 是 Leiningen 的替代品，提供同样的功能。Leiningen 更受欢迎（截至 2015 年夏天），但我个人喜欢用 Boot 工作，因为它更容易扩展。本附录解释了 Boot 的基本概念，并指导你编写你的第一个 Boot 任务。如果你对使用 Boot 构建项目感兴趣，请查看它的 GitHub README（GitHub - boot-clj/boot: Build tooling for Clojure.）和它的 wiki（Home - boot-clj/boot Wiki - GitHub）。
注意 截至本文写作时，Boot 对 Windows 的支持有限。Boot 团队欢迎大家的贡献!
Boot 的抽象 Boot 由 Micha Niskin 和 Alan Dipert 创建，是对 Clojure 工具领域的一个有趣而强大的补充。从表面上看，它是构建 Clojure 应用程序和从命令行运行 Clojure 任务的一种便捷方式。深入研究一下，你会发现 Boot 就像 Git 和 Unix 的爱情结晶，它提供的抽象使你在操作系统和应用程序的交叉点上编写代码时更加愉快。
Unix 提供了我们都很熟悉的抽象，以至于我们认为它们是理所当然的。(偶尔带你的电脑去吃一顿好的餐厅会死吗？) 进程抽象让你把程序推理成独立的逻辑单元，可以通过 STDIN 和 STDOUT 文件描述符轻松地组成一个流处理管道。这些抽象使某些类型的操作，如文本处理，变得非常直接。
同样，Boot 也提供了一些抽象，使得独立的操作很容易被组合成构建工具最终要做的那种复杂、协调的操作，比如将 ClojureScript 转换为 JavaScript。 Boot 的任务抽象让你可以轻松地定义逻辑单元，通过文件集合进行通信。文件集合抽象可以跟踪不断变化的构建环境，并提供一个定义明确、可靠的任务协调方法。</description>
    </item>
    
    <item>
      <title>AppendixA 用 Leiningen 构建和开发</title>
      <link>https://zhenfeng-zhu.github.io/post/appendixa/</link>
      <pubDate>Sat, 15 Jan 2022 21:39:36 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/appendixa/</guid>
      <description>用 Leiningen 构建和开发 用任何语言编写软件都需要生成工件，即可执行文件或库包，用于部署或共享。它还涉及到管理依赖工件，也称为依赖，以确保它们被加载到你正在构建的项目中。Clojurists 中最流行的管理工件的工具是 Leiningen，本附录将告诉你如何使用它。你还将学习如何使用 Leiningen 来完全增强你的开发经验，使用插件。
Artifact Ecosystem 因为 Clojure 托管在 Java 虚拟机（JVM）上，所以 Clojure 的工件是以 JAR 文件的形式分发的（在第 12 章有介绍）。Java 地已经有一个处理 JAR 文件的完整的工件生态系统，Clojure 也使用它。神器生态系统并不是一个官方的编程术语；我用它来指代用于识别和分发神器的一套工具、资源和惯例。Java 的生态系统是围绕着 Maven 构建工具发展起来的，由于 Clojure 使用这个生态系统，你会经常看到对 Maven 的引用。Maven 是一个巨大的工具，可以执行各种古怪的项目管理任务。值得庆幸的是，你不需要获得 Maven 学的博士学位就能成为一名有效的 Clojurist。你需要知道的唯一特征是，Maven 规定了一种识别 Clojure 项目所遵守的工件的模式，它还规定了如何在 Maven 仓库中托管这些工件，Maven *仓库只是存储工件以供分发的服务器。
Identification Maven 工件需要一个组 ID，一个工件 ID，以及一个版本。你可以在project.clj文件中为你的项目指定这些。以下是你在第一章创建的clojure-noob项目的project.clj第一行的内容。
1  (defproject clojure-noob &amp;#34;0.1.0-SNAPSHOT&amp;#34;   clojure-noob是你项目的组 ID 和工件 ID，&amp;quot;0.1.0-SNAPSHOT&amp;quot;是其版本。一般来说，版本是永久性的；如果你将一个版本为 0.1.0 的工件部署到存储库，你不能对该工件进行修改并使用相同的版本号进行部署。您需要改变版本号。(许多程序员喜欢 Semantic Versioning 系统，您可以在*Semantic Versioning 2.0.0 | Semantic Versioning.*中阅读到这一系统。） 如果你想表明该版本是一个正在进行的工作，并且你计划不断地更新它，你可以在你的版本号后面加上-SNAPSHOT。
如果你想让你的组 ID 与你的工件 ID 不同，你可以用斜线将两者分开，像这样。</description>
    </item>
    
    <item>
      <title>Chapter13 抽象</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter13/</link>
      <pubDate>Sat, 15 Jan 2022 21:29:04 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter13/</guid>
      <description>用 Multimethods、协议和记录创建和扩展抽象概念 花一分钟思考一下，作为大自然的顶级产品之一：人类是多么伟大。作为一个人类，你可以在社交媒体上闲聊，玩龙与地下城，戴帽子。也许更重要的是，你可以用抽象的概念来思考和交流。
抽象思考的能力确实是人类最好的特征之一。它可以让你规避你的认知极限，将不同的细节捆绑在一起，形成一个整齐的概念包，让你可以在工作记忆中持有。你不需要去想 &amp;ldquo;可挤压的红球鼻子装饰 &amp;ldquo;这种笨重的想法，而只需要 &amp;ldquo;小丑鼻子 &amp;ldquo;这个概念。
在 Clojure 中，一个抽象是一个操作的集合，而数据类型实现抽象。例如，seq 抽象由 &amp;ldquo;first &amp;ldquo;和 &amp;ldquo;rest &amp;ldquo;等操作组成，而 Vector 数据类型是该抽象的实现；它对所有 seq 操作做出响应。像[:seltzer :water]这样的特定 Vector 是该数据类型的*实例。
编程语言越是让你以抽象的方式思考和写作，你的生产力就越高。例如，如果你知道一个数据结构是 seq 抽象的一个实例，你就可以立即调用一个大的知识网，了解哪些函数可以与数据结构一起工作。因此，你会花时间去实际使用这个数据结构，而不是不断地去查找关于它如何工作的文档。同样地，如果你扩展一个数据结构，使其与 seq 抽象一起工作，你就可以在上面使用大量的 seq 函数库。
在第四章中，你了解到 Clojure 是以抽象的方式编写的。这很强大，因为在 Clojure 中，你可以专注于你可以用数据结构实际做的事情，而不用担心实现的细枝末节。本章向你介绍了创建和实现你自己的抽象的世界。你将学习 Multimethods、协议和记录的基础知识。
多态 我们在 Clojure 中实现抽象的主要方式是将一个操作名称与一个以上的算法联系起来。这种技术被称为多态。例如，在列表上执行 &amp;ldquo;conj &amp;ldquo;的算法与 Vector 的算法不同，但我们把它们统一在同一个名字下，以表明它们实现了同一个概念，即向这个数据结构添加一个元素。
因为 Clojure 的许多数据类型都依赖于 Java 的标准库，所以本章中使用了一点 Java。例如，Clojure 的字符串只是 Java 的字符串，是 Java 类java.lang.String的实例。要在 Java 中定义你自己的数据类型，你要使用类。Clojure 提供了额外的类型结构。 记录和类型。本书只涉及记录。
在我们学习记录之前，让我们看看 Multimethods，这是我们定义多态行为的第一个工具。
Multimethods Multimethods为你提供了一种直接的、灵活的方法，将多态引入你的代码中。使用 Multimethods，你可以通过定义一个调度函数将一个名字与多个实现联系起来，该函数产生调度值，用来决定使用哪个方法。调度函数就像餐厅里的主人。主人会问你一些问题，比如 &amp;ldquo;你有预订吗？&amp;ldquo;和 &amp;ldquo;聚会人数？&amp;quot;，然后给你安排相应的座位。同样，当你调用一个 Multimethods 时，调度函数将询问参数，并将它们发送到正确的方法，正如这个例子所显示的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  (ns were-creatures) ➊ (defmulti full-moon-behavior (fn [were-creature] (:were-type were-creature))) ➋ (defmethod full-moon-behavior :wolf  [were-creature]  (str (:name were-creature) &amp;#34; will howl and murder&amp;#34;)) ➌ (defmethod full-moon-behavior :simmons  [were-creature]  (str (:name were-creature) &amp;#34; will encourage people and sweat to the oldies&amp;#34;))  (full-moon-behavior {:were-type :wolf ➍ :name &amp;#34;Rachel from next door&amp;#34;}) ; =&amp;gt; &amp;#34;Rachel from next door will howl and murder&amp;#34;  (full-moon-behavior {:name &amp;#34;Andy the baker&amp;#34; ➎ :were-type :simmons}) ; =&amp;gt; &amp;#34;Andy the baker will encourage people and sweat to the oldies&amp;#34;   这个 Multimethods 显示了你如何定义不同种类的狼人生物的满月行为。大家都知道狼人变成了狼，到处嚎叫着杀人。一种不太知名的狼人，即狼-西蒙斯，变成理查德-西蒙斯，烫着头发，到处跑，鼓励人们做最好的自己，为老人们流汗。你不想被这两种生物咬到，否则你就会变成它们。</description>
    </item>
    
    <item>
      <title>Chapter12 与 Java 的互操作</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter12/</link>
      <pubDate>Sat, 15 Jan 2022 20:55:18 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter12/</guid>
      <description>与 JVM 一起工作 在每个 Clojurist 的生命中都会有这么一天，她必须从纯函数和不可变数据结构的庇护所冒险进入野蛮的 Java 大陆。这段艰难的旅程是必要的，因为 Clojure 是在 Java 虚拟机（JVM）上托管的，这赋予了它三个基本特性。
赋予它三个基本特征。首先，你运行 Clojure 应用程序的方式与你运行 Java 应用程序的方式相同。第二，你需要使用 Java 对象来实现核心功能，如读取文件和处理日期。第三，Java 有一个庞大的有用库的生态系统，你需要对 Java 有一定的了解才能使用它们。
这样一来，Clojure 就有点像一个乌托邦社区，被放置在一个乌托邦国家的中间。显然，你更愿意与其他乌托邦人互动，但偶尔你也需要与当地人交谈，以便完成工作。
这一章就像一本短语书和 Java 国家的文化介绍之间的交叉。你将了解什么是 JVM，它是如何运行程序的，以及如何为它编译程序。本章还将为你简要介绍常用的 Java 类和方法，并解释如何使用 Clojure 与它们互动。你将学会如何思考和理解 Java，以便将任何 Java 库纳入你的 Clojure 程序中。
要运行本章的例子，你需要在电脑上安装 1.6 或更高版本的 Java 开发工具包（JDK）。你可以通过在终端运行javac -version来检查。你应该看到类似 &amp;ldquo;java 1.8.0_40 &amp;ldquo;的内容；如果没有，请访问http://www.oracle.com/，下载最新的 JDK。
JVM 开发人员用 JVM 这个词来指代一些不同的东西。你会听到他们说，&amp;ldquo;Clojure 在the JVM 上运行&amp;rdquo;，你也会听到，&amp;ldquo;Clojure 程序在a JVM 中运行&amp;rdquo;。在第一种情况下，JVM 指的是一个抽象概念&amp;ndash;Java 虚拟机的一般模型。在第二种情况下，它指的是一个进程&amp;ndash;一个正在运行的程序的实例。我们将专注于 JVM 模型，但当我们谈论运行中的 JVM 进程时，我将指出来。
为了理解 JVM，让我们回头看看普通的计算机是如何工作的。在计算机心脏的深处是它的 CPU，而 CPU 的工作是执行像加和无符号乘法这样的操作。你可能听说过程序员将这些指令编码在打卡机上、灯泡里、乌龟壳的神圣缝隙里，或者什么的，但现在这些操作在汇编语言中用 ADD 和 MUL 这样的记忆符号表示。CPU 架构（X86、ARMv7，等等）决定了哪些操作可以作为该架构的指令集的一部分。</description>
    </item>
    
    <item>
      <title>Chapter11 core.async</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter11/</link>
      <pubDate>Sat, 15 Jan 2022 12:56:01 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter11/</guid>
      <description>用 core.async 掌握并发进程 有一天，当你走在大街上时，你会惊讶、好奇，并有点厌恶地发现一台热狗自动贩卖机。你的头皮被有罪的好奇心刺痛，你会忍不住掏出三块钱，看看这个装置是否真的能工作。在 &amp;ldquo;咔嚓 &amp;ldquo;一声接受了你的钱后，它弹出了一个新鲜的热狗，包括面包和所有的东西。
自动售货机表现出简单的行为：当它收到钱时，它会放出一个热狗，然后为下一次购买做准备。当它的热狗用完时，它就会停止。我们周围的热狗自动售货机以不同的面貌出现，它们是独立的实体，同时对世界上的事件作出反应。你最喜欢的咖啡店的浓缩咖啡机，你小时候喜欢的宠物仓鼠&amp;ndash;所有的东西都可以被分解成一组行为，这些行为遵循一般的形式 &amp;ldquo;当x发生时，做y&amp;quot;。甚至我们写的程序也只是美化的热狗贩卖机，每一个都是独立的进程，等待着下一个事件的发生，无论是击键、超时，还是套接字上的数据到达。
Clojure 的 core.async 库允许你在一个程序中创建多个独立进程。 本章描述了思考这种编程风格的有用模型，以及你在实际编写代码时需要了解的实际细节。你将学习如何使用通道在由 go 块和thread创建的独立进程之间进行通信；了解一些关于 Clojure 如何通过停放和阻塞有效地管理线程；如何使用alts!!；以及一种更直接的创建队列的方法。最后，你将学习如何用进程管道来踢回调的屁股。
进程的入门 core.async 的核心是*进程，一个并发运行的逻辑单元，对事件做出反应。进程对应于我们对现实世界的心理模型：实体之间的互动和响应是独立的，没有某种中央控制机制的牵制。你把钱放进机器里，就会有一个热狗出来，所有这些都不需要光照派或老大哥来策划整个事情。这与你迄今为止一直在探索的并发性观点不同，在那里，你定义的任务要么只是控制主线程的扩展（例如，用pmap实现数据并行），要么是你没有兴趣与之交流的任务（如用future创建的一次性任务）。
把自动售货机看成是一个进程可能很奇怪：自动售货机是名词和事物，而进程是动词和行为。为了获得正确的思维方式，可以尝试将现实世界的物体定义为其事件驱动的行为的总和。当一粒种子被浇水时，它就会发芽；当母亲看着她的新生儿时，她就会感受到爱；而当你观看《星战》第一集时，你会充满愤怒和绝望。如果你想变得超级哲学，可以考虑是否有可能将每个事物的本质定义为它所识别的事件的集合，以及它如何做出反应。现实是否只是热狗售卖机的组成？
总之，我说得够多了! 让我们通过创建一些简单的过程，从理论上走向具体。首先，用 &amp;ldquo;lein new app playsync &amp;ldquo;创建一个新的 Leiningen 项目，名为playsync。然后，打开project.clj文件，将 core.async 添加到:dependenciesVector 中，使其内容如下。
1 2  [[org.clojure/clojure &amp;#34;1.9.0&amp;#34;] [org.clojure/core.async &amp;#34;0.1.346.0-17112a-alpha&amp;#34;]]   注意 自从我写完这篇文章后，core.async 的版本有可能有所进步。关于最新的版本，请查看 core.async 的 GitHub 项目页面。但为了这些练习的目的，请使用这里列出的版本。
接下来，打开src/playsync/core.clj，使其看起来像这样。
1 2 3 4 5  (ns playsync.core  (:require [clojure.core.async  :as a  :refer [&amp;gt;! &amp;lt;! &amp;gt;!! &amp;lt;!! go chan buffer close!</description>
    </item>
    
    <item>
      <title>Chapter10 形而上学</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter10/</link>
      <pubDate>Sat, 15 Jan 2022 12:42:26 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter10/</guid>
      <description>Clojure Metaphysics: 原子、Refs、Vars 和拥抱僵尸 三个并发性的小妖精都是从同一个邪恶的坑里生出来的：对可变状态的共享访问。你可以在第九章的引用单元讨论中看到这一点。当两个线程对引用单元进行不协调的更改时，结果是不可预测的。
Rich Hickey 设计 Clojure 是为了专门解决共享访问易变状态所产生的问题。事实上，Clojure 体现了一种非常清晰的状态概念，使其在本质上比大多数流行的编程语言更安全。它是安全的，一直到它的meta-freakin-physics。
在本章中，你将了解 Clojure 的底层形而上学，与典型的面向对象（OO）语言的形而上学相比较。学习这种哲学将使你准备好处理 Clojure 剩下的并发工具，atom、ref和var引用类型。(Clojure 还有一个额外的引用类型，agents，本书没有涉及。) 这些类型中的每一个都能让你安全地同时执行状态修改操作。你还会学到一些简单的方法，使你的程序更有效率，而不需要引入状态。
形而上学试图用最广泛的术语来回答两个基本问题。
 那里有什么？ 它是什么样子的？  为了引出 Clojure 和 OO 语言之间的差异，我将解释两种不同的拥抱僵尸的建模方式。与普通的僵尸不同，拥抱僵尸并不想要吞噬你的大脑。它只想用勺子舀你，也许还想闻闻你的脖子。这使得它的不死、摇晃、腐烂的状态更加悲惨。你怎么能试图杀死只想要爱的东西呢？谁是这里真正的怪物？
面向对象的形而上学 OO 形而上学将拥抱僵尸视为存在于世界上的一个对象。这个对象的属性可能会随着时间的推移而改变，但它仍然被当作一个单一的、不变的对象。如果这看起来是一个完全明显的、没有争议的僵尸形而上学的方法，那么你可能没有在哲学入门课上花几个小时来争论一把椅子的存在意味着什么，以及什么真正使它首先成为一把椅子。
棘手的部分是，拥抱的僵尸总是在变化。它的身体慢慢恶化。随着时间的推移，它对拥抱的不灭渴望越来越强烈。在 OO 术语中，我们会说拥抱僵尸是一个具有可改变状态的对象，它的状态是不断波动的。但是不管这个僵尸有多大的变化，我们仍然把它认定为同一个僵尸。下面是你如何在 Ruby 中对抱团僵尸进行建模和交互。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class CuddleZombie  # attr_accessor is just a shorthand way for creating getters and  # setters for the listed instance variables  attr_accessor :cuddle_hunger_level, :percent_deteriorated   def initialize(cuddle_hunger_level = 1, percent_deteriorated = 0)  self.</description>
    </item>
    
    <item>
      <title>Chapter9 并发的艺术</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter9/</link>
      <pubDate>Sat, 15 Jan 2022 12:30:14 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter9/</guid>
      <description>并发和并行编程的神圣艺术 如果我是一个庄园的主人，而你是我的继承人，我会在你的第 13 个命名日让你坐下来，告诉你：&amp;ldquo;计算的世界正在改变，小姑娘，你必须为多核处理器的新世界做好准备，以免你被它践踏。
&amp;ldquo;好好听着。近年来，CPU 的时钟速度几乎没有增加，但双核和四核计算机已经变得很普遍。物理定律是残酷而绝对的，它们要求提高时钟速度需要成倍的功率。领域内最好的工程师不太可能很快克服这一限制，如果有的话。因此，你可以预期单台机器上的内核不断增加的趋势将继续下去&amp;ndash;作为一个程序员，你将知道如何充分利用现代硬件的期望也是如此。
&amp;ldquo;在这种新模式下学习编程将是有趣和迷人的，真的。但请注意：它也充满了危险。你必须学习并发和并行编程*，这是一门神圣的艺术，使你的应用结构安全地管理多个同时执行的任务。
&amp;ldquo;你从对并发和并行概念的概述开始学习这门艺术。然后，你将学习困扰每个从业者的三个小妖精：参考单元、互斥和矮人狂战士。你还将学习三种有助于你的工具：Future、许诺和延迟&amp;rdquo;。
然后我会用键盘拍拍你的肩膀，示意你可以开始了。
并发和并行的概念 并发和并行编程在程序执行的各个层面都涉及到很多混乱的细节，从硬件到操作系统，到编程语言库，再到从你的内心涌出的、落在编辑器中的代码。但在你为这些细节烦恼之前，在这一节中，我将介绍围绕并发和并行的高级概念。
管理多个任务与同时执行任务 并发指的是在同一时间管理一个以上的任务。 任务只是意味着 &amp;ldquo;需要完成的事情&amp;rdquo;，它并不意味着任何有关硬件或软件的实现。我们可以用 Lady Gaga 的歌曲《电话》来说明并发性。Gaga 唱道
 I cannot text you with a drink in my hand, eh
 这里，她在解释她只能管理一个任务（喝酒）。她断然拒绝了她可以处理一个以上的任务的建议。然而，如果她决定同时处理任务，她会唱歌。
 I will put down this drink to text you, then put my phone away and continue drinking, eh
 在这个假设的宇宙中，Lady Gaga 正在处理两个任务：喝酒和发短信。然而，她并没有同时执行这两项任务。相反，她在这两个任务之间进行切换，或者说是交错。请注意，在交错过程中，你不必在切换之前完全完成一项任务：Gaga 可以打一个字，放下手机，拿起饮料喝一口，然后换回手机，再打一个字。
平行性指的是同时执行一个以上的任务。如果加加夫人平行地执行她的两项任务，她会唱歌。
 I can text you with one hand while I use the other to drink, eh</description>
    </item>
    
    <item>
      <title>Chapter8 宏</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter8/</link>
      <pubDate>Sat, 15 Jan 2022 12:22:42 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter8/</guid>
      <description>编写宏 当我 18 岁时，我在新墨西哥州圣菲的一家酒店找到了一份夜班审计师的工作，每周工作四个晚上，从晚上 11 点到早上 7 点。经过几个月的这种不眠不休的工作，我的情绪有了自己的变化。一天晚上，大约在
凌晨 3 点，我正在看一个信息广告，该产品声称可以恢复男人的头发。当我看到一个曾经秃头的人的故事时，我被真诚的喜悦所淹没。&amp;ldquo;终于来了！&amp;ldquo;我的大脑涌动着。&amp;ldquo;这个人得到了他应得的爱和成功! 多么不可思议的产品，给无望的人以希望！&amp;rdquo;
从那时起，我发现自己一直在想，我是否能以某种方式重新创造因长期睡眠不足而引起的情感放弃和对生命的欣赏。也许是某种药水&amp;ndash;喝上几口，释放我内心的理查德-西蒙斯，但时间不会太长。
就像药水可以让我暂时改变我的基本性质一样，宏允许你以其他语言无法实现的方式修改 Clojure。有了宏，你可以扩展 Clojure 以适应你的问题空间，建立起语言。
在这一章中，你将彻底研究如何编写宏，从基本的例子开始，逐步提高复杂性。最后，你将戴上你的假想帽，用宏来验证你想象中的在线药水店的客户订单。
在本章结束时，你将了解你用来编写宏的所有工具：引号、语法引号、解引号、解引号拼接（又称皮纳塔工具）和 gensym。你还会了解到对毫无戒心的宏作者来说隐藏着的危险：双重求值、变量捕获和宏感染。
宏是必不可少的 在你开始编写宏之前，我想帮助你把它们放在适当的环境中。是的，宏比北极熊的脚趾甲还要酷，但你不应该把宏看成是一些深奥的工具，当你想对你的代码进行额外的花哨处理时，就把它拿出来。事实上，宏允许 Clojure 从一个很小的函数和特殊形式的核心中获得大量的内置功能。以when为例。 when有这样的一般形式。
1 2 3 4 5 6  (when boolean-expression  expression-1  expression-2  expression-3  ...  expression-x)   你可能认为when是一个像if一样的特殊形式。那么你猜怎么着？它不是! 在大多数其他语言中，你只能使用特殊的关键字来创建条件表达式，而没有办法创建你自己的条件运算符。然而，when实际上是一个宏。
在这个宏扩展中，你可以看到when是用if和do来实现的。
1 2 3 4 5 6 7 8  (macroexpand &amp;#39;(when boolean-expression  expression-1  expression-2  expression-3)) ; =&amp;gt; (if boolean-expression  (do expression-1  expression-2  expression-3))   这表明宏是 Clojure 开发中不可或缺的一部分&amp;ndash;它们甚至被用来提供基本操作。宏并不是为奇特的特殊情况而保留的；你应该把写宏看作是你工具包中的另一个工具。当你学会编写自己的宏时，你会发现它们是如何让你进一步扩展语言，使其适合你的特定问题领域的形状。</description>
    </item>
    
    <item>
      <title>Chapter7 炼金术</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter7/</link>
      <pubDate>Sat, 15 Jan 2022 12:14:36 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter7/</guid>
      <description>Clojure 炼金术：读取器、求值器和宏 哲学家之石，与生命之药和伟哥一样，是炼金术传说中最著名的标本之一，因其能将铅转化为金而受到追捧。然而，Clojure 提供了一种工具，使哲学家的石头看起来只是一个小饰品：*宏。
宏允许你将任意的表达式转化为有效的 Clojure，因此你可以扩展语言本身以满足你的需求。而且，你甚至不需要是一个穿长袍的老家伙或老太太来使用它们
为了获得这种能力，请考虑这个微不足道的宏。
1 2 3 4 5 6  (defmacro backwards  [form]  (reverse form))  (backwards (&amp;#34; backwards&amp;#34; &amp;#34; am&amp;#34; &amp;#34;I&amp;#34; str)) ; =&amp;gt; &amp;#34;I am backwards&amp;#34;   backwards宏允许 Clojure 成功地 Eval 表达式(&amp;quot; backwards&amp;quot; &amp;quot; am&amp;quot; &amp;quot;I&amp;quot; str)，尽管它没有遵循 Clojure 的内置语法规则，这些规则要求表达式的操作数首先出现（更不用说表达式不能按相反顺序书写的规则）。如果没有 &amp;ldquo;向后&amp;rdquo;，这个表达式会比几千年来的炼金术士用他们的一生来追求不可能实现的长生不老的方法更难失败。有了`向后&amp;rsquo;，*你就创造了你自己的语法！*你扩展了 Clojure，这样你就可以随心所欲地写代码了 我告诉你，这比把铅变成金子要好得多!
本章为你提供了编写自己的宏所需的概念基础，使你能够疯狂地编写自己的宏。它解释了 Clojure 求值模型的元素：读取器，求值器，和宏扩展器。这就像 Clojure 元素的周期表。想想周期表是如何揭示原子的特性的：同一列的元素行为相似，因为它们有相同的核电荷。如果没有元素周期表及其基础理论，我们就会像过去的炼金术士一样，随意地把东西混在一起，看看什么东西会爆炸。但是，随着对元素的深入了解，你可以看到为什么东西会爆炸，并学会如何有目的地炸毁东西。
A Overview of Clojure&amp;rsquo;s Evaluation Model Clojure（像所有的 Lisps）有一个不同于大多数其他语言的求值模型：它有一个两阶段的系统，它读文本源代码，产生 Clojure 数据结构。然后对这些数据结构进行*求值。Clojure 遍历数据结构，并根据数据结构的类型执行函数应用或 var 查找等操作。例如，当 Clojure 读取文本(+ 1 2)时，结果是一个列表数据结构，其第一个元素是一个+符号，后面是数字 1 和 2。这个数据结构被传递给 Clojure 的求值器，求值器查找+对应的函数，并将该函数应用于 1 和 2。</description>
    </item>
    
    <item>
      <title>Chapter6 组织你的项目</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter6/</link>
      <pubDate>Fri, 14 Jan 2022 12:40:41 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter6/</guid>
      <description>组织你的项目：一个图书管理员的故事 在我们每个人心中都住着一个叫 Melvil 的图书管理员，一个以组织艺术为乐的奇异生物。日日夜夜，Melvil 都渴望为你的代码库带来秩序。幸运的是，Clojure 提供了一套工具，专门用来帮助这个侏儒与混乱的力量不断斗争。
这些工具通过将相关的函数和数据分组来帮助你组织你的代码。它们还可以防止名称冲突，这样你就不会意外地覆盖别人的代码，反之亦然。在这个充满悬念和神秘的故事中，请和我一起学习如何使用这些工具，并解决一生中的抢劫案吧 在这个传奇故事的最后，你将了解以下内容。
  `def&amp;rsquo;是做什么的
  什么是命名空间以及如何使用它们
  命名空间和文件系统之间的关系
  如何使用refer、alias、require、use和ns。
  如何使用文件系统来组织 Clojure 项目
  我先来介绍一下 Clojure 的组织系统，它的工作原理很像一个库。Melvil 兴奋地颤抖着!
你的项目是一个库 现实世界中的图书馆存储对象的集合，如书籍、杂志和 DVD。他们使用寻址系统，所以当你得到一个物体的地址时，你可以导航到物理空间并检索到该物体。
当然，没有人能够直接知道一本书或 DVD 的地址是什么。这就是为什么图书馆要记录一个物体的标题和它的地址之间的联系，并提供工具来搜索这些记录。在计算机之前的旧时代，图书馆提供卡片目录，即装满纸质卡片的柜子，其中包含每本书的标题、作者、&amp;ldquo;地址&amp;rdquo;（杜威十进制或国会图书馆编号）和其他信息。
例如，要找到《达芬奇密码》，你可以翻阅书名目录（按书名排序的卡片），直到你找到正确的卡片。在那张卡片上，你会看到地址813.54（如果它使用杜威十进制系统），浏览图书馆，找到达芬奇密码所在的书架，并参与你一生中的文学和/或仇恨阅读冒险。
在 Clojure 中想象一个类似的设置是很有用的。我认为 Clojure 是将对象（如数据结构和函数）存储在一组巨大的编号架上。没有人能够直接知道一个对象被存储在哪个架子上。相反，我们给 Clojure 一个标识符，它用来检索该对象。
为了使之成功，Clojure 必须维护我们的标识符和货架地址之间的关联。它通过使用namespaces来做到这一点。命名空间包含了人类友好的符号和书架地址的引用之间的 Map，被称为vars，很像卡片目录。
从技术上讲，命名空间是 &amp;ldquo;clojure.lang.Namespace &amp;ldquo;类型的对象，你可以与它们互动，就像你可以与 Clojure 数据结构互动一样。例如，你可以用*ns*来引用当前的命名空间，你可以用(ns-name *ns*)来获得其名称。
1 2  (ns-name *ns*) ; =&amp;gt; user   例如，当你启动 REPL 时，你在user命名空间中（正如你在这里看到的）。提示符显示当前名称空间，使用user=&amp;gt;。
当前名字空间的概念意味着你可以有多个名字空间，事实上 Clojure 允许你创建任意多的名字空间（尽管从技术上讲，你可以创建的名字数量可能有一个上限）。在 Clojure 程序中，你总是在个命名空间中。</description>
    </item>
    
    <item>
      <title>Chapter5 函数式编程</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter5/</link>
      <pubDate>Fri, 14 Jan 2022 10:00:07 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter5/</guid>
      <description>函数式编程 到目前为止，你已经专注于熟悉 Clojure 提供的工具：不可变的数据结构、函数、抽象，等等。在这一章中，你将学习如何思考你的编程任务，以最好的方式利用这些工具。你将开始把你的经验整合到一个新的函数式编程思维中。
你将学到的核心概念包括：什么是纯函数，为什么它们很有用；如何使用不可变的数据结构，为什么它们比可变的表亲更有优势；如何将数据和函数分开，给你带来更多的力量和灵活性；以及为什么对一小部分数据抽象进行编程会很强大。一旦你把所有这些知识塞进你的大脑，你就会有一个全新的解决问题的方法
在学习了这些主题之后，你将通过编写一个基于终端的游戏来运用你所学到的一切，这个游戏的灵感来自于美国各地 Cracker Barrel 餐馆中的一种古老而神秘的思维训练装置。Peg Thing!
纯函数：是什么和为什么 除了 &amp;ldquo;println &amp;ldquo;和 &amp;ldquo;rand&amp;rdquo;，到目前为止，你所使用的所有函数都是纯函数。是什么使它们成为纯函数，为什么会有这样的问题？如果一个函数符合两个条件，它就是纯函数。
 如果给出相同的参数，它总是返回相同的结果。这被称为引用透明度，你可以把它添加到你的 5 美元编程术语列表中。 它不能引起任何副作用。也就是说，该函数不能做出任何在函数本身之外可以观察到的改变&amp;ndash;例如，通过改变一个外部可访问的可改变对象或写到一个文件。  这些特性使你更容易推理你的程序，因为这些函数是完全隔离的，无法影响你系统的其他部分。当你使用它们时，你不必问自己，&amp;ldquo;我调用这个函数会破坏什么？&amp;rdquo; 它们也是一致的：你永远不需要搞清楚为什么给一个函数传递相同的参数会导致不同的返回值，因为这永远不会发生。
纯函数和算术一样稳定，没有问题（你最后一次为两个数字相加而烦恼是什么时候？） 它们是巨大的函数小砖块，你可以自信地将其作为你程序的基础。让我们更详细地看看引用透明性和无副作用，看看它们到底是什么，以及它们是如何发挥作用的。
纯函数是引用透明的 为了在调用相同参数时返回相同的结果，纯函数只依靠 1）自己的参数和 2）不可变的值来决定其返回值。例如，数学函数是引用透明的。
1 2  (+ 1 2) ; =&amp;gt; 3   如果一个函数依赖于一个不可变的值，那么它就是引用透明的。字符串`&amp;rdquo;, Daniel-san &amp;ldquo;是不可变的，所以下面的函数也是引用透明的。
1 2 3 4 5 6  (defn wisdom  [words]  (str words &amp;#34;, Daniel-san&amp;#34;))  (wisdom &amp;#34;Always bathe on Fridays&amp;#34;) ; =&amp;gt; &amp;#34;Always bathe on Fridays, Daniel-san&amp;#34;   相比之下，下面的函数在相同的参数下不会产生相同的结果；因此，它们在指称上是不透明的。任何依赖随机数生成器的函数都不可能是指称透明的。</description>
    </item>
    
    <item>
      <title>Chapter4 深入研究核心函数</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter4/</link>
      <pubDate>Thu, 13 Jan 2022 17:39:28 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter4/</guid>
      <description>核心函数的深入研究 如果你像我一样是焦虑的、以青少年为中心的准肥皂剧*《吸血鬼日记》*的超级粉丝，你一定记得主角埃琳娜开始质疑她苍白的、神秘的暗恋者的行为的那一集。&amp;ldquo;为什么当我的膝盖被刮伤时，他立刻消失得无影无踪？&amp;ldquo;和 &amp;ldquo;为什么当我的手指被划破时，他的脸变成了一个怪异的死亡面具？&amp;ldquo;等等。
如果你已经开始把玩 Clojure 的核心函数，你可能也会问自己类似的问题。&amp;ldquo;为什么map会返回一个列表，而我给它的是一个 Vector？&amp;ldquo;和 &amp;ldquo;为什么reduce会把我的 map 当成一个 Vector？&amp;ldquo;等等。(不过，有了 Clojure，你至少可以免于思考作为一个 17 岁孩子的深刻的存在恐惧，直到永远）。
在这一章中，你将了解到 Clojure 的深邃、黑暗、嗜血、超自然的cough，我的意思是，在这一章中，你将了解到 Clojure 的抽象的基本概念以及序列和集合的抽象。你还会了解到疯狂的序列。这将为你提供所需的基础，使你能够阅读你以前没有使用过的函数的文档，并理解当你试着使用它们时发生了什么。
接下来，你将获得更多关于你最需要使用的函数的经验。你将学习如何用函数map、reduce、into、conj、concat、some、filter、take、drop、sort、sort-by和identity来处理列表、Vector、Map 和 Set。你还将学习如何用apply、partial和complement创建新的函数。所有这些信息将帮助你了解如何以 Clojure 的方式做事，它将为你编写自己的代码以及阅读和学习他人的项目打下坚实的基础。
最后，你将学会如何解析和查询 CSV 中的吸血鬼数据，以确定在你的家乡潜伏着哪些诺斯费拉图。
从编程到抽象 为了理解从编程到抽象，让我们把 Clojure 与一种没有考虑到这个原则的语言进行比较。Emacs Lisp（elisp）。在 elisp 中，你可以使用mapcar函数来导出一个新的列表，这与你在 Clojure 中使用map的方式相似。然而，如果你想在 elisp 中 Map 一个哈希 Map（类似于 Clojure 的 map 数据结构），你需要使用maphash函数，而在 Clojure 中你仍然可以只使用map。换句话说，elisp 使用两个不同的、针对数据结构的函数来实现map操作，而 Clojure 只使用一个。你也可以在 Clojure 中对 map 调用reduce，而 elisp 并没有提供一个函数来减少散列 map。
原因是 Clojure 在序列抽象方面定义了map和reduce函数，而不是在具体的数据结构方面。只要数据结构响应核心序列操作（函数first、rest和cons，我们稍后会仔细研究），它就能与map、reduce以及其他大量的序列函数免费工作。这就是 Clojurists 所说的抽象编程，也是 Clojure 哲学的一个核心原则。
我认为抽象是操作的命名集合。如果你能在一个对象上执行一个抽象的所有操作，那么这个对象就是该抽象的一个实例。我甚至在编程之外也是这样想的。例如，电池抽象包括 &amp;ldquo;将导电介质连接到其阳极和阴极 &amp;ldquo;的操作，而该操作的输出是电流。电池是用锂还是用土豆做的并不重要。只要它对定义电池的一系列操作做出反应，它就是一个电池。
同样地，map并不关心列表、Vector、Set 和 Map 是如何实现的。它只关心它是否能对它们进行序列操作。让我们看看map是如何在序列抽象中定义的，这样你就能理解一般的抽象编程。</description>
    </item>
    
    <item>
      <title>Chapter3 速成班</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter3/</link>
      <pubDate>Thu, 13 Jan 2022 11:12:19 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter3/</guid>
      <description>做事情：Clojure 速成班 是时候学习如何用 Clojure 真正地做事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。
在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!
当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!
语法 Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。
Form 所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。
 数据结构的字面表示（如数字、字符串、Map 和 Vector） 操作  我们使用术语form来指代有效的代码。我有时也会用表达式来指代 Clojure Form。但不要太纠结于术语。Clojure 求值每一个 Form，以产生一个值。这些字面意义的表达都是有效的 Form。
1 2 3  1 &amp;#34;a string&amp;#34; [&amp;#34;a&amp;#34; &amp;#34;vector&amp;#34; &amp;#34;of&amp;#34; &amp;#34;strings&amp;#34;]   当然，你的代码很少包含自由浮动的字符，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你做事情的方式。所有操作的 Form 都是：开括号，操作符，操作数，闭括号。
1  (operator operand1 operand2 ... operandn)   请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。</description>
    </item>
    
    <item>
      <title>Chapter2 如何使用 Emacs</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter2/</link>
      <pubDate>Thu, 13 Jan 2022 10:43:56 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter2/</guid>
      <description>如何使用 Emacs，一个优秀的 Clojure 编辑器 在你掌握 Clojure 的过程中，你的编辑器将是你最亲密的盟友。我强烈建议使用 Emacs，但你当然也可以使用任何你想要的编辑器。如果你不遵循本章中关于 Emacs 的详尽说明，或者你选择使用一个不同的编辑器，那么至少值得投入一些时间来设置你的编辑器，以便与 REPL 一起工作。我推荐的两个在社区中受到好评的替代品是Cursive和Nightcode。
我推荐 Emacs 的原因是，它提供了与 Clojure REPL 的紧密集成，这使你可以在写作时立即尝试你的代码。这种紧密的反馈回路在学习 Clojure 和以后编写真正的 Clojure 程序时都很有用。Emacs 也很适合与任何 Lisp 方言一起工作；事实上，Emacs 是用一种叫做 Emacs Lisp（elisp）的 Lisp 方言编写的。
在本章结束时，你的 Emacs 设置将看起来像图 2-1。
图 2-1: 使用 Clojure 的典型 Emacs 设置：一边是代码，另一边是 REPL。
为了达到这个目的，你将从安装 Emacs 开始，设置一个适合新人的 Emacs 配置。然后你将学习基础知识：如何打开、编辑和保存文件，以及如何使用基本的键绑定与 Emacs 进行交互。最后，你将学习如何实际编辑 Clojure 代码并与 REPL 进行交互。
安装 你应该使用 Emacs 的最新主要版本，即 Emacs 24，用于你工作的平台。
 OS X从*http://emacsformacosx.com*安装 vanilla Emacs 作为一个 Mac 应用程序。其他选项，如 Aquamacs，应该是为了使 Emacs 更 &amp;ldquo;像 Mac&amp;rdquo;，但从长远来看是有问题的，因为它们的设置与标准 Emacs 有很大的不同，以至于很难使用 Emacs 手册或跟随教程。 Ubuntu按照*https://launchpad.</description>
    </item>
    
    <item>
      <title>Chapter1 构建、运行和 REPL</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter1/</link>
      <pubDate>Thu, 13 Jan 2022 10:26:48 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter1/</guid>
      <description>构建、运行和 REPL 在本章中，你将预先投入少量时间来熟悉建立和运行 Clojure 程序的快速、傻瓜式方法。让一个真正的程序运行起来感觉很好。达到了这个里程碑，你就可以自由地进行实验，分享你的工作，并向那些仍在使用上个世纪的语言的同事幸灾乐祸。这将有助于保持你的积极性!
你还将学习如何使用*Read-Eval-Print Loop（REPL）*在一个正在运行的 Clojure 进程中即时运行代码，这使你能够快速测试你对语言的理解并更有效地学习。
但首先，我将简要地介绍 Clojure。接下来，我将介绍 Leiningen，这是 Clojure 事实上的标准构建工具。在本章结束时，你将知道如何做以下事情。
 用 Leiningen 创建一个新的 Clojure 项目 构建该项目以创建一个可执行的 JAR 文件 执行 JAR 文件 在 Clojure REPL 中执行代码  第一重要的事: 什么是 Clojure Clojure 是由 Rich Hickey 在一座神话般的火山中铸造的。他使用 Lisp、函数式编程和他自己的一绺史诗般的头发的合金，创造了一种令人愉快而强大的语言。它的 Lisp 遗产使你有能力写出比大多数非 Lisp 语言更有表现力的代码，而它对函数式编程的独特理解将使你作为一个程序员的思维更敏锐。此外，Clojure 为你提供了更好的工具来处理复杂的领域（如并发编程），这些领域在传统上被认为会使开发人员陷入多年的治疗中。
不过，在谈论 Clojure 时，重要的是要牢记 Clojure 语言和 Clojure 编译器之间的区别。Clojure 语言是一种强调函数的 Lisp 方言，其语法和语义与任何实现都无关。编译器是一个可执行的 JAR 文件，clojure.jar，它接收用 Clojure 语言编写的代码并将其编译为 Java 虚拟机（JVM）字节码。你会看到Clojure被用来指代语言和编译器，如果你不知道它们是独立的东西，就会感到困惑。但现在你意识到了，你就会好起来。
这种区分是必要的，因为与大多数编程语言如 Ruby、Python、C 和其他许多语言不同，Clojure 是一种托管语言。Clojure 程序在 JVM 中执行，并依赖 JVM 的核心功能，如线程和垃圾收集。Clojure 还针对 JavaScript 和微软的通用语言运行时（CLR），但本书只关注 JVM 的实现。</description>
    </item>
    
    <item>
      <title>Introduction 简介</title>
      <link>https://zhenfeng-zhu.github.io/post/introduction/</link>
      <pubDate>Thu, 13 Jan 2022 10:11:25 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/introduction/</guid>
      <description>简介 在你的内心深处，你一直都知道你注定要学习 Clojure。 每当你高举着键盘，为一个难以理解的类层次结构而痛苦地哭泣时；每当你晚上躺在床上，为一个突变引起的海森堡虫而哭泣扰乱你的亲人时；每当一个竞赛条件使你拔掉更多你不断减少的头发时，你的某个秘密部分已经知道一定有一个更好的办法。
现在，终于，你面前的教学材料将使你与你渴望已久的编程语言结合起来。
学习一种新的编程语言：穿越四个迷宫的旅程 为了最大限度地发挥 Clojure 的作用，你需要在每个学习新语言的程序员面临的四个迷宫中找到自己的路。
 工具之林 友好而高效的编程环境使你能够轻松地尝试你的想法。你将学习如何设置你的环境。 语言之山 随着你的攀登，你将获得 Clojure 的语法、语义和数据结构方面的知识。你将学习如何使用最强大的编程工具之一&amp;ndash;宏，并学习如何利用 Clojure 的并发结构来简化你的生活。 神器之洞 在它的深处，你将学会构建、运行和发布你自己的程序，以及如何使用代码库。你还将学习 Clojure 与 Java 虚拟机（JVM）的关系。 心态云堡 在其稀薄的空气中，你将了解 Lisp 和函数式编程的原因和方法。你将了解渗透在 Clojure 中的简单哲学，以及如何像 Clojurist 一样解决问题。  别搞错了，你要工作。但这本书会让你感觉到工作是令人振奋的，而不是疲惫的。这是因为本书遵循三个准则。
 它采取了甜点优先的方法，给你提供了你需要的开发工具和语言细节，以便立即开始玩真正的程序。 它假定你对 JVM、函数式编程或 Lisp 没有经验。它详细地涵盖了这些主题，所以当你构建和运行 Clojure 程序时，你会对你正在做的事情感到自信。 它避开了 真实世界 的例子，而选择了更有趣的练习，如 攻击霍比特人 和 追踪闪亮的吸血鬼 。  到最后，你将能够使用 Clojure&amp;ndash;现存的最令人兴奋和最有趣的编程语言之一!
本书是如何组织的 本书分为三个部分，以便更好地指导你完成你的勇敢探索，勇敢的初出茅庐的 Clojurist。
第一部分：环境设置 为了保持动力和高效学习，你需要实际写代码和构建可执行文件。这些章节将带领你快速浏览你所需要的工具，以便轻松地编写程序。这样，你就可以专注于学习 Clojure，而不是摆弄你的环境。
第 1 章：构建、运行和 REPL
让一个真正的程序运行起来，有一种强大的激励作用。一旦你能做到这一点，你就可以自由地进行实验，而且你可以真正地分享你的工作
在这短短的一章中，你将投入少量时间来熟悉建立和运行 Clojure 程序的快速方法。你将学习如何在一个正在运行的 Clojure 进程中使用 read-eval-print 循环（REPL）来实验代码。这将收紧你的反馈回路，帮助你更有效地学习。</description>
    </item>
    
    <item>
      <title>Acknowledgments 致谢</title>
      <link>https://zhenfeng-zhu.github.io/post/acknowledgments/</link>
      <pubDate>Thu, 13 Jan 2022 10:06:10 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/acknowledgments/</guid>
      <description>致谢 有很多人帮助我诞生了这个奇怪的婴儿，我对他们的支持感到感激。
首先，感谢我的妻子杰西，她为这本书绘制了插图，使它具有我所希望的视觉特性。也感谢你的支持，感谢你在我处于疯狂的作家模式时容忍我。(附注：通过一本编程书的封面感谢我的妻子，感觉很奇怪。）
感谢我在麦肯锡的朋友和同事，他们阅读了早期的修订稿并鼓励我继续写作。其中最重要的是 Pat Shaughnessy、Alex Rothenberg、Thomas Newton、Jalil Fanaian、Chris Parker、Mark Daggett、Christian Lilley，以及 Mike Morreale。你们都太伟大了；请搬到 Durham。
感谢我的朋友布里奇特-希勒（Bridget Hillyer）一直以来的支持。我总是觉得你是我的后盾，这对我来说意义重大。也感谢我的朋友乔-杰克逊，感谢他阅读、听我喋喋不休、并为我提供反馈，并感谢他在我面前对其他人大谈这本书，让我感觉很酷。Alan Dipert，朋友，技术评论员，现在的同事，我向你表示万分感谢，感谢你出色的技术编辑，感谢你首先将我引入 Clojure。
我不知道是否每个作家都会不断地问自己：&amp;ldquo;我到底为什么要这样做？是否有人会读它？&amp;ldquo;但我肯定会这样做。因此，我想感谢所有在这本书的最初网络版本编写过程中写信给我并建议进行编辑的友好人士。这些积极的反馈使我感到有信心，我正在做一件有意义的事情。同样地，感谢所有购买 Leanpub 版本的人
非常感谢 Clojure 社区领导人 Eric Normand、David Nolen 和 Alex Miller 对本书的积极宣传。在下一届 Conj 大会上见!
最后，要感谢 No Starch 出版社的各位同仁，感谢你们对本书的帮助，使之成为我无比自豪的作品。感谢你们的高标准。感谢你们不断地促使本书更加清晰，甚至提出笑话。(Seph 的 &amp;ldquo;蜡球 &amp;ldquo;编辑仍然让我开怀大笑。) Seph Kramer, Riley Hoffman, Hayley Baker, Alison Law, Tyler Ortman, Anne Marie Walker: 谢谢你们!</description>
    </item>
    
    <item>
      <title>Foreword 前言</title>
      <link>https://zhenfeng-zhu.github.io/post/foreword/</link>
      <pubDate>Thu, 13 Jan 2022 10:04:46 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/foreword/</guid>
      <description>前言 当你阅读这本搞笑的书时，你会在某个时刻经历一个非常严肃的时刻。在了解了一些 Clojure 之后，编程变得更加有趣。这也是你在这本书上的投资，包括金钱和时间，得到回报的时刻&amp;ndash;有趣。
幽默与严肃性有一定的关系。对严肃的事情开玩笑是合适的，但只有在适当的时间过去之后。例如，当我想起我最喜欢的叔叔的最后一句话时，我花了很多年才能够破涕为笑。&amp;ldquo;拿着我的啤酒&amp;rdquo;。
这本书的工作方式正好相反。它在严肃事件发生之前，甚至在严肃事件发生期间，适时地指出了真正有趣的事情&amp;ndash;那一刻你意识到你因为 Clojure 而更喜欢编程。它在做到这一点的同时，并没有掩盖你将要学习的 Clojure 编程的深层技术层面。
这种方法令人耳目一新，因为我读过的大多数编程书籍都比骆驼的屁还干。我们很幸运，丹尼尔是一位出色的程序员和作家，他的妻子杰斯是一位同样出色的插图画家。我们特别幸运的是，他们两个都疯了，决定在完全相同的时间写一本书。
Clojure 是本书的主题，但在某种程度上它&amp;ndash;或者说它的创造者 Rich Hickey&amp;ndash;也是作者之一，因为 Clojure 是有史以来最优雅的编程语言。就像早午餐的概念一样，Clojure 是如此的优雅，以至于如果不以某种方式提高他们的水平，就很难告诉别人关于它的任何事情。
优雅是编程语言家族中许多 Lisp 方言经常被赋予的品质，Clojure 就是其中之一。所有的 Lisp 都是由数学家 John McCarthy 在 1958 年做出的一系列简单而美丽的发现演变而来。
自 1958 年以来，出现了许多 Lisp 方言 和 Lisp 书籍。还有更多的 Lisp 方言 和书籍即将问世。作为过去和未来的神器，每一种都适合它们的作者在各自的时代所面临的独特的约束和欲望的组合。
我发现 Clojure，以及这本关于它的特殊书籍，特别适合现在。我希望你也会这样。
Alan Dipert</description>
    </item>
    
    <item>
      <title>Thrfit 入门</title>
      <link>https://zhenfeng-zhu.github.io/post/thrfit-get-started/</link>
      <pubDate>Thu, 06 Jan 2022 10:41:45 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/thrfit-get-started/</guid>
      <description>本文主要介绍 Thrift 的 IDL 基本语法。
 IDL Thrift 采用 IDL（Interface Definition Language）来定义通用的服务接口，然后通过 Thrift 提供的编译器，可以将服务接口编译成不同语言编写的代码，通过这个方式来实现跨语言的功能。
基本类型 thrift基本支持所有的 Java 基本类型以及引用类型。
 bool  布尔值，对应 java 中的 boolean   byte  有符号字节，对应 java 中的 byte   i16  16 位有符号整型，对应 java 中的 short   i32  32 位有符号整型，对应 java 中的 int   i64  64 位有符号整型，对应 java 中的 long   double  64 位浮点型，对应 java 中的 double   string  字符串，对应 java 中的 String   binary  对应 java 中的 byte[]    struct 结构体 struct 有以下的一些约束：</description>
    </item>
    
    <item>
      <title>修复 Vscode Git Cannot Use Api Proposal ScmValidation</title>
      <link>https://zhenfeng-zhu.github.io/post/fix-vscode-git-cannot-use-api-proposal-scmvalidation/</link>
      <pubDate>Thu, 06 Jan 2022 10:29:52 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/fix-vscode-git-cannot-use-api-proposal-scmvalidation/</guid>
      <description>问题表现 某天，我的 vscode 的 git 管理出现了问题。
类似这个样子。
解决方式 1  @builtin @id:vscode.git   直接卸载了。
出现原因 应该是某个公司的插件给我自动装上导致的</description>
    </item>
    
    <item>
      <title>Gavin Wood: Web3 去中心化技术是维护自由民主的唯一希望</title>
      <link>https://zhenfeng-zhu.github.io/post/what-is-web3/</link>
      <pubDate>Wed, 05 Jan 2022 10:20:39 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/what-is-web3/</guid>
      <description>Gavin Wood 在 2014 年创造了 Web3（最初是 Web 3.0）这个词。当时，他刚开始帮助开发以太坊，这是一种在知名度和市场规模上仅次于比特币的加密货币。如今，他经营着支持去中心化技术项目的 Web3 基金会，以及专注于为 Web3 构建区块链基础设施的公司 Parity Technologies。居住在瑞士的 Gavin 上周通过视频与我讨论了 Web 2.0 出错的地方、他对未来的展望，以及为什么我们都需要更少的信任。以下采访是我们谈话的记录的整理版。
  WIRED：据我所知，Web3 最基本的想法是当前的 Web2.0 不好。因此，在我们讨论 Web3 会带来什么之前，你会怎么描述现在的问题？
Gavin Wood：我认为 Web 2.0 的模型与互联网出现之前的社会模型非常相似。如果你回到 500 年前，人们基本上只在他们的小村庄和乡镇，并与他们认识的人进行交易。从广义上讲，他们依靠社会结构来确保他们的期望是可信的，并且很可能会真正发生，比如，这些苹果没有腐烂，或者这个马蹄铁在三周后不会破裂。
这种机制运行很好，因为在城镇之间移动既困难又耗时且成本高昂。所以你有相当高的可信度，就会有人留下来，他们并不想被流放。
但是随着社会变得更大规模，我们有了城市、国家和国际组织，我们开始关注这种奇怪的品牌声誉问题。我们创建了这些强大但受监管的机构，监管机构原则上确保满足我们的期望。想要在特定行业开展业务，你必须满足某些法定要求。
这不是一个很好的解决方案，原因有几个。其中之一是，去监管新兴产业非常困难。政府的行动是比较缓慢的，需要一段时间才能赶上。另一个是监管机构不完善。尤其是当他们与行业密切合作时，行业和监管机构之间通常会存在一些旋转门关系。
另一个是监管机构的支持力度非常有限，也就是政府投入多少资金。因此，监管将是不完整的。他们能够监管最大的罪犯，但他们无法在任何地方都保持真正强大的影响力。当然，监管机构和法律因司法管辖区而异。如果你去欧盟的某个地方，那么 xx 活动就可以了；如果你去别的地方，那就不行了。随着我们成为一个非常国际化的社会，这实际上意味着你的期望仍未得到满足。
所以我们需要超越这一点。但不幸的是，Web 2.0 仍然存在于这种非常中心化的模型中。
WIRED：我们真的在谈论技术的失败吗？还是我们在谈论治理、监管和竞争政策的失败？因为听起来你是在说：这是监管的失败，但答案却不是更好的监管，而是需要有一个新的技术层，因为监管失败是不可避免的。我是否正确描述了您的观点？
Gavin Wood：是的，这个模型坏了。
WIRED：那么让我们来谈谈应该用什么来代替它。我们一直在讨论为什么 Web 2.0 不起作用。你对 Web3 的定义是什么？
Gavin Wood：Less trust, more truth。更少的信任，更多的事实。
WIRED：“less trust”是什么意思？
Gavin Wood：我对信任有一个特殊的含义，它本质上是信仰。这是一种信念（faith），即某些事情会发生的信仰，世界会以某种方式运转，而没有任何真实的证据或理性的论据来说明为什么会发生这种情况。所以我们想要的更少的信任，我们想要更多的事实真相。我真正想表达的意思是在 Web3 下更加可以相信我们的期望会得到满足。
WIRED：这听起来像是在说“减少盲目信仰，增加信誉的可信度”。
Gavin Wood：可以说是，也可以说不是。我认为信任本身实际上围绕着坏事。信任意味着你将某种权力授予其他人或某个组织，他们将能够以某种任意方式使用该权力。一旦它成为可信的信任，它就不再是真正的信任。它会有一个机制，一个基本原理，一个论点，一个逻辑机制。无论如何，但在我看来，这不是信任。
WIRED：已经写到 Web3 将打破像 Google 和 Facebook 这样的垄断企业平台。你能解释一下它将如何做到这一点吗？</description>
    </item>
    
    <item>
      <title>Openfaas Workshop Lab11</title>
      <link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab11/</link>
      <pubDate>Tue, 04 Jan 2022 13:44:15 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab11/</guid>
      <description>Lab 11 - 高级函数 - 使用 HMAC 的信任 前言 用于微服务的传统认证策略与函数的工作原理完全相同。在这个实验室中，我们将讨论使用共享秘密和基于哈希的消息验证码（HMAC）的几种可用方法之一。有关其他认证策略和想法，请参见。openfaas-function-auth
这绝不是一个广泛的清单，安全和认证是一个复杂的领域，最好留给专家使用经过试验的方法。
准备好你的环境 在开始这个实验之前，创建一个新的文件夹
1 2  mkdir -p lab11\`bash  &amp;amp;&amp;amp; cd lab11   也要确保你的faas-cli&#39;版本是0.7.4&amp;rsquo;或以上，使用以下命令。
1  faas-cli version   什么是 HMAC 如果没有任何形式的认证或信任，我们的函数可能会暴露给任何能猜到其 URL 的人。如果我们的函数可以在互联网或本地网络上访问，那么它们就可能被坏的行为者调用。默认情况下，函数会对任何请求做出响应。然而，如果我们想控制对函数的访问，我们可以使用基于哈希的消息验证码（HMAC）来验证信息的来源。
来自[alexellis/hmac]（https://github.com/alexellis/hmac）。
 HMAC 使用发送方/接收方提前共享的对称密钥。发送方在想要传输信息时将产生一个哈希值&amp;ndash;该数据与有效载荷一起发送。然后，收件人将用共享密钥签署有效载荷，如果哈希值匹配，则假定有效载荷来自发件人。
 这样我们就可以避免我们的函数被无效的甚至是危险的信息所调用。
使用 HMAC 我们将使用 faas-cli 提供的--sign标志来包含一个头，其中包含使用我们用--key标志提供的共享密钥创建的散列信息。
 注意: --sign和--key必须同时存在。
 让我们首先通过部署-env函数来检查该标志的作用，该函数将打印函数中可访问的所有环境变量。
1  faas-cli deploy --name env --fprocess=&amp;#34;env&amp;#34; --image=&amp;#34;function/alpine:new&amp;#34;    调用不带--sign标志的函数。  1 2 3 4 5 6 7 8 9 10 11 12 13 14  $ echo &amp;#34;The message&amp;#34; | faas-cli invoke env PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/sbin:/bin HOSTNAME=d2c1a2cb20c2 fprocess=env HOME=/root Http_X_Call_Id=b84947c6-2970-4fcf-ba3b-66dde6943999 Http_X_Forwarded_For=10.</description>
    </item>
    
    <item>
      <title>Openfaas Workshop Lab10</title>
      <link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab10/</link>
      <pubDate>Tue, 04 Jan 2022 13:44:12 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab10/</guid>
      <description>Lab 10 - 高级函数 - 秘密 在开始本实验室之前，为你的文件创建一个新的文件夹。由于本实验室是建立在先前的实验室基础上的，因此请复制 lab5。
1 2  $ cp -r lab5 lab10\  &amp;amp;&amp;amp; cd lab10   使用秘密 实验室 5研究了issue-bot如何从环境变量（auth_token）获得 GitHub 的*个人访问令牌。 另一种方法是使用机密来存储敏感信息。
来自 Docker 文档。
 &amp;hellip; 秘密是一团数据，如密码、SSH 私钥、SSL 证书或其他数据，不应通过网络传输或未经加密存储在 Docker 文件或应用程序的源代码中。
 这是一个比环境变量更安全的选择。环境变量更容易使用，但最适合于非保密的配置项目。 似乎很适合用于存储auth_token值。
请参阅docs中关于秘密的更多信息和它的设计。
创建一个秘密  秘密名称必须遵循 DNS-1123 惯例，由小写字母数字字符或&amp;rsquo;-&amp;lsquo;组成，并且必须以一个字母数字字符开始和结束
 从一个终端运行以下命令。
1  echo -n &amp;lt;auth_token&amp;gt; | faas-cli secret create auth-token   测试秘密是否被创建。
1  faas-cli secret ls    注意：请记住，-g标志可以在网关之间轻松切换。 这也适用于秘密。</description>
    </item>
    
    <item>
      <title>Openfaas Workshop Lab9</title>
      <link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab9/</link>
      <pubDate>Tue, 04 Jan 2022 13:44:09 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab9/</guid>
      <description>Lab 9 - 高级函数 - 自动缩放 自动缩放函数的应用 正如文档中描述的那样，OpenFaaS 带有自动扩展函数。在这个实验室中，我们将看看自动扩展是如何运作的。
前提条件   在完成了Lab 1中对 OpenFaaS 的设置后，你将拥有触发自动扩展所需的一切。
  多个工具可以用来创建足够的流量来触发自动扩展 - 在这个例子中，`curl&amp;rsquo;将被使用，因为它很容易在 Mac 和 Linux 上使用，并在 Windows 上与 Git Bash 打包。
  自动扩展的背景 开箱即用的 OpenFaaS 是这样配置的，它将根据 Prometheus 测量的 每秒请求指标进行自动扩展。 这个指标是在流量通过 API 网关的时候捕获的。如果超过了定义的 每秒请求的阈值，AlertManager 就会启动。这个阈值应该被重新配置为适合生产使用的水平，因为在这个例子中，为了演示，它被设置为一个低值。
 在文档网站中找到更多关于自动缩放的信息。
 每次警报被 AlertManager 触发时，API 网关将把你的函数的一定数量的副本添加到集群中。OpenFaaS 有两个配置选项，允许指定复制的起始/最低数量，也允许停止复制的最大数量。
你可以通过设置com.openfaas.scale.min来控制函数的最小复制量，目前默认值为1。
你可以通过设置com.openfaas.scale.max来控制一个函数可以产生的最大复制量，目前默认值是20。
 注意: 如果你把com.openfaas.scale.min和com.openfaas.scale.max设置成相同的值，你就会禁用自动缩放函数。
 查看 Prometheus 你需要运行这个端口转发命令，以便能够在http://127.0.0.1:9090访问 Prometheus。
1  kubectl port-forward deployment/prometheus 9090:9090 -n openfaas   现在添加一个所有成功调用部署的函数的图。我们可以通过执行rate( gateway_function_invocation_total{code=&amp;quot;200&amp;quot;} [20s])作为查询来实现。导致一个看起来像这样的页面。</description>
    </item>
    
    <item>
      <title>Openfaas Workshop Lab8</title>
      <link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab8/</link>
      <pubDate>Tue, 04 Jan 2022 13:44:05 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab8/</guid>
      <description>Lab 8 - 高级函数 - 超时 在开始这个实验之前，为你的文件创建一个新的文件夹。
1 2  $ mkdir -p lab8 \  &amp;amp;&amp;amp; cd lab8   用read_timeout扩展超时时间 timeout对应于一个函数可以运行多长时间，直到被执行。它对防止分布式系统中的误操作很重要。
有几个地方可以为你的函数配置超时，在每个地方都可以通过使用环境变量来完成。
  函数超时
  read_timeout - 允许函数通过 HTTP 读取一个请求的时间
  write_timeout - 允许函数在 HTTP 上写一个响应的时间
  exec_timeout - 一个函数在被终止前可以运行的最大时间。
  API 网关的默认时间是 20 秒，所以我们来测试一下在一个函数上设置一个更短的超时时间。
1  faas-cli new --lang python3 sleep-for --prefix=&amp;#34;&amp;lt;your-docker-username-here&amp;gt;&amp;#34;   编辑handler.py。
1 2 3 4 5 6 7 8 9 10 11 12 13 14  import time import os  def handle(req):  &amp;#34;&amp;#34;&amp;#34;handle a request to the function Args: req (str): request body &amp;#34;&amp;#34;&amp;#34;   sleep_duration = int(os.</description>
    </item>
    
    <item>
      <title>Openfaas Workshop Lab7</title>
      <link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab7/</link>
      <pubDate>Tue, 04 Jan 2022 13:44:02 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab7/</guid>
      <description>实验 7&amp;ndash;异步函数 在开始这个实验之前，为你的文件创建一个新的文件夹。
1 2  $ mkdir -p lab7 \  &amp;amp;&amp;amp; cd lab7   同步与异步地调用一个函数 当你同步调用一个函数时，一个连接会通过网关连接到你的函数，并且在整个执行过程中保持开放。同步调用是*阻塞的，所以你应该看到你的客户端暂停，变得不活跃，直到该函数完成其任务。
 网关使用的路由是。/function/&amp;lt;function_name&amp;gt;。 你必须等待，直到它完成 你在调用后得到结果 你知道它是通过还是失败  异步任务以类似的方式运行，但有一些区别。
 网关使用不同的路由：/async-function/&amp;lt;function_name&amp;gt;。 客户端从网关得到一个立即的202 接受的响应。 该函数稍后使用一个队列工作器来调用 默认情况下，结果被丢弃  让我们试一试快速演示。
1  faas-cli new --lang dockerfile long-task --prefix=&amp;#34;&amp;lt;your-docker-username-here&amp;gt;&amp;#34;   编辑long-task/Dockerfile并将 fprocess 改为sleep 1。
现在构建、部署并同步调用你的函数 10 次，像这样。
1 2 3 4 5 6 7 8 9 10  echo -n &amp;#34;&amp;#34; | faas-cli invoke long-task echo -n &amp;#34;&amp;#34; | faas-cli invoke long-task echo -n &amp;#34;&amp;#34; | faas-cli invoke long-task echo -n &amp;#34;&amp;#34; | faas-cli invoke long-task echo -n &amp;#34;&amp;#34; | faas-cli invoke long-task echo -n &amp;#34;&amp;#34; | faas-cli invoke long-task echo -n &amp;#34;&amp;#34; | faas-cli invoke long-task echo -n &amp;#34;&amp;#34; | faas-cli invoke long-task echo -n &amp;#34;&amp;#34; | faas-cli invoke long-task echo -n &amp;#34;&amp;#34; | faas-cli invoke long-task   现在异步调用该函数 10 次。</description>
    </item>
    
    <item>
      <title>Openfaas Workshop Lab6</title>
      <link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab6/</link>
      <pubDate>Tue, 04 Jan 2022 13:43:59 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab6/</guid>
      <description>实验 6&amp;ndash;你的函数的 HTML 在开始这个实验之前，为你的文件创建一个新的文件夹。
1 2  $ mkdir -p lab6\  &amp;amp;&amp;amp; cd lab6   从一个函数中生成并返回基本的 HTML 函数可以返回 HTML，并将Content-Type设置为text/html。因此，函数返回的 HTML 可以通过浏览器进行渲染。让我们创建一个简单的函数，生成并返回一个基本的 HTML。
1  faas-cli new --lang python3 show-html --prefix=&amp;#34;&amp;lt;your-docker-username-here&amp;gt;&amp;#34;   编辑handler.py。
1 2 3 4 5 6 7 8 9  def handle(req):  &amp;#34;&amp;#34;&amp;#34;handle a request to the function Args: req (str): request body &amp;#34;&amp;#34;&amp;#34;   html = &amp;#39;&amp;lt;html&amp;gt;&amp;lt;h2&amp;gt;Hi, from your function!&amp;lt;/h2&amp;gt;&amp;lt;/html&amp;gt;&amp;#39;   return html   这将返回 HTML 给调用者。 还有一件事我们应该做的是设置响应的Content-Type&#39;。我们100%确定这个函数将返回一个HTML，所以Content-Type应该总是text/html。我们可以利用show-html.</description>
    </item>
    
    <item>
      <title>Openfaas Workshop Lab5</title>
      <link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab5/</link>
      <pubDate>Tue, 04 Jan 2022 13:43:56 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab5/</guid>
      <description>Lab 5 - 创建一个 GitHub 机器人 在开始这个实验之前，为你的文件创建一个新的文件夹。
1 2  $ mkdir -p lab5\  &amp;amp;&amp;amp; cd lab5   我们将使用 OpenFaaS 的函数来创建一个名为 issue-bot的 GitHub 机器人。
问题机器人的工作是通过分析 描述 字段的情绪来分流新的问题，然后它将应用一个积极或审查的标签。这将有助于维护者在繁忙的工作中，可以优先考虑哪些问题需要首先处理。
问题机器人的图示](./diagram/issue-bot.png)
获取一个 GitHub 账户   注册一个GitHub 账户，如果你还没有一个账户。
  创建一个新的仓库，并将其称为bot-test。
  注意：我们将只使用这个仓库作为创建问题的测试场所。你不需要在那里提交任何代码。
建立一个带有入口的隧道 你需要接收来自 GitHub 的 webhooks。幸运的是，inlets 让这一切变得非常快速和简单。它可以按月或按年订阅，所以如果你不确定是否全年都需要它，你可以只付一个月的钱。
inlets 有一个叫做 inlets-operator 的 Kubernetes 集成。你可以用它来设置 LoadBalancers 或带有 TLS 的 Ingress。它的工作原理是为你创建一个云虚拟机，并在那里运行一个隧道服务器，然后为你运行一个隧道客户端作为一个 Pod，你就可以获得传入流量。
在你喜欢的云提供商（如 DigitalOcean）的 API 页面下创建一个写入访问令牌，然后将内容保存到digital-ocean-api-token.txt。
设置完订阅后，将你的密钥保存到$HOME/.inlets/LICENSE，然后运行以下程序。
1 2 3 4  arkade install inlets-operator \  --provider digitalocean \  --region lon1 \  --token-file $HOME/digital-ocean-api-token.</description>
    </item>
    
    <item>
      <title>Blockchain 数据结构分析</title>
      <link>https://zhenfeng-zhu.github.io/post/blockchain-schema/</link>
      <pubDate>Tue, 04 Jan 2022 10:04:05 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/blockchain-schema/</guid>
      <description>区块 想要了解区块到底是什么，最简单快捷的方法就是分析它的数据结构，以 bitcoin 种的区块为例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  { 　&amp;#34;hash&amp;#34;:&amp;#34;00000000000000000018b0a6ae560fa33c469b6528bc9e0fb0c669319a186c33&amp;#34;, 　&amp;#34;confirmations&amp;#34;:1009, 　&amp;#34;strippedsize&amp;#34;:956228, 　&amp;#34;size&amp;#34;:1112639, 　&amp;#34;weight&amp;#34;:3981323, 　&amp;#34;height&amp;#34;:514095, 　&amp;#34;version&amp;#34;:536870912, 　&amp;#34;versionHex&amp;#34;:&amp;#34;20000000&amp;#34;, 　&amp;#34;merkleroot&amp;#34;:&amp;#34;5f8f8e053fd4c0c3175c10ac5189c15e6ba218909319850936fe54934dcbfeac&amp;#34;, 　&amp;#34;tx&amp;#34;:[ 　// ... 　], 　&amp;#34;time&amp;#34;:1521380124, 　&amp;#34;mediantime&amp;#34;:1521377506, 　&amp;#34;nonce&amp;#34;:3001236454, 　&amp;#34;bits&amp;#34;:&amp;#34;17514a49&amp;#34;, 　&amp;#34;difficulty&amp;#34;:3462542391191.563, 　&amp;#34;chainwork&amp;#34;:&amp;#34;0000000000000000000000000000000000000000014d2b41a340e60b72292430&amp;#34;, 　&amp;#34;previousblockhash&amp;#34;:&amp;#34;000000000000000000481ab128418847dc25db4dafec464baa5a33e66490990b&amp;#34;, 　&amp;#34;nextblockhash&amp;#34;:&amp;#34;0000000000000000000c74966205813839ad1c6d55d75f95c9c5f821db9c3510&amp;#34; }   在这个 Block 的结构体中，previousblockhash 和 merkleroot 是两个最重要的字段；前者是一个哈希指针，它其实是前一个 Block 的哈希，通过 previousblockhash 我们能递归地找到全部的 Block，也就是整条主链，后者是一个 Merkle 树的根，Merkle 树中包含整个 Block 中的全部交易，通过保存 merkleroot，我们可以保证当前 Block 中任意交易都不会被修改。 Ethereum 的区块链模型虽然与 Bitcoin 有非常大的不同，但是它的 Block 结构中也有着类似的信息：</description>
    </item>
    
    <item>
      <title>轻服务 nodejs 助力爬虫 web3</title>
      <link>https://zhenfeng-zhu.github.io/post/how-to-crawl-a-web-in-nodejs/</link>
      <pubDate>Mon, 20 Dec 2021 09:58:58 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/how-to-crawl-a-web-in-nodejs/</guid>
      <description>周末的时候，写了一个简单的小项目，用来抓取 web3 的文章，然后存到本地。最后选取了公司对外的轻服务：https://qingfuwu.cn/docs/nodejs/
整项目用到了两个库
 axios：用来做 http 请求 cheerio：用来解析 html  观察目标网页的格式 我们以巴比特为例：https://www.8btc.com/web3.0，打开控制台，定位到正文的 div，可以发现是 article-list。
右键复制一下 selector，然后在代码中这样实现就可以了。
抓取网页信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  const cheerio = require(&amp;#39;cheerio&amp;#39;).default const axios = require(&amp;#39;axios&amp;#39;).default  async function getData() {  const data = await (await axios.get(&amp;#39;https://www.8btc.com/web3.0&amp;#39;,  {  headers:  { &amp;#39;User-Agent&amp;#39;: &amp;#39;Mozilla/5.</description>
    </item>
    
    <item>
      <title>Crystal Roadmap</title>
      <link>https://zhenfeng-zhu.github.io/post/crystal_roadmap/</link>
      <pubDate>Thu, 28 Oct 2021 10:11:41 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/crystal_roadmap/</guid>
      <description>This roadmap defines the things that we want to have in the language and plan to do.
Language Stuff that has to do with the language syntax, semantic and runtime.
Concurrency Finalize multithreading support, so fibers can run on multiple threads.
Windows support Finalize support for Windows platform. The compiler already works, but some stdlib features like concurrency support are still missing. Ongoing efforts on #5430.
Type system review Make a review and possible formalisation of Crystal&amp;rsquo;s type system, with a strong emphasis on generics, type restrictions and the meta-model in general.</description>
    </item>
    
    <item>
      <title>Crystal 1.2 版本更新说明</title>
      <link>https://zhenfeng-zhu.github.io/post/crystal1.2/</link>
      <pubDate>Sun, 17 Oct 2021 23:08:51 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/crystal1.2/</guid>
      <description>Crystal 1.2.0 发布 我们正在发布一个包含多个错误修复和改进的新版本。下面我们列出了最重要或最有趣的变化，但没有提到几个错误修正。有关详细信息，请访问发行说明。重大更改标有 ⚠️。
统计数据 在此版本中，我们包含了自 1.1.1 版本以来 32 位贡献者的 181 个 PR。我们感谢为改进语言及其标准库所做的所有努力！❤️
平台支持 正如在 1.2 的上一篇博客文章中提到的，我们决定降低对 32 位 x86 架构的支持。但是我们确实有一些好消息要分享！
我们在原生 Windows 支持方面取得了进展，在此版本中包括套接字实现（#11205、#11137、#10605、#10605）。
与 Windows 相关，也与 ARM64 架构相关，我们修复了一个重要的代码生成错误。我们现在处于将 aarch64 平台提升到 Tier 1 的条件，预计很快就会支持。这也与带有 M1 芯片组的 macOS 相关：从这个版本开始，我们包含一个适用于 x86 和 M1 mac 的通用 macOS 包。
我们发现 Windows 和 M1 的 mac 上出现的两个错误来自 LLVM 11 和 12。我们预计该修复将随最近发布的 LLVM 13 一起提供。Crystal 1.2.0 与 LLVM 12 兼容，尽管我们建议不要使用 LLVM 11 和 12.
语言变化 现在可以将泛型类的子类分配给父类的实例：</description>
    </item>
    
    <item>
      <title>如何理解可观测性</title>
      <link>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/</link>
      <pubDate>Fri, 15 Oct 2021 09:45:38 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/</guid>
      <description>可观测性 可观测性 ≠ 监控   核心不同
 监控以运维为核心，通过各项指标来定义整体的运行状态、失败情况。 观测则以开发为核心，除了监控，它还会对系统进行分析。    维度不同
 监控是从外围的角度，通过各种指标（机器 CPU、负载、网络等维度）来判断整个系统的执行情况。 可观测性则在上述外部指标基础上，以应用内的各个维度来展开推测，通过二者的数据结合来真实的反应应用的运行情况。    展现的信息不同
 有些系统在正常运行时十分稳定，但是一到高并发就会出现问题，此时监控只能汇报问题出现的状况，而可观测性可以很好的通过图形化的方式告知我们问题的原因，不用我们通过经验来猜测。    可观测性打破了开发和运维的原有问题解决方式，不再是运维发现问题开发解决，而是以开发为中心。
监控数据来源   端上访问
 用户体验监控  web 页面的白屏时间 dom 元素/资源加载耗时 文档网络耗时 app 卡顿率 崩溃率 热启动加载时长   日志 端到端  用户端到后端的请求状况，访问量、成功率、响应时间等。 还需要端上所处的地区、网络环境、响应状态码   可用率  访问是否可用、响应耗时长短的一些指标和 cdn、dns 等公共资源有关系。      应用程序
 执行情况 资源消耗 vm 指标监控 容量 服务关系 应用日志 健康情况    业务监控</description>
    </item>
    
    <item>
      <title>如何从零开始写一个静态网站生成器</title>
      <link>https://zhenfeng-zhu.github.io/post/how-to-write-a-static-site-generator/</link>
      <pubDate>Fri, 23 Jul 2021 09:33:18 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/how-to-write-a-static-site-generator/</guid>
      <description>我们常见的静态网站生成器有 Hugo、Hexo 等，程序员们经常会使用类似的工具去将自己的播客托管到 github pages。前段时间研究了一下实现的方式，用 Elixir 简单实现了一个版本。
一个静态网站生成器的工作流程通常有如下几个步骤：
 读取源文件，一般是 markdown 格式的。 模板引擎的渲染 生成目标文件  接下来会从每个步骤来进行简单介绍。
最终版本的请参考：https://github.com/zhenfeng-zhu/ego， 欢迎 pr 和 issue。
极简 MVP 版本介绍 初始化 1  mix new ego   在 mix.exs 中添加依赖
 earmark 是将 markdown 转换为 html。 plug_cowboy 是提供本地预览 html 文件的 server。 json 是一个 json 解析库 指定以 escript 的方式启动  解析 markdown 文件 将一个 markdown 文件转为 html 也是比较简单的，首先读取，然后调用 Earmark.as_html!函数，就能将 markdown 转换为 html 了。
eg.
1 2 3 4 5  def gen_blogs(m) do  m  |&amp;gt; File.</description>
    </item>
    
    <item>
      <title>Openfaas Workshop Lab2</title>
      <link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab2/</link>
      <pubDate>Tue, 30 Mar 2021 09:57:01 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab2/</guid>
      <description>实验室 2&amp;ndash;测试东西 在开始这个实验之前，创建一个新的文件夹。
1 2  $ mkdir -p lab2 \  &amp;amp;&amp;amp; cd lab2   使用 UI 门户 现在你可以测试一下 OpenFaaS 的用户界面了。
如果你已经设置了一个$OPENFAAS_URL，那么就可以得到这个 URL，然后点击它。
1 2  echo $OPENFAAS_URL http://127.0.0.1:31112   如果你没有设置&amp;quot;$OPENFAAS_URL&amp;quot;，那么默认情况下是这样的。http://127.0.0.1:8080.
我们可以部署一些样本函数，然后用它们来测试一下。
1  faas-cli deploy -f https://raw.githubusercontent.com/openfaas/faas/master/stack.yml   你可以在用户界面中试用它们，比如将 Markdown 代码转换为 HTML 的 Markdown 函数。
在Request字段中键入以下内容。
1  ## The **OpenFaaS** _workshop_   现在点击Invoke，看到响应出现在屏幕的下半部分。
即。
1  &amp;lt;h2&amp;gt;The &amp;lt;strong&amp;gt;OpenFaaS&amp;lt;/strong&amp;gt; &amp;lt;em&amp;gt;workshop&amp;lt;/em&amp;gt;&amp;lt;/h2&amp;gt;   你将看到以下字段显示。
 状态 - 该函数是否准备好运行。在状态显示准备好之前，你将不能从用户界面调用该函数。 Replicas - 在集群中运行的函数的副本数量 镜像 - 发布在 Docker Hub 或 Docker 资源库中的 Docker 图像名称和版本 调用次数 - 这显示了该函数被调用的次数，每 5 秒更新一次  点击Invoke若干次，看到Invocation count的增加。</description>
    </item>
    
    <item>
      <title>Openfaas Workshop Lab1b</title>
      <link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab1b/</link>
      <pubDate>Tue, 30 Mar 2021 09:55:20 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab1b/</guid>
      <description>Lab 1 - 用 Kubernetes 设置 OpenFaaS 安装最新的 kubectl 使用下面的说明或官方文档为你的操作系统安装kubectl。
 Linux  1 2 3 4  export VER=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt) curl -LO https://storage.googleapis.com/kubernetes-release/release/$VER/bin/linux/amd64/kubectl chmod +x kubectl mv kubectl /usr/local/bin/    MacOS  1 2 3 4  export VER=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt) curl -LO https://storage.googleapis.com/kubernetes-release/release/$VER/bin/darwin/amd64/kubectl chmod +x kubectl mv kubectl /usr/local/bin/    Windows  1 2 3 4 5  export VER=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt) curl -LO https://storage.</description>
    </item>
    
    <item>
      <title>Openfaas Workshop Lab1</title>
      <link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab1/</link>
      <pubDate>Tue, 30 Mar 2021 09:54:25 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab1/</guid>
      <description>Lab 1 - 为 OpenFaaS 做准备 OpenFaaS 需要一个Kubernetes集群来运行。你可以使用一个单节点集群或多节点集群，不管是在你的笔记本电脑上还是在云端。
任何 OpenFaaS 函数的基本原件都是一个 Docker 镜像，它是使用faas-cli工具链构建的。
前提条件 让我们来安装 Docker、OpenFaaS CLI 以及设置 Kubernetes。
Docker 适用于 Mac
 Docker CE for Mac Edge Edition  适用于 Windows
 仅使用 Windows 10 Pro 或企业版 安装Docker CE for Windows   请确保通过使用 Windows 任务栏通知区的 Docker 菜单来使用Linux容器的 Docker 守护程序。
  安装Git Bash  当你安装 git bash 时，选择以下选项。install UNIX commands和use true-type font。
 注意：请在所有步骤中使用Git Bash：不要试图使用PowerShell、WSL或Bash for Windows。
 Linux - Ubuntu 或 Debian</description>
    </item>
    
    <item>
      <title>Openfaas Workshop</title>
      <link>https://zhenfeng-zhu.github.io/post/openfaas-workshop/</link>
      <pubDate>Tue, 30 Mar 2021 09:53:12 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop/</guid>
      <description>openfaas-workshop 这是一个自定进度的研讨会，学习如何使用 OpenFaaS 构建、部署和运行无服务器函数。
在这个工作坊中，你将首先把 OpenFaaS 部署到你的笔记本电脑或使用 Docker for Mac 或 Windows 的远程集群。然后你将对 OpenFaaS 的用户界面、CLI 和函数商店进行测试。在用 Python 构建、部署和调用你自己的无服务器函数之后，你将继续学习以下内容：用 pip 管理依赖关系，通过安全秘密处理 API 令牌，用 Prometheus 监控函数，异步调用函数以及将函数连接起来创建应用程序。实验的高潮是让你创建自己的 GitHub 机器人，可以自动响应问题。同样的方法可以通过 IFTTT.com 连接到在线事件流&amp;ndash;这将使你能够建立机器人、自动回复器以及与社交媒体和物联网设备的集成。
最后，实验室涵盖了更多的高级主题，并给出了进一步学习的建议。
译文
 日本語 简体中文  免费学习，作为 GitHub 赞助商表示感谢 OpenFaaS 连同这些材料都是免费提供的，需要时间和精力来维护。
 成为OpenFaaS on GitHub的赞助商。  要求 我们在Lab 1中讲解了如何安装这些需求。请在参加讲师指导的研讨会之前做Lab 1。
 函数将用 Python 语言编写，所以有编程或脚本经验者优先。 安装推荐的代码编辑器/IDE VSCode 对于 Windows，安装Git Bash 首选的操作系统。MacOS, Windows 10 Pro/Enterprise, Ubuntu Linux  Docker。
 Docker CE for Mac/Windows 边缘版。 Docker CE for Linux   注意：作为最后的手段，如果你有一台不兼容的 PC，你可以在https://labs.</description>
    </item>
    
    <item>
      <title>Streaming 101</title>
      <link>https://zhenfeng-zhu.github.io/post/streaming-101/</link>
      <pubDate>Fri, 26 Mar 2021 14:11:29 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/streaming-101/</guid>
      <description> 有效的复杂系统总是从简单
 </description>
    </item>
    
    <item>
      <title>K3d With Openfaas</title>
      <link>https://zhenfeng-zhu.github.io/post/k3d-with-openfaas/</link>
      <pubDate>Wed, 10 Mar 2021 20:09:11 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/k3d-with-openfaas/</guid>
      <description>openfaas https://github.com/openfaas/workshop/blob/master/lab1b.md
安装 docker 1  brew install homebrew/cask/docker   安装单节点 K8S 1  brew install k3d   配置单节点 K8S 集群
1 2 3 4 5  k3d cluster create CLUSTER_NAME  k3d kubeconfig merge CLUSTER_NAME --kubeconfig-switch-context  kubectl get pods --all-namespaces   安装 arkade 1  curl -SLsf https://dl.get-arkade.dev/ | sudo sh   安装 openfaas 客户端 faas-cli 1  brew install faas-cli   安装 openfaas server 端 1  arkade install openfaas   配置 openfaas 的 ui 界面</description>
    </item>
    
    <item>
      <title>换一种方式思考</title>
      <link>https://zhenfeng-zhu.github.io/post/%E6%8D%A2%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%80%9D%E8%80%83/</link>
      <pubDate>Sat, 27 Feb 2021 12:16:48 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E6%8D%A2%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%80%9D%E8%80%83/</guid>
      <description> 面向对象不是设计代码的唯一方法 函数式编程不一定是复杂和纯数学的 编程的基础不是赋值、if 语句和循环 并发不一定需要锁、信号量、监视器等类似的东西 进程不必消耗大量的资源 元编程不只是语言的附属品 即使编程是你的工作，也应该是充满乐趣的  </description>
    </item>
    
    <item>
      <title>小白都能快速上手的 Vim 配置</title>
      <link>https://zhenfeng-zhu.github.io/post/vim/</link>
      <pubDate>Sat, 20 Feb 2021 09:56:31 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/vim/</guid>
      <description>首先把所有的 vim 相关的都删除 1 2 3  cd  rm -rf .vim*   创建自己的.vimrc 1  vim .vimrc   一些基本的设置 在.vimrc 中添加下面的代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  &amp;#34; basic set set number set noswapfile set encoding=utf-8 set fileencodings=utf-8,gb18030 set backspace=eol,start,indent set laststatus=2 set colorcolumn=80 set cursorline set linebreak set autoindent set ignorecase set smartcase set ruler set diffopt+=internal,indent-heuristic,algorithm:patience set showcmd set clipboard^=unnamed,unnamedplus set showmode set mouse=a set tabstop=2 set shiftwidth=4 set expandtab set softtabstop=2 set showmatch set incsearch set nobackup set autoread set wildmenu set wildmode=longest:list,full set nofoldenable  filetype plugin indent on syntax on   有了上面的设置，会让你的 vim 更好用一些。</description>
    </item>
    
    <item>
      <title>Github Action 自动部署 blog</title>
      <link>https://zhenfeng-zhu.github.io/post/hugo-github-action/</link>
      <pubDate>Thu, 18 Feb 2021 13:20:11 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/hugo-github-action/</guid>
      <description>之前我采用的方式是两个 github repo 的方式：
一个叫 hugo-blog，用于存放 blog 的源文件
一个叫 zhenfeng-zhu.github.io，用于存放生成之后的文件
然后通过写一个 shell 脚本，将生成之后的文件推向 zhenfeng-zhu.github.io 仓库中，同时将 blog 的源文件也做了一个 backup。后来使用了一个 github action 的方式， 就不用在两个仓库中进行折腾，一切都由 github action 来做了。
方案 设置 workflow 首先创建一个.github/workflows/gh-pages.yml
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  name: github pages  on:  push:  branches:  - main  # Set a branch to deploy  jobs:  deploy:  runs-on: ubuntu-18.</description>
    </item>
    
    <item>
      <title>编程语言的世界观</title>
      <link>https://zhenfeng-zhu.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%96%E7%95%8C%E8%A7%82/</link>
      <pubDate>Thu, 18 Feb 2021 13:05:31 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%96%E7%95%8C%E8%A7%82/</guid>
      <description>Elixir  everything is a process. process are strongly isolated. process creation and destruction is a lightweight operation. message passing is the only way for processes to interact. processes have unique names. if you know the name of a process you can send it a message. processes share no resources. error handling is non-local. processes do what they are supposed to do or fail.  Go  simple, poetic, pithy don&amp;rsquo;t communicate by sharing memory, share memory by communicating concurrency is not parallelism channels orchestrate; mutexes serialize the bigger the interface, the weaker the abstraction make the zero value useful interface{} says nothing gofmt&amp;rsquo;s style is no one&amp;rsquo;s favorite, yet gofmt is everyone&amp;rsquo;s favorite A little copying is better than a little dependency  </description>
    </item>
    
    <item>
      <title>如何建立指标体系</title>
      <link>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E6%8C%87%E6%A0%87%E4%BD%93%E7%B3%BB/</link>
      <pubDate>Thu, 18 Feb 2021 12:48:34 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E6%8C%87%E6%A0%87%E4%BD%93%E7%B3%BB/</guid>
      <description>什么是指标体系 指标体系是在业务的不同阶段，分析师牵头与业务方协助，制定一套能从各个维度反映业务状况的待实施框架。
关键点  在业务的前期、中期和后期，指标体系是不一样的 一定是由分析师牵头与业务方协助，而不是闭门造车 从各个维度去反应业务的核心状况，指标有很多维度 最后就是一个大的实施框架，一定要实施，否则就是浪费大家的时间  指标选取的几个原则  根本性：对于核心数据一定要理解到位和准确，如果这里错了，后面基本就不用看。 可理解性：所有指标要配上业务解释 结构性：能够充分从各维度对业务进行解读，方便归因。  建立步骤   理清业务阶段和方向 我们需要知道当前产品或者业务处于什么阶段，具体的业务方向是什么。一般都是分为三个阶段： 第一阶段：业务前期。在业务的前期更多的是想要快速推出来，有更多人去使用我们的产品。所以此时我们的指标体系应该更多的围绕用户量提升做各种维度的拆解 第二阶段：业务中期（快速发展期）。在业务中期，除了关注盘子的大小，还要看产品的健康度。 第三阶段：业务后期（成熟期）。主要看变现能力以及市场份额。
  确定核心指标 找核心指标不是一件容易的事儿。 只能多花时间去考虑这个事儿。
  指标核心维度拆解 核心指标的波动必然是由某种维度的波动引起，所以监控核心指标指标，本质是监控核心维度。 通用的拆解方法是先对核心指标进行公式计算，再按照业务路径或者业务模块去拆解。 核心指标的拆解，需要多和业务方进行沟通，把能够考虑的模块都考虑进去，基本上就能比较全面。
  指标宣贯、存档和落地 宣贯：实际上搭建号指标体系之后，要当面触达所有相关的业务接口人。 存档：同时对指标的口径和业务逻辑进行详细的描述存档，也就是指标口径归档 落地：落地就是建立核心指标的相关报表，实际工作中，报表会在埋点前建好，这样一旦版本上线就能立刻看到数据，这样各方的配合度就会很高。
  </description>
    </item>
    
    <item>
      <title>业务代码的成长机会</title>
      <link>https://zhenfeng-zhu.github.io/post/%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E7%9A%84%E6%88%90%E9%95%BF%E6%9C%BA%E4%BC%9A/</link>
      <pubDate>Wed, 17 Feb 2021 17:45:40 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E7%9A%84%E6%88%90%E9%95%BF%E6%9C%BA%E4%BC%9A/</guid>
      <description>对于大部分公司而言，能够写底层代码或者中间件代码的人总是有限的，写业务代码会面临更高的复杂度。这里分三个层次来看其中的机会：
 第一个层次，让代码写的不一样。可从代码规范、可读性、可扩展性等角度着手，这也是程序员的基本功。 第二个层次，考虑业务问题和技术问题的匹配。可从写业务代码中理解需求，并做好分析设计。被动接收需求和实现接口，确实成长空间不大。 第三个层次，总结相关方法体系，成为业务及技术双料专家。  </description>
    </item>
    
    <item>
      <title>unix 哲学</title>
      <link>https://zhenfeng-zhu.github.io/post/unix-philosophy/</link>
      <pubDate>Wed, 17 Feb 2021 16:46:52 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/unix-philosophy/</guid>
      <description> 让每个程序都做好一件事。要做一件新的工作，写一个新程序，而不是通过添加“功能”让老程序复杂化。 期待每个程序的输出成为另一个程序的输入。不要将无关信息混入输出。避免使用严格的列数据或二进制输入格式。不要坚持交互式输入。 设计和构建软件，甚至是操作系统，要尽早尝试，最好在几周内完成。不要犹豫，扔掉笨拙的部分，重建它们。 优先使用工具来减轻编程任务，即使必须曲线救国编写工具，且在用完后很可能要扔掉大部分。  </description>
    </item>
    
    <item>
      <title>Web 前端性能优化</title>
      <link>https://zhenfeng-zhu.github.io/post/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Fri, 20 Nov 2020 16:01:49 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>一般来说 web 前端是指网站业务逻辑之前的部分，比如：浏览器加载、网站视图模型、图片服务、CDN 服务等等。web 前端优化主要从如下三个方面入手：
浏览器访问优化   减少 http 请求
http 协议是一个无状态的，每次请求都需要建立通信链路进行传输，在服务器端，一般每个请求都会分配一个线程去处理。
减少 http 请求的主要手段是合并 CSS、合并 js、合并图片。
  使用浏览器缓存
css、js、Logo、图标等静态资源文件更新频率较低，可以将这些文件缓存在浏览器中。
在更新 js 等文件的时候，一般不是将文件内容更新，而是生成一个新的文件，然后更新 html 的引用。
更新静态资源的时候，也是要逐量更新，以避免用户浏览器的大量缓存失效，造成服务器负载增加、网络堵塞。
  启用压缩
在服务器对文件压缩，然后在浏览器端解压缩，可以减少通信传输的数据量。
  CSS 放在页面最上面，js 放在页面最下面
浏览器会在下载完全部 CSS 之后才对整个页面进行渲染，而浏览器是在加载 js 之后就立即执行，有可能会阻塞整个页面。因此最好的做法就是把 CSS 放在最上面，js 放在最下面。但是如果是页面解析的时候就用到 js，也是要相应的 js 放在上面。
  减少 cookie 传输
cookie 会包含在每次请求和响应中，太大的 cookie 会影响数据传输，需要慎重考虑哪些数据写入 cookie 中。
对于某些静态资源的访问，如 css 和 js 等，发送 cookie 没意义，可以考虑静态资源使用独立域名访问，避免请求静态资源时发送 cookie。
  CDN 加速 CDN（content distribute network，内容分发网络）的本质仍然是一个缓存。将缓存放在离用户最近的地方，使得用户可以以最快的速度获取数据。</description>
    </item>
    
    <item>
      <title>大型网站发展历程</title>
      <link>https://zhenfeng-zhu.github.io/post/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/</link>
      <pubDate>Fri, 20 Nov 2020 16:00:59 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/</guid>
      <description>前几天跟一个朋友聊了一些关于网站缓存分布式的一些东西，发现自己的知识还是太过贫瘠。理论+协议，这是现在我亟待加强的。这个周末买了两本关于分布式网站的书，本着好记性不如烂笔头，便有了这样一系列的文章。希望一同分享，也请多指教。
 code less, play more!
 前言 这个世界上没有哪个网站从诞生起就是大型网站；也没有哪个网站第一次发布的时候就拥有庞大的用户，高并发的访问，海量的数据；大型网站都是从小型网站发展而来。网站的价值在于它能给用户提供什么家宅，在于网站能做什么，而不在于它是怎么做的，所以网站在小的时候就去追求网站的架构是舍本逐末，得不偿失的。小型网站最需要做的就是为用户提供更好的服务来创造价值，得到用户认可，活下去，野蛮生长。
大型网站软件系统的特点  高并发，大流量 高可用 海量数据 用户分布广泛，网络情况复杂 安全环境恶劣 需求快速变更，发布平频繁 渐进式发展  大型网站的发展历程   初始阶段的网站架构
最开始没有多少人访问，所以应用程序，数据库，文件都在同一台机器上。
  应用服务器和数据服务分离
应用和数据分离之后，一般需要三台服务器。应用服务器，文件服务器和数据库服务器，这三种服务器对于硬件要求各不相同。
 应用服务器：更强大的 CPU 数据库服务器：更快速的磁盘和更大的内存 文件服务器：容量更大的硬盘    使用缓存改善性能
网站的访问也遵循二八定律：80%的业务集中在 20%的数据上。因此可以把这一小部分数据缓存在内存中，减少数据库的访问压力。
网站的缓存可以分为两种：
 本地缓存：缓存在应用服务器上。本地缓存访问速度快，但是受制于内存限制，缓存数量有限，而且也会出现和应用程序争抢内存的情况。 远程分布式缓存：以集群的方式，缓存在大内存的专用缓存服务器。可以在理论上做到不受内存容量限制。    使用应用服务器集群提高并发能力
当一台服务器的处理能力和存储空间不足的时候，不要企图更换更强大的服务器。对于大型网站来说，不管多么强大的服务器，都满足不了网站持续增长的业务需求。此时就可以考虑集群的方式，通过负载均衡调度服务器，可以将来自用户的请求分发到应用服务器集群中的任何一台服务器上。
  数据库读写分离
使用缓存后，大部分的数据读操作访问都可以不通过数据库完成，但是仍有部分读操作（如缓存过期，缓存不命中）和全部的写操作需要访问数据库。
目前大部分数据库都提供主从热备的功能，在写数据的时候，访问主库，主库通过主从复制机制将数据更新同步至从数据库，在读的时候就可以通过从数据库获取数据。
  使用反向代理和 CDN 加速网站响应
在《web 性能权威指南》中有讲到，网站性能的瓶颈，大部分时间都浪费在 TCP 的握手和传输上。因此可以通过 CDN 和反向代理的方式来加快响应。
CDN 和反向代理的本质都是通过缓存，不同的主要是：
 CDN 部署在服务器器上的机房，用户在请求时，从距离自己最近的机房获取数据。 反向代理是部署在中心机房，用户请求到达中心机房之后，首先访问的服务器是反向代理的拂去其，如果反向代理服务器中缓存着用户请求的额资源，就将其返回给用户。    使用分布式文件系统和分布式数据库系统</description>
    </item>
    
    <item>
      <title>Geth 私链</title>
      <link>https://zhenfeng-zhu.github.io/post/geth-%E7%A7%81%E9%93%BE/</link>
      <pubDate>Fri, 20 Nov 2020 15:59:22 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/geth-%E7%A7%81%E9%93%BE/</guid>
      <description>在上一篇文章《Geth 入门》中，主要讲了开发环境下以太坊 geth 客户端的使用。今天简单说下私链的配置。
genesis.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  {  &amp;#34;config&amp;#34;: {  &amp;#34;chainId&amp;#34;: 10,  &amp;#34;homesteadBlock&amp;#34;: 0,  &amp;#34;eip155Block&amp;#34;: 0,  &amp;#34;eip158Block&amp;#34;: 0  },  &amp;#34;coinbase&amp;#34; : &amp;#34;0x0000000000000000000000000000000000000000&amp;#34;,  &amp;#34;difficulty&amp;#34; : &amp;#34;0x40000&amp;#34;,  &amp;#34;extraData&amp;#34; : &amp;#34;&amp;#34;,  &amp;#34;gasLimit&amp;#34; : &amp;#34;0xffffffff&amp;#34;,  &amp;#34;nonce&amp;#34; : &amp;#34;0x0000000000000042&amp;#34;,  &amp;#34;mixhash&amp;#34; : &amp;#34;0x0000000000000000000000000000000000000000000000000000000000000000&amp;#34;,  &amp;#34;parentHash&amp;#34; : &amp;#34;0x0000000000000000000000000000000000000000000000000000000000000000&amp;#34;,  &amp;#34;timestamp&amp;#34; : &amp;#34;0x00&amp;#34;,  &amp;#34;alloc&amp;#34;: { } }      参数 描述     nonce nonce 就是一个 64 位随机数，用于挖矿   mixhash 与 nonce 配合用于挖矿，由上一个区块的一部分生成的 hash   difficulty 设置当前区块的难度，如果难度过大，cpu 挖矿就很难，这里设置较小难度   alloc 用来预置账号以及账号的以太币数量，因为私有链挖矿比较容易，所以我们不需要预置有币的账号，需要的时候自己创建即可以   coinbase 矿工的账号，随便填   timestamp 设置创世块的时间戳   parentHash 上一个区块的 hash 值，因为是创世块，所以这个值是 0   extraData 附加信息，随便填，可以填你的个性信息   gasLimit 该值设置对 GAS 的消耗总量限制，用来限制区块能包含的交易信息总和，因为我们是私有链，所以填最大。   config Fatal: failed to write genesis block: genesis has no chain configuration ：这个错误信息，就是说，你的 json 文件中，缺少 config 部分。看到这个信息，我们不需要把 geth 退回到 v1.</description>
    </item>
    
    <item>
      <title>Geth</title>
      <link>https://zhenfeng-zhu.github.io/post/geth/</link>
      <pubDate>Fri, 20 Nov 2020 10:07:39 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/geth/</guid>
      <description>Geth 简介 go-ethereum
go-ethereum 客户端通常被称为 geth，它是个命令行界面，执行在 Go 上实现的完整以太坊节点。通过安装和运行 geth，可以参与到以太坊前台实时网络并进行以下操作：
 挖掘真的以太币 在不同地址间转移资金 创建合约，发送交易 探索区块历史 及很多其他   网站: http://ethereum.github.io/go-ethereum/ Github: https://github.com/ethereum/go-ethereum 维基百科: https://github.com/ethereum/go-ethereum/wiki/geth Gitter: https://gitter.im/ethereum/go-ethereum
 mac 下安装 geth  首先安装 homebrew， 使用 brew 安装即可。在安装 geth 的时候，会将 go 也安装上。  1 2  brew tap ethereum/ethereum brew install ethereum    在命令行输入 geth —help，如果出现
1 2 3 4 5 6 7 8 9 10 11  zhuzhenengdeMBP:blog zhuzhenfeng$ geth --help NAME:  geth - the go-ethereum command line interface   Copyright 2013-2017 The go-ethereum Authors  USAGE:  geth [options] command [command options] [arguments.</description>
    </item>
    
    <item>
      <title>hive 常用函数</title>
      <link>https://zhenfeng-zhu.github.io/post/hive%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 16 Apr 2020 17:59:03 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/hive%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</guid>
      <description>json 字符串处理  get_json_object lateral_view explode substr json_tuple  get_json_object get_json_object(string json_string, string path)
解析 json 字符串 json_string，返回 path 指定的内容。如果输入的 json 字符串是无效的，那么返回 null。
path 就是 &amp;lsquo;$.字段名&amp;rsquo;。
如果该字段的 value 也是 json，就可以一直点下去。
如果该字段的 value 是数组，就可以用 &amp;lsquo;$.字段名[0]&amp;rsquo;，类似这样下标的形式去访问。
explode explode(array)
经常和 lateral view 一起使用，将数组中的元素拆分成多行显示。
substr substr(string A, int start, int len)
返回字符串 A 从 start 位置开始，长度为 len 的字符串
json_tuple json_tuple(string json_string, col1, col2, &amp;hellip;)
经常和 lateral view 一起使用，同时解析多个 json 字符串中的多个字段。
parse_url, regexp_replace, regexp_extract parse_url parse_url(string urlString, string partToExtract, string keyToExtract)</description>
    </item>
    
    <item>
      <title>mysql 的学习</title>
      <link>https://zhenfeng-zhu.github.io/post/mysql%E7%9A%84%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Thu, 16 Apr 2020 17:34:30 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/mysql%E7%9A%84%E5%AD%A6%E4%B9%A0/</guid>
      <description>SQL 条件语句 IF if(exp1, exp2, exp3)
exp1 是条件，条件为 true 的话，是 exp2，否则是 exp3
case when 1 2 3 4 5   case 列名  when 条件 then 结果  else 其他结果  end 别名   IFNULL IFNULL(exp1, exp2)
在 exp1 的值不为 null 的情况下，返回 exp1，如果 exp1 位 null，返回 exp2 的值。</description>
    </item>
    
    <item>
      <title>clickhouse</title>
      <link>https://zhenfeng-zhu.github.io/post/clickhouse/</link>
      <pubDate>Sat, 12 Oct 2019 06:48:01 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/clickhouse/</guid>
      <description>ClickHouse ClickHouse 是一个用于联机分析（Online Analytical Processing：OLAP）的列式数据库管理系统(DBMS)。通过使用 OLAP 工具，用户能够从多个角度交互地分析多维数据。
OLAP 由三个基本的分析操作组成：上卷（roll-up）、钻取（drill-down）、切片（slicing）和切块（dicing）。
  上卷（roll-up）：涉及可以在一个或多个维度中累积和计算的数据的聚合。例如，所有的销售办事处汇总到销售部门，以预测销售趋势。
  钻取（drill-down）：是一种允许用户浏览详细信息的技术。例如，用户可以查看组成一个地区销售额的单个产品的销售额。
  切片（slicing）和切块（dicing）：用户可以从 OLAP 多维数据集中取出（切片）一组特定的数据，并从不同的角度查看（切块）切片。这些角度有时被称为维度（例如按销售人员、按日期、按客户、按产品或按地区查看相同的销售情况等）。
  传统行式数据库中，处于同一行中的数据总是被物理的存在一起。列式数据库总是将同一列的数据存储在一起，不同列的数据分开存储。
行式数据库：mysql，pg
列式数据库：vertica，druid
OLAP 的关键特征  大多是读请求 数据总是以相当大的批（&amp;gt;1000w）进行写入 不修改已经添加的数据 每次查询都从数据库中读取大量的行，但是同时又仅需要少量的列 宽表，即每个表包含大量的列 较少的查询（通常每台服务器每秒数百个查询或更少） 对于简单的查询，允许延迟大约 50ms 列中的数据相对较小：数字和短字符串 处理单个查询时需要高吞吐量（每个服务器每秒高达数十亿行） 事务不是必须的 对数据一致性要求低 每一个查询除了一个大表外都很小 查询结果明显小于数据源，换句话说，数据被过滤或者聚合之后能够被放在单台服务器的内存中  列式数据库更适合 OLAP 场景 Input/Output  分析类的查询，通常只需要读取表的一小部分列。 数据总是打包成批量读取，列压缩更容易 IO 降低了  CPU 由于执行一个查询需要处理大量的行，因此在整个 Vector 上执行所有操作将比在每一行上执行所有操作更加高效。同时这将有助于实现一个几乎没有调用成本的查询引擎。
 Vector 引擎 代码生成  为了提高 CPU 效率，查询语言必须是声明型的(SQL 或 MDX)， 或者至少一个 Vector(J，K)。 查询应该只包含隐式循环，允许进行优化。</description>
    </item>
    
    <item>
      <title>每日学习 2</title>
      <link>https://zhenfeng-zhu.github.io/post/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0-2019-09-29/</link>
      <pubDate>Sun, 29 Sep 2019 02:19:03 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0-2019-09-29/</guid>
      <description>https://mubu.com/doc/oHlgG0FSu0</description>
    </item>
    
    <item>
      <title>每日学习-2019-09-24</title>
      <link>https://zhenfeng-zhu.github.io/post/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0-2019-09-24/</link>
      <pubDate>Sun, 29 Sep 2019 02:17:46 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0-2019-09-24/</guid>
      <description>开言英语 极客时间 编译原理之美 语义分析（下）：如何做上下文相关情况的处理  语义分析的本质，就是针对上下文相关的情况做处理。  引用消解：不同作用域里可能有相同名称的变量，必须找到正确的那个，这个过程就是引用消解。  函数引用消解 命名空间引用消解   左值和右值  左值取的是变量的地址或者说是变量的引用，获得地址之后，我们就可以把新值写进去。 右值就是我们常说的值。 不是所有的表达式都能生成一个合格的左值。   属性计算  上下文分析或者说语义分析的一种算法。 属性文法的主要思路是计算机科学的重要开拓者，是在上下文无关文法的基础上做了一些增强，使之可以计算属性值。   过程  类型和作用域解析 类型的消解 引用的消解和 S 属性的类型推导 做类型检查 做一些语义合法性检查      趣谈 Linux 操作系统 Namespace 技术：内部创业公司应该独立运营 为了隔离不同类型的资源，Linux 内核里面有如下几种不同类型的 namespace：
 UTS，表示不同的 namespace 可以配置不同的 hostname User，可以配置不同的用户和组 Mount，文件系统挂载点是隔离的 PID，有完全独立的 pid Network，有独立的网络协议栈  </description>
    </item>
    
    <item>
      <title>tmux</title>
      <link>https://zhenfeng-zhu.github.io/post/tmux/</link>
      <pubDate>Wed, 28 Aug 2019 12:03:46 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/tmux/</guid>
      <description>折腾一下 tmux
安装 1  brew install tmux   概念  session：理解为一个会话，持久保存工作状态。 window：可以理解为我们常说的 tab 页。 pane：一个 window 被分成若干个 pane，理解为 iterm 的分屏。  session 新建
1  tmux new -s your-session-name   断开
1  tmux detach   恢复
1 2 3  tmux attach-session -t your-session-name 或者 tmux a -t your-session-name   关闭
 kill-server kill-session kill-window kill-pane  1 2 3  tmux kill-session -t your-session-name  tmux kill-server   查看</description>
    </item>
    
    <item>
      <title>crystal 开发环境</title>
      <link>https://zhenfeng-zhu.github.io/post/crystal%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Tue, 27 Aug 2019 14:03:12 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/crystal%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid>
      <description>突然搞明白了 crystal 的 vscode 插件的正确使用姿势，记录一下。
安装 crystal 1  brew install crystal   安装 vscode 插件 https://marketplace.visualstudio.com/items?itemName=faustinoaq.crystal-lang
安装 scry scry 是 crystal 的 language server 的 client 工具，在本地安装 scry 就可以做到代码跳转了。
1 2 3 4 5 6 7 8  $ git clone https://github.com/crystal-lang-tools/scry.git  $ cd scry  $ shards build -v Dependencies are satisfied Building: scry crystal build -o /Users/lucas/Documents/demos/crystal/scry/bin/scry src/scry.cr   /Users/lucas/Documents/demos/crystal/scry/bin/scry 就是编译出来的二进制的路径
配置插件 1 2 3 4 5 6 7 8 9 10   &amp;#34;crystal-lang.</description>
    </item>
    
    <item>
      <title>crystal 简介</title>
      <link>https://zhenfeng-zhu.github.io/post/crystal%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 27 Aug 2019 02:14:18 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/crystal%E7%AE%80%E4%BB%8B/</guid>
      <description>关注 crystal 也有一段时间了，看到多线程的 pr 已经提了，今天简单写一下。
 Fast as C, Slick as Ruby
 语法 crystal 的语法和 Ruby 比较类似。
1 2 3 4 5 6 7 8 9 10  # A very basic HTTP server require &amp;#34;http/server&amp;#34;  server = HTTP::Server.new do |context|  context.response.content_type = &amp;#34;text/plain&amp;#34;  context.response.print &amp;#34;Hello world, got #{context.request.path}!&amp;#34; end  puts &amp;#34;Listening on http://127.0.0.1:8080&amp;#34; server.listen(8080)   类型系统 crystal 的一大卖点就是静态类型系统，但是写起来又和脚本语言类似。
1 2 3 4 5 6 7 8 9  def shout(x)  # Notice that both Int32 and String respond_to `to_s`  x.</description>
    </item>
    
    <item>
      <title>socket</title>
      <link>https://zhenfeng-zhu.github.io/post/socket/</link>
      <pubDate>Mon, 26 Aug 2019 06:54:14 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/socket/</guid>
      <description>Socket 网络模型 osi 七层模型  应用层 表示层 会话层 传输层 网络层 数据链路层 物理层  对应的 tcpip 就是  应用层  dns http   传输层  icmp tcp udp   ip 层  ipv4 ipv6   mac 层  arp vlan   物理层  Ethernet    为什么要分层 因为网络环境过于复杂，不是一个能够集中控制的体系。全球的服务器和设备各有各的体系，但是可以通过同一套网络协议栈切分成多个层次和组合，来满足不同设备之间的通信需求。
二层到四层，即 mac、ip 和传输等层都是 Linux 内核中处理。应用层的如浏览器、Nginx 和 Tomcat 等都是用户态的。
传输层的 tcp 和 udp 里都有端口的概念，不同应用监听不同的段即可。
应用层和内核的互通机制，就是通过 socket 系统调用。其实 socket 哪一层都不属于，它是属于操作系统的概念，而不是网络分层的概念。因为操作系统把二层到四层的处理代码在内核里，应用层的处理代码让应用自己做，两者需要跨内核态和用户态进行通信，这个就是 socket。</description>
    </item>
    
    <item>
      <title>go 进阶</title>
      <link>https://zhenfeng-zhu.github.io/post/go%E8%BF%9B%E9%98%B6/</link>
      <pubDate>Mon, 26 Aug 2019 06:53:32 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/go%E8%BF%9B%E9%98%B6/</guid>
      <description>Diagnostics go 提供了一系列诊断逻辑和性能问题的工具。
 profiling 分析 tracing 跟踪 debuging 调试 运行时统计信息和事件  Profiling profiling 信息可以在 go test 或者 net/http/pprof 包的时候使用。
runtime/pprof 包有：
 cpu  主动消费 cpu 周期所花费的时间，不包括睡眠或者 io 等待   heap  报告内存分配采样； 当前或历史内存使用状况 检测内存泄露   threadcreate  报告创建新的系统线程   goroutine  当前所有协程的堆栈跟踪   block  显示 goroutine 阻塞等待同步原语的位置。 默认不开启，使用 runtime.SetBlockProfileRate 启用   mutex  报告锁竞争。 如果认为自己的程序因为互斥锁导致 cpu 不能充分利用的时候，使用这个。 默认也是不开启，使用 runtime.SetMutexProfileFraction 启用。    其他可用的的性能分析工具</description>
    </item>
    
    <item>
      <title>mysql</title>
      <link>https://zhenfeng-zhu.github.io/post/mysql/</link>
      <pubDate>Sat, 01 Dec 2018 15:54:53 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/mysql/</guid>
      <description>MySQL 基本架构 客户端
server 层
  连接器：管理连接，权限验证
  查询缓存：命中规则，直接返回结果 8.0 之后全部删除了这个模块
  分析器：词法分析，语法分析
  优化器：执行计划生成，索引选择
  执行器：操作引擎，返回结果
  存储引擎：存储数据，提供读写接口
数据库中的长连接指连接成功之后，如果客户端持续有请求，则一直使用同一个连接。短连接是指每次执行完很少的几次查询之后就断开连接，下次再重新建立。
如果全部使用长连接，会导致 mysql 内存涨的很快，可能出现 OOM，因此要定期断开长连接，或者在执行一个比较大的操作之后，执行 mysql_reset_connection 重置一下。
日志系统 redo log 重做日志 redo log 是 innodb 引擎特有的。物理日志，记录的是某个数据页上做了什么修改。循环写入。
WAL 技术：Write-Ahead Logging：关键点就是先写日志，再写磁盘。当一条记录更新时，先把记录写到 redolog 中，更新到内存，这时这个更新操作就成功了。然后 innodb 引擎就会在适当的时候，将这个操作记录更新到磁盘中。因此在数据库异常重启的时候，之前的提交的记录不会丢失。
binlog 归档日志 binlog 是 server 层实现的，所有的引擎都可以使用。binlog 是逻辑日志，记录的是这个语句的原始逻辑。binlog 是写到一定大小后，切换下一个，不会覆盖以前的日志。
因此一个 update 操作就是：
找到该行
判断数据页是否在内存中，如果是返回行数据，否则从磁盘读入到内存中。
将值进行更新，写入新行
新行更新到内存
写入 redolog，处于 prepare 阶段
写入 binlog
提交事务，处于 commit 阶段。</description>
    </item>
    
    <item>
      <title>graphql</title>
      <link>https://zhenfeng-zhu.github.io/post/graphql/</link>
      <pubDate>Thu, 08 Nov 2018 18:28:13 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/graphql/</guid>
      <description>graphql 经常被认为是聚焦于前端的技术。
核心概念 SDL：schema definition language（模式定义语言） 如：
1 2 3 4  type Person{  name: String!  age: Int! }   这个类型有两个字段，name 和 age，他们的类型是 String 和 Int。！的意思代表他们是必需的。
1 2 3 4  type Post{  title: String!  author: Person! }   接下来的 Post 也有两个字段，其中 Person 也是可以作为一个类型。
也可以这样，在 Person 中添加一个 post：
1 2 3 4 5  type Person{  name: String!  age: Int!  posts: [Post!</description>
    </item>
    
    <item>
      <title>go-best-practice</title>
      <link>https://zhenfeng-zhu.github.io/post/go-best-practice/</link>
      <pubDate>Wed, 07 Nov 2018 17:16:07 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/go-best-practice/</guid>
      <description> 短变量名称在声明和上次使用之间的距离很短时效果很好。 长变量名称需要证明自己的合理性; 名称越长，需要提供的价值越高。冗长的名称与页面上的重量相比，信号量较小。 请勿在变量名称中包含类型名称。 常量应该描述它们持有的值，而不是该如何使用。 对于循环和分支使用单字母变量，参数和返回值使用单个字，函数和包级别声明使用多个单词 方法、接口和包使用单个词。 请记住，包的名称是调用者用来引用名称的一部分，因此要好好利用这一点。  变量的名称应描述其内容，而不是内容的类型。
典型错误：
1  var usersMap map[string]*User   如果users的描述性都不够用，那么usersMap也不会。
声明变量但没有初始化时，请使用 var。
在声明和初始化时，使用:=。
关于变量和常量的注释应描述其内容而非其目的  任何既不明显也不简短的公共功能必须予以注释。 无论长度或复杂程度如何，对库中的任何函数都必须进行注释  在编写函数之前，请编写描述函数的注释。 如果你发现很难写出注释，那么这就表明你将要编写的代码很难理解。
以包所提供的内容来命名，而不是它包含的内容。
避免使用类似base，common或util的包名称 尽早return而不是深度嵌套 使用internal包来减少公共 API 不鼓励使用nil作为参数 首选可变参数函数而非[]T参数 通过消除错误来消除错误处理 使用github.com/pkg/errors包装errors 永远不要启动一个停止不了的 goroutine </description>
    </item>
    
    <item>
      <title>kubernetes</title>
      <link>https://zhenfeng-zhu.github.io/post/kubernetes/</link>
      <pubDate>Mon, 08 Oct 2018 15:29:21 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/kubernetes/</guid>
      <description>docker 利用 Linux 的 cgroups 和 namespace，构建一个沙箱运行环境。
docker 镜像 其实就是一个压缩包，这个压缩包是由一个完整的操作系统的所有文件目录构成，包含了这个应用运行所需要的所有依赖，所以本地开发环境和测试环境是一样的。
解决了应用打包的根本性问题。
容器编排 对 Docker 容器的一系列定义、配置和创建动作的管理
 容器本身没有价值，有价值的是“容器编排”。
 原理 容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造一个“边界”。
在创建一个容器进程的时候，指定了这个进程所需要启动的一组 Namespace 参数，这样容器就只能看到当前 Namespace 所限定的资源、文件、设备、状态或配置。
Cgroups 主要作用是为一个进程组设置资源上限，如 CPU、内存、磁盘和带宽等。也可以设置进程优先级，审计，挂起，重启等。
因此，一个正在运行的 Docker 容器，其实就是一个启用了多个 Namespace 的应用进程，而这个进程能够使用的资源是由 Cgroups 来限制。
挂载在容器根目录上，用来为容器进程提供隔离后执行环境的文件系统，就是容器镜像，rootfs。
 启动 Namespace 配置 设置 Cgroups 参数 切换进程根目录 rootf  docker 镜像设计时，引入了层（layer），用户制作镜像的每一步操作都会生成一个层，也就是一个增量的 rootfs。AuFS，所以就有了共享层，镜像不用那么大。
一个进程，可以选择加入到某个进程已有的 Namespace 当中，从而达到进入这个进程所在的容器的目的，这正是 docker exec 的实现原理。
volume 机制，允许你将宿主机上指定的目录或文件，挂载到容器里面进行读取和修改操作。
主要依赖 Linux 依赖三大技术  Namespace Cgroups rootfs  和虚拟机比较 虚拟机是通过硬件虚拟化功能，模拟一套操作系统所需要的各种硬件，如 CPU、内存、IO 设备等，然后安装一个新的操作系统。
docker 是利用 Linux 的 Namespace 原理，帮助用户启动的还是系统的应用进程，只是加了一些参数，限制其能看到的资源。因此相对于虚拟机资源消耗更小，而且轻量级，敏捷高性能。</description>
    </item>
    
    <item>
      <title>watchdog</title>
      <link>https://zhenfeng-zhu.github.io/post/watchdog/</link>
      <pubDate>Thu, 06 Sep 2018 16:23:57 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/watchdog/</guid>
      <description>监视器
监视器提供了一个外部世界和函数之间的非托管的通用接口。它的工作是收集从 API 网关来的 HTTP 请求，然后调用程序。监视器是一个小型的 Golang 服务——下图展示了它是如何工作的：
 上图：一个小型的 web 服务，可以为每个传入的 HTTP 请求分配所需要的进程。
 每个函数都需要嵌入这个二进制文件并将其作为ENTRYPOINT 或 CMD，实际上是把它作为容器的初始化进程。一旦你的进程被创建分支，监视器就会通过stdin 传递 HTTP 请求并从stdout中读取 HTTP 响应。这意味着你的程序无需知道 web 和 HTTP 的任何信息。
轻松创建新函数 从 CLI 创建一个函数
创建函数最简单的方法是使用 FaaS CLI 和模板。CLI 抽象了所有 Docker 的知识，使得你只需要编写所支持语言的 handler 文件即可。
 你的第一个使用 OpenFaaS 的无服务器 Python 函数 阅读有关 FaaS CLI 的教程  深入研究 Package your function 打包你的函数
如果你不想使用 CLI 或者现有的二进制文件或镜像，可以使用下面的方法去打包函数：
 使用一个现有的或者一个新的 Docker 镜像作为基础镜像 FROM 通过curl 或 ADD https://从 Releases 页面 添加 fwatchdog 二进制文件 为每个你要运行的函数设置 fprocess(函数进程) 环境变量 Expose port 8080 暴露端口 8080 Set the CMD to fwatchdog 设置 CMD为fwatchdog  一个echo函数的示例 Dockerfile：</description>
    </item>
    
    <item>
      <title>queue-worker</title>
      <link>https://zhenfeng-zhu.github.io/post/queue-worker/</link>
      <pubDate>Thu, 06 Sep 2018 16:23:12 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/queue-worker/</guid>
      <description>queue-worker 源码分析 异步函数和同步函数 在 OpenFaaS 中同步调用函数时，将会连接到网关，直到函数成功返回才会关闭连接。同步调用是阻塞的。
 网关的路由是：/function/&amp;lt;function_name&amp;gt; 必须等待 在结束的时候得到结果 明确知道是成功还是失败  异步函数会有一些差异：
 网关的路由是：/async-function/&amp;lt;function_name&amp;gt; 客户端获得 202 的即时响应码 从 queue-worker 中调用函数 默认情况下，结果是被丢弃的。  查看 queue-worker 的日志 1  docker service logs -f func_queue-worker   利用 requestbin 和 X-Callback-Url 获取异步函数的结果 如果需要获得异步函数的结果，有两个方法：
 更改代码，将结果返回给端点或者消息系统 利用内置的回调 内置的回调将会允许函数提供一个 url，queue-worker 会报告函数的成功或失败。 requestbin 会创建一个新的 bin，这是互联网的一个 url 地址，可以从这里获取函数的结果。  源码分析 依赖项 1 2 3 4  github.com/nats-io/go-nats-streaming github.com/nats-io/go-nats  github.com/openfaas/faas   go-nats 和 go-nats-streaming 是 nats 和 nats-streaming 的 go 版本的客户端。</description>
    </item>
    
    <item>
      <title>区块链学习笔记</title>
      <link>https://zhenfeng-zhu.github.io/post/blockchain/</link>
      <pubDate>Thu, 23 Aug 2018 15:14:02 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/blockchain/</guid>
      <description>本文是阅读http://www.netkiller.cn/blockchain/ch01s10.html 上的一些笔记。
 理解区块链的分布式记账 http://www.netkiller.cn/blockchain/ch01s10.html
区块链中提到的账本，记账等词汇是和会计无关的词汇。
我们传统理解的账本是一个二维的表格，记录了某年某月某日的费用：
   时间 用途 金额     2018-08-23 借 100   2018-08-22 还 200   2018-08-21 借 50   2018-08-20 还 1000    如果账目比较多，可以拆账，将不同分类的账目放在特定的账本中，而且二维表格还可以设置索引等，快速找到一笔交易。
但是区块链的记账形式是：
可以发现，区块链的这种记账方式是做了行列矩阵转换，节点之间收尾相互连接，成为链式结构，所有的账目都在一条链上。
所谓分布式记账，其实就是上述链状的数据结构保存在所有的节点上，形成分布式集群。
之所以采用区块链来做分布式记账，主要是区块链有如下好处：
  去中心化
传统的数据库存储是中心化的，通过暴露 ip 地址和端口号提供服务，后来分布式进群化之后，出现了主主从架构等。
与数据库相比，区块链是多主架构，而且实现更为复杂，节点之间的数据之间不是简单的二进制日志同步，而是要通过加密技术，节点达成共识之后才存储。
  可追溯
  安全
安全分为很多层，区块链只能做到存储层的安全。
区块链无法解决用户层，应用层，逻辑层等安全问题，他只能保证存储在硬盘上的区块不被修改。
  不可篡改
很多人认为区块链数据一旦创建之后就不能修改，所以采用区块链技术很安全。其实不然，数据是可以修改的，但是不能篡改。
撰改是指非法修改区块链数据，而修改则是合法变更数据。
通常撰改区块链数据多指数据存储层面的修改。而修改则是通过合约提供的修改函数变更区块链里面的数据。
多数区块链平台没有用户认证权限管理模块。所以无法控制区块中的哪些数据能被修改，哪些不能修改，哪些用户可以修改等等。即使有些区块链平台具备权限控制，颗粒度也无法达到目前的数据库控制的那么细。
  采用区块链作为账本的时候，会面临如下几个问题：
  不能建立索引，无法快速搜索出区块中的数据，必须依赖区块链以外的技术，如搜索引擎，数据库等。例如；etherscan.</description>
    </item>
    
    <item>
      <title>谈谈聊天机器人框架的实现原理</title>
      <link>https://zhenfeng-zhu.github.io/post/botbuilder/</link>
      <pubDate>Wed, 22 Aug 2018 19:39:12 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/botbuilder/</guid>
      <description>在这篇文章不考虑人工智能，谈谈我对聊天机器人框架实现机制的理解。
聊天机器人  聊天机器人（Chatterbot）是经由对话或文字进行交谈的计算机程序[1]。能够模拟人类对话，通过图灵测试。
 我们可以看到现有的 IM 工具上已经有了很多机器人，其实聊天机器人不只是单纯的和用户进行聊天，他其实还可以做很多事情，例如根据用户输入的一些话，可以帮用户订餐。另外在运维领域，也出现了 chatops，通过和机器人聊天，进行运维操作。
机器人开发框架 作为聊天机器人开发者，面对如此多的 IM 工具和 SDK，常会感到无所适从。Bot 开发框架就是对聊天机器人开发过程中的人工内容做抽象化处理。简单地解释，机器人开发框架就是用来制造机器人并定义其行为。
然而尽管很多机器人框架宣称「代码一旦写好可部署到任何地方」，但是还会是出现为每一个 IM 工具开发一个单独的聊天机器人。而一个良好的机器人框架主要包含开发 SDK，连接器和模拟器等。
使用机器人框架其实并不适合初学者学习聊天机器人开发。它们尝试自动化太多工作，对初学者掩盖了基础机制。
实现方式  webhook 事件回调 FSM 状态机 workflow 工作流  最简单的机器人是没有上下文的语义理解的一问一答，仅仅是对用户的对话进行响应，这种就可以采用 webhook 的方式进行开发。不需要采用什么开发框架。
那么对于多轮对话的时候，就需要进行一定的对话管理。由此引入了 FSM 状态机。
可能有人不是很懂有限状态机，这里做一下简单说明。
 有限状态机在现实生活中其实随处可见，伸缩式圆珠笔其实就是一个有限状态机（两种状态互相转换）。
有限状态机，缩写为 FSM，又称为有限状态自动机，简称状态机。是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。
可以总结为：f(state, action) =&amp;gt; state’
也就是说，这个函数采用当前的状态和一次行动（即更改状态的方法），之后将该行动应用于这种状态并返回新的状态。
可以认为状态机是图灵完备的。
 我们可以将对话看做是在有限状态内跳转的过程，每个状态都有对应的动作和回复，如果能从开始节点顺利的流转到终止节点，任务就完成了。
我们可以将对话的过程，分为一个个的状态，然后使用 DSL 来实现一个 FSM，对于开发者来讲，我们只需要关注一个个状态函数即可。
特点是：
 人为定义对话流程 完全有系统主导，系统问用户答 答非所问的情况直接忽略 建模简单，能清晰明了的把交互匹配到模型 难以扩展，很容易变的复杂 适用于简单的任务，难以处理复杂问题 缺少灵活性，表达能力有限，输入有限，对话结构和流转路径有限  示例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  const {startWith, when, goto, stay, stop} = botkit.</description>
    </item>
    
    <item>
      <title>基于以太坊的 Parity 联盟链部署</title>
      <link>https://zhenfeng-zhu.github.io/post/parity/</link>
      <pubDate>Wed, 22 Aug 2018 16:51:13 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/parity/</guid>
      <description>公司项目中使用公网上的以太坊私链，交易速度比较慢，于是这几天都在鼓捣基于以太坊的联盟链，parity 是可以构建出一个基于 PoA 共识的私链，而且兼容以太坊的合约。这篇文章主要是记录自己的踩坑经历，主要实现了节点的搭建，合约的部署以及本地以太坊浏览器的启动。
部署联盟链 parity 的文档：https://wiki.parity.io/Demo-PoA-tutorial
安装 首先是下载 parity，在 mac 下是直接 brew 安装即可。
1 2 3  brew tap paritytech/paritytech  brew install parity   创世区块 创世区块的配置文件：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  // demo-spec.</description>
    </item>
    
    <item>
      <title>dive-into-redis</title>
      <link>https://zhenfeng-zhu.github.io/post/dive-into-redis/</link>
      <pubDate>Mon, 20 Aug 2018 09:39:08 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/dive-into-redis/</guid>
      <description>redis 持久化，
机制有两种：
 快照：全量备份，二进制序列化，存储紧凑 AOF 日志：连续的增量备份，内存数据修改的文本  </description>
    </item>
    
    <item>
      <title>golang 踩坑</title>
      <link>https://zhenfeng-zhu.github.io/post/golang%E8%B8%A9%E5%9D%91/</link>
      <pubDate>Tue, 14 Aug 2018 20:10:55 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/golang%E8%B8%A9%E5%9D%91/</guid>
      <description>一  x509 error when using HTTPS inside a Docker container
 因为 docker 中没有 CA 证书。
普通的镜像解决办法
1 2 3 4 5 6  FROM ubuntu:14.04.1  RUN apt-get update RUN apt-get install -y ca-certificates  CMD curl https://www.google.com   如果是 alpine 的参考这个：
1 2 3 4 5 6 7 8 9  FROM docker.finogeeks.club/base/alpine MAINTAINER &amp;#34;zhuzhenfeng@finogeeks.club&amp;#34;  RUN set -ex \  &amp;amp;&amp;amp; apk add --no-cache ca-certificates  COPY src/wallet/wallet /opt/wallet  ENTRYPOINT /opt/wallet   二  panic: runtime error: invalid memory address or nil pointer dereference [signal 0xb code=0x1 addr=0x38 pc=0x26df]</description>
    </item>
    
    <item>
      <title>以太坊开发总结</title>
      <link>https://zhenfeng-zhu.github.io/post/eth-tools/</link>
      <pubDate>Fri, 10 Aug 2018 18:57:09 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/eth-tools/</guid>
      <description>最近因公司项目需要，做为一个打杂工程师，操起键盘和笔记本开始了以太坊的踩坑之旅。以太坊的开发比较新，变化也比较多，还好有@cctanfujun的手把手带领下，半只脚踏入了以太坊的开发的大门。
在这篇文章中，我将会简单介绍一下以太坊的基本概念，以及我现在用到的一些工具，还有具体的一个开发流程。因为我还没有接触到如何上主链，所以这些都是基于测试链讲解。希望能给大家带来一些帮助。
什么是区块链
相信大家对区块链都有自己的理解，不仅仅是互联网公司，传统企业也在“币改转型”。
**简言之，区块链就是数据库。**它是特定数据的数据库，里面的数据不断增长，具有非凡特性：
 一旦数据存储于数据库，永远都无法被修改或删除。区块链上的每个记录会被永久保存下来。 没有单独的个人或组织能维护该数据库。必须要上千个人才行，每个人都有数据库的副本。  什么是以太坊？
 以太坊（英语：Ethereum）是一个开源的有智能合约功能的公共区块链平台[1][2]。通过其专用加密货币以太币（Ether，又称“以太币”）提供去中心化的虚拟机（称为“以太虚拟机”Ethereum Virtual Machine）来处理点对点合约。
 为什么选择以太坊？
  智能合约
  代币
  资料相对完善，相对容易开发
  大佬对以太坊比较熟悉
  大佬对以太坊比较熟悉
  大佬对以太坊比较熟悉
  重要的事情说三遍，有一个经验丰富的人带领，做东西肯定事半功倍。
自己动手写区块链
这里提供两个教程，一个是书，一个是视频。其中视频和书是对应的，不清楚是不是同一个作者。
Blockchain Tutorial
私有区块链，我们一起 GO
以太坊开发
由于我是专注于后端的开发，现在的技术栈是
 node go  正式进入以太坊的开发。这是我这段时间接触到的一些资源：
  go-ethereum：也就是 geth，官方的 go 版本的客户端
  solidity：智能合约编程语言
  truffle：智能合约的编程框架，基于 nodejs
  Ganache：启动了多个节点本地私链
  Rinkeby：以太坊测试链
  Etherscan：以太坊区块链浏览器，可以查询交易</description>
    </item>
    
    <item>
      <title>以太坊</title>
      <link>https://zhenfeng-zhu.github.io/post/%E4%BB%A5%E5%A4%AA%E5%9D%8A/</link>
      <pubDate>Tue, 07 Aug 2018 20:09:26 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E4%BB%A5%E5%A4%AA%E5%9D%8A/</guid>
      <description>参与了公司的一个项目，上了以太坊，这里简单记录一下踩坑。
首先先把 go 的依赖下载下来：
1  go get -u -v github.com/ethereum/go-ethereum   有时候下载的很慢，可以从 github 上拉下来代码。
账户 以太坊的地址在离线状态下也可以创建到。
创建账户有两种方式：
以公钥和私钥的形式创建 1 2 3 4 5 6 7 8 9 10 11 12 13 14  func CreateAccount() (string, error) {  key, err := crypto.GenerateKey()  if err != nil {  log.Fatalln(err)  return &amp;#34;&amp;#34;, nil  }   address := crypto.PubkeyToAddress(key.PublicKey).Hex()  log.Println(&amp;#34;address: &amp;#34;, address)   privateKey := hex.</description>
    </item>
    
    <item>
      <title>contract</title>
      <link>https://zhenfeng-zhu.github.io/post/contract/</link>
      <pubDate>Fri, 03 Aug 2018 14:32:03 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/contract/</guid>
      <description>类型 Solidity 是静态类型的语言。
值类型  bool int/uint fixed/unfixed address  balance 和 transfer send call, callcode 和 delegatecall   byte bytes 和 string 十六进制 hex&amp;quot;0012&amp;quot; enum function  引用类型   数组
uint[]
  结构体
struct
  Map
mapping(key =&amp;gt; value)
  单元和全局变量   以太币的单位
在数字后面加上 wei、 finney、 szabo 或 ether。默认是 wei
  时间单位
数字后面带有 seconds、 minutes、 hours、 days、 weeks 和 years。默认是秒。
  区块和交易</description>
    </item>
    
    <item>
      <title>faas-provider</title>
      <link>https://zhenfeng-zhu.github.io/post/faas-provider/</link>
      <pubDate>Wed, 01 Aug 2018 19:53:23 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/faas-provider/</guid>
      <description>faas-provider 是一个模板，只要实现了这个模板的接口，就可以自定义实现自己的 provider。
faas-provider OpenFaaS 官方提供了两套后台 provider：
 Docker Swarm Kubernetes  这两者在部署和调用函数的时候流程图如下：
部署一个函数
调用一个函数
provider 要提供的一些 API 有：
 List / Create / Delete 一个函数  /system/functions
方法: GET / POST / DELETE
 获取一个函数  /system/function/{name:[-a-zA-Z_0-9]+}
方法: GET
 伸缩一个函数  /system/scale-function/{name:[-a-zA-Z_0-9]+}
方法: POST
 调用一个函数  /function/{name:[-a-zA-Z_0-9]+}
方法: POST
在 provider 的 server.go 的 serve 方法，可以看到这个 serve 方法创建了几个路由，接受一个 FaaSHandler 对象。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // Serve load your handlers into the correct OpenFaaS route spec.</description>
    </item>
    
    <item>
      <title>gateway-reading</title>
      <link>https://zhenfeng-zhu.github.io/post/gateway-reading/</link>
      <pubDate>Wed, 01 Aug 2018 09:15:35 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/gateway-reading/</guid>
      <description>OpenFaaS 的 Gateway 是一个 golang 实现的请求转发的网关，在这个网关服务中，主要有以下几个功能：
 UI 部署函数 监控 自动伸缩  架构分析 从图中可以发现，当 Gateway 作为一个入口，当 CLI 或者 web 页面发来要部署或者调用一个函数的时候，Gateway 会将请求转发给 Provider，同时会将监控指标发给 Prometheus。AlterManager 会根据需求，调用 API 自动伸缩函数。
源码分析 依赖 1 2 3 4 5 6 7  github.com/gorilla/mux  github.com/nats-io/go-nats-streaming github.com/nats-io/go-nats github.com/openfaas/nats-queue-worker  github.com/prometheus/client_golang   mux 是一个用来执行 http 请求的路由和分发的第三方扩展包。
go-nats-streaming，go-nats，nats-queue-worker 这三个依赖是异步函数的时候才会用到，在分析 queue-worker 的时候有说到 Gateway 也是一个发布者。
client_golang 是 Prometheus 的客户端。
项目结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  ├── Dockerfile ├── Dockerfile.</description>
    </item>
    
    <item>
      <title>NATS streaming</title>
      <link>https://zhenfeng-zhu.github.io/post/nats-streaming/</link>
      <pubDate>Mon, 30 Jul 2018 14:51:26 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/nats-streaming/</guid>
      <description>市面上常见到的和 Nats 功能类似的消息通信系统有：
ActiveMQ（Java 编写）、KafKa（Scala 编写）、RabbitMq（Ruby 编写）、Nats（之前是 Ruby 编写现已修改为 Go）、Redis（C 语言编写）、Kestrel（Scala 编写不常用）、NSQ（Go 语言编写），这些消息通信系统在 Broker 吞吐量方面的比较：
可以看到 NATS 的吞吐量特别高， NATS 原来是使用 Ruby 编写，可以实现每秒 150k 消息，后来使用 Go 语言重写，能够达到每秒 8-11 百万个消息，整个程序很小只有 3M Docker image，它不支持持久化消息，如果你离线，你就不能获得消息。关于 NATS 的详细介绍，请参考上篇文章：NATS 简介
NATS Streaming NATS Streaming 是由 NATS 驱动的数据流系统，也是由 go 语言写成的，在保证吞吐量和时延的基础上，解决了 Nats 消息投递一致性的问题。nats streaming 可以和核心 nats 平台无缝嵌入，扩展和互动。
功能 除了 nats 平台的一些功能，nats streaming 还支持以下的：
 增强的消息协议 消息/事件持久化 至少一次投递 发布者速率限制 每个订阅者的速率匹配/限制 可重复消费 持久订阅  使用 首先安装 nats-streaming-server 服务，有多种方式，这里介绍两种：
  homebrew</description>
    </item>
    
    <item>
      <title>nats 简介</title>
      <link>https://zhenfeng-zhu.github.io/post/nats/</link>
      <pubDate>Mon, 30 Jul 2018 11:15:39 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/nats/</guid>
      <description>nats 是一个开源的，云原生的消息系统。Apcera，百度，西门子，VMware，HTC 和爱立信等公司都有在使用。
核心基于 EventMachine 开发，原理是基于消息发布订阅机制，每台服务器上的每个模块会根据自己的消息类别向 MessageBus 发布多个消息主题，而同时也向自己需要交互的模块，按照需要的主题订阅消息。能够达到每秒 8-11 百万个消息，整个程序很小只有 3M Docker image，它不支持持久化消息，如果你离线，你就不能获得消息。使用 nats streaming 可以做到持久化，缓存等功能。
NATS server nats 提供了一个 go 编写的轻量级服务器。发行版包括二进制和 docker 镜像
NATS clients
nats 官方提供的客户端有 Go，Node，Ruby，Java，C，C＃，NGINX 等。
NATS 设计目标
核心原则是性能，可伸缩和易用性。
 高效 始终在线和可用 非常轻巧 支持多种质量的服务 支持各种消息传递模型和使用场景  NATS 使用场景 nats 是一个简单且强大的消息系统，为支持现代云原生架构设计。由于可伸缩性的复杂性，nats 旨在容易使用和实现，且能提供多种质量的服务。
一些适用 nats 的场景有：
 高吞吐量的消息分散 —— 少数的生产者需要将数据发送给很多的消费者。 寻址和发现 —— 将数据发送给特定的应用实例，设备或者用户，也可用于发现并连接到基础架构中的实例，设备或用户。 命令和控制（控制面板）—— 向程序或设备发送指令，并从程序/设备中接收状态，如 SCADA，卫星遥感，物联网等。 负载均衡 —— 主要应用于程序会生成大量的请求，且可动态伸缩程序实例。 N 路可扩展性 —— 通信基础架构能够充分利用 go 的高效并发/调度机制，以增强水平和垂直的扩展性。 位置透明 —— 程序在各个地理位置上分布者大量实例，且你无法了解到程序之间的端点配置详情，及他们所生产或消费的数据。 容错  使用 nats-streaming 的附加场景有：</description>
    </item>
    
    <item>
      <title>overview-of-openfaas</title>
      <link>https://zhenfeng-zhu.github.io/post/overview-of-openfaas/</link>
      <pubDate>Thu, 26 Jul 2018 17:41:33 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/overview-of-openfaas/</guid>
      <description>OpenFaaS 概览  无服务器函数变得简单。
 函数监视器  你可以通过添加函数监视器 (一个小型的 Golang HTTP 服务)把任何一个 Docker 镜像变成无服务器函数。 函数监视器是允许 HTTP 请求通过 STDIN 转发到目标进程的入口点。响应会从你应用写入 STDOUT 返回给调用者。  API 网关/UI 门户  API 网关为你的函数提供外部路由，并通过 Prometheus 收集云原生指标。 你的 API 网关将会根据需求更改 Docker Swarm 或 Kubernetes API 中的服务副本数来实现伸缩性。 UI 是允许你在浏览器中调用函数或者根据需要创建新的函数。   API 网关是一个 RESTful 形式的微服务，你可以在这里查看Swagger 文档。
 命令行 Docker 中的任何容器或者进程都可以是 FaaS 中的一个无服务器函数。使用FaaS CLI ，你可以快速的部署函数。
可以从 Node.js, Python, Go 或者更多的语言模板中创建新的函数。如果你无法找到一个合适的模板，甚至可以使用一个 Dockerfile。
 CLI 实际上是 API 网关的一个 RESTful 客户端。
 在配置好 OpenFaaS 之后，你可以在这里开始学习 CLI开始学习 CLI</description>
    </item>
    
    <item>
      <title>OpenFaaS on Rancher 2.0</title>
      <link>https://zhenfeng-zhu.github.io/post/openfaas-on-rancher/</link>
      <pubDate>Thu, 26 Jul 2018 09:50:46 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/openfaas-on-rancher/</guid>
      <description>这是一篇关于如何在 Rancher 2.0 上创建 OpenFaaS 栈的文章。我假设你已经准备好了 Rancher 2.0 集群，如果没有请按照官方文档创建一个。
下面的视频展示了如何创建 OpenFaaS 栈，并在实际中使用：
https://www.youtube.com/watch?v=kX8mXv5d1qg&amp;amp;feature=youtu.be
这里是创建栈的compose.yml文件：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  version: &amp;#34;2&amp;#34; services:  alertmanager:  image: functions/alertmanager:latest  labels:  io.</description>
    </item>
    
    <item>
      <title>openfaas-workshop-lab4</title>
      <link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab4/</link>
      <pubDate>Mon, 02 Jul 2018 09:32:59 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab4/</guid>
      <description>实验 4&amp;ndash;更深入地使用函数 在开始本实验之前，为你的文件创建一个新的文件夹。由于本实验是建立在早期实验的基础上的，所以请复制 lab3。
1 2  $ cp -r lab3 lab4\  &amp;amp;&amp;amp; cd lab4   通过环境变量注入配置 能够控制一个函数在运行时的行为方式是很有用的，我们至少可以通过两种方式来实现这一点。
在部署时 *在部署时设置环境变量
我们在Lab 3中用write_debug做了这个 - 你也可以在这里设置任何你想要的自定义环境变量 - 例如，如果你想为你的hello world函数配置一种语言，你可以引入一个spoken_language变量。
使用 HTTP 上下文&amp;ndash;querystring / headers *使用 querystring 和 HTTP headers
另一个更动态的、可以在每个请求层面上改变的选项是使用查询字符串和 HTTP 头信息，两者都可以通过faas-cli或curl传递。
这些头信息通过环境变量暴露出来，所以它们很容易在你的函数中被使用。所以任何头信息都以Http_为前缀，所有-连字符都被替换成_下划线。
让我们用 querystring 和一个列出所有环境变量的函数来试试。
 使用 BusyBox 的内置命令，部署一个打印环境变量的函数。  1  faas-cli deploy --name env --fprocess=&amp;#34;env&amp;#34; --image=&amp;#34;function/alpine:latest&amp;#34;    用一个查询字符串调用该函数。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  $ echo &amp;#34;&amp;#34; | faas-cli invoke env --query workshop=1 PATH=/usr/local/bin:/usr/local/bin:/usr/bin:/sbin:/bin HOSTNAME=05e8db360c5a fprocess=env HOME=/root Http_Connection=close Http_Content_Type=text/plain Http_X_Call_Id=cdbed396-a20a-43fe-9123-1d5a122c976d Http_X_Forwarded_For=10.</description>
    </item>
    
    <item>
      <title>ubuntu-docker-sudo</title>
      <link>https://zhenfeng-zhu.github.io/post/ubuntu-docker-sudo/</link>
      <pubDate>Fri, 29 Jun 2018 13:54:25 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/ubuntu-docker-sudo/</guid>
      <description>1 2  sudo chown &amp;#34;$USER&amp;#34;:&amp;#34;$USER&amp;#34; /home/&amp;#34;$USER&amp;#34;/.docker -R sudo chmod g+rwx &amp;#34;/home/$USER/.docker&amp;#34; -R   1 2 3 4 5  https://api.finochat.com/api/v1/platform/apps/RETAIL/profiles/@custom:finolabs.com.cn/avatar?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmY2lkIjoiQHBjdXN0b20tMTA6Zmlub2xhYnMuY29tLmNuIiwiaXNzIjoieUNkNXVhaWRhWU4zc1pwTTdHU2V5WWVqSGdlN3hSa1EiLCJpYXQiOjE1MzAyNjk5NDh9.UUsO2xw1f8cA6FiG1bNAGyYQh-vh32hKHKSJ2EKZicI    http://localhost:3000/api/v1/platform/apps/RETAIL/profiles/@custom:finolabs.com.cn/avatar?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmY2lkIjoiQHBjdXN0b20tMTA6Zmlub2xhYnMuY29tLmNuIiwiaXNzIjoieUNkNXVhaWRhWU4zc1pwTTdHU2V5WWVqSGdlN3hSa1EiLCJpYXQiOjE1MzAyNjk5NDh9.UUsO2xw1f8cA6FiG1bNAGyYQh-vh32hKHKSJ2EKZicI   </description>
    </item>
    
    <item>
      <title>openfaas-workshop-lab3</title>
      <link>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab3/</link>
      <pubDate>Thu, 28 Jun 2018 17:29:56 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/openfaas-workshop-lab3/</guid>
      <description>实验 3&amp;ndash;函数介绍 在开始这个实验之前，为你的文件创建一个新的文件夹。
1 2  $ mkdir -p lab3\`s  &amp;amp;&amp;amp; cd lab3   创建一个新的函数 有两种方法来创建一个新的函数。
 使用一个内置的或社区的代码模板建立一个函数（默认情况下） 使用一个现有的二进制文件并将其作为你的函数（高级）  构建或生成一个新函数 在用模板创建新函数之前，请确保你从 GitHub 上提取了模板。
1 2 3 4 5  $ faas-cli template pull  Fetch templates from repository: https://github.com/openfaas/templates.git  Attempting to expand templates from https://github.com/openfaas/templates.git 2021/08/25 15:58:10 Fetched 13 template(s) : [csharp dockerfile go java11 java11-vert-x node node12 node14 php7 python python3 python3-debian ruby] from https://github.com/openfaas/templates.git   之后，要想知道哪些语言是可用的，请键入。</description>
    </item>
    
    <item>
      <title>译：openfaas-workshop-Lab1</title>
      <link>https://zhenfeng-zhu.github.io/post/workshop-lab1/</link>
      <pubDate>Mon, 25 Jun 2018 18:04:09 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/workshop-lab1/</guid>
      <description>今天大多数公司在开发应用程序并将其部署在服务器上的时候，无论是选择公有云还是私有的数据中心，都需要提前了解究竟需要多少台服务器、多大容量的存储和数据库的功能等。并需要部署运行应用程序和依赖的软件到基础设施之上。假设我们不想在这些细节上花费精力，是否有一种简单的架构模型能够满足我们这种想法？这个答案已经存在，这就是今天软件架构世界中新鲜但是很热门的一个话题——Serverless（无服务器）架构。
目前已经有一批优秀的 serverless 架构开源项目，OpenFaas 就是其中的佼佼者。奈何其中的中文资料比较少，我也是边学边翻译，希望能够抛砖引玉，助力 serverless 的发展。
这是一个自学研讨会，学习如何构建、部署和运行 OpenFaas 函数。
Lab1 - OpenFaas 的准备工作 OpenFaas 可以在 Docker Swarm 和 Kubernetes 的过几个主要平台之上运行。在此教程里，我们将会在的您本地电脑使用 Docker Swarm 来入门。
预备条件 Docker Mac
 Docker CE for Mac Edge Edition  Windows
 仅针对 windows10 专业版或企业版 安装Docker CE for Windows 安装Git Bash   备注：所有步骤中请使用 Git Bash：不要尝试使用 WSL 或 Bash for Windows。
 Linux - Ubuntu 或 Debian
 Docker CE for Linux   你可以从Docker Store中安装 Docker CE</description>
    </item>
    
    <item>
      <title>openfaas</title>
      <link>https://zhenfeng-zhu.github.io/post/openfaas/</link>
      <pubDate>Sun, 24 Jun 2018 15:43:46 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/openfaas/</guid>
      <description>对于 mac 环境来讲，首先安装新版 docker:
1  brew cask install docker   然后启动 docker。
命令行登陆 docker hub
1  docker login   启动 docker swarm
1  docker swarm init   安装 faas-cli
1  brew install faas-cli   clone 下来代码：
1  git clone https://github.com/openfaas/faas   然后执行
1  ./deploy_stack.sh   部署一些示例
1  faas-cli deploy -f https://raw.githubusercontent.com/openfaas/faas/master/stack.yml   使用浏览器打开 http://127.0.0.1:8080 就可以看到 ui 界面了。</description>
    </item>
    
    <item>
      <title>java-reactive-web</title>
      <link>https://zhenfeng-zhu.github.io/post/java-reactive-web/</link>
      <pubDate>Sat, 23 Jun 2018 15:05:32 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/java-reactive-web/</guid>
      <description>Spring web mvc： 传统 servlet web
spring web flux： Reactive web
 编程模式： non-blocking 非阻塞  nio：同步？异步？   并行模型  sync 同步 async 异步    Reactive 概念 Reactive programming： 响应式编程
In computing, reactive programming is a declarative programming paradigm concerned with data streams and the propagation of change. With this paradigm it is possible to express static (e.g. arrays) or dynamic (e.g. event emitters) data streams with ease, and also communicate that an inferred dependency within the associated execution model exists, which facilitates the automatic propagation of the changed data flow.</description>
    </item>
    
    <item>
      <title>kafka</title>
      <link>https://zhenfeng-zhu.github.io/post/kafka/</link>
      <pubDate>Thu, 21 Jun 2018 17:49:46 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/kafka/</guid>
      <description>启动 zookeeper
1  bin/zookeeper-server-start.sh config/zookeeper.properties   启动 kafka
1  bin/kafka-server-start.sh config/server.properties   创建一个主题
1  bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test   1  bin/kafka-topics.sh --list --zookeeper localhost:2181   生产者
1  bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test   消费者
1  bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning   kafka connect
1  echo -e &amp;#34;zhisheng\ntian&amp;#34; &amp;gt; test.txt   ls</description>
    </item>
    
    <item>
      <title>译：vertx-kotlin-coroutine</title>
      <link>https://zhenfeng-zhu.github.io/post/vertx-kotlin-coroutine/</link>
      <pubDate>Sat, 02 Jun 2018 16:00:52 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/vertx-kotlin-coroutine/</guid>
      <description>尝试翻译 vertx 的文档。尊重原文，部分使用自己的理解。
 Vert.x 的 kotlin 协程提供了 async/await 或者和 go 类似的 channel。这使得你能够以熟悉的顺序风格写垂直代码。
vertx-lang-kotlin-coroutines 集成了 kotlin 协程，用于执行异步操作和处理事件。这样就能够以同步代码的模型编写代码，而且不会阻塞内核线程。
简介 vert.x 与许多旧的应用平台相比的一个主要优势是它几乎完全是非阻塞的（内核线程）。这允许基于 vert.x 的程序使用极少数的内核线程处理大量的并发（例如：许多连接和消息），可以获得更好的伸缩性。
vert.x 的非阻塞特性形成了非阻塞 API。非阻塞 API 可以采用多种形式来实现，包括回调函数，promise，fibers 或者响应式扩展。vert.x 的核心 API 使用回调函数的风格，但是它也支持其他模型，如 RxJava 1 和 2。
在某些情况下，使用异步的 API 编程可能比使用经典的顺序代码风格更具有挑战性，特别是需要按照顺序完成若干操作。另外，使用异步 API 时，错误的传播也更为复杂。
vertx-lang-kotlin-coroutines 使用协程。协程是非常轻量级的线程，而且不与底层的内核线程对应。所以当协程需要“阻塞”时，它会暂停并释放当前的内核线程，使得另一个协程可以处理事件。
vertx-lang-kotlin-coroutines 使用 kotlinx.coroutines 来实现协程。
 vertx-lang-kotlin-coroutines 目前仅适用于 kotlin，而且是 kotlin1.1 的一个实验特性。
 从一个 vertx.x 的 contex 中启动协程 导入 io.vertx.kotlin.coroutines.VertxCoroutine，launch（协程生成器）方法中允许运行一段代码作为可以暂停的协程：
1 2 3 4 5 6 7 8 9  val vertx = Vertx.</description>
    </item>
    
    <item>
      <title>小议 async/await 和 coroutine</title>
      <link>https://zhenfeng-zhu.github.io/post/async/</link>
      <pubDate>Mon, 21 May 2018 19:37:14 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/async/</guid>
      <description>Being happy doesn&amp;rsquo;t mean that everything is perfect. It means that you decided to look beyond the imperfections.
 后端编程，涉及最多的就是并发。简单理解就是：
 并发是同时管理多个任务去执行，并行是针对多核处理器，同时执行多个任务。可以理解为一个是 manage，一个是 run。
 并发一般特指 IO，IO 是独立于 CPU 的设备，IO 设备通常远远慢于 CPU，所以我们引入了并发的概念，让 CPU 可以一次性发起多个 IO 操作而不用等待 IO 设备做完一个操作再做令一个。原理就是非阻塞操作+事件通知。
硬件底层上我其实不关心，主要就是在写程序上，如何简单的去写并发的代码。在语法层面上对并发做的比较好的，很适合做服务端，比如 go，比如 node，又比如某些函数式语言。我最近最近主要使用的是 node 和 kotlin。
那么在写并发代码的时候，就会时不时的想这样一个问题：
一个问题 当代码遇到一个“暂时不能完成”的流程时（例如建立一个 tcp 链接，可能需要 5ms 才能建立），他不想阻塞在这里睡眠，想暂时离开现场去干点别的事情（例如看看另外一个已经建立的链接是否可以收包了）。问题是：离开现场后，当你回来的时候，上下文还像你走的时候吗？
跳转离开，在任何语言里都有 2 种最基本的方法：1）从当前函数返回； 2）调用一个新的函数。 前者会把上下文中的局部变量和函数参数全部摧毁，除非他返回前把这些变量找个别的地方保存起来；后者则能保护住整个上下文的内存（除了协程切换后会摧毁一些寄存器），而且跳转回来也是常规方法：函数返回。
在写 node 的时候，基本上是无脑上 async/await。每次看到回调函数的时候，强迫症就犯了，总是想方设法将那个方法转成 promise，然后使用 await 获得结果。无脑尝试了 bluebird 和 node 的 util，虽然有些是很好用的，但是有的还是无法达到我预期的。靠着无脑的 async/await，实现了很多功能，代码写起来也是快的飞起，但是只顾着做业务而不深入思考的话，是一个不好的表现，所以我就停下来搜了很多 async/await 的东西，特别是从阮一峰老师那里收获了很多。</description>
    </item>
    
    <item>
      <title>elasticsearch</title>
      <link>https://zhenfeng-zhu.github.io/post/elasticsearch/</link>
      <pubDate>Sun, 20 May 2018 14:17:07 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/elasticsearch/</guid>
      <description>以前没有好好学的东西，现在在工作中慢慢的补回来了。
基础概念  索引  es 是将数据存储在一个或者多个索引（index）中。
索引就像是数据库。
 文档  文档是 es 的实体。由字段构成，每个字段包含字段名和一个或者多个字段值。
文档就像数据库中的一条条记录。
 类型  每个文档都有一个类型与之相对应。
类型就像数据库中的表。
 Map  所有文档在被写入到 es 中，都会被分析。由用户设置一些参数决定如何分割词条、哪些字应该被过滤掉等等。
 节点  单个 es 服务实例就是一个节点。
 集群  多个协同工作的 es 节点的集合就是集群。
 分片  es 将数据分散到多个物理的 Lucene 索引上，这些物理 Lucene 索引被称为分片。
 副本  副本就是每个分片都做冗余处理，一个宕机之后，不影响服务。
快速入门 安装 es 的安装很简单，我这里使用的是 mac，下载下来 zip 包，解压即可使用。
1 2 3 4 5 6 7  [elasticsearch-6.2.4] pwd /Users/zhuzhenfeng/Documents/software/elasticsearch-6.2.4 [elasticsearch-6.2.4] .</description>
    </item>
    
    <item>
      <title>git 常用操作</title>
      <link>https://zhenfeng-zhu.github.io/post/git/</link>
      <pubDate>Mon, 14 May 2018 10:04:02 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/git/</guid>
      <description>整理一下常用的 git 操作，不用再到处找了。
git 放弃本地修改，强制更新 1 2  git fetch --all git reset --hard origin/master   git 修改远程仓库地址 1  git remote set-url origin url   cherry-pick 当你通过一番挣扎终于搞定一个 bug,顺手提交到 git 服务器,心里一阵暗爽. 这时发现你当前所在的分支是 master !!!
这个分支不是开发者用来提交代码的,可惜现在剁手也晚了.
 先切换到 master  1 2 3  git checkout master  git log    复制提交的 commit id
  切换到 dev, cherry-pick
  1 2 3  git checkout dev  git cherry-pic ${commit_id}   常用开发流程 git checkout -b feature1</description>
    </item>
    
    <item>
      <title>node 的 cluster</title>
      <link>https://zhenfeng-zhu.github.io/post/node%E7%9A%84cluster/</link>
      <pubDate>Sat, 05 May 2018 15:45:47 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/node%E7%9A%84cluster/</guid>
      <description>我们知道 js 是运行单线程的，也就是说一个 node 进程只能运行在一个 cpu 上。那么如果用 node 来做 web server 的话，就无法享受到多核运算的好处。
一个问题就是：
1  如何榨干服务器资源，利用多核CPU的并发优势。   node 官方提供的解决方案是 cluster。
1 cluster 是什么 简单来说：
 在服务器上同时启动多个进程。 每个进程都跑的是同一份源码。 这些进程可以同时监听一个端口。  其中：
 负责启动其他进程的叫做 master 进程，不做具体工作，只负责启动其他进程。 其他被启动的叫 worker 进程。他们接收请求，对外提供服务。 worker 进程的数量一般根据服务器的 cpu 核数来决定，这样就可以完美利用多核资源。  以下是官方文档的一个例子：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  const cluster = require(&amp;#39;cluster&amp;#39;); const http = require(&amp;#39;http&amp;#39;); const numCPUs = require(&amp;#39;os&amp;#39;).</description>
    </item>
    
    <item>
      <title>node 踩坑</title>
      <link>https://zhenfeng-zhu.github.io/post/node%E8%B8%A9%E5%9D%91/</link>
      <pubDate>Sat, 05 May 2018 15:32:59 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/node%E8%B8%A9%E5%9D%91/</guid>
      <description>module 首先第一个就是 es6 的 module。
看到别人写的
1  import { a } from &amp;#34;./module&amp;#34;;   所以自己也想要这么写，但是每次运行的时候都会报错。
1 2 3 4 5 6 7 8 9  // demo2.js export const a = &amp;#34;hello&amp;#34;;  //demo1.js import { a } from &amp;#34;./demo2&amp;#34;;  function hello() {  console.log(a); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  zhuzhenfengdeMacBook-Pro :: node/node-example » node demo1.</description>
    </item>
    
    <item>
      <title>node 学习笔记</title>
      <link>https://zhenfeng-zhu.github.io/post/node-learning/</link>
      <pubDate>Sun, 22 Apr 2018 15:41:21 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/node-learning/</guid>
      <description>写 node 也有一段时间了，整理一下学习笔记，共同进步
什么是 node 首先看一下什么是 node.js
 Node 是一个服务器端 JavaScript Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效 Node.js 的包管理器 npm，是全球最大的开源库生态系统  模块系统是 node 最基本也是最常用的。一般可以分为四类：
 原生模块 文件模块 第三方模块 自定义模块  node 社区崇尚 DRY 文化，即 Don&amp;rsquo;t repeate yourself。这种文化使得 node 的生态异常繁荣，同样也由于某些包的质量低下引来了一些诟病。
谈谈自定义模块 我们在写 node 程序的时候，一般都是在写自定义模块。
  创建模块
1 2 3 4 5 6 7  // b.js function FunA(){  return &amp;#34;hello world&amp;#34;; }  // 暴露方法FunA module.</description>
    </item>
    
    <item>
      <title>node 的 redis 实战</title>
      <link>https://zhenfeng-zhu.github.io/post/node%E7%9A%84redis%E5%AE%9E%E6%88%98/</link>
      <pubDate>Fri, 13 Apr 2018 10:00:12 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/node%E7%9A%84redis%E5%AE%9E%E6%88%98/</guid>
      <description>Node.js Redis 客户端模块 为了追新，这里我使用的 yarn，毕竟我是 HDD（面向热点编程）编程实践者。
模块安装
1  yarn add redis   模块使用实例
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const redis = require(&amp;#39;redis&amp;#39;) const client = redis.createClient(&amp;#39;6379&amp;#39;, &amp;#39;127.0.0.1&amp;#39;)  client.on(&amp;#34;error&amp;#34;, function (err) {  console.log(&amp;#34;Error &amp;#34; + err); });  client.set(&amp;#34;string key&amp;#34;, &amp;#34;string val&amp;#34;, redis.print); client.hset(&amp;#34;hash key&amp;#34;, &amp;#34;hashtest 1&amp;#34;, &amp;#34;some value&amp;#34;, redis.print); client.hset([&amp;#34;hash key&amp;#34;, &amp;#34;hashtest 2&amp;#34;, &amp;#34;some other value&amp;#34;], redis.</description>
    </item>
    
    <item>
      <title>谈谈 web 框架</title>
      <link>https://zhenfeng-zhu.github.io/post/%E8%B0%88%E8%B0%88web%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Sun, 08 Apr 2018 16:01:48 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E8%B0%88%E8%B0%88web%E6%A1%86%E6%9E%B6/</guid>
      <description>这篇文章打的标签比较多，也基本涵盖了我所了解的一些知识，归纳总结一下自己对 web 框架的理解。自己了解的也不是很多，也请多多指教。
写程序免不了要做 web 相关的，现在由于前后端的分离，后端一般只提供 rest 接口，前端一般使用 node 来做渲染。在之前使用 jsp 那一套的时候，基本上都要写 html+js 的前端的一套，也要写后端 java 的 CRUD。
我理解的 web 框架中，大致是分为这么两类：
 router 框架 mvc 框架  mvc 类框架 mvc，初级程序员面试笔试的时候必考的一个知识点。model-view-controller，即模型-视图-控制器。
 m，模型主要用于封装与应用程序相关的数据以及对数据的处理方法。 v，在 View 中一般没有程序上的逻辑。为了实现 View 上的刷新功能，View 需要访问它监视的数据模型（Model），因此应该事先在被它监视的数据那里注册。 c，用于控制应用程序的流程。  我了解比较多的 mvc 框架是 spring mvc。spring、spring mvc 和 spring boot 等，他们并不是一个概念，也不是仅仅用于 web 开发。但是在这里我就不分那么细，统一用 spring 来代替。这里所说的 spring 都是指狭义上的 web 开发方面。
在做 web 开发的时候，项目目录一般是这样的：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24   $ tree [16:23:43] .</description>
    </item>
    
    <item>
      <title>技术栈</title>
      <link>https://zhenfeng-zhu.github.io/post/%E6%8A%80%E6%9C%AF%E6%A0%88/</link>
      <pubDate>Thu, 05 Apr 2018 09:49:06 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E6%8A%80%E6%9C%AF%E6%A0%88/</guid>
      <description>创业公司真的比较锻炼人，接触了很多的东西，视野开阔了，但是在某些时候自己疲于奔命，每个东西都是接触了一点点就被赶鸭子上架开始开发了。
技术栈  Docker  docker 是一个容器，以前就看过 docker 相关的东西，但是没有仔细研究，docker 的命令会用一些，在工作中使用了，看了一本 docker 的书，能够编写 docker 的 compose 文件。
 rancher  rancher 是一个做容器管理的。我们把主机添加到 rancher 中，他就可以自动做到 LB，服务的发现编排。我们部署的时候只需要编写 catalog，他就可以自动发现 docker 应用，然后拉取镜像，部署到相关的机器上，很是方便。
 aws  近期主要是对 aws 的进行公司服务的部署，搭建一套 rancher 的环境。aws 的服务特别多，ec2 是实例主机，就和虚拟机一样，VPC 就像机房，ec2 依托于 VPC 而存在，在这基础上又了解了子网、DHCP 弹性 IP 等等。
 kotlin  之前自己用 kotlin 开发过一个博客，对 kotlin 的感觉是有些东西写的很爽，但是还是觉得 java 好用一些，对 kotlin 的态度是用不用都无所谓。
 guice  这个我之前都读错了，我读成了盖斯，其实是和果汁的英文发音很像，ju 斯。只是一个依赖注入框架，只是单纯的去做 DI，比 spring 更轻量级一些。
需要我们编写 AppModule.java 去手动配置哪个类注入哪个类。
 rxjava  rxjava 我都没有找到一个系统的教程，不知道该从哪里学习。</description>
    </item>
    
    <item>
      <title>同步一个 fork</title>
      <link>https://zhenfeng-zhu.github.io/post/%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA-fork/</link>
      <pubDate>Wed, 04 Apr 2018 16:01:31 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA-fork/</guid>
      <description>具体方法 Configuring a remote for a fork  给 fork 配置一个 remote 主要使用 git remote -v 查看远程状态。  1 2 3  git remote -v # origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) # origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)    添加一个将被同步给 fork 远程的上游仓库  1  git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git    再次查看状态确认是否配置成功。  1 2 3 4 5  git remote -v # origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) # origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) # upstream https://github.</description>
    </item>
    
    <item>
      <title>Go 语言体会</title>
      <link>https://zhenfeng-zhu.github.io/post/go%E8%AF%AD%E8%A8%80%E4%BD%93%E4%BC%9A/</link>
      <pubDate>Wed, 04 Apr 2018 13:48:57 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/go%E8%AF%AD%E8%A8%80%E4%BD%93%E4%BC%9A/</guid>
      <description>最近公司要统一技术栈，在 kotlin 和 go 之间选。我心里是比较倾向 go 的，主要有如下几点体会。
 语言简单，上手快。 gorotuine 易发布 垃圾回收 约定大于配置  我最早听说协程，是在大三找实习的时候，那个时候面试会问线程和进程的关系，问的深一些就是协程和线程的区别。游戏公司基本都用 lua，看了 lua 的资料后，对协程有了一些自己的了解，随后就是在做 Unity 相关的开发，在 unity 中使用了很多的协程，但是在 unity 中使用的协程好像跟主流的不太一样，在看了 go 之后，豁然开朗。
goroutine 使用的内存比线程更少，go 在运行的时候会自动在配置的一组逻辑处理器上调度执行。比如：
1 2 3 4 5  func log(msg string){  ... }  go log(&amp;#34;&amp;#34;)   使用关键字 go，即可让 log 函数在一个 goroutine 里执行了。
并发最难的部分是要确保其他并发运行的进程、线程或者 goroutine 不会以外的修改数据。go 使用了 Channel 的方式来解决这个问题。对于通道模式，保证同一时刻只会有一个 goroutine 修改数据。
说起 go 的语言简单，其实主要是他的类型比较简单。go 使用的是组合模式，只需要将一个类型嵌入到另外一个类型就可以复用所有的功能。而且 go 还具有独特的接口实现机制，允许用户对行为进行建模，在 go 中不需要声明某个类型实现了某个接口，编译器会自动判断一个实例是使用什么接口。
对于 java 来说，所有的设计都是围绕着接口展开，于是在设计模式中，就是面向接口编程：</description>
    </item>
    
    <item>
      <title>关于时间管理</title>
      <link>https://zhenfeng-zhu.github.io/post/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sun, 25 Mar 2018 20:28:42 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</guid>
      <description>主动管理时间，敢于说不。
有目标向前看，没目标向钱看。</description>
    </item>
    
    <item>
      <title>一致性哈希算法</title>
      <link>https://zhenfeng-zhu.github.io/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 24 Mar 2018 19:03:58 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</guid>
      <description>当我们在做数据库分库分表或者做分布式缓存的时候，不可避免的都会遇到一个问题：
如何将数据均匀的分散到各个节点中，并且尽量的在加减节点的时能使受影响的数据最少。
1 hash 取模 随机放置就不多说了。通常最容易想到的方案是哈希取模了。
可以将传入的 key 按照 $$ index=hash(key) % N $$ 这样来计算出需要存放的节点。
这样可以满足数据的均匀分配，但是这个算法的容错性和扩展性比较差。比如增加或者删除一个节点的时候，所有的 key 都要重新计算，显然这样的成本比较高，为此需要一个算法来满足均匀的同时也要有良好的容错性和扩展性。
2 一致性 hash 算法 一致性 hash 算法是将所有的哈希值构成了一个环，其范围是 0~2^32-1。如图：
之后将各个服务器节点散列到这个环上，可以用节点的 IP，hostname 这样唯一性的字段作为 key 进行 hash。散列之后如下：
之后需要将数据定位到对应的节点上，使用同样的 hash 函数将 key 也映射到这个环上。
这样就按照顺时针方向就可以将 k1 定位到 N1 节点，k2 定位到 N3 节点，k3 定位到 N2 节点。
2.1 容错性 假设 N1 宕机了：
依然根据顺时针方向，k2 和 k3 保持不变，只有 k1 被重新映射到了 N3。这样就很好的保证了容错性，当一个节点宕机时只会影响到少部分数据。
2.2 扩展性 当新增一个节点时：
在 N2 和 N3 之间新增了一个节点 N4，这时受影响的数据只有 k3，其余的数据也是保持不变。</description>
    </item>
    
    <item>
      <title>Spring Boot 启动原理分析</title>
      <link>https://zhenfeng-zhu.github.io/post/spring-boot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 24 Mar 2018 19:03:22 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/spring-boot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid>
      <description>Spring Boot 启动原理分析 我们在开发 spring boot 应用的时候，一般会遇到如下的启动类：
1 2 3 4 5 6  @SpringBootApplication public class DemoApplication {  public static void main(String[] args) {  SpringApplication.run(DemoApplication.class, args);  } }   从这段代码可以看出，注解@SpringBootApplication 和 SpringApplication.run()是比较重要的两个东西。
1 @SpringApplication 注解 1 2 3 4 5 6 7 8 9 10 11 12  @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = {  @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),  @Filter(type = FilterType.</description>
    </item>
    
    <item>
      <title>Spring Data Jpa 实战</title>
      <link>https://zhenfeng-zhu.github.io/post/spring-data-jpa%E5%AE%9E%E6%88%98/</link>
      <pubDate>Sat, 24 Mar 2018 19:02:48 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/spring-data-jpa%E5%AE%9E%E6%88%98/</guid>
      <description>为了解决抽象各个 Java 实体基本的“增删改查”操作，我们通常会以泛型的方式封装一个模板 Dao 来进行抽象简化，但是这样依然不是很方便，我们需要针对每个实体编写一个继承自泛型模板 Dao 的接口，再编写该接口的实现。虽然一些基础的数据访问已经可以得到很好的复用，但是在代码结构上针对每个实体都会有一堆 Dao 的接口和实现。
由于模板 Dao 的实现，使得这些具体实体的 Dao 层已经变的非常“薄”，有一些具体实体的 Dao 实现可能完全就是对模板 Dao 的简单代理，并且往往这样的实现类可能会出现在很多实体上。Spring-data-jpa 的出现正可以让这样一个已经很“薄”的数据访问层变成只是一层接口的编写方式。
1 工程配置 1.1 pom 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  &amp;lt;?</description>
    </item>
    
    <item>
      <title>spring boot 多数据源配置</title>
      <link>https://zhenfeng-zhu.github.io/post/spring-boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sat, 24 Mar 2018 19:01:37 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/spring-boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/</guid>
      <description>spring boot 多数据源配置 在单数据源的情况下，Spring Boot 的配置非常简单，只需要在 application.properties 文件中配置连接参数即可。但是往往随着业务量发展，我们通常会进行数据库拆分或是引入其他数据库，从而我们需要配置多个数据源。
1 准备 1.1 禁止 DataSourceAutoConfiguration 首先要将 spring boot 自带的DataSourceAutoConfiguration禁掉，因为它会读取application.properties文件的spring.datasource.*属性并自动配置单数据源。在@SpringBootApplication注解中添加exclude属性即可：
1 2 3 4 5 6  @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class}) public class DemoApplication {  public static void main(String[] args) {  SpringApplication.run(JpaDemoApplication.class, args);  } }   1.2 配置数据库连接 然后在application.properties中配置多数据源连接信息：
1 2 3 4 5 6 7 8 9  spring.datasource.primary.url=jdbc:mysql://localhost:3306/test spring.datasource.primary.username=root spring.datasource.primary.password=root spring.datasource.primary.driver-class-name=com.mysql.jdbc.Driver  spring.datasource.secondary.url=jdbc:mysql://localhost:3306/test1 spring.datasource.secondary.username=root spring.datasource.secondary.password=root spring.datasource.secondary.driver-class-name=com.mysql.jdbc.Driver   1.</description>
    </item>
    
    <item>
      <title>spring boot 连接 redis</title>
      <link>https://zhenfeng-zhu.github.io/post/spring-boot%E8%BF%9E%E6%8E%A5redis/</link>
      <pubDate>Sat, 24 Mar 2018 19:00:48 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/spring-boot%E8%BF%9E%E6%8E%A5redis/</guid>
      <description>Spring-data-redis为 spring-data 模块中对 redis 的支持部分，简称为“SDR”，提供了基于 jedis 客户端 API 的高度封装以及与 spring 容器的整合，
jedis 客户端在编程实施方面存在如下不足：
 connection 管理缺乏自动化，connection-pool 的设计缺少必要的容器支持。 数据操作需要关注“序列化”/“反序列化”，因为 jedis 的客户端 API 接受的数据类型为 string 和 byte，对结构化数据(json,xml,pojo 等)操作需要额外的支持。 事务操作纯粹为硬编码 pub/sub 功能，缺乏必要的设计模式支持，对于开发者而言需要关注的太多。  1 spring-data-redis 特性  连接池自动管理，提供了一个高度封装的“RedisTemplate”类 针对 jedis 客户端中大量 api 进行了归类封装,将同一类型操作封装为 operation 接口  ValueOperations：简单 K-V 操作 SetOperations：set 类型数据操作 ZSetOperations：zset 类型数据操作 HashOperations：针对 map 类型的数据操作 ListOperations：针对 list 类型的数据操作   提供了对 key 的“bound”(绑定)便捷化操作 API，可以通过 bound 封装指定的 key，然后进行一系列的操作而无须“显式”的再次指定 Key，即 BoundKeyOperations：  BoundValueOperations BoundSetOperations BoundListOperations BoundSetOperations BoundHashOperations   将事务操作封装，有容器控制。 针对数据的“序列化/反序列化”，提供了多种可选择策略(RedisSerializer)  JdkSerializationRedisSerializer：POJO 对象的存取场景，使用 JDK 本身序列化机制，将 pojo 类通过 ObjectInputStream/ObjectOutputStream 进行序列化操作，最终 redis-server 中将存储字节序列。是目前最常用的序列化策略。 StringRedisSerializer：Key 或者 value 为字符串的场景，根据指定的 charset 对数据的字节序列编码成 string，是“new String(bytes, charset)”和“string.</description>
    </item>
    
    <item>
      <title>最终一致性的实现手段</title>
      <link>https://zhenfeng-zhu.github.io/post/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%AE%B5/</link>
      <pubDate>Sat, 24 Mar 2018 18:59:55 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%AE%B5/</guid>
      <description>最终一致性的实现手段 实现最终一致性有三种手段：可靠事件模式、业务补偿模式和 TCC 模式
1 可靠事件模式 可靠事件模式属于事件驱动架构，当某件重要的事情发生时，比如更新一个业务实体，微服务会向消息代理发布一个事件。消息代理会将订阅事件的微服务推送事件。
要实现这种模式需要消息队列实现事件的持久化和 at least once 的可靠事件投递模式。
1.1 本地事件表 本地事件表方法是将事件和业务数据保存在同一个数据库中，使用一个额外的事件恢复服务来恢复事件，由本地事物保证更新业务和发布事件的原子性。
但是业务系统和事件系统耦合比较紧密，额外的事件数据库操作也会给数据库带来额外的压力，可能成为瓶颈。
1.2 外部事件 此方法是将事件持久化到外部的事件系统，事件系统需要提供实时事件服务以接受微服务发布的事件，同时事件系统还需要提供事件恢复服务来确认恢复事件。
1.3 不足 此过程可能出现重复消费的情况。
2 补偿模式 一般来讲，异常一般是由以下两种情况造成的：
业务异常：业务逻辑产生的错误，比如余额不足、库存不足等。
技术异常：非业务逻辑产生的异常，比如网络连接异常、超时等。
补偿模式就是使用一个额外的协调服务来协调各个需要保证一致性的其他服务。协调服务按顺序调用每一个服务，如果某个服务调用异常就取消之前所有已经调用成功的服务。
建议仅用于技术异常的情况。对于业务异常来讲，应该尽可能的去优化业务模式，以避免要求补偿事务。
2.1 常用手段 在实现补偿模式时应该做到两点：
 首先要确定失败的步骤和状态，从而确定要补偿的范围。 其次要能提供补偿操作使用的业务数据。  可以通过记录完整的业务流水的方法来实现上面两点要求。但是对于一个通用的补偿框架来说，预先知道微服务需要记录的业务要素是不可能的，那么就需要一种办法来保证业务流水的可扩展性，实践中主要有两种方法：大表和关联表。
 大表，顾明思议就是设计时除了必须的字段外，还需要预留大量的备用字段，框架可以提供辅助工具来将业务数据映射到备用字段中。大表对于框架层实现起来比较简单，但是也有一些难点，比如预留多少个字段合适，每个字段又需要预留多长。还有一个难点是如果仅从数据层面来查询数据，很难一眼看出备用字段的业务含义，维护过程不友好。 关联表，分为技术表和业务表。技术表中保存为实现补偿操作所需要的技术数据，业务表中保存业务数据。通过在技术表中增加业务表名和业务表主键来建立和业务数据的关联。关联表更灵活，能支持不同业务类型记录不同的业务要素。但是在框架的实现上难度较高，每次查询都需要复杂的关联动作，性能会受到影响。  2.2 重试 补偿过程作为一个服务，在调用的时候也会出现不成功的情况，这时就要通过重试机制来保证补偿的成功率。因此要求补偿操作具有幂等性。
但是也不是盲目的重试，我们需要根据服务执行失败的原因来选择不同的策略：
 因业务因素导致失败，需要停止重试。 罕见的异常，如网络中断，传输过程中数据丢失，应该立即重试。 如果是因为系统繁忙，此时需要等待一段时间再重试。  2.3 不足 在补偿模式中有一个明显的缺陷是隔离性，从第一个服务开始一直到补偿完成，不一致性是对其他服务可见的。另外补偿模式过分依赖协调服务的健壮性，如果协调服务异常，则没办法达到一致性。
3 TCC 模式 TCC，是 Try，Confirm 和 Cancel 的缩写。一个完整的 TCC 业务一般是由一个主业务和若干个从业务组成。
 Try  完成所有业务检查 预留必须的业务资源   Confirm  真正执行业务 不做任何业务检查 只使用 Try 阶段预留的业务资源 满足幂等性   Cancel  释放 Try 阶段预留的业务资源 满足幂等性    3.</description>
    </item>
    
    <item>
      <title>Reactive 微服务</title>
      <link>https://zhenfeng-zhu.github.io/post/reactive%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Sat, 24 Mar 2018 17:57:58 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/reactive%E5%BE%AE%E6%9C%8D%E5%8A%A1/</guid>
      <description>Reactive 微服务 分布式系统构建起来很困难，因为它们容易出问题，运行缓慢，并且被 CAP 和 FLP 理论所限制。换句话说，它们的构建和运维都特别复杂。为了解决这个问题，reactive 便出现了。
Reactive 编程：一种开发模型，其专注于数据流向、对变化的反馈，以及传播他们。
在 reactive 编程中，刺激信号是数据的转移，叫做 streams。其实很像生产者——消费者模式，消费者对值进行订阅并响应。
Reactive 系统：一种架构风格，其基于异步消息来构建响应式的分布式系统。
reactive 系统使用了消息驱动的方法。所有的构建通过异步消息的发送和接收来交互。消息投递的逻辑由底层的实现决定。发送者不会阻塞着等待回复，它们可能会稍后才接收到回复。
reactive 系统会有两个重要的特征：
  伸缩性——可以横向伸缩
伸缩性来自消息传递的解耦。消息被发送到一个地址之后，可以被一组消费者按照一种负载均衡方法消费。当 reactive 系统遇到负载高峰时，它可以创造出新的消费者，并在此之后销毁它们。
  恢复性——可以处理错误并且恢复
首先，这种消息交互模式允许组件在其本地处理错误，组件不需要等待消息，因此当一个组件发生错误时，其他组件仍然会正常工作。其次，当一个处理消息的组件发生错误后，消息可以可以传递给在相同地址注册的其他组件。
  reactive 微服务系统是由 reactive 微服务组成的。这些微服务有下面四个特征：
 自治性 异步性 恢复性 伸缩性  Reactive 微服务是可自治的。他们可以根据周围的服务是否可用来调整自己的行为。自治性往往伴随着孤立性；Reactive 微服务可以在本地处理错误、独立地完成任务，并在必要时和其他服务合作。它们使用异步消息传递的机制和其他服务沟通；它们也会接收消息并且对其作出回应。
得益于异步消息机制，reactive 微服务可以处理错误并根据情况调整自己的行为。错误不会被扩散，而是在靠近错误源头的地方被处理掉。当一个微服务挂掉之后，它的消费者微服务要能够处理错误并避免扩散。这一孤立原则是避免错误逐层上浮而毁掉整个系统的关键。可恢复性不只是关于处理错误，它还涉及到自愈性；一个 reactive 微服务应该能够从错误中恢复并且对错误进行补救。
最后，reactive 微服务必须是可伸缩的，这样系统才可以根据负载情况来调整节点数量。这一特性意味着将会有一系列的限制，比如不能有在内存中的状态，要能够在必要时同步状态信息，或者要能够将消息路由到状态信息相同的节点。
Vert.x Vert.x 是一个用于构建 reactive 和分布式系统的工具箱，其使用了异步非阻塞编程模型。当使用 Vert.x 构建微服务的时候，微服务会自然地带上一个核心特征：所有事情都是异步的。
传统编程模式
1  int res = compute(1, 2);   在这段代码中，是在等待 compute 函数计算出来结果之后再进行剩下的操作。而在异步非阻塞的编程模式中，将会创建一个 handler：</description>
    </item>
    
    <item>
      <title>Guice 快速入门</title>
      <link>https://zhenfeng-zhu.github.io/post/guice%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 24 Mar 2018 17:57:15 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/guice%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid>
      <description>Guice 快速入门 接手的新项目主要是使用 kotlin+vert.x 来写的，使用 gradle 构建，依赖注入框架使用了 guice。这段时间都是在熟悉代码的过程，恶补一些知识。
guice 是谷歌推出的一个轻量级的依赖注入框架，当然 spring 也可以实现依赖注入，只是 spring 太庞大了。
1 基本使用 引入依赖 使用 gradle 或者 maven，引入 guice。
maven:
1 2 3 4 5  &amp;lt;dependency&amp;gt;  &amp;lt;groupId&amp;gt;com.google.inject&amp;lt;/groupId&amp;gt;  &amp;lt;artifactId&amp;gt;guice&amp;lt;/artifactId&amp;gt;  &amp;lt;version&amp;gt;4.1.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;   Gradle:
1  compile &amp;#34;com.google.inject:guice:4.1.0&amp;#34;   项目骨架 首先需要一个业务接口，包含一个方法来执行业务逻辑，它的实现非常简单：
1 2 3 4 5 6 7 8 9 10 11 12 13  package com.learning.guice; public interface UserService {  void process(); }   package com.</description>
    </item>
    
    <item>
      <title>kotlin 快速入门</title>
      <link>https://zhenfeng-zhu.github.io/post/kotlin%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 24 Mar 2018 17:56:45 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/kotlin%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid>
      <description>快速浏览一下 Kotlin 的语法。
基本语法 包定义和引用 在源文件头部：
1 2  package my.demo import java.util.*   方法定义  带有方法体，并且返回确定类型数据的定义方式，例如接受 Int 类型的参数并返回 Int 类型的值：  1 2 3  fun sum(a: Int, b: Int): Int {  return a + b }    带有方法体，返回推断类型数据的定义方式，例如：  1  fun sum(a: Int, b: Int) = a + b    返回无意义类型的定义方式：  1 2 3  fun printSum(a: Int, b: Int): Unit {  println(&amp;#34;sum of $aand $bis ${a + b}&amp;#34;) }   或者省略 Unit：</description>
    </item>
    
    <item>
      <title>RxJava2 快速入门</title>
      <link>https://zhenfeng-zhu.github.io/post/rxjava2%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 24 Mar 2018 17:55:56 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/rxjava2%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid>
      <description>RxJava2 快速入门 引入依赖 1  compile &amp;#39;io.reactivex.rxjava2:rxjava:2.0.1&amp;#39;   写法 简单版本 1 2 3 4 5 6 7 8 9 10   private static void helloSimple() {  Consumer&amp;lt;String&amp;gt; consumer = new Consumer&amp;lt;String&amp;gt;() {  @Override  public void accept(String s) throws Exception {  System.out.println(&amp;#34;consumer accept is &amp;#34; + s);  }  };   Observable.just(&amp;#34;hello world&amp;#34;).subscribe(consumer);  }   复杂版本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25   private static void helloComplex() {  Observer&amp;lt;String&amp;gt; observer = new Observer&amp;lt;String&amp;gt;() {  @Override  public void onSubscribe(Disposable d) {  System.</description>
    </item>
    
    <item>
      <title>领域实体类</title>
      <link>https://zhenfeng-zhu.github.io/post/%E9%A2%86%E5%9F%9F%E5%AE%9E%E4%BD%93%E7%B1%BB/</link>
      <pubDate>Sat, 24 Mar 2018 17:53:42 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/%E9%A2%86%E5%9F%9F%E5%AE%9E%E4%BD%93%E7%B1%BB/</guid>
      <description>在看项目代码的时候，发现了 entity 包和 dto 包，里面都是只保存数据的类，仔细查了资料，才发现 java 对于只保存数据的类有好几个分类。
 pojo 类：这是普通的 java 类，具有一部分的 get 和 set 方法。 dto 类：data transfer object 数据传输对象类，泛指用于展示层与服务层之间传输的对象。 vo 类：vo 有两种说法，一种是 view object，一种是 value object。 po 类：persisent object 持久对象。和 pojo 类一样，也是只有 get set 方法，但是这种类一般是用于持久层。 bo 类：business object，业务对象，表示应用程序领域内事物的所有实体类。 do 类：domain object，领域对象，就是从现实中抽象出来的有形或者无形的业务实体。  根据我的经验来看，大部分人都没有分那么清楚，一般是把数据类放在 domain 包，或者 entity 包里。再细分一下的话，可以把 dto 类单独提取到一个包里。</description>
    </item>
    
    <item>
      <title>docker</title>
      <link>https://zhenfeng-zhu.github.io/post/docker/</link>
      <pubDate>Sat, 24 Mar 2018 17:42:58 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/docker/</guid>
      <description>docker 常用命令 docker   获取镜像
docker pull
  新建并启动
docker run
  列出镜像
docker image ls
docker images
  删除虚悬镜像
docker image prune
  删除本地镜像
docker iamge rm
  查看应用信息
docker logs
  dockerfile 一般步骤  在一个目录里，新建一个文件，命名为 Dockerfile 在 Dockerfile 的目录内，执行 docker build  常用指令   FROM 指定基础镜像，且是第一条命令
  RUN 执行命令
shell 格式
exec 格式
  COPY 和 ADD 指令是复制文件</description>
    </item>
    
    <item>
      <title>express</title>
      <link>https://zhenfeng-zhu.github.io/post/express/</link>
      <pubDate>Sat, 24 Mar 2018 17:41:01 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/express/</guid>
      <description>Express 快速入门 安装 1 2 3  npm init  npm install --save express   hello world 1 2 3 4 5 6 7 8 9 10  var express = require(&amp;#39;express&amp;#39;); var app = express();  app.get(&amp;#39;/&amp;#39;, function (req, res) {  res.send(&amp;#39;Hello World!&amp;#39;); });  app.listen(3000, function () {  console.log(&amp;#39;Example app listening on port 3000!&amp;#39;); });   执行命令运行应用程序
1  node app.js   然后，在浏览器中输入 http://localhost:3000/ 以查看输出。</description>
    </item>
    
    <item>
      <title>碎碎念</title>
      <link>https://zhenfeng-zhu.github.io/post/a-month-in-finogeeks/</link>
      <pubDate>Sat, 24 Mar 2018 15:55:58 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/a-month-in-finogeeks/</guid>
      <description>一直没有机会写 2017 的年终总结，想到去年写的新的一年的计划，好像自己都没有按照计划来做，而且写的计划也不知道写到哪里去了。
站在现在的时间点去审视过去的一年，这个本命年还是发生了很多对自己的未来有着比较大影响的的事情。房子+女朋友+新工作，这些事情突然的涌现出来，搞得自己有些手忙脚乱。
梳理一下自己的收获吧：
首先当然是结识了一帮小伙伴，我们一起打农药，一起调 bug，一起奋战双十一。
在技术上也有了一定的提升，关键是自己的视野上有了很大的变化，不再是像当初大学的时候，不知道自己在做什么。这里对我影响比较大的一个是 phodal，看了他写的博客和书之后，对自己的触动很大，感觉他懂得很多东西，知识面很广，而且能够写出来，扩大了自己的影响力，所以我就想着自己能不能模仿他。另外一个就是田哥了，我觉得他是我认识的同龄人中，比较有自己想法的一个人，打进 acm world final 的人就是不一样，他看问题的角度比较新颖，而且归纳总结能力很强，给了我一些在编程上的指点，让我少走了很多弯路。
也很感谢自己的几个室友，让我不再感到孤单。自从刘巍来了深圳之后，11I 更欢乐了，也更污了。我们经常在家里煮火锅吃，吃的特别爽，以至于现在我都不想去火锅店里吃，总觉得在家吃的比较爽。
女朋友，出乎我的意料，现在想想还是感觉活在梦里，略过略过。
至于买房，没买之前的想法盲目乐观，后来算了一下，要是在深圳买房的话，我每个月的房贷是 2 万多，关键是首付还不一定能搞得出来。还是建议在北上广深工作的人，有机会现在老家的省会一类的城市，先搞一套，以后可以置换，能上车的时候早点上车，也是相当于变相攒钱了。对于不会投资或者创业的朋友，有时候辛辛苦苦干一年之后算一下，不知不觉中，自己的钱都不知道花在了哪里，如果有房贷的话，等用的时候说不定卖掉还能赚一些钱。
感觉自己换公司还是挺戏剧化的，当时也没想着真的就换工作吧，只是想投投简历，然后去面试一波看看自己的水平怎么样。总觉得自己在招银的舒适区待的太久了，没有什么激情了。同时自己也想出来试试，万一公司上市，摇身一变成为富翁了。当然这是白日梦了，路还是要一步一步的走的。
总感觉自己想了很多东西，但是就是写不出来，自己讲故事的能力还是要提升一些。</description>
    </item>
    
    <item>
      <title>Java 内存模型和线程</title>
      <link>https://zhenfeng-zhu.github.io/post/java-memory-thread/</link>
      <pubDate>Thu, 22 Mar 2018 19:16:37 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/java-memory-thread/</guid>
      <description>java 内存模型和线程  并发不一定依赖多线程，但是在 java 里面谈论并发，大多与线程脱不开关系。
 线程是大多是面试都会问到的问题。我们都知道，线程是比进程更轻量级的调度单位，线程之间可以共享内存。之前面试的时候，也是这样回答，迷迷糊糊，没有一个清晰的概念。
大学的学习的时候，写 C 和 C++，自己都没有用过多线程，看过一个 Windows 编程的书，里面讲多线程的时候，一大堆大写的字母，看着一点都不爽，也是惭愧。后来的实习，写 unity，unity 的 C#使用的是协程。只有在做了 java 后端之后，才知道线程到底是怎么用的。了解了java 内存模型之后，仔细看了一些资料，对 java 线程有了更深入的认识，整理写成这篇文章，用来以后参考。
1 Java 内存模型 Java 虚拟机规范试图定义一种 java 内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 java 程序在各种平台下都能达到一致性内存访问的效果。
java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量的底层细节。（这里所说的变量包括了实例字段、静态字段和数组等，但不包括局部变量与方法参数，因为这些是线程私有的，不被共享。）
1.1 主内存和工作内存 java 规定所有的变量都存储在主内存。每条线程有自己的工作内存。
线程的工作内存中的变量是主内存中该变量的副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程间也无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。
1.2 内存之间的交互 关于主内存和工作内存之间的具体交互协议，java 内存模型定义了 8 中操作来完成，虚拟机实现的时候必须保证每个操作都是原子的，不可分割的（对于 long 和 double 有例外）
 lock 锁定：作用于主内存变量，代表一个变量是一条线程独占。 unlock 解锁：作用于主内存变量，把锁定的变量解锁。 read 读取：作用于主内存变量，把变量值从主内存传到线程的工作内存中，供 load 使用。 load 载入：作用工作内存变量，把上一个 read 到的值放入到工作内存中的变量中。 use 使用：作用于工作内存变量，把工作内存中的一个变量的值传递给执行引擎。 assign：作用于工作内存变量，把执行引擎执行过的值赋给工作内存中的变量。 store 存储：作用于工作内存变量，把工作内存中的变量值传给主内存，供 write 使用。  这些操作要满足一定的规则。</description>
    </item>
    
    <item>
      <title>aws.md</title>
      <link>https://zhenfeng-zhu.github.io/post/aws-md/</link>
      <pubDate>Thu, 22 Mar 2018 14:04:09 +0000</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/aws-md/</guid>
      <description>一些基础概念
EC2 云服务器，可以理解成虚拟机，新建一个实例，就是新建一个虚拟机并安装操作系统（Linux 或者 windows）。
VPC Virtual Private Cloud。可以理解成数据中心，机房。对于灾备或者双活需要的，可以创建两个 VPC。
子网 一个 VPC 里可以有多个子网。比如某机构的一个 VPC 可以办公网和生产网段，或者内网和外网。一般外网可以被访问，内网的话可以是数据库的服务器之类的。
IAM 角色 类似于用户，可以被分配权限。
安全组 控制连接到此 EC2 实例的流量，或者是控制对外暴露的端口。
CIDR CIDR 主要是一个按位的、基于前缀的，用于解释 IP 地址的标准。当用二进制表示这些地址时，它们有着在开头部分的一系列相同的位。
IPv4 的 CIDR 地址块的表示方法和 IPv4 地址的表示方法是相似的：由四部分组成的点分十进制地址，后跟一个斜线，最后是范围在 0 到 32 之间的一个数字：A.B.C.D/N。点分十进制的部分和 IPv4 地址一样是一个被分成四个八位位组的 32 位二进制数。斜线后面的数字就是前缀长度，也就是从左到右，被地址块里的地址所共享的位的数目。
十进制部分有时会被省略，因此，/20 就表示一个前缀长度是 20 的 CIDR 地址块。如果一个 IP 地址的前 N 位与一个 CIDR 地址块的前缀是相同的话，那么就说这个地址属于这个 CIDR 地址块，也可以说是与 CIDR 地址块的前缀匹配。所以，要理解 CIDR，就要把地址写成二进制的形式。</description>
    </item>
    
  </channel>
</rss>
