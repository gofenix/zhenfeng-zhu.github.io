<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>小议 async/await 和 coroutine | Awesome Fenix</title><meta name=keywords content><meta name=description content="Being happy doesn&rsquo;t mean that everything is perfect. It means that you decided to look beyond the imperfections.
 后端编程，涉及最多的就是并发。简单理解就是：
 并发是同时管理多个任务去执行，并行是针对多核处理器，同时执行多个任务。可以理解为一个是 manage，一个是 run。
 并发一般特指 IO，IO 是独立于 CPU 的设备，IO 设备通常远远慢于 CPU，所以我们引入了并发的概念，让 CPU 可以一次性发起多个 IO 操作而不用等待 IO 设备做完一个操作再做令一个。原理就是非阻塞操作+事件通知。
硬件底层上我其实不关心，主要就是在写程序上，如何简单的去写并发的代码。在语法层面上对并发做的比较好的，很适合做服务端，比如 go，比如 node，又比如某些函数式语言。我最近最近主要使用的是 node 和 kotlin。
那么在写并发代码的时候，就会时不时的想这样一个问题：
一个问题 当代码遇到一个“暂时不能完成”的流程时（例如建立一个 tcp 链接，可能需要 5ms 才能建立），他不想阻塞在这里睡眠，想暂时离开现场去干点别的事情（例如看看另外一个已经建立的链接是否可以收包了）。问题是：离开现场后，当你回来的时候，上下文还像你走的时候吗？
跳转离开，在任何语言里都有 2 种最基本的方法：1）从当前函数返回； 2）调用一个新的函数。 前者会把上下文中的局部变量和函数参数全部摧毁，除非他返回前把这些变量找个别的地方保存起来；后者则能保护住整个上下文的内存（除了协程切换后会摧毁一些寄存器），而且跳转回来也是常规方法：函数返回。
在写 node 的时候，基本上是无脑上 async/await。每次看到回调函数的时候，强迫症就犯了，总是想方设法将那个方法转成 promise，然后使用 await 获得结果。无脑尝试了 bluebird 和 node 的 util，虽然有些是很好用的，但是有的还是无法达到我预期的。靠着无脑的 async/await，实现了很多功能，代码写起来也是快的飞起，但是只顾着做业务而不深入思考的话，是一个不好的表现，所以我就停下来搜了很多 async/await 的东西，特别是从阮一峰老师那里收获了很多。"><meta name=author content="Fenix"><link rel=canonical href=https://zhenfeng-zhu.github.io/post/async/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zhenfeng-zhu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zhenfeng-zhu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zhenfeng-zhu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zhenfeng-zhu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zhenfeng-zhu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.98.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-216295420-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="小议 async/await 和 coroutine"><meta property="og:description" content="Being happy doesn&rsquo;t mean that everything is perfect. It means that you decided to look beyond the imperfections.
 后端编程，涉及最多的就是并发。简单理解就是：
 并发是同时管理多个任务去执行，并行是针对多核处理器，同时执行多个任务。可以理解为一个是 manage，一个是 run。
 并发一般特指 IO，IO 是独立于 CPU 的设备，IO 设备通常远远慢于 CPU，所以我们引入了并发的概念，让 CPU 可以一次性发起多个 IO 操作而不用等待 IO 设备做完一个操作再做令一个。原理就是非阻塞操作+事件通知。
硬件底层上我其实不关心，主要就是在写程序上，如何简单的去写并发的代码。在语法层面上对并发做的比较好的，很适合做服务端，比如 go，比如 node，又比如某些函数式语言。我最近最近主要使用的是 node 和 kotlin。
那么在写并发代码的时候，就会时不时的想这样一个问题：
一个问题 当代码遇到一个“暂时不能完成”的流程时（例如建立一个 tcp 链接，可能需要 5ms 才能建立），他不想阻塞在这里睡眠，想暂时离开现场去干点别的事情（例如看看另外一个已经建立的链接是否可以收包了）。问题是：离开现场后，当你回来的时候，上下文还像你走的时候吗？
跳转离开，在任何语言里都有 2 种最基本的方法：1）从当前函数返回； 2）调用一个新的函数。 前者会把上下文中的局部变量和函数参数全部摧毁，除非他返回前把这些变量找个别的地方保存起来；后者则能保护住整个上下文的内存（除了协程切换后会摧毁一些寄存器），而且跳转回来也是常规方法：函数返回。
在写 node 的时候，基本上是无脑上 async/await。每次看到回调函数的时候，强迫症就犯了，总是想方设法将那个方法转成 promise，然后使用 await 获得结果。无脑尝试了 bluebird 和 node 的 util，虽然有些是很好用的，但是有的还是无法达到我预期的。靠着无脑的 async/await，实现了很多功能，代码写起来也是快的飞起，但是只顾着做业务而不深入思考的话，是一个不好的表现，所以我就停下来搜了很多 async/await 的东西，特别是从阮一峰老师那里收获了很多。"><meta property="og:type" content="article"><meta property="og:url" content="https://zhenfeng-zhu.github.io/post/async/"><meta property="og:image" content="https://zhenfeng-zhu.github.io/papermod-cover.png"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-05-21T19:37:14+00:00"><meta property="article:modified_time" content="2018-05-21T19:37:14+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zhenfeng-zhu.github.io/papermod-cover.png"><meta name=twitter:title content="小议 async/await 和 coroutine"><meta name=twitter:description content="Being happy doesn&rsquo;t mean that everything is perfect. It means that you decided to look beyond the imperfections.
 后端编程，涉及最多的就是并发。简单理解就是：
 并发是同时管理多个任务去执行，并行是针对多核处理器，同时执行多个任务。可以理解为一个是 manage，一个是 run。
 并发一般特指 IO，IO 是独立于 CPU 的设备，IO 设备通常远远慢于 CPU，所以我们引入了并发的概念，让 CPU 可以一次性发起多个 IO 操作而不用等待 IO 设备做完一个操作再做令一个。原理就是非阻塞操作+事件通知。
硬件底层上我其实不关心，主要就是在写程序上，如何简单的去写并发的代码。在语法层面上对并发做的比较好的，很适合做服务端，比如 go，比如 node，又比如某些函数式语言。我最近最近主要使用的是 node 和 kotlin。
那么在写并发代码的时候，就会时不时的想这样一个问题：
一个问题 当代码遇到一个“暂时不能完成”的流程时（例如建立一个 tcp 链接，可能需要 5ms 才能建立），他不想阻塞在这里睡眠，想暂时离开现场去干点别的事情（例如看看另外一个已经建立的链接是否可以收包了）。问题是：离开现场后，当你回来的时候，上下文还像你走的时候吗？
跳转离开，在任何语言里都有 2 种最基本的方法：1）从当前函数返回； 2）调用一个新的函数。 前者会把上下文中的局部变量和函数参数全部摧毁，除非他返回前把这些变量找个别的地方保存起来；后者则能保护住整个上下文的内存（除了协程切换后会摧毁一些寄存器），而且跳转回来也是常规方法：函数返回。
在写 node 的时候，基本上是无脑上 async/await。每次看到回调函数的时候，强迫症就犯了，总是想方设法将那个方法转成 promise，然后使用 await 获得结果。无脑尝试了 bluebird 和 node 的 util，虽然有些是很好用的，但是有的还是无法达到我预期的。靠着无脑的 async/await，实现了很多功能，代码写起来也是快的飞起，但是只顾着做业务而不深入思考的话，是一个不好的表现，所以我就停下来搜了很多 async/await 的东西，特别是从阮一峰老师那里收获了很多。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://zhenfeng-zhu.github.io/post/"},{"@type":"ListItem","position":3,"name":"小议 async/await 和 coroutine","item":"https://zhenfeng-zhu.github.io/post/async/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"小议 async/await 和 coroutine","name":"小议 async\/await 和 coroutine","description":"Being happy doesn\u0026rsquo;t mean that everything is perfect. It means that you decided to look beyond the imperfections.\n 后端编程，涉及最多的就是并发。简单理解就是：\n 并发是同时管理多个任务去执行，并行是针对多核处理器，同时执行多个任务。可以理解为一个是 manage，一个是 run。\n 并发一般特指 IO，IO 是独立于 CPU 的设备，IO 设备通常远远慢于 CPU，所以我们引入了并发的概念，让 CPU 可以一次性发起多个 IO 操作而不用等待 IO 设备做完一个操作再做令一个。原理就是非阻塞操作+事件通知。\n硬件底层上我其实不关心，主要就是在写程序上，如何简单的去写并发的代码。在语法层面上对并发做的比较好的，很适合做服务端，比如 go，比如 node，又比如某些函数式语言。我最近最近主要使用的是 node 和 kotlin。\n那么在写并发代码的时候，就会时不时的想这样一个问题：\n一个问题 当代码遇到一个“暂时不能完成”的流程时（例如建立一个 tcp 链接，可能需要 5ms 才能建立），他不想阻塞在这里睡眠，想暂时离开现场去干点别的事情（例如看看另外一个已经建立的链接是否可以收包了）。问题是：离开现场后，当你回来的时候，上下文还像你走的时候吗？\n跳转离开，在任何语言里都有 2 种最基本的方法：1）从当前函数返回； 2）调用一个新的函数。 前者会把上下文中的局部变量和函数参数全部摧毁，除非他返回前把这些变量找个别的地方保存起来；后者则能保护住整个上下文的内存（除了协程切换后会摧毁一些寄存器），而且跳转回来也是常规方法：函数返回。\n在写 node 的时候，基本上是无脑上 async/await。每次看到回调函数的时候，强迫症就犯了，总是想方设法将那个方法转成 promise，然后使用 await 获得结果。无脑尝试了 bluebird 和 node 的 util，虽然有些是很好用的，但是有的还是无法达到我预期的。靠着无脑的 async/await，实现了很多功能，代码写起来也是快的飞起，但是只顾着做业务而不深入思考的话，是一个不好的表现，所以我就停下来搜了很多 async/await 的东西，特别是从阮一峰老师那里收获了很多。","keywords":[],"articleBody":" Being happy doesn’t mean that everything is perfect. It means that you decided to look beyond the imperfections.\n 后端编程，涉及最多的就是并发。简单理解就是：\n 并发是同时管理多个任务去执行，并行是针对多核处理器，同时执行多个任务。可以理解为一个是 manage，一个是 run。\n 并发一般特指 IO，IO 是独立于 CPU 的设备，IO 设备通常远远慢于 CPU，所以我们引入了并发的概念，让 CPU 可以一次性发起多个 IO 操作而不用等待 IO 设备做完一个操作再做令一个。原理就是非阻塞操作+事件通知。\n硬件底层上我其实不关心，主要就是在写程序上，如何简单的去写并发的代码。在语法层面上对并发做的比较好的，很适合做服务端，比如 go，比如 node，又比如某些函数式语言。我最近最近主要使用的是 node 和 kotlin。\n那么在写并发代码的时候，就会时不时的想这样一个问题：\n一个问题 当代码遇到一个“暂时不能完成”的流程时（例如建立一个 tcp 链接，可能需要 5ms 才能建立），他不想阻塞在这里睡眠，想暂时离开现场去干点别的事情（例如看看另外一个已经建立的链接是否可以收包了）。问题是：离开现场后，当你回来的时候，上下文还像你走的时候吗？\n跳转离开，在任何语言里都有 2 种最基本的方法：1）从当前函数返回； 2）调用一个新的函数。 前者会把上下文中的局部变量和函数参数全部摧毁，除非他返回前把这些变量找个别的地方保存起来；后者则能保护住整个上下文的内存（除了协程切换后会摧毁一些寄存器），而且跳转回来也是常规方法：函数返回。\n在写 node 的时候，基本上是无脑上 async/await。每次看到回调函数的时候，强迫症就犯了，总是想方设法将那个方法转成 promise，然后使用 await 获得结果。无脑尝试了 bluebird 和 node 的 util，虽然有些是很好用的，但是有的还是无法达到我预期的。靠着无脑的 async/await，实现了很多功能，代码写起来也是快的飞起，但是只顾着做业务而不深入思考的话，是一个不好的表现，所以我就停下来搜了很多 async/await 的东西，特别是从阮一峰老师那里收获了很多。\njs 异步编程 因为 js 是单线程，所以异步编程对 js 特别重要。\n实现异步主要有如下几种：\n  回调函数\ncallback，英语直译就是重新调用。\n所谓的回调函数就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，直接调用这个函数。\n回调本身没问题，但是就怕多重嵌套。\n  promise\npromise 是一种新的写法，把回调函数的横向嵌套，用 then 的形式改成纵向的加载。\n  协程\n协程就是比线程更小的单位。\n执行过程大致如下：\n第一步，协程 A 开始执行。\n第二步，协程 A 执行到一半，进入暂停，执行权转移到协程 B。\n第三步，（一段时间后）协程 B 交还执行权。\n第四步，协程 A 恢复执行。\n后面再展开说协程。\n  很明显，在 go 火起来之后，很多编程语言都在往协程上靠，因为协程很好的将异步的写法转化成了同步的写法，降低了心智负担。js 当然也不落后。\njs 的异步写法的演进\n  generator\nes6 增加了 generator 函数，就是协程的一种实现，最大特点就是使用 yield 关键字就是用来交出函数的执行权。\n1 2 3 4  function* gen(x){  var y = yield x + 2;  return y; }   不同于普通函数的地方在于调用 generator 函数的时候，不返回结果，而是会返回一个内部的指针。调用指针的 next 方法，会移动内部指针（即执行异步任务的第一段），遇到的 yield 语句就交出执行权，执行别的代码。下次再调用该函数指针的 next 方法，就继续执行到该函数的下一个 yield 语句。\n虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段），这样看来其实 generator 函数就是一个异步操作的容器，需要有一个触发它自动执行的机制。\n  Thunk 函数\n说到 thunk 函数，就得先了解一下参数的求值策略。\n1 2 3 4 5 6  let m=1; function f(x){  return x*2 }  f(m+5)     传值调用\n先计算出来 m+5 的值 6，然后再将值传给函数 f，即 6*2\n  传名调用\n把 m+5 传入到 f 中，在用到的时候再计算，即(x+5)*2。\n  传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。\n编译器的\"传名调用\"实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。\njs 是传值调用。他的 thunk 函数是将多参数的函数，替换成了单参数的版本，而且只接受回调函数作为参数。\n这样就可以很方便的实现了基于 thunk 函数的 generator 自动执行器。\n具体的实现和如何使用，参考http://www.ruanyifeng.com/blog/2015/05/thunk.html。\n  co 函数\nco 函数是基于 Promise 的 generator 函数的自动执行器。\n源代码只有几十行，tj 大神太强👍了。\nhttp://www.ruanyifeng.com/blog/2015/05/co.html\n  async/await\nasync 函数就是 generator 函数的语法糖。\nasync 函数自带执行器，无脑写 async 和 await 的时候就是，几乎所有的函数都写成了 async 函数，只要需要等待的方法，都用 await 去等待，这样就造成了很多无意义的等待。本来两个不相干的操作，如果每个都是用 await 等的话，就会很影响性能。\n多个请求并发执行的时候，尽量选用 Promise.all 方法。\n  理解了以上的演进过程，感觉自己终于摆脱了 java 思维的枪，对 node 终于入门了。然后，同步地写着 kotlin 项目，又陷入了泥潭中。\nFuture、RxJava、Actor 和 kotlin 协程 我理解的也不是很深，求科普。\n以前写 java 的时候，自己都是无脑用线程池，开多线程去处理，一般这种情况下不需要线程的结果。\n  future\n因为不能直接从别的线程中得到函数的返回值，所以 future 就出场了。\nFutrue 可以监视目标线程调用 call 的情况，当你调用 Future 的 get()方法以获得结果时，当前线程就开始阻塞，直接 call 方法结束返回结果。\nFuture 对象本身可以看作是一个显式的引用，一个对异步处理结果的引用。由于其异步性质，在创建之初，它所引用的对象可能还并不可用（比如尚在运算中，网络传输中或等待中）。这时，得到 Future 的程序流程如果并不急于使用 Future 所引用的对象，那么它可以做其它任何想做的事儿，当流程进行到需要 Future 背后引用的对象时，可能有两种情况：\n  希望能看到这个对象可用，并完成一些相关的后续流程。\n可以通过调用 Future.isDone()判断引用的对象是否就绪，并采取不同的处理。\n  如果实在不可用，也可以进入其它分支流程。\n只需调用 get()或 get(long timeout, TimeUnit unit)通过同步阻塞方式等待对象就绪。实际运行期是阻塞还是立即返回就取决于 get()的调用时机和对象就绪的先后了。\n    rxjava\n  actor\n  coroutine\n  跪求科普，等理解了再接着完善。\n浅谈协程 说到协程，就要说线程。\n线程是操作系统的用户态概念，线程本身也依赖中断来进行调度。早期的用户态 IO 并发处理是用 poll(select)模型去轮询 IO 状态，然后发起相应的 IO 操作，称之为事件响应式的异步模型，这种方式并不容易使用，所以又发展出了阻塞式 IO 操作，让逻辑挂起并等待 IO 完成，为了让阻塞式 IO 能够并发就必须依赖多线程或者多进程模型来实现。但是线程的开销是非常大的，当遇到大规模并发的时候多线程模型就无法胜任了。所以大规模并发时我们又退回去使用事件响应，epoll 在本质上还是 poll 模型，只是在算法上优化了实现，此时我们只用单线程就可以处理上万的并发请求了。\n直到多核 CPU 的出现，我们发现只用一个线程是无法发挥多核 CPU 的威力的，所以再次引入线程池来分摊 IO 操作的 CPU 消耗，甚至 CPU 的中断响应也可以由多个核来分摊执行，此时的线程数量是大致等于 CPU 的核心数而远小于并发 IO 数的（这时 CPU 能处理百万级的并发），线程的引入完全是为了负载均衡而跟并发没有关系。所以不管是用 select/epoll/iocp 在逻辑层都绕不开基于事件响应的异步操作，面对异步逻辑本身的复杂性，我们才引入了 async/await 以及 coroutine 来降低复杂性。\ncoroutine 是个很宽泛的概念，async/await 也属于 coroutine 的一种。\n而协程在实现模式上又分为：stackful coroutine 和 stackless coroutine。\n所谓 stackful 是指每个 coroutine 有独立的运行栈，比如 go 语言的每个 goroutine 会分配一个 4k 的内存来做为运行栈，切换 goroutine 的时候运行栈也会切换。stackful 的好处在于这种 coroutine 是完整的，coroutine 可以嵌套、循环。\n与 stackful 对应的是 stackless coroutine，比如 js 的 generator 函数，这类 coroutine 不需要分配单独的栈空间，coroutine 状态保存在闭包里，但缺点是功能比较弱，不能被嵌套调用，也没办法和异步函数配合使用进行控制流的调度，所以基本上没办法跟 stackful coroutine 做比较。保存这些状态的时候，有的语言就引入了状态机的模型来实现线程。\nasync/await 的出现，实现了基于 stackless coroutine 的完整 coroutine。在特性上已经非常接近 stackful coroutine 了，不但可以嵌套使用也可以支持 try catch。\n结语 发现自己挺无脑的，学会了一个东西，就无脑的去用，直到碰壁了才会去思考。\n","wordCount":"372","inLanguage":"en","datePublished":"2018-05-21T19:37:14Z","dateModified":"2018-05-21T19:37:14Z","author":{"@type":"Person","name":"Fenix"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhenfeng-zhu.github.io/post/async/"},"publisher":{"@type":"Organization","name":"Awesome Fenix","logo":{"@type":"ImageObject","url":"https://zhenfeng-zhu.github.io/favicon.ico"}}}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8502076734034112" crossorigin=anonymous></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8502076734034112" crossorigin=anonymous></script><header class=header><nav class=nav><div class=logo><a href=https://zhenfeng-zhu.github.io accesskey=h title="Awesome Fenix (Alt + H)">Awesome Fenix</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://zhenfeng-zhu.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zhenfeng-zhu.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zhenfeng-zhu.github.io/about title=About><span>About</span></a></li><li><a href=https://zhenfeng-zhu.github.io/search/ title=🔍><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zhenfeng-zhu.github.io>Home</a>&nbsp;»&nbsp;<a href=https://zhenfeng-zhu.github.io/post/>Posts</a></div><h1 class=post-title>小议 async/await 和 coroutine</h1><div class=post-meta><span title="2018-05-21 19:37:14 +0000 UTC">May 21, 2018</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix&nbsp;|&nbsp;<a href=https://github.com/zhenfeng-zhu/zhenfeng-zhu.github.io/tree/main/content/post/async.md rel="noopener noreferrer" target=_blank>修改本文章</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e4%b8%aa%e9%97%ae%e9%a2%98 aria-label=一个问题>一个问题</a></li><li><a href=#js-%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b aria-label="js 异步编程">js 异步编程</a></li><li><a href=#futurerxjavaactor-%e5%92%8c-kotlin-%e5%8d%8f%e7%a8%8b aria-label="Future、RxJava、Actor 和 kotlin 协程">Future、RxJava、Actor 和 kotlin 协程</a></li><li><a href=#%e6%b5%85%e8%b0%88%e5%8d%8f%e7%a8%8b aria-label=浅谈协程>浅谈协程</a></li><li><a href=#%e7%bb%93%e8%af%ad aria-label=结语>结语</a></li></ul></div></details></div><div class=post-content><blockquote><p>Being happy doesn&rsquo;t mean that everything is perfect. It means that you decided to look beyond the imperfections.</p></blockquote><p>后端编程，涉及最多的就是并发。简单理解就是：</p><blockquote><p>并发是同时管理多个任务去执行，并行是针对多核处理器，同时执行多个任务。可以理解为一个是 manage，一个是 run。</p></blockquote><p>并发一般特指 IO，IO 是独立于 CPU 的设备，IO 设备通常远远慢于 CPU，所以我们引入了并发的概念，让 CPU 可以一次性发起多个 IO 操作而不用等待 IO 设备做完一个操作再做令一个。原理就是非阻塞操作+事件通知。</p><p>硬件底层上我其实不关心，主要就是在写程序上，如何简单的去写并发的代码。在语法层面上对并发做的比较好的，很适合做服务端，比如 go，比如 node，又比如某些函数式语言。我最近最近主要使用的是 node 和 kotlin。</p><p>那么在写并发代码的时候，就会时不时的想这样一个问题：</p><h2 id=一个问题>一个问题<a hidden class=anchor aria-hidden=true href=#一个问题>#</a></h2><p>当代码遇到一个“暂时不能完成”的流程时（例如建立一个 tcp 链接，可能需要 5ms 才能建立），他不想阻塞在这里睡眠，想暂时离开现场去干点别的事情（例如看看另外一个已经建立的链接是否可以收包了）。问题是：离开现场后，当你回来的时候，上下文还像你走的时候吗？</p><p>跳转离开，在任何语言里都有 2 种最基本的方法：1）从当前函数返回； 2）调用一个新的函数。 前者会把上下文中的局部变量和函数参数全部摧毁，除非他返回前把这些变量找个别的地方保存起来；后者则能保护住整个上下文的内存（除了协程切换后会摧毁一些寄存器），而且跳转回来也是常规方法：函数返回。</p><p>在写 node 的时候，基本上是无脑上 async/await。每次看到回调函数的时候，强迫症就犯了，总是想方设法将那个方法转成 promise，然后使用 await 获得结果。无脑尝试了 bluebird 和 node 的 util，虽然有些是很好用的，但是有的还是无法达到我预期的。靠着无脑的 async/await，实现了很多功能，代码写起来也是快的飞起，但是只顾着做业务而不深入思考的话，是一个不好的表现，所以我就停下来搜了很多 async/await 的东西，特别是从阮一峰老师那里收获了很多。</p><h2 id=js-异步编程>js 异步编程<a hidden class=anchor aria-hidden=true href=#js-异步编程>#</a></h2><p>因为 js 是单线程，所以异步编程对 js 特别重要。</p><p>实现异步主要有如下几种：</p><ul><li><p>回调函数</p><p>callback，英语直译就是重新调用。</p><p>所谓的回调函数就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，直接调用这个函数。</p><p>回调本身没问题，但是就怕多重嵌套。</p></li><li><p>promise</p><p>promise 是一种新的写法，把回调函数的横向嵌套，用 then 的形式改成纵向的加载。</p></li><li><p>协程</p><p>协程就是比线程更小的单位。</p><p>执行过程大致如下：</p><p>第一步，协程 A 开始执行。</p><p>第二步，协程 A 执行到一半，进入暂停，执行权转移到协程 B。</p><p>第三步，（一段时间后）协程 B 交还执行权。</p><p>第四步，协程 A 恢复执行。</p><p>后面再展开说协程。</p></li></ul><p>很明显，在 go 火起来之后，很多编程语言都在往协程上靠，因为协程很好的将异步的写法转化成了同步的写法，降低了心智负担。js 当然也不落后。</p><p>js 的异步写法的演进</p><ul><li><p>generator</p><p>es6 增加了 generator 函数，就是协程的一种实现，最大特点就是使用 yield 关键字就是用来交出函数的执行权。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-0-1><a style=outline:none;text-decoration:none;color:inherit href=#hl-0-1>1</a>
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-0-2><a style=outline:none;text-decoration:none;color:inherit href=#hl-0-2>2</a>
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-0-3><a style=outline:none;text-decoration:none;color:inherit href=#hl-0-3>3</a>
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-0-4><a style=outline:none;text-decoration:none;color:inherit href=#hl-0-4>4</a>
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>function* gen(x){
</span></span><span style=display:flex><span>  var y = yield x + 2;
</span></span><span style=display:flex><span>  return y;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>不同于普通函数的地方在于调用 generator 函数的时候，不返回结果，而是会返回一个内部的指针。调用指针的 next 方法，会移动内部指针（即执行异步任务的第一段），遇到的 yield 语句就交出执行权，执行别的代码。下次再调用该函数指针的 next 方法，就继续执行到该函数的下一个 yield 语句。</p><p>虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段），这样看来其实 generator 函数就是一个异步操作的容器，需要有一个触发它自动执行的机制。</p></li><li><p>Thunk 函数</p><p>说到 thunk 函数，就得先了解一下参数的求值策略。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-1-1><a style=outline:none;text-decoration:none;color:inherit href=#hl-1-1>1</a>
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-1-2><a style=outline:none;text-decoration:none;color:inherit href=#hl-1-2>2</a>
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-1-3><a style=outline:none;text-decoration:none;color:inherit href=#hl-1-3>3</a>
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-1-4><a style=outline:none;text-decoration:none;color:inherit href=#hl-1-4>4</a>
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-1-5><a style=outline:none;text-decoration:none;color:inherit href=#hl-1-5>5</a>
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-1-6><a style=outline:none;text-decoration:none;color:inherit href=#hl-1-6>6</a>
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>let m=1;
</span></span><span style=display:flex><span>function f(x){
</span></span><span style=display:flex><span>    return x*2
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>f(m+5)
</span></span></code></pre></td></tr></table></div></div><ul><li><p>传值调用</p><p>先计算出来 m+5 的值 6，然后再将值传给函数 f，即 6*2</p></li><li><p>传名调用</p><p>把 m+5 传入到 f 中，在用到的时候再计算，即(x+5)*2。</p></li></ul><p>传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p><p>编译器的"传名调用"实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。</p><p>js 是传值调用。他的 thunk 函数是将多参数的函数，替换成了单参数的版本，而且只接受回调函数作为参数。</p><p>这样就可以很方便的实现了基于 thunk 函数的 generator 自动执行器。</p><p>具体的实现和如何使用，参考<a href=http://www.ruanyifeng.com/blog/2015/05/thunk.html>http://www.ruanyifeng.com/blog/2015/05/thunk.html</a>。</p></li><li><p>co 函数</p><p>co 函数是基于 Promise 的 generator 函数的自动执行器。</p><p>源代码只有几十行，tj 大神太强👍了。</p><p><a href=http://www.ruanyifeng.com/blog/2015/05/co.html>http://www.ruanyifeng.com/blog/2015/05/co.html</a></p></li><li><p>async/await</p><p>async 函数就是 generator 函数的语法糖。</p><p>async 函数自带执行器，无脑写 async 和 await 的时候就是，几乎所有的函数都写成了 async 函数，只要需要等待的方法，都用 await 去等待，这样就造成了很多无意义的等待。本来两个不相干的操作，如果每个都是用 await 等的话，就会很影响性能。</p><p>多个请求并发执行的时候，尽量选用 Promise.all 方法。</p></li></ul><p>理解了以上的演进过程，感觉自己终于摆脱了 java 思维的枪，对 node 终于入门了。然后，同步地写着 kotlin 项目，又陷入了泥潭中。</p><h2 id=futurerxjavaactor-和-kotlin-协程>Future、RxJava、Actor 和 kotlin 协程<a hidden class=anchor aria-hidden=true href=#futurerxjavaactor-和-kotlin-协程>#</a></h2><p>我理解的也不是很深，求科普。</p><p>以前写 java 的时候，自己都是无脑用线程池，开多线程去处理，一般这种情况下不需要线程的结果。</p><ul><li><p>future</p><p>因为不能直接从别的线程中得到函数的返回值，所以 future 就出场了。</p><p>Futrue 可以监视目标线程调用 call 的情况，当你调用 Future 的 get()方法以获得结果时，当前线程就开始阻塞，直接 call 方法结束返回结果。</p><p>Future 对象本身可以看作是一个显式的引用，一个对异步处理结果的引用。由于其异步性质，在创建之初，它所引用的对象可能还并不可用（比如尚在运算中，网络传输中或等待中）。这时，得到 Future 的程序流程如果并不急于使用 Future 所引用的对象，那么它可以做其它任何想做的事儿，当流程进行到需要 Future 背后引用的对象时，可能有两种情况：</p><ul><li><p>希望能看到这个对象可用，并完成一些相关的后续流程。</p><p>可以通过调用 Future.isDone()判断引用的对象是否就绪，并采取不同的处理。</p></li><li><p>如果实在不可用，也可以进入其它分支流程。</p><p>只需调用 get()或 get(long timeout, TimeUnit unit)通过同步阻塞方式等待对象就绪。实际运行期是阻塞还是立即返回就取决于 get()的调用时机和对象就绪的先后了。</p></li></ul></li><li><p>rxjava</p></li><li><p>actor</p></li><li><p>coroutine</p></li></ul><p>跪求科普，等理解了再接着完善。</p><h2 id=浅谈协程>浅谈协程<a hidden class=anchor aria-hidden=true href=#浅谈协程>#</a></h2><p>说到协程，就要说线程。</p><p>线程是操作系统的用户态概念，线程本身也依赖中断来进行调度。早期的用户态 IO 并发处理是用 poll(select)模型去轮询 IO 状态，然后发起相应的 IO 操作，称之为事件响应式的异步模型，这种方式并不容易使用，所以又发展出了阻塞式 IO 操作，让逻辑挂起并等待 IO 完成，为了让阻塞式 IO 能够并发就必须依赖多线程或者多进程模型来实现。但是线程的开销是非常大的，当遇到大规模并发的时候多线程模型就无法胜任了。所以大规模并发时我们又退回去使用事件响应，epoll 在本质上还是 poll 模型，只是在算法上优化了实现，此时我们只用单线程就可以处理上万的并发请求了。</p><p>直到多核 CPU 的出现，我们发现只用一个线程是无法发挥多核 CPU 的威力的，所以再次引入线程池来分摊 IO 操作的 CPU 消耗，甚至 CPU 的中断响应也可以由多个核来分摊执行，此时的线程数量是大致等于 CPU 的核心数而远小于并发 IO 数的（这时 CPU 能处理百万级的并发），线程的引入完全是为了负载均衡而跟并发没有关系。所以不管是用 select/epoll/iocp 在逻辑层都绕不开基于事件响应的异步操作，面对异步逻辑本身的复杂性，我们才引入了 async/await 以及 coroutine 来降低复杂性。</p><p>coroutine 是个很宽泛的概念，async/await 也属于 coroutine 的一种。</p><p>而协程在实现模式上又分为：stackful coroutine 和 stackless coroutine。</p><p>所谓 stackful 是指每个 coroutine 有独立的运行栈，比如 go 语言的每个 goroutine 会分配一个 4k 的内存来做为运行栈，切换 goroutine 的时候运行栈也会切换。stackful 的好处在于这种 coroutine 是完整的，coroutine 可以嵌套、循环。</p><p>与 stackful 对应的是 stackless coroutine，比如 js 的 generator 函数，这类 coroutine 不需要分配单独的栈空间，coroutine 状态保存在闭包里，但缺点是功能比较弱，不能被嵌套调用，也没办法和异步函数配合使用进行控制流的调度，所以基本上没办法跟 stackful coroutine 做比较。保存这些状态的时候，有的语言就引入了状态机的模型来实现线程。</p><p>async/await 的出现，实现了基于 stackless coroutine 的完整 coroutine。在特性上已经非常接近 stackful coroutine 了，不但可以嵌套使用也可以支持 try catch。</p><h2 id=结语>结语<a hidden class=anchor aria-hidden=true href=#结语>#</a></h2><p>发现自己挺无脑的，学会了一个东西，就无脑的去用，直到碰壁了才会去思考。</p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://zhenfeng-zhu.github.io/post/vertx-kotlin-coroutine/><span class=title>« Prev Page</span><br><span>译：vertx-kotlin-coroutine</span></a>
<a class=next href=https://zhenfeng-zhu.github.io/post/elasticsearch/><span class=title>Next Page »</span><br><span>elasticsearch</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 小议 async/await 和 coroutine on twitter" href="https://twitter.com/intent/tweet/?text=%e5%b0%8f%e8%ae%ae%20async%2fawait%20%e5%92%8c%20coroutine&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fpost%2fasync%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 小议 async/await 和 coroutine on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fpost%2fasync%2f&title=%e5%b0%8f%e8%ae%ae%20async%2fawait%20%e5%92%8c%20coroutine&summary=%e5%b0%8f%e8%ae%ae%20async%2fawait%20%e5%92%8c%20coroutine&source=https%3a%2f%2fzhenfeng-zhu.github.io%2fpost%2fasync%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 小议 async/await 和 coroutine on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzhenfeng-zhu.github.io%2fpost%2fasync%2f&title=%e5%b0%8f%e8%ae%ae%20async%2fawait%20%e5%92%8c%20coroutine"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 小议 async/await 和 coroutine on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzhenfeng-zhu.github.io%2fpost%2fasync%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 小议 async/await 和 coroutine on whatsapp" href="https://api.whatsapp.com/send?text=%e5%b0%8f%e8%ae%ae%20async%2fawait%20%e5%92%8c%20coroutine%20-%20https%3a%2f%2fzhenfeng-zhu.github.io%2fpost%2fasync%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 小议 async/await 和 coroutine on telegram" href="https://telegram.me/share/url?text=%e5%b0%8f%e8%ae%ae%20async%2fawait%20%e5%92%8c%20coroutine&url=https%3a%2f%2fzhenfeng-zhu.github.io%2fpost%2fasync%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=zhenfeng-zhu/zhenfeng-zhu.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://zhenfeng-zhu.github.io>Awesome Fenix</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>