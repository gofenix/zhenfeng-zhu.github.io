<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>clojure on Awesome Fenix</title>
    <link>https://zhenfeng-zhu.github.io/tags/clojure/</link>
    <description>Recent content in clojure on Awesome Fenix</description>
    <image>
      <url>https://zhenfeng-zhu.github.io/papermod-cover.png</url>
      <link>https://zhenfeng-zhu.github.io/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 15 Jan 2022 21:45:17 +0800</lastBuildDate><atom:link href="https://zhenfeng-zhu.github.io/tags/clojure/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Farewell 永别了</title>
      <link>https://zhenfeng-zhu.github.io/post/farewell/</link>
      <pubDate>Sat, 15 Jan 2022 21:45:17 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/farewell/</guid>
      <description>永别了 正如 Semisonic 在 90 年代的热门歌曲 &amp;ldquo;Closing Time &amp;ldquo;所告诉我们的那样，每一个新的开始都来自于其他一些开始的结束。恭喜你，高贵的读者，完成了这次 Clojure 之旅。我希望你发现它是有价值的，我也希望你期待着更多的东西！相信我，还有更多的东西等着你。
相信我，还有很多东西。我最喜欢 Clojure 的一点是，它有一个完整的世界可以探索。逻辑编程、解析器、类型系统……只要你能说出计算机科学的一个有趣领域，你就可以用 Clojure 来研究它。我把我对下一步要去哪里的建议留给你。
如果你想对 Clojure 生态系统有一个广泛的了解，请查看The Clojure Toolbox，它列出了数百个 Clojure 项目，并按照它们所解决的问题进行组织。
如果你对网络编程感兴趣，一个很好的开始是 Luminus 框架（Luminus - 一个 Clojure 网络框架）。它的文档非常好，你很快就会有一个网站在运行。
要想了解 Clojure 的最新动态，Eric Normand 的 Clojure Gazzette 是一个很好的资源（注册每周功能编程通讯）。当然，还有 Clojure 邮件列表（https://groups.google.com/forum/#!forum/clojure）和 Clojure subreddit 也是一个有用的、友好的地方（http://www.reddit.com/r/clojure）。
如果 Twitter 是你选择的社交媒体，那么@swannodette (David Nolen), @gigasquid (Carin Meier), @puredanger (Alex Miller), @ztellman (Zach Tellman), @bbatsov (Bozidar Batsov) 和 @stuartsierra (Stuart Sierra) 是你的小红帽。你也可以关注我，@nonrecursive!
再见了，小茶杯，祝你 Clojuring 愉快</description>
    </item>
    
    <item>
      <title>AppendixB 花哨的 Boot</title>
      <link>https://zhenfeng-zhu.github.io/post/appendixb/</link>
      <pubDate>Sat, 15 Jan 2022 21:41:09 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/appendixb/</guid>
      <description>Boot，花哨的 Clojure 构建框架 Boot 是 Leiningen 的替代品，提供同样的功能。Leiningen 更受欢迎（截至 2015 年夏天），但我个人喜欢用 Boot 工作，因为它更容易扩展。本附录解释了 Boot 的基本概念，并指导你编写你的第一个 Boot 任务。如果你对使用 Boot 构建项目感兴趣，请查看它的 GitHub README（GitHub - boot-clj/boot: Build tooling for Clojure.）和它的 wiki（Home - boot-clj/boot Wiki - GitHub）。
注意 截至本文写作时，Boot 对 Windows 的支持有限。Boot 团队欢迎大家的贡献!
Boot 的抽象 Boot 由 Micha Niskin 和 Alan Dipert 创建，是对 Clojure 工具领域的一个有趣而强大的补充。从表面上看，它是构建 Clojure 应用程序和从命令行运行 Clojure 任务的一种便捷方式。深入研究一下，你会发现 Boot 就像 Git 和 Unix 的爱情结晶，它提供的抽象使你在操作系统和应用程序的交叉点上编写代码时更加愉快。
Unix 提供了我们都很熟悉的抽象，以至于我们认为它们是理所当然的。(偶尔带你的电脑去吃一顿好的餐厅会死吗？) 进程抽象让你把程序推理成独立的逻辑单元，可以通过 STDIN 和 STDOUT 文件描述符轻松地组成一个流处理管道。这些抽象使某些类型的操作，如文本处理，变得非常直接。
同样，Boot 也提供了一些抽象，使得独立的操作很容易被组合成构建工具最终要做的那种复杂、协调的操作，比如将 ClojureScript 转换为 JavaScript。 Boot 的任务抽象让你可以轻松地定义逻辑单元，通过文件集合进行通信。文件集合抽象可以跟踪不断变化的构建环境，并提供一个定义明确、可靠的任务协调方法。</description>
    </item>
    
    <item>
      <title>AppendixA 用 Leiningen 构建和开发</title>
      <link>https://zhenfeng-zhu.github.io/post/appendixa/</link>
      <pubDate>Sat, 15 Jan 2022 21:39:36 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/appendixa/</guid>
      <description>用 Leiningen 构建和开发 用任何语言编写软件都需要生成工件，即可执行文件或库包，用于部署或共享。它还涉及到管理依赖工件，也称为依赖，以确保它们被加载到你正在构建的项目中。Clojurists 中最流行的管理工件的工具是 Leiningen，本附录将告诉你如何使用它。你还将学习如何使用 Leiningen 来完全增强你的开发经验，使用插件。
Artifact Ecosystem 因为 Clojure 托管在 Java 虚拟机（JVM）上，所以 Clojure 的工件是以 JAR 文件的形式分发的（在第 12 章有介绍）。Java 地已经有一个处理 JAR 文件的完整的工件生态系统，Clojure 也使用它。神器生态系统并不是一个官方的编程术语；我用它来指代用于识别和分发神器的一套工具、资源和惯例。Java 的生态系统是围绕着 Maven 构建工具发展起来的，由于 Clojure 使用这个生态系统，你会经常看到对 Maven 的引用。Maven 是一个巨大的工具，可以执行各种古怪的项目管理任务。值得庆幸的是，你不需要获得 Maven 学的博士学位就能成为一名有效的 Clojurist。你需要知道的唯一特征是，Maven 规定了一种识别 Clojure 项目所遵守的工件的模式，它还规定了如何在 Maven 仓库中托管这些工件，Maven *仓库只是存储工件以供分发的服务器。
Identification Maven 工件需要一个组 ID，一个工件 ID，以及一个版本。你可以在project.clj文件中为你的项目指定这些。以下是你在第一章创建的clojure-noob项目的project.clj第一行的内容。
1  (defproject clojure-noob &amp;#34;0.1.0-SNAPSHOT&amp;#34;   clojure-noob是你项目的组 ID 和工件 ID，&amp;quot;0.1.0-SNAPSHOT&amp;quot;是其版本。一般来说，版本是永久性的；如果你将一个版本为 0.1.0 的工件部署到存储库，你不能对该工件进行修改并使用相同的版本号进行部署。您需要改变版本号。(许多程序员喜欢 Semantic Versioning 系统，您可以在*Semantic Versioning 2.0.0 | Semantic Versioning.*中阅读到这一系统。） 如果你想表明该版本是一个正在进行的工作，并且你计划不断地更新它，你可以在你的版本号后面加上-SNAPSHOT。
如果你想让你的组 ID 与你的工件 ID 不同，你可以用斜线将两者分开，像这样。</description>
    </item>
    
    <item>
      <title>Chapter13 抽象</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter13/</link>
      <pubDate>Sat, 15 Jan 2022 21:29:04 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter13/</guid>
      <description>用 Multimethods、协议和记录创建和扩展抽象概念 花一分钟思考一下，作为大自然的顶级产品之一：人类是多么伟大。作为一个人类，你可以在社交媒体上闲聊，玩龙与地下城，戴帽子。也许更重要的是，你可以用抽象的概念来思考和交流。
抽象思考的能力确实是人类最好的特征之一。它可以让你规避你的认知极限，将不同的细节捆绑在一起，形成一个整齐的概念包，让你可以在工作记忆中持有。你不需要去想 &amp;ldquo;可挤压的红球鼻子装饰 &amp;ldquo;这种笨重的想法，而只需要 &amp;ldquo;小丑鼻子 &amp;ldquo;这个概念。
在 Clojure 中，一个抽象是一个操作的集合，而数据类型实现抽象。例如，seq 抽象由 &amp;ldquo;first &amp;ldquo;和 &amp;ldquo;rest &amp;ldquo;等操作组成，而 Vector 数据类型是该抽象的实现；它对所有 seq 操作做出响应。像[:seltzer :water]这样的特定 Vector 是该数据类型的*实例。
编程语言越是让你以抽象的方式思考和写作，你的生产力就越高。例如，如果你知道一个数据结构是 seq 抽象的一个实例，你就可以立即调用一个大的知识网，了解哪些函数可以与数据结构一起工作。因此，你会花时间去实际使用这个数据结构，而不是不断地去查找关于它如何工作的文档。同样地，如果你扩展一个数据结构，使其与 seq 抽象一起工作，你就可以在上面使用大量的 seq 函数库。
在第四章中，你了解到 Clojure 是以抽象的方式编写的。这很强大，因为在 Clojure 中，你可以专注于你可以用数据结构实际做的事情，而不用担心实现的细枝末节。本章向你介绍了创建和实现你自己的抽象的世界。你将学习 Multimethods、协议和记录的基础知识。
多态 我们在 Clojure 中实现抽象的主要方式是将一个操作名称与一个以上的算法联系起来。这种技术被称为多态。例如，在列表上执行 &amp;ldquo;conj &amp;ldquo;的算法与 Vector 的算法不同，但我们把它们统一在同一个名字下，以表明它们实现了同一个概念，即向这个数据结构添加一个元素。
因为 Clojure 的许多数据类型都依赖于 Java 的标准库，所以本章中使用了一点 Java。例如，Clojure 的字符串只是 Java 的字符串，是 Java 类java.lang.String的实例。要在 Java 中定义你自己的数据类型，你要使用类。Clojure 提供了额外的类型结构。 记录和类型。本书只涉及记录。
在我们学习记录之前，让我们看看 Multimethods，这是我们定义多态行为的第一个工具。
Multimethods Multimethods为你提供了一种直接的、灵活的方法，将多态引入你的代码中。使用 Multimethods，你可以通过定义一个调度函数将一个名字与多个实现联系起来，该函数产生调度值，用来决定使用哪个方法。调度函数就像餐厅里的主人。主人会问你一些问题，比如 &amp;ldquo;你有预订吗？&amp;ldquo;和 &amp;ldquo;聚会人数？&amp;quot;，然后给你安排相应的座位。同样，当你调用一个 Multimethods 时，调度函数将询问参数，并将它们发送到正确的方法，正如这个例子所显示的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  (ns were-creatures) ➊ (defmulti full-moon-behavior (fn [were-creature] (:were-type were-creature))) ➋ (defmethod full-moon-behavior :wolf  [were-creature]  (str (:name were-creature) &amp;#34; will howl and murder&amp;#34;)) ➌ (defmethod full-moon-behavior :simmons  [were-creature]  (str (:name were-creature) &amp;#34; will encourage people and sweat to the oldies&amp;#34;))  (full-moon-behavior {:were-type :wolf ➍ :name &amp;#34;Rachel from next door&amp;#34;}) ; =&amp;gt; &amp;#34;Rachel from next door will howl and murder&amp;#34;  (full-moon-behavior {:name &amp;#34;Andy the baker&amp;#34; ➎ :were-type :simmons}) ; =&amp;gt; &amp;#34;Andy the baker will encourage people and sweat to the oldies&amp;#34;   这个 Multimethods 显示了你如何定义不同种类的狼人生物的满月行为。大家都知道狼人变成了狼，到处嚎叫着杀人。一种不太知名的狼人，即狼-西蒙斯，变成理查德-西蒙斯，烫着头发，到处跑，鼓励人们做最好的自己，为老人们流汗。你不想被这两种生物咬到，否则你就会变成它们。</description>
    </item>
    
    <item>
      <title>Chapter12 与 Java 的互操作</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter12/</link>
      <pubDate>Sat, 15 Jan 2022 20:55:18 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter12/</guid>
      <description>与 JVM 一起工作 在每个 Clojurist 的生命中都会有这么一天，她必须从纯函数和不可变数据结构的庇护所冒险进入野蛮的 Java 大陆。这段艰难的旅程是必要的，因为 Clojure 是在 Java 虚拟机（JVM）上托管的，这赋予了它三个基本特性。
赋予它三个基本特征。首先，你运行 Clojure 应用程序的方式与你运行 Java 应用程序的方式相同。第二，你需要使用 Java 对象来实现核心功能，如读取文件和处理日期。第三，Java 有一个庞大的有用库的生态系统，你需要对 Java 有一定的了解才能使用它们。
这样一来，Clojure 就有点像一个乌托邦社区，被放置在一个乌托邦国家的中间。显然，你更愿意与其他乌托邦人互动，但偶尔你也需要与当地人交谈，以便完成工作。
这一章就像一本短语书和 Java 国家的文化介绍之间的交叉。你将了解什么是 JVM，它是如何运行程序的，以及如何为它编译程序。本章还将为你简要介绍常用的 Java 类和方法，并解释如何使用 Clojure 与它们互动。你将学会如何思考和理解 Java，以便将任何 Java 库纳入你的 Clojure 程序中。
要运行本章的例子，你需要在电脑上安装 1.6 或更高版本的 Java 开发工具包（JDK）。你可以通过在终端运行javac -version来检查。你应该看到类似 &amp;ldquo;java 1.8.0_40 &amp;ldquo;的内容；如果没有，请访问http://www.oracle.com/，下载最新的 JDK。
JVM 开发人员用 JVM 这个词来指代一些不同的东西。你会听到他们说，&amp;ldquo;Clojure 在the JVM 上运行&amp;rdquo;，你也会听到，&amp;ldquo;Clojure 程序在a JVM 中运行&amp;rdquo;。在第一种情况下，JVM 指的是一个抽象概念&amp;ndash;Java 虚拟机的一般模型。在第二种情况下，它指的是一个进程&amp;ndash;一个正在运行的程序的实例。我们将专注于 JVM 模型，但当我们谈论运行中的 JVM 进程时，我将指出来。
为了理解 JVM，让我们回头看看普通的计算机是如何工作的。在计算机心脏的深处是它的 CPU，而 CPU 的工作是执行像加和无符号乘法这样的操作。你可能听说过程序员将这些指令编码在打卡机上、灯泡里、乌龟壳的神圣缝隙里，或者什么的，但现在这些操作在汇编语言中用 ADD 和 MUL 这样的记忆符号表示。CPU 架构（X86、ARMv7，等等）决定了哪些操作可以作为该架构的指令集的一部分。</description>
    </item>
    
    <item>
      <title>Chapter11 core.async</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter11/</link>
      <pubDate>Sat, 15 Jan 2022 12:56:01 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter11/</guid>
      <description>用 core.async 掌握并发进程 有一天，当你走在大街上时，你会惊讶、好奇，并有点厌恶地发现一台热狗自动贩卖机。你的头皮被有罪的好奇心刺痛，你会忍不住掏出三块钱，看看这个装置是否真的能工作。在 &amp;ldquo;咔嚓 &amp;ldquo;一声接受了你的钱后，它弹出了一个新鲜的热狗，包括面包和所有的东西。
自动售货机表现出简单的行为：当它收到钱时，它会放出一个热狗，然后为下一次购买做准备。当它的热狗用完时，它就会停止。我们周围的热狗自动售货机以不同的面貌出现，它们是独立的实体，同时对世界上的事件作出反应。你最喜欢的咖啡店的浓缩咖啡机，你小时候喜欢的宠物仓鼠&amp;ndash;所有的东西都可以被分解成一组行为，这些行为遵循一般的形式 &amp;ldquo;当x发生时，做y&amp;quot;。甚至我们写的程序也只是美化的热狗贩卖机，每一个都是独立的进程，等待着下一个事件的发生，无论是击键、超时，还是套接字上的数据到达。
Clojure 的 core.async 库允许你在一个程序中创建多个独立进程。 本章描述了思考这种编程风格的有用模型，以及你在实际编写代码时需要了解的实际细节。你将学习如何使用通道在由 go 块和thread创建的独立进程之间进行通信；了解一些关于 Clojure 如何通过停放和阻塞有效地管理线程；如何使用alts!!；以及一种更直接的创建队列的方法。最后，你将学习如何用进程管道来踢回调的屁股。
进程的入门 core.async 的核心是*进程，一个并发运行的逻辑单元，对事件做出反应。进程对应于我们对现实世界的心理模型：实体之间的互动和响应是独立的，没有某种中央控制机制的牵制。你把钱放进机器里，就会有一个热狗出来，所有这些都不需要光照派或老大哥来策划整个事情。这与你迄今为止一直在探索的并发性观点不同，在那里，你定义的任务要么只是控制主线程的扩展（例如，用pmap实现数据并行），要么是你没有兴趣与之交流的任务（如用future创建的一次性任务）。
把自动售货机看成是一个进程可能很奇怪：自动售货机是名词和事物，而进程是动词和行为。为了获得正确的思维方式，可以尝试将现实世界的物体定义为其事件驱动的行为的总和。当一粒种子被浇水时，它就会发芽；当母亲看着她的新生儿时，她就会感受到爱；而当你观看《星战》第一集时，你会充满愤怒和绝望。如果你想变得超级哲学，可以考虑是否有可能将每个事物的本质定义为它所识别的事件的集合，以及它如何做出反应。现实是否只是热狗售卖机的组成？
总之，我说得够多了! 让我们通过创建一些简单的过程，从理论上走向具体。首先，用 &amp;ldquo;lein new app playsync &amp;ldquo;创建一个新的 Leiningen 项目，名为playsync。然后，打开project.clj文件，将 core.async 添加到:dependenciesVector 中，使其内容如下。
1 2  [[org.clojure/clojure &amp;#34;1.9.0&amp;#34;] [org.clojure/core.async &amp;#34;0.1.346.0-17112a-alpha&amp;#34;]]   注意 自从我写完这篇文章后，core.async 的版本有可能有所进步。关于最新的版本，请查看 core.async 的 GitHub 项目页面。但为了这些练习的目的，请使用这里列出的版本。
接下来，打开src/playsync/core.clj，使其看起来像这样。
1 2 3 4 5  (ns playsync.core  (:require [clojure.core.async  :as a  :refer [&amp;gt;! &amp;lt;! &amp;gt;!! &amp;lt;!! go chan buffer close!</description>
    </item>
    
    <item>
      <title>Chapter10 形而上学</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter10/</link>
      <pubDate>Sat, 15 Jan 2022 12:42:26 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter10/</guid>
      <description>Clojure Metaphysics: 原子、Refs、Vars 和拥抱僵尸 三个并发性的小妖精都是从同一个邪恶的坑里生出来的：对可变状态的共享访问。你可以在第九章的引用单元讨论中看到这一点。当两个线程对引用单元进行不协调的更改时，结果是不可预测的。
Rich Hickey 设计 Clojure 是为了专门解决共享访问易变状态所产生的问题。事实上，Clojure 体现了一种非常清晰的状态概念，使其在本质上比大多数流行的编程语言更安全。它是安全的，一直到它的meta-freakin-physics。
在本章中，你将了解 Clojure 的底层形而上学，与典型的面向对象（OO）语言的形而上学相比较。学习这种哲学将使你准备好处理 Clojure 剩下的并发工具，atom、ref和var引用类型。(Clojure 还有一个额外的引用类型，agents，本书没有涉及。) 这些类型中的每一个都能让你安全地同时执行状态修改操作。你还会学到一些简单的方法，使你的程序更有效率，而不需要引入状态。
形而上学试图用最广泛的术语来回答两个基本问题。
 那里有什么？ 它是什么样子的？  为了引出 Clojure 和 OO 语言之间的差异，我将解释两种不同的拥抱僵尸的建模方式。与普通的僵尸不同，拥抱僵尸并不想要吞噬你的大脑。它只想用勺子舀你，也许还想闻闻你的脖子。这使得它的不死、摇晃、腐烂的状态更加悲惨。你怎么能试图杀死只想要爱的东西呢？谁是这里真正的怪物？
面向对象的形而上学 OO 形而上学将拥抱僵尸视为存在于世界上的一个对象。这个对象的属性可能会随着时间的推移而改变，但它仍然被当作一个单一的、不变的对象。如果这看起来是一个完全明显的、没有争议的僵尸形而上学的方法，那么你可能没有在哲学入门课上花几个小时来争论一把椅子的存在意味着什么，以及什么真正使它首先成为一把椅子。
棘手的部分是，拥抱的僵尸总是在变化。它的身体慢慢恶化。随着时间的推移，它对拥抱的不灭渴望越来越强烈。在 OO 术语中，我们会说拥抱僵尸是一个具有可改变状态的对象，它的状态是不断波动的。但是不管这个僵尸有多大的变化，我们仍然把它认定为同一个僵尸。下面是你如何在 Ruby 中对抱团僵尸进行建模和交互。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class CuddleZombie  # attr_accessor is just a shorthand way for creating getters and  # setters for the listed instance variables  attr_accessor :cuddle_hunger_level, :percent_deteriorated   def initialize(cuddle_hunger_level = 1, percent_deteriorated = 0)  self.</description>
    </item>
    
    <item>
      <title>Chapter9 并发的艺术</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter9/</link>
      <pubDate>Sat, 15 Jan 2022 12:30:14 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter9/</guid>
      <description>并发和并行编程的神圣艺术 如果我是一个庄园的主人，而你是我的继承人，我会在你的第 13 个命名日让你坐下来，告诉你：&amp;ldquo;计算的世界正在改变，小姑娘，你必须为多核处理器的新世界做好准备，以免你被它践踏。
&amp;ldquo;好好听着。近年来，CPU 的时钟速度几乎没有增加，但双核和四核计算机已经变得很普遍。物理定律是残酷而绝对的，它们要求提高时钟速度需要成倍的功率。领域内最好的工程师不太可能很快克服这一限制，如果有的话。因此，你可以预期单台机器上的内核不断增加的趋势将继续下去&amp;ndash;作为一个程序员，你将知道如何充分利用现代硬件的期望也是如此。
&amp;ldquo;在这种新模式下学习编程将是有趣和迷人的，真的。但请注意：它也充满了危险。你必须学习并发和并行编程*，这是一门神圣的艺术，使你的应用结构安全地管理多个同时执行的任务。
&amp;ldquo;你从对并发和并行概念的概述开始学习这门艺术。然后，你将学习困扰每个从业者的三个小妖精：参考单元、互斥和矮人狂战士。你还将学习三种有助于你的工具：Future、许诺和延迟&amp;rdquo;。
然后我会用键盘拍拍你的肩膀，示意你可以开始了。
并发和并行的概念 并发和并行编程在程序执行的各个层面都涉及到很多混乱的细节，从硬件到操作系统，到编程语言库，再到从你的内心涌出的、落在编辑器中的代码。但在你为这些细节烦恼之前，在这一节中，我将介绍围绕并发和并行的高级概念。
管理多个任务与同时执行任务 并发指的是在同一时间管理一个以上的任务。 任务只是意味着 &amp;ldquo;需要完成的事情&amp;rdquo;，它并不意味着任何有关硬件或软件的实现。我们可以用 Lady Gaga 的歌曲《电话》来说明并发性。Gaga 唱道
 I cannot text you with a drink in my hand, eh
 这里，她在解释她只能管理一个任务（喝酒）。她断然拒绝了她可以处理一个以上的任务的建议。然而，如果她决定同时处理任务，她会唱歌。
 I will put down this drink to text you, then put my phone away and continue drinking, eh
 在这个假设的宇宙中，Lady Gaga 正在处理两个任务：喝酒和发短信。然而，她并没有同时执行这两项任务。相反，她在这两个任务之间进行切换，或者说是交错。请注意，在交错过程中，你不必在切换之前完全完成一项任务：Gaga 可以打一个字，放下手机，拿起饮料喝一口，然后换回手机，再打一个字。
平行性指的是同时执行一个以上的任务。如果加加夫人平行地执行她的两项任务，她会唱歌。
 I can text you with one hand while I use the other to drink, eh</description>
    </item>
    
    <item>
      <title>Chapter8 宏</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter8/</link>
      <pubDate>Sat, 15 Jan 2022 12:22:42 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter8/</guid>
      <description>编写宏 当我 18 岁时，我在新墨西哥州圣菲的一家酒店找到了一份夜班审计师的工作，每周工作四个晚上，从晚上 11 点到早上 7 点。经过几个月的这种不眠不休的工作，我的情绪有了自己的变化。一天晚上，大约在
凌晨 3 点，我正在看一个信息广告，该产品声称可以恢复男人的头发。当我看到一个曾经秃头的人的故事时，我被真诚的喜悦所淹没。&amp;ldquo;终于来了！&amp;ldquo;我的大脑涌动着。&amp;ldquo;这个人得到了他应得的爱和成功! 多么不可思议的产品，给无望的人以希望！&amp;rdquo;
从那时起，我发现自己一直在想，我是否能以某种方式重新创造因长期睡眠不足而引起的情感放弃和对生命的欣赏。也许是某种药水&amp;ndash;喝上几口，释放我内心的理查德-西蒙斯，但时间不会太长。
就像药水可以让我暂时改变我的基本性质一样，宏允许你以其他语言无法实现的方式修改 Clojure。有了宏，你可以扩展 Clojure 以适应你的问题空间，建立起语言。
在这一章中，你将彻底研究如何编写宏，从基本的例子开始，逐步提高复杂性。最后，你将戴上你的假想帽，用宏来验证你想象中的在线药水店的客户订单。
在本章结束时，你将了解你用来编写宏的所有工具：引号、语法引号、解引号、解引号拼接（又称皮纳塔工具）和 gensym。你还会了解到对毫无戒心的宏作者来说隐藏着的危险：双重求值、变量捕获和宏感染。
宏是必不可少的 在你开始编写宏之前，我想帮助你把它们放在适当的环境中。是的，宏比北极熊的脚趾甲还要酷，但你不应该把宏看成是一些深奥的工具，当你想对你的代码进行额外的花哨处理时，就把它拿出来。事实上，宏允许 Clojure 从一个很小的函数和特殊形式的核心中获得大量的内置功能。以when为例。 when有这样的一般形式。
1 2 3 4 5 6  (when boolean-expression  expression-1  expression-2  expression-3  ...  expression-x)   你可能认为when是一个像if一样的特殊形式。那么你猜怎么着？它不是! 在大多数其他语言中，你只能使用特殊的关键字来创建条件表达式，而没有办法创建你自己的条件运算符。然而，when实际上是一个宏。
在这个宏扩展中，你可以看到when是用if和do来实现的。
1 2 3 4 5 6 7 8  (macroexpand &amp;#39;(when boolean-expression  expression-1  expression-2  expression-3)) ; =&amp;gt; (if boolean-expression  (do expression-1  expression-2  expression-3))   这表明宏是 Clojure 开发中不可或缺的一部分&amp;ndash;它们甚至被用来提供基本操作。宏并不是为奇特的特殊情况而保留的；你应该把写宏看作是你工具包中的另一个工具。当你学会编写自己的宏时，你会发现它们是如何让你进一步扩展语言，使其适合你的特定问题领域的形状。</description>
    </item>
    
    <item>
      <title>Chapter7 炼金术</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter7/</link>
      <pubDate>Sat, 15 Jan 2022 12:14:36 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter7/</guid>
      <description>Clojure 炼金术：读取器、求值器和宏 哲学家之石，与生命之药和伟哥一样，是炼金术传说中最著名的标本之一，因其能将铅转化为金而受到追捧。然而，Clojure 提供了一种工具，使哲学家的石头看起来只是一个小饰品：*宏。
宏允许你将任意的表达式转化为有效的 Clojure，因此你可以扩展语言本身以满足你的需求。而且，你甚至不需要是一个穿长袍的老家伙或老太太来使用它们
为了获得这种能力，请考虑这个微不足道的宏。
1 2 3 4 5 6  (defmacro backwards  [form]  (reverse form))  (backwards (&amp;#34; backwards&amp;#34; &amp;#34; am&amp;#34; &amp;#34;I&amp;#34; str)) ; =&amp;gt; &amp;#34;I am backwards&amp;#34;   backwards宏允许 Clojure 成功地 Eval 表达式(&amp;quot; backwards&amp;quot; &amp;quot; am&amp;quot; &amp;quot;I&amp;quot; str)，尽管它没有遵循 Clojure 的内置语法规则，这些规则要求表达式的操作数首先出现（更不用说表达式不能按相反顺序书写的规则）。如果没有 &amp;ldquo;向后&amp;rdquo;，这个表达式会比几千年来的炼金术士用他们的一生来追求不可能实现的长生不老的方法更难失败。有了`向后&amp;rsquo;，*你就创造了你自己的语法！*你扩展了 Clojure，这样你就可以随心所欲地写代码了 我告诉你，这比把铅变成金子要好得多!
本章为你提供了编写自己的宏所需的概念基础，使你能够疯狂地编写自己的宏。它解释了 Clojure 求值模型的元素：读取器，求值器，和宏扩展器。这就像 Clojure 元素的周期表。想想周期表是如何揭示原子的特性的：同一列的元素行为相似，因为它们有相同的核电荷。如果没有元素周期表及其基础理论，我们就会像过去的炼金术士一样，随意地把东西混在一起，看看什么东西会爆炸。但是，随着对元素的深入了解，你可以看到为什么东西会爆炸，并学会如何有目的地炸毁东西。
A Overview of Clojure&amp;rsquo;s Evaluation Model Clojure（像所有的 Lisps）有一个不同于大多数其他语言的求值模型：它有一个两阶段的系统，它读文本源代码，产生 Clojure 数据结构。然后对这些数据结构进行*求值。Clojure 遍历数据结构，并根据数据结构的类型执行函数应用或 var 查找等操作。例如，当 Clojure 读取文本(+ 1 2)时，结果是一个列表数据结构，其第一个元素是一个+符号，后面是数字 1 和 2。这个数据结构被传递给 Clojure 的求值器，求值器查找+对应的函数，并将该函数应用于 1 和 2。</description>
    </item>
    
    <item>
      <title>Chapter6 组织你的项目</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter6/</link>
      <pubDate>Fri, 14 Jan 2022 12:40:41 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter6/</guid>
      <description>组织你的项目：一个图书管理员的故事 在我们每个人心中都住着一个叫 Melvil 的图书管理员，一个以组织艺术为乐的奇异生物。日日夜夜，Melvil 都渴望为你的代码库带来秩序。幸运的是，Clojure 提供了一套工具，专门用来帮助这个侏儒与混乱的力量不断斗争。
这些工具通过将相关的函数和数据分组来帮助你组织你的代码。它们还可以防止名称冲突，这样你就不会意外地覆盖别人的代码，反之亦然。在这个充满悬念和神秘的故事中，请和我一起学习如何使用这些工具，并解决一生中的抢劫案吧 在这个传奇故事的最后，你将了解以下内容。
  `def&amp;rsquo;是做什么的
  什么是命名空间以及如何使用它们
  命名空间和文件系统之间的关系
  如何使用refer、alias、require、use和ns。
  如何使用文件系统来组织 Clojure 项目
  我先来介绍一下 Clojure 的组织系统，它的工作原理很像一个库。Melvil 兴奋地颤抖着!
你的项目是一个库 现实世界中的图书馆存储对象的集合，如书籍、杂志和 DVD。他们使用寻址系统，所以当你得到一个物体的地址时，你可以导航到物理空间并检索到该物体。
当然，没有人能够直接知道一本书或 DVD 的地址是什么。这就是为什么图书馆要记录一个物体的标题和它的地址之间的联系，并提供工具来搜索这些记录。在计算机之前的旧时代，图书馆提供卡片目录，即装满纸质卡片的柜子，其中包含每本书的标题、作者、&amp;ldquo;地址&amp;rdquo;（杜威十进制或国会图书馆编号）和其他信息。
例如，要找到《达芬奇密码》，你可以翻阅书名目录（按书名排序的卡片），直到你找到正确的卡片。在那张卡片上，你会看到地址813.54（如果它使用杜威十进制系统），浏览图书馆，找到达芬奇密码所在的书架，并参与你一生中的文学和/或仇恨阅读冒险。
在 Clojure 中想象一个类似的设置是很有用的。我认为 Clojure 是将对象（如数据结构和函数）存储在一组巨大的编号架上。没有人能够直接知道一个对象被存储在哪个架子上。相反，我们给 Clojure 一个标识符，它用来检索该对象。
为了使之成功，Clojure 必须维护我们的标识符和货架地址之间的关联。它通过使用namespaces来做到这一点。命名空间包含了人类友好的符号和书架地址的引用之间的 Map，被称为vars，很像卡片目录。
从技术上讲，命名空间是 &amp;ldquo;clojure.lang.Namespace &amp;ldquo;类型的对象，你可以与它们互动，就像你可以与 Clojure 数据结构互动一样。例如，你可以用*ns*来引用当前的命名空间，你可以用(ns-name *ns*)来获得其名称。
1 2  (ns-name *ns*) ; =&amp;gt; user   例如，当你启动 REPL 时，你在user命名空间中（正如你在这里看到的）。提示符显示当前名称空间，使用user=&amp;gt;。
当前名字空间的概念意味着你可以有多个名字空间，事实上 Clojure 允许你创建任意多的名字空间（尽管从技术上讲，你可以创建的名字数量可能有一个上限）。在 Clojure 程序中，你总是在个命名空间中。</description>
    </item>
    
    <item>
      <title>Chapter5 函数式编程</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter5/</link>
      <pubDate>Fri, 14 Jan 2022 10:00:07 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter5/</guid>
      <description>函数式编程 到目前为止，你已经专注于熟悉 Clojure 提供的工具：不可变的数据结构、函数、抽象，等等。在这一章中，你将学习如何思考你的编程任务，以最好的方式利用这些工具。你将开始把你的经验整合到一个新的函数式编程思维中。
你将学到的核心概念包括：什么是纯函数，为什么它们很有用；如何使用不可变的数据结构，为什么它们比可变的表亲更有优势；如何将数据和函数分开，给你带来更多的力量和灵活性；以及为什么对一小部分数据抽象进行编程会很强大。一旦你把所有这些知识塞进你的大脑，你就会有一个全新的解决问题的方法
在学习了这些主题之后，你将通过编写一个基于终端的游戏来运用你所学到的一切，这个游戏的灵感来自于美国各地 Cracker Barrel 餐馆中的一种古老而神秘的思维训练装置。Peg Thing!
纯函数：是什么和为什么 除了 &amp;ldquo;println &amp;ldquo;和 &amp;ldquo;rand&amp;rdquo;，到目前为止，你所使用的所有函数都是纯函数。是什么使它们成为纯函数，为什么会有这样的问题？如果一个函数符合两个条件，它就是纯函数。
 如果给出相同的参数，它总是返回相同的结果。这被称为引用透明度，你可以把它添加到你的 5 美元编程术语列表中。 它不能引起任何副作用。也就是说，该函数不能做出任何在函数本身之外可以观察到的改变&amp;ndash;例如，通过改变一个外部可访问的可改变对象或写到一个文件。  这些特性使你更容易推理你的程序，因为这些函数是完全隔离的，无法影响你系统的其他部分。当你使用它们时，你不必问自己，&amp;ldquo;我调用这个函数会破坏什么？&amp;rdquo; 它们也是一致的：你永远不需要搞清楚为什么给一个函数传递相同的参数会导致不同的返回值，因为这永远不会发生。
纯函数和算术一样稳定，没有问题（你最后一次为两个数字相加而烦恼是什么时候？） 它们是巨大的函数小砖块，你可以自信地将其作为你程序的基础。让我们更详细地看看引用透明性和无副作用，看看它们到底是什么，以及它们是如何发挥作用的。
纯函数是引用透明的 为了在调用相同参数时返回相同的结果，纯函数只依靠 1）自己的参数和 2）不可变的值来决定其返回值。例如，数学函数是引用透明的。
1 2  (+ 1 2) ; =&amp;gt; 3   如果一个函数依赖于一个不可变的值，那么它就是引用透明的。字符串`&amp;rdquo;, Daniel-san &amp;ldquo;是不可变的，所以下面的函数也是引用透明的。
1 2 3 4 5 6  (defn wisdom  [words]  (str words &amp;#34;, Daniel-san&amp;#34;))  (wisdom &amp;#34;Always bathe on Fridays&amp;#34;) ; =&amp;gt; &amp;#34;Always bathe on Fridays, Daniel-san&amp;#34;   相比之下，下面的函数在相同的参数下不会产生相同的结果；因此，它们在指称上是不透明的。任何依赖随机数生成器的函数都不可能是指称透明的。</description>
    </item>
    
    <item>
      <title>Chapter4 深入研究核心函数</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter4/</link>
      <pubDate>Thu, 13 Jan 2022 17:39:28 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter4/</guid>
      <description>核心函数的深入研究 如果你像我一样是焦虑的、以青少年为中心的准肥皂剧*《吸血鬼日记》*的超级粉丝，你一定记得主角埃琳娜开始质疑她苍白的、神秘的暗恋者的行为的那一集。&amp;ldquo;为什么当我的膝盖被刮伤时，他立刻消失得无影无踪？&amp;ldquo;和 &amp;ldquo;为什么当我的手指被划破时，他的脸变成了一个怪异的死亡面具？&amp;ldquo;等等。
如果你已经开始把玩 Clojure 的核心函数，你可能也会问自己类似的问题。&amp;ldquo;为什么map会返回一个列表，而我给它的是一个 Vector？&amp;ldquo;和 &amp;ldquo;为什么reduce会把我的 map 当成一个 Vector？&amp;ldquo;等等。(不过，有了 Clojure，你至少可以免于思考作为一个 17 岁孩子的深刻的存在恐惧，直到永远）。
在这一章中，你将了解到 Clojure 的深邃、黑暗、嗜血、超自然的cough，我的意思是，在这一章中，你将了解到 Clojure 的抽象的基本概念以及序列和集合的抽象。你还会了解到疯狂的序列。这将为你提供所需的基础，使你能够阅读你以前没有使用过的函数的文档，并理解当你试着使用它们时发生了什么。
接下来，你将获得更多关于你最需要使用的函数的经验。你将学习如何用函数map、reduce、into、conj、concat、some、filter、take、drop、sort、sort-by和identity来处理列表、Vector、Map 和 Set。你还将学习如何用apply、partial和complement创建新的函数。所有这些信息将帮助你了解如何以 Clojure 的方式做事，它将为你编写自己的代码以及阅读和学习他人的项目打下坚实的基础。
最后，你将学会如何解析和查询 CSV 中的吸血鬼数据，以确定在你的家乡潜伏着哪些诺斯费拉图。
从编程到抽象 为了理解从编程到抽象，让我们把 Clojure 与一种没有考虑到这个原则的语言进行比较。Emacs Lisp（elisp）。在 elisp 中，你可以使用mapcar函数来导出一个新的列表，这与你在 Clojure 中使用map的方式相似。然而，如果你想在 elisp 中 Map 一个哈希 Map（类似于 Clojure 的 map 数据结构），你需要使用maphash函数，而在 Clojure 中你仍然可以只使用map。换句话说，elisp 使用两个不同的、针对数据结构的函数来实现map操作，而 Clojure 只使用一个。你也可以在 Clojure 中对 map 调用reduce，而 elisp 并没有提供一个函数来减少散列 map。
原因是 Clojure 在序列抽象方面定义了map和reduce函数，而不是在具体的数据结构方面。只要数据结构响应核心序列操作（函数first、rest和cons，我们稍后会仔细研究），它就能与map、reduce以及其他大量的序列函数免费工作。这就是 Clojurists 所说的抽象编程，也是 Clojure 哲学的一个核心原则。
我认为抽象是操作的命名集合。如果你能在一个对象上执行一个抽象的所有操作，那么这个对象就是该抽象的一个实例。我甚至在编程之外也是这样想的。例如，电池抽象包括 &amp;ldquo;将导电介质连接到其阳极和阴极 &amp;ldquo;的操作，而该操作的输出是电流。电池是用锂还是用土豆做的并不重要。只要它对定义电池的一系列操作做出反应，它就是一个电池。
同样地，map并不关心列表、Vector、Set 和 Map 是如何实现的。它只关心它是否能对它们进行序列操作。让我们看看map是如何在序列抽象中定义的，这样你就能理解一般的抽象编程。</description>
    </item>
    
    <item>
      <title>Chapter3 速成班</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter3/</link>
      <pubDate>Thu, 13 Jan 2022 11:12:19 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter3/</guid>
      <description>做事情：Clojure 速成班 是时候学习如何用 Clojure 真正地做事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。
在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!
当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!
语法 Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。
Form 所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。
 数据结构的字面表示（如数字、字符串、Map 和 Vector） 操作  我们使用术语form来指代有效的代码。我有时也会用表达式来指代 Clojure Form。但不要太纠结于术语。Clojure 求值每一个 Form，以产生一个值。这些字面意义的表达都是有效的 Form。
1 2 3  1 &amp;#34;a string&amp;#34; [&amp;#34;a&amp;#34; &amp;#34;vector&amp;#34; &amp;#34;of&amp;#34; &amp;#34;strings&amp;#34;]   当然，你的代码很少包含自由浮动的字符，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你做事情的方式。所有操作的 Form 都是：开括号，操作符，操作数，闭括号。
1  (operator operand1 operand2 ... operandn)   请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。</description>
    </item>
    
    <item>
      <title>Chapter2 如何使用 Emacs</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter2/</link>
      <pubDate>Thu, 13 Jan 2022 10:43:56 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter2/</guid>
      <description>如何使用 Emacs，一个优秀的 Clojure 编辑器 在你掌握 Clojure 的过程中，你的编辑器将是你最亲密的盟友。我强烈建议使用 Emacs，但你当然也可以使用任何你想要的编辑器。如果你不遵循本章中关于 Emacs 的详尽说明，或者你选择使用一个不同的编辑器，那么至少值得投入一些时间来设置你的编辑器，以便与 REPL 一起工作。我推荐的两个在社区中受到好评的替代品是Cursive和Nightcode。
我推荐 Emacs 的原因是，它提供了与 Clojure REPL 的紧密集成，这使你可以在写作时立即尝试你的代码。这种紧密的反馈回路在学习 Clojure 和以后编写真正的 Clojure 程序时都很有用。Emacs 也很适合与任何 Lisp 方言一起工作；事实上，Emacs 是用一种叫做 Emacs Lisp（elisp）的 Lisp 方言编写的。
在本章结束时，你的 Emacs 设置将看起来像图 2-1。
图 2-1: 使用 Clojure 的典型 Emacs 设置：一边是代码，另一边是 REPL。
为了达到这个目的，你将从安装 Emacs 开始，设置一个适合新人的 Emacs 配置。然后你将学习基础知识：如何打开、编辑和保存文件，以及如何使用基本的键绑定与 Emacs 进行交互。最后，你将学习如何实际编辑 Clojure 代码并与 REPL 进行交互。
安装 你应该使用 Emacs 的最新主要版本，即 Emacs 24，用于你工作的平台。
 OS X从*http://emacsformacosx.com*安装 vanilla Emacs 作为一个 Mac 应用程序。其他选项，如 Aquamacs，应该是为了使 Emacs 更 &amp;ldquo;像 Mac&amp;rdquo;，但从长远来看是有问题的，因为它们的设置与标准 Emacs 有很大的不同，以至于很难使用 Emacs 手册或跟随教程。 Ubuntu按照*https://launchpad.</description>
    </item>
    
    <item>
      <title>Chapter1 构建、运行和 REPL</title>
      <link>https://zhenfeng-zhu.github.io/post/chapter1/</link>
      <pubDate>Thu, 13 Jan 2022 10:26:48 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/chapter1/</guid>
      <description>构建、运行和 REPL 在本章中，你将预先投入少量时间来熟悉建立和运行 Clojure 程序的快速、傻瓜式方法。让一个真正的程序运行起来感觉很好。达到了这个里程碑，你就可以自由地进行实验，分享你的工作，并向那些仍在使用上个世纪的语言的同事幸灾乐祸。这将有助于保持你的积极性!
你还将学习如何使用*Read-Eval-Print Loop（REPL）*在一个正在运行的 Clojure 进程中即时运行代码，这使你能够快速测试你对语言的理解并更有效地学习。
但首先，我将简要地介绍 Clojure。接下来，我将介绍 Leiningen，这是 Clojure 事实上的标准构建工具。在本章结束时，你将知道如何做以下事情。
 用 Leiningen 创建一个新的 Clojure 项目 构建该项目以创建一个可执行的 JAR 文件 执行 JAR 文件 在 Clojure REPL 中执行代码  第一重要的事: 什么是 Clojure Clojure 是由 Rich Hickey 在一座神话般的火山中铸造的。他使用 Lisp、函数式编程和他自己的一绺史诗般的头发的合金，创造了一种令人愉快而强大的语言。它的 Lisp 遗产使你有能力写出比大多数非 Lisp 语言更有表现力的代码，而它对函数式编程的独特理解将使你作为一个程序员的思维更敏锐。此外，Clojure 为你提供了更好的工具来处理复杂的领域（如并发编程），这些领域在传统上被认为会使开发人员陷入多年的治疗中。
不过，在谈论 Clojure 时，重要的是要牢记 Clojure 语言和 Clojure 编译器之间的区别。Clojure 语言是一种强调函数的 Lisp 方言，其语法和语义与任何实现都无关。编译器是一个可执行的 JAR 文件，clojure.jar，它接收用 Clojure 语言编写的代码并将其编译为 Java 虚拟机（JVM）字节码。你会看到Clojure被用来指代语言和编译器，如果你不知道它们是独立的东西，就会感到困惑。但现在你意识到了，你就会好起来。
这种区分是必要的，因为与大多数编程语言如 Ruby、Python、C 和其他许多语言不同，Clojure 是一种托管语言。Clojure 程序在 JVM 中执行，并依赖 JVM 的核心功能，如线程和垃圾收集。Clojure 还针对 JavaScript 和微软的通用语言运行时（CLR），但本书只关注 JVM 的实现。</description>
    </item>
    
    <item>
      <title>Introduction 简介</title>
      <link>https://zhenfeng-zhu.github.io/post/introduction/</link>
      <pubDate>Thu, 13 Jan 2022 10:11:25 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/introduction/</guid>
      <description>简介 在你的内心深处，你一直都知道你注定要学习 Clojure。 每当你高举着键盘，为一个难以理解的类层次结构而痛苦地哭泣时；每当你晚上躺在床上，为一个突变引起的海森堡虫而哭泣扰乱你的亲人时；每当一个竞赛条件使你拔掉更多你不断减少的头发时，你的某个秘密部分已经知道一定有一个更好的办法。
现在，终于，你面前的教学材料将使你与你渴望已久的编程语言结合起来。
学习一种新的编程语言：穿越四个迷宫的旅程 为了最大限度地发挥 Clojure 的作用，你需要在每个学习新语言的程序员面临的四个迷宫中找到自己的路。
 工具之林 友好而高效的编程环境使你能够轻松地尝试你的想法。你将学习如何设置你的环境。 语言之山 随着你的攀登，你将获得 Clojure 的语法、语义和数据结构方面的知识。你将学习如何使用最强大的编程工具之一&amp;ndash;宏，并学习如何利用 Clojure 的并发结构来简化你的生活。 神器之洞 在它的深处，你将学会构建、运行和发布你自己的程序，以及如何使用代码库。你还将学习 Clojure 与 Java 虚拟机（JVM）的关系。 心态云堡 在其稀薄的空气中，你将了解 Lisp 和函数式编程的原因和方法。你将了解渗透在 Clojure 中的简单哲学，以及如何像 Clojurist 一样解决问题。  别搞错了，你要工作。但这本书会让你感觉到工作是令人振奋的，而不是疲惫的。这是因为本书遵循三个准则。
 它采取了甜点优先的方法，给你提供了你需要的开发工具和语言细节，以便立即开始玩真正的程序。 它假定你对 JVM、函数式编程或 Lisp 没有经验。它详细地涵盖了这些主题，所以当你构建和运行 Clojure 程序时，你会对你正在做的事情感到自信。 它避开了 真实世界 的例子，而选择了更有趣的练习，如 攻击霍比特人 和 追踪闪亮的吸血鬼 。  到最后，你将能够使用 Clojure&amp;ndash;现存的最令人兴奋和最有趣的编程语言之一!
本书是如何组织的 本书分为三个部分，以便更好地指导你完成你的勇敢探索，勇敢的初出茅庐的 Clojurist。
第一部分：环境设置 为了保持动力和高效学习，你需要实际写代码和构建可执行文件。这些章节将带领你快速浏览你所需要的工具，以便轻松地编写程序。这样，你就可以专注于学习 Clojure，而不是摆弄你的环境。
第 1 章：构建、运行和 REPL
让一个真正的程序运行起来，有一种强大的激励作用。一旦你能做到这一点，你就可以自由地进行实验，而且你可以真正地分享你的工作
在这短短的一章中，你将投入少量时间来熟悉建立和运行 Clojure 程序的快速方法。你将学习如何在一个正在运行的 Clojure 进程中使用 read-eval-print 循环（REPL）来实验代码。这将收紧你的反馈回路，帮助你更有效地学习。</description>
    </item>
    
    <item>
      <title>Acknowledgments 致谢</title>
      <link>https://zhenfeng-zhu.github.io/post/acknowledgments/</link>
      <pubDate>Thu, 13 Jan 2022 10:06:10 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/acknowledgments/</guid>
      <description>致谢 有很多人帮助我诞生了这个奇怪的婴儿，我对他们的支持感到感激。
首先，感谢我的妻子杰西，她为这本书绘制了插图，使它具有我所希望的视觉特性。也感谢你的支持，感谢你在我处于疯狂的作家模式时容忍我。(附注：通过一本编程书的封面感谢我的妻子，感觉很奇怪。）
感谢我在麦肯锡的朋友和同事，他们阅读了早期的修订稿并鼓励我继续写作。其中最重要的是 Pat Shaughnessy、Alex Rothenberg、Thomas Newton、Jalil Fanaian、Chris Parker、Mark Daggett、Christian Lilley，以及 Mike Morreale。你们都太伟大了；请搬到 Durham。
感谢我的朋友布里奇特-希勒（Bridget Hillyer）一直以来的支持。我总是觉得你是我的后盾，这对我来说意义重大。也感谢我的朋友乔-杰克逊，感谢他阅读、听我喋喋不休、并为我提供反馈，并感谢他在我面前对其他人大谈这本书，让我感觉很酷。Alan Dipert，朋友，技术评论员，现在的同事，我向你表示万分感谢，感谢你出色的技术编辑，感谢你首先将我引入 Clojure。
我不知道是否每个作家都会不断地问自己：&amp;ldquo;我到底为什么要这样做？是否有人会读它？&amp;ldquo;但我肯定会这样做。因此，我想感谢所有在这本书的最初网络版本编写过程中写信给我并建议进行编辑的友好人士。这些积极的反馈使我感到有信心，我正在做一件有意义的事情。同样地，感谢所有购买 Leanpub 版本的人
非常感谢 Clojure 社区领导人 Eric Normand、David Nolen 和 Alex Miller 对本书的积极宣传。在下一届 Conj 大会上见!
最后，要感谢 No Starch 出版社的各位同仁，感谢你们对本书的帮助，使之成为我无比自豪的作品。感谢你们的高标准。感谢你们不断地促使本书更加清晰，甚至提出笑话。(Seph 的 &amp;ldquo;蜡球 &amp;ldquo;编辑仍然让我开怀大笑。) Seph Kramer, Riley Hoffman, Hayley Baker, Alison Law, Tyler Ortman, Anne Marie Walker: 谢谢你们!</description>
    </item>
    
    <item>
      <title>Foreword 前言</title>
      <link>https://zhenfeng-zhu.github.io/post/foreword/</link>
      <pubDate>Thu, 13 Jan 2022 10:04:46 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/post/foreword/</guid>
      <description>前言 当你阅读这本搞笑的书时，你会在某个时刻经历一个非常严肃的时刻。在了解了一些 Clojure 之后，编程变得更加有趣。这也是你在这本书上的投资，包括金钱和时间，得到回报的时刻&amp;ndash;有趣。
幽默与严肃性有一定的关系。对严肃的事情开玩笑是合适的，但只有在适当的时间过去之后。例如，当我想起我最喜欢的叔叔的最后一句话时，我花了很多年才能够破涕为笑。&amp;ldquo;拿着我的啤酒&amp;rdquo;。
这本书的工作方式正好相反。它在严肃事件发生之前，甚至在严肃事件发生期间，适时地指出了真正有趣的事情&amp;ndash;那一刻你意识到你因为 Clojure 而更喜欢编程。它在做到这一点的同时，并没有掩盖你将要学习的 Clojure 编程的深层技术层面。
这种方法令人耳目一新，因为我读过的大多数编程书籍都比骆驼的屁还干。我们很幸运，丹尼尔是一位出色的程序员和作家，他的妻子杰斯是一位同样出色的插图画家。我们特别幸运的是，他们两个都疯了，决定在完全相同的时间写一本书。
Clojure 是本书的主题，但在某种程度上它&amp;ndash;或者说它的创造者 Rich Hickey&amp;ndash;也是作者之一，因为 Clojure 是有史以来最优雅的编程语言。就像早午餐的概念一样，Clojure 是如此的优雅，以至于如果不以某种方式提高他们的水平，就很难告诉别人关于它的任何事情。
优雅是编程语言家族中许多 Lisp 方言经常被赋予的品质，Clojure 就是其中之一。所有的 Lisp 都是由数学家 John McCarthy 在 1958 年做出的一系列简单而美丽的发现演变而来。
自 1958 年以来，出现了许多 Lisp 方言 和 Lisp 书籍。还有更多的 Lisp 方言 和书籍即将问世。作为过去和未来的神器，每一种都适合它们的作者在各自的时代所面临的独特的约束和欲望的组合。
我发现 Clojure，以及这本关于它的特殊书籍，特别适合现在。我希望你也会这样。
Alan Dipert</description>
    </item>
    
  </channel>
</rss>
