<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>clojure on 演示站点</title><link>https://example.com/tags/clojure/</link><description>Recent content in clojure on 演示站点</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 15 Jan 2022 21:45:17 +0800</lastBuildDate><atom:link href="https://example.com/tags/clojure/index.xml" rel="self" type="application/rss+xml"/><item><title>Farewell 永别了</title><link>https://example.com/p/farewell-%E6%B0%B8%E5%88%AB%E4%BA%86/</link><pubDate>Sat, 15 Jan 2022 21:45:17 +0800</pubDate><guid>https://example.com/p/farewell-%E6%B0%B8%E5%88%AB%E4%BA%86/</guid><description>&lt;h1 id="永别了">永别了&lt;/h1>
&lt;p>正如 Semisonic 在 90 年代的热门歌曲 &amp;ldquo;Closing Time &amp;ldquo;所告诉我们的那样，每一个新的开始都来自于其他一些开始的结束。恭喜你，高贵的读者，完成了这次 Clojure 之旅。我希望你发现它是有价值的，我也希望你期待着更多的东西！相信我，还有更多的东西等着你。&lt;/p>
&lt;p>相信我，还有很多东西。我最喜欢 Clojure 的一点是，它有一个完整的世界可以探索。逻辑编程、解析器、类型系统……只要你能说出计算机科学的一个有趣领域，你就可以用 Clojure 来研究它。我把我对下一步要去哪里的建议留给你。&lt;/p>
&lt;p>如果你想对 Clojure 生态系统有一个广泛的了解，请查看&lt;a class="link" href="http://www.clojure-toolbox.com/" target="_blank" rel="noopener"
>The Clojure Toolbox&lt;/a>，它列出了数百个 Clojure 项目，并按照它们所解决的问题进行组织。&lt;/p>
&lt;p>如果你对网络编程感兴趣，一个很好的开始是 Luminus 框架（&lt;em>&lt;a class="link" href="http://www.luminusweb.net/" target="_blank" rel="noopener"
>Luminus - 一个 Clojure 网络框架&lt;/a>&lt;/em>）。它的文档非常好，你很快就会有一个网站在运行。&lt;/p>
&lt;p>要想了解 Clojure 的最新动态，Eric Normand 的 Clojure Gazzette 是一个很好的资源（&lt;a class="link" href="http://www.clojuregazette.com/" target="_blank" rel="noopener"
>注册每周功能编程通讯&lt;/a>）。当然，还有 Clojure 邮件列表（&lt;a class="link" href="https://groups.google.com/forum/#!forum/clojure" target="_blank" rel="noopener"
>https://groups.google.com/forum/#!forum/clojure&lt;/a>）和 Clojure subreddit 也是一个有用的、友好的地方（&lt;a class="link" href="http://www.reddit.com/r/clojure" target="_blank" rel="noopener"
>http://www.reddit.com/r/clojure&lt;/a>）。&lt;/p>
&lt;p>如果 Twitter 是你选择的社交媒体，那么&lt;a class="link" href="http://twitter.com/swannodette" target="_blank" rel="noopener"
>@swannodette&lt;/a> (David Nolen), &lt;a class="link" href="http://twitter.com/gigasquid" target="_blank" rel="noopener"
>@gigasquid&lt;/a> (Carin Meier), &lt;a class="link" href="http://twitter.com/puredanger" target="_blank" rel="noopener"
>@puredanger&lt;/a> (Alex Miller), &lt;a class="link" href="http://twitter.com/ztellman" target="_blank" rel="noopener"
>@ztellman&lt;/a> (Zach Tellman), &lt;a class="link" href="http://twitter.com/bbatsov" target="_blank" rel="noopener"
>@bbatsov&lt;/a> (Bozidar Batsov) 和 &lt;a class="link" href="http://twitter.com/stuartsierra" target="_blank" rel="noopener"
>@stuartsierra&lt;/a> (Stuart Sierra) 是你的小红帽。你也可以关注我，&lt;a class="link" href="http://twitter.com/nonrecursive" target="_blank" rel="noopener"
>@nonrecursive&lt;/a>!&lt;/p>
&lt;p>再见了，小茶杯，祝你 Clojuring 愉快&lt;/p></description></item><item><title>AppendixB 花哨的 Boot</title><link>https://example.com/p/appendixb-%E8%8A%B1%E5%93%A8%E7%9A%84-boot/</link><pubDate>Sat, 15 Jan 2022 21:41:09 +0800</pubDate><guid>https://example.com/p/appendixb-%E8%8A%B1%E5%93%A8%E7%9A%84-boot/</guid><description>&lt;h1 id="boot花哨的-clojure-构建框架">Boot，花哨的 Clojure 构建框架&lt;/h1>
&lt;p>Boot 是 Leiningen 的替代品，提供同样的功能。Leiningen 更受欢迎（截至 2015 年夏天），但我个人喜欢用 Boot 工作，因为它更容易扩展。本附录解释了 Boot 的基本概念，并指导你编写你的第一个 Boot 任务。如果你对使用 Boot 构建项目感兴趣，请查看它的 GitHub README（&lt;em>&lt;a class="link" href="https://github.com/boot-clj/boot/" target="_blank" rel="noopener"
>GitHub - boot-clj/boot: Build tooling for Clojure.&lt;/a>&lt;/em>）和它的 wiki（&lt;a class="link" href="https://github.com/boot-clj/boot/wiki/" target="_blank" rel="noopener"
>Home - boot-clj/boot Wiki - GitHub&lt;/a>&lt;em>）&lt;/em>。&lt;/p>
&lt;p>注意 截至本文写作时，Boot 对 Windows 的支持有限。Boot 团队欢迎大家的贡献!&lt;/p>
&lt;h2 id="boot-的抽象">Boot 的抽象&lt;/h2>
&lt;p>Boot 由 Micha Niskin 和 Alan Dipert 创建，是对 Clojure 工具领域的一个有趣而强大的补充。从表面上看，它是构建 Clojure 应用程序和从命令行运行 Clojure 任务的一种便捷方式。深入研究一下，你会发现 Boot 就像 Git 和 Unix 的爱情结晶，它提供的抽象使你在操作系统和应用程序的交叉点上编写代码时更加愉快。&lt;/p>
&lt;p>Unix 提供了我们都很熟悉的抽象，以至于我们认为它们是理所当然的。(偶尔带你的电脑去吃一顿好的餐厅会死吗？) 进程抽象让你把程序推理成独立的逻辑单元，可以通过 STDIN 和 STDOUT 文件描述符轻松地组成一个流处理管道。这些抽象使某些类型的操作，如文本处理，变得非常直接。&lt;/p>
&lt;p>同样，Boot 也提供了一些抽象，使得独立的操作很容易被组合成构建工具最终要做的那种复杂、协调的操作，比如将 ClojureScript 转换为 JavaScript。 Boot 的任务抽象让你可以轻松地定义逻辑单元，通过&lt;em>文件集合&lt;/em>进行通信。文件集合抽象可以跟踪不断变化的构建环境，并提供一个定义明确、可靠的任务协调方法。&lt;/p>
&lt;p>这就是很多高层次的描述，希望能吸引你的注意力。但是，如果我带着一板一眼的隐喻离开你，那就太丢人了。哦，不，亲爱的读者，这只是开胃菜而已。在本附录的其余部分，你将学习如何建立自己的 Boot 任务。在这一过程中，你会发现，构建工具实际上是有概念基础的。&lt;/p>
&lt;h2 id="任务">任务&lt;/h2>
&lt;p>像 make、rake、grunt 和其他以前的构建工具一样，Boot 让你定义任务。 &lt;em>任务&lt;/em>是命名的操作，接受由某个中间程序（make、rake、Boot）调度的命令行选项。&lt;/p>
&lt;p>Boot 提供了调度程序&lt;em>boot&lt;/em>和一个 Clojure 库，使你可以很容易地用&lt;code>deftask&lt;/code>宏来定义命名的操作及其命令行选项。为了看看所有的大惊小怪，让我们来创建你的第一个任务。通常情况下，编程教程鼓励你写代码来打印 &amp;ldquo;Hello World&amp;rdquo;，但我希望我的例子能有真实的效用，所以你的任务是打印 &amp;ldquo;我的裤子着火了！&amp;rdquo; 这个信息客观上更有用。首先，安装 Boot；然后创建一个名为&lt;em>boot-walkthrough&lt;/em>的新目录，导航到该目录，创建一个名为*build.boot**的文件，*然后这样写。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(deftask fire
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Prints &amp;#39;My pants are on fire!&amp;#39;&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> []
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;My pants are on fire!&amp;#34;))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在用&lt;code>boot fire&lt;/code>从命令行运行这个任务；你应该看到你写的信息被打印到终端。这个任务展示了三个任务组件中的两个：任务被命名为（&lt;code>fire&lt;/code>），并且由 boot 调度。这真是太酷了。你基本上已经创建了一个 Clojure shell 脚本，独立的 Clojure 代码，你可以轻松地从命令行运行。不需要&lt;em>project.clj&lt;/em>，不需要目录结构，也不需要命名空间!&lt;/p>
&lt;p>让我们扩展一下这个例子，演示一下你如何编写命令行选项。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(deftask fire
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Announces that something is on fire&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [t thing THING str &amp;#34;The thing that&amp;#39;s on fire&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> p pluralize bool &amp;#34;Whether to pluralize&amp;#34;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [verb (if pluralize &amp;#34;are&amp;#34; &amp;#34;is&amp;#34;)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;My&amp;#34; thing verb &amp;#34;on fire!&amp;#34;)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>试着像这样运行该任务。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">boot fire -t heart
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># =&amp;gt; My heart is on fire!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">boot fire -t logs -p
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># =&amp;gt; My logs are on fire!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在第一种情况下，要么你是新近恋爱，要么你需要赶到急诊室。在第二个例子中，你是一个童子军，尴尬地表达了你对达到功绩勋章要求的兴奋。在这两种情况下，你都能轻松地指定任务的选项。&lt;/p>
&lt;p>这次对&lt;code>fire&lt;/code>任务的改进引入了两个命令行选项，&lt;code>thing&lt;/code>和&lt;code>pluralize&lt;/code>。这两个选项都是用*域特定语言（DSL）*定义的。DSL 是他们自己的主题，但简单地说，这个术语指的是微型语言，你可以在一个大的程序中使用，为狭义的领域（如定义选项）编写紧凑的、富有表现力的代码。&lt;/p>
&lt;p>在选项&lt;code>thing&lt;/code>中，&lt;code>t&lt;/code>指定其短名称，&lt;code>thing&lt;/code>指定其长名称。 &lt;code>THING&lt;/code>有点复杂，我稍后会讲到它。 &lt;code>str&lt;/code>指定了选项的类型，Boot 用它来验证参数并进行转换。 &lt;code>&amp;quot;着火的东西 &amp;quot;是该选项的文档。你可以用&lt;/code>boot task-name -h`在终端查看一个任务的文档。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">boot fire -h
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># Announces that something is on fire
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># Options:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># -h, --help Print this help info.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># -t, --thing THING Set the thing that&amp;#39;s on fire to THING.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># -p, --pluralize Whether to pluralize
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>相当棒的! Boot 使编写要从命令行调用的代码变得非常容易。&lt;/p>
&lt;p>现在，让我们看看&lt;code>THING&lt;/code>。&lt;code>THING&lt;/code>是一个&lt;em>optarg&lt;/em>，它表示这个选项需要一个参数。当你定义一个选项时，你不需要包括 optarg（注意&lt;code>pluralize&lt;/code>选项没有 optarg）。optarg 不必与选项的全名相对应；你可以用&lt;code>BILLY_JOEL'或其他你想要的东西来代替&lt;/code>THING&amp;rsquo;，任务也会照常进行。你也可以使用 optarg 来指定复杂的选项。(&lt;a class="link" href="https://github.com/boot-clj/boot/wiki/Task-Options-DSL#complex-options" target="_blank" rel="noopener"
>访问&lt;em>https://github.com/boot-clj/boot/wiki/Task-Options-DSL#complex-options&lt;/em>&lt;/a>了解 Boot 关于这个问题的文档。) 基本上，复杂选项允许你指定选项参数应被视为 Map、集合、Vector，甚至是嵌套集合。这是很强大的。&lt;/p>
&lt;p>Boot 为你提供了用 Clojure 构建命令行界面所需的所有工具。而你才刚刚开始学习它!&lt;/p>
&lt;h2 id="the-repl">The REPL&lt;/h2>
&lt;p>Boot 有许多有用的内置任务，包括一个 REPL 任务。运行 &lt;code>boot repl&lt;/code> 来启动这个小家伙。Boot 的 REPL 与 Leiningen 的类似，它负责加载你的项目代码，这样你就可以随意玩耍。你可能认为这不适用于你所写的项目，因为你只写了任务，但实际上你可以在 REPL 中运行任务（我省略了&lt;code>boot.user=&amp;gt;&lt;/code>提示）。你可以用一个字符串指定选项。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(fire &amp;#34;-t&amp;#34; &amp;#34;NBA Jam guy&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; My NBA Jam guy is on fire!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; nil
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，选项的值就在选项的后面。&lt;/p>
&lt;p>你也可以用关键字来指定一个选项。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(fire :thing &amp;#34;NBA Jam guy&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; My NBA Jam guy is on fire!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; nil
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你也可以结合选项。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(fire &amp;#34;-p&amp;#34; &amp;#34;-t&amp;#34; &amp;#34;NBA Jam guys&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; My NBA Jam guys are on fire!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; nil
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(fire :pluralize true :thing &amp;#34;NBA Jam guys&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; My NBA Jam guys are on fire!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; nil
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当然，你也可以在 REPL 中使用&lt;code>deftask&lt;/code>，毕竟这只是 Clojure。我们的收获是，Boot 可以让你把任务作为 Clojure 函数进行交互，因为它们就是这样的。&lt;/p>
&lt;h2 id="组成和协调">组成和协调&lt;/h2>
&lt;p>如果到目前为止你所看到的就是 Boot 所能提供的一切，那它将是一个非常棒的工具，但它与其他构建工具没有什么不同。让 Boot 与众不同的一个特点是，它可以让你编排任务。为了便于比较，这里有一个 Rake 调用的例子（Rake 是主要的 Ruby 构建工具）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">rake db:create d{:tag :a, :attrs {:href &amp;#34;db:seed&amp;#34;}, :content [&amp;#34;b:migra&amp;#34;]}te db:seed
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段代码将创建一个数据库，在其上运行迁移，并在 Rails 项目中运行时向其填充种子数据。然而，值得注意的是，Rake 并没有提供任何方法让这些任务之间相互通信。指定多个任务只是为了方便，让你不必运行&lt;code>rake db:create; rake db:migrate; rake db:seed&lt;/code>。如果你想在任务 B 中访问任务 A 的结果，构建工具并不能帮助你；你必须自己管理这种协调。通常，你要做的是把任务 A 的结果塞进文件系统中的一个特殊位置，然后确保任务 B 读取这个特殊位置。这看起来就像用易变的全局变量进行编程，而且它也是很脆弱的。&lt;/p>
&lt;h3 id="handler-和中间件">Handler 和中间件&lt;/h3>
&lt;p>Boot 通过将任务视为&lt;em>中间**件工厂&lt;/em>来解决这个任务通信问题。如果你熟悉 Ring，Boot 的任务工作起来非常相似，所以请随意跳到&lt;a class="link" href="https://www.braveclojure.com/appendix-b/#Anchor" target="_blank" rel="noopener"
>&amp;ldquo;任务是中间件工厂 &amp;ldquo;第 287 页&lt;/a>。如果你对中间件的概念不熟悉，请允许我解释一下! &lt;em>中间件&lt;/em>指的是程序员遵守的一套&lt;em>公约，这样他们就可以灵活地创建特定领域的功能管道。这是相当密集的，所以让我们解除密集。我将在本节中讨论&lt;/em>灵活的部分，并在&lt;a class="link" href="https://www.braveclojure.com/appendix-b/#Anchor-12" target="_blank" rel="noopener"
>&amp;ldquo;文件集合 &amp;ldquo;第 288 页&lt;/a>中介绍&lt;em>特定领域的&lt;/em>。&lt;/p>
&lt;p>为了理解中间件方法与普通函数组合的不同之处，这里有一个组合日常函数的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def strinc (comp str inc))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(strinc 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;4&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个函数组合并没有什么有趣的地方。事实上，这个函数组合是如此的不起眼，以至于我作为一个作家，要对它说些什么都很费劲。有两个函数，各自做自己的事情，现在它们被组成了一个。Whoop-dee-doo!&lt;/p>
&lt;p>中间件为函数组合引入了一个额外的步骤，使你在定义函数管道时有更大的灵活性。假设在前面的例子中，你想对任意的数字返回 &amp;ldquo;我不喜欢这个数字 X&amp;rdquo;，而对其他的东西返回一个字符串化的数字。以下是你如何做到这一点的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn whiney-str
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [rejects]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:pre [(set? rejects)]}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (fn [x]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if (rejects x)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str &amp;#34;I don&amp;#39;t like &amp;#34; x)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str x))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def whiney-strinc (comp (whiney-str #{2}) inc))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(whiney-strinc 1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;I don&amp;#39;t like 2&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在让我们再进一步。如果你想决定是否首先调用&lt;code>inc&lt;/code>呢？清单 B-1 显示了你如何做到这一点。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn whiney-middleware
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [next-handler rejects]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:pre [(set? rejects)]}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (fn [x]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➊ (if (= x 1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;I&amp;#39;m not going to bother doing anything to that&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [y (next-handler x)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if (rejects y)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str &amp;#34;I don&amp;#39;t like &amp;#34; y)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str y))))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def whiney-strinc (whiney-middleware inc #{2}))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(whiney-strinc 1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;I&amp;#39;m not going to bother doing anything to that&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>B-1. 函数组合的中间件方法让你引入选择权&lt;/li>
&lt;/ol>
&lt;p>在这里，你不是用&lt;code>comp&lt;/code>来创建你的函数管道，而是将管道中的下一个函数作为第一个参数传递给中间件函数。在这种情况下，你将&lt;code>inc&lt;/code>作为第一个参数传递给&lt;code>whiney-middleware&lt;/code>作为&lt;code>next-handler&lt;/code>。 &lt;code>whiney-middleware&lt;/code>然后返回一个匿名函数，该函数关闭了&lt;code>inc&lt;/code>并有能力选择是否调用它。你可以在➊看到这个选择。&lt;/p>
&lt;p>我们说，一个中间件把一个 Handler 作为它的第一个参数，并返回一个 Handler。在这个例子中，&lt;code>whiney-middleware&lt;/code>将一个 Handler 作为它的第一个参数，&lt;code>inc&lt;/code>，它返回另一个 Handler，即匿名函数，&lt;code>x&lt;/code>是它唯一的参数。中间件也可以接受额外的参数，如&lt;code>rejects&lt;/code>，作为配置。其结果是，中间件返回的 Handler 可以表现得更加灵活（由于配置），而且它对函数管道有更多的控制（因为它可以选择是否调用下一个 Handler）。&lt;/p>
&lt;h3 id="任务是中间件工厂">任务是中间件工厂&lt;/h3>
&lt;p>Boot 通过将中间件的配置与 Handler 的创建分开，将这种使函数组合更加灵活的模式向前推进了一步。首先，你创建一个接受&lt;em>n&lt;/em>配置参数的函数。这就是&lt;em>中间件工厂&lt;/em>，它返回一个中间件函数。中间件函数希望得到一个参数，即下一个 Handler，并返回一个 Handler，就像前面的例子中一样。下面是一个发牢骚的中间件工厂。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn whiney-middleware-factory
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [rejects]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:pre [(set? rejects)]}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (fn [handler]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (fn [x]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if (= x 1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;I&amp;#39;m not going to bother doing anything to that&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [y (handler x)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if (rejects y)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str &amp;#34;I don&amp;#39;t like &amp;#34; y &amp;#34; :&amp;#39;(&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str y)))))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def whiney-strinc ((whiney-middleware-factory #{3}) inc))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>正如你所看到的，这段代码与清单 B-1 几乎相同。变化在于，最上面的函数，&lt;code>whiney-middleware-factory&lt;/code>，现在只接受一个参数，&lt;code>rejects&lt;/code>。它返回一个匿名函数，即中间件，它希望得到一个参数，即 Handler。其余的代码都是一样的。&lt;/p>
&lt;p>在 Boot 中，任务可以充当中间件工厂。为了说明这一点，让我们把&lt;code>fire&lt;/code>任务分成两个任务：&lt;code>what&lt;/code>和&lt;code>fire&lt;/code>（见清单 B-2）。 &lt;code>what&lt;/code>让你指定一个对象以及它是否是复数，而&lt;code>fire&lt;/code>则宣布它着火了。这是伟大的模块化软件工程，因为它允许你添加其他任务，如&lt;code>gnomes&lt;/code>，宣布一个东西被地精占领了，这在客观上同样有用。(作为一个练习，尝试创建 gnome 任务。它应该和&lt;code>what&lt;/code>任务组成，就像&lt;code>fire&lt;/code>一样）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(deftask what
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Specify a thing&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [t thing THING str &amp;#34;An object&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> p pluralize bool &amp;#34;Whether to pluralize&amp;#34;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (fn middleware [next-handler]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➊ (fn handler [fileset]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (next-handler (merge fileset {:thing thing :pluralize pluralize})))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(deftask fire
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Announce a thing is on fire&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> []
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (fn middleware [next-handler]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➋ (fn handler [fileset]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [verb (if (:pluralize fileset) &amp;#34;are&amp;#34; &amp;#34;is&amp;#34;)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;My&amp;#34; (:thing fileset) verb &amp;#34;on fire!&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> fileset))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>宣布某物着火的可组合 Boot 任务的完整代码&lt;/li>
&lt;/ol>
&lt;p>以下是你如何在命令行上运行它。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">boot what -t &amp;#34;pants&amp;#34; -p - fire
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下面是在 REPL 中的运行方式。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(boot (what :thing &amp;#34;pants&amp;#34; :pluralize true) (fire))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>等一下，那个&lt;code>boot'的调用是怎么回事？在➊和➋的&lt;/code>fileset&lt;code>又是怎么回事？用Micha的话说，&amp;quot;&lt;/code>boot&lt;code>宏负责设置和清理（创建初始文件集合，停止由任务启动的服务器，诸如此类的事情）。任务是函数，所以你可以直接调用它们，但如果它们使用了文件集合，就会失败，除非你通过&lt;/code>boot`宏调用它们。&amp;rdquo; 让我们仔细看看文件集合的情况。&lt;/p>
&lt;h2 id="文件集合">文件集合&lt;/h2>
&lt;p>前面我提到，中间件是用来创建&lt;em>域特定的&lt;/em>函数管道。这意味着每个 Handler 都期望接收特定领域的数据并返回特定领域的数据。以 Ring 为例，每个 Handler 都希望收到一个代表 HTTP 请求的请求 Map，它可能看起来像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">{:server-port 80
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :request-method :get
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :scheme :http}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>每个 Handler 可以选择以某种方式修改这个请求 Map，然后再传递给下一个 Handler，例如，添加一个&lt;code>:params&lt;/code>键，其中包含所有查询字符串和 POST 参数的漂亮 Clojure Map。环形 Handler 返回一个&lt;em>响应 Map&lt;/em>，由&lt;code>:status'、&lt;/code>:headers&amp;rsquo;和`:body&amp;rsquo;三个键组成，每个 Handler 可以再次以某种方式转换这些数据，然后再返回给其父 Handler。&lt;/p>
&lt;p>在 Boot 中，每个 Handler 接收并返回一个&lt;em>fileset&lt;/em>。文件集合的抽象让你把文件系统上的文件当作不可更改的数据，这对构建工具来说是一项伟大的创新，因为构建项目是以文件为中心的。例如，你的项目可能需要在文件系统上放置临时的、中间的文件。通常，在大多数构建工具中，这些文件被放置在一些特别命名的地方，比如，&lt;em>project/target/tmp&lt;/em>。这样做的问题是，&lt;em>project/target/tmp&lt;/em>实际上是一个全局变量，其他任务可能会意外地把它搞乱。&lt;/p>
&lt;p>Boot 的文件集合抽象通过在文件系统上增加一层间接性来解决这个问题。比方说，任务 A 创建了文件 X，并告诉文件集合来存储它。在幕后，文件集合将该文件存储在一个匿名的临时目录中。然后，该文件集合被传递给任务 B，任务 B 修改了文件 X 并要求文件集合存储结果。在幕后，一个新的文件，文件 Y，被创建和存储，但文件 X 仍然没有被触动。在任务 B 中，一个更新的文件集合被返回。这相当于用 Map 做 &amp;ldquo;assoc-in&amp;rdquo;。任务 A 仍然可以访问原始文件集合和它引用的文件。&lt;/p>
&lt;p>在清单 B-2 中的&lt;code>what'和&lt;/code>fire&amp;rsquo;任务中，你甚至都没有使用这些很酷的文件管理功能。尽管如此，当 Boot 组成任务时，它希望 Handler 能接收并返回 fileset 记录。因此，为了跨任务传达你的数据，你偷偷地用&lt;code>(merge fileset {:thing thing :pluralize pluralize})&lt;/code>把它加到文件集合记录中。&lt;/p>
&lt;p>虽然这涵盖了中间件工厂的基本概念，但你还需要学习更多的东西来充分利用文件集合的优势。在 fileset wiki（&lt;em>&lt;a class="link" href="https://github.com/boot-clj/boot/wiki/Filesets" target="_blank" rel="noopener"
>Filesets - boot-clj/boot Wiki - GitHub&lt;/a>&lt;/em>）中，对使用 filesets 的机制都有解释。同时，我希望这些信息能给你一个很好的概念性概述!&lt;/p>
&lt;h2 id="接下来的步骤">接下来的步骤&lt;/h2>
&lt;p>本附录的重点是解释 Boot 背后的概念。不过，Boot 还有一堆其他的功能，比如&lt;code>set-env!&lt;/code>和&lt;code>task-options!&lt;/code>，当你真正使用它的时候，会让你的编程生活更轻松。它提供了惊人的神奇功能，比如提供 classpath 隔离，这样你就可以用一个 JVM 运行多个项目，并让你在无需重启 REPL 的情况下向项目添加新的依赖项。如果 Boot 让你心痒难耐，请查看它的 README，了解更多关于实际使用的信息。另外，它的 wiki 提供了一流的文档。&lt;/p></description></item><item><title>AppendixA 用 Leiningen 构建和开发</title><link>https://example.com/p/appendixa-%E7%94%A8-leiningen-%E6%9E%84%E5%BB%BA%E5%92%8C%E5%BC%80%E5%8F%91/</link><pubDate>Sat, 15 Jan 2022 21:39:36 +0800</pubDate><guid>https://example.com/p/appendixa-%E7%94%A8-leiningen-%E6%9E%84%E5%BB%BA%E5%92%8C%E5%BC%80%E5%8F%91/</guid><description>&lt;h1 id="用-leiningen-构建和开发">用 Leiningen 构建和开发&lt;/h1>
&lt;p>用任何语言编写软件都需要生成&lt;em>工件&lt;/em>，即可执行文件或库包，用于部署或共享。它还涉及到管理依赖工件，也称为&lt;em>依赖&lt;/em>，以确保它们被加载到你正在构建的项目中。Clojurists 中最流行的管理工件的工具是 Leiningen，本附录将告诉你如何使用它。你还将学习如何使用 Leiningen 来完全增强你的开发经验，使用&lt;em>插件&lt;/em>。&lt;/p>
&lt;h2 id="artifact-ecosystem">Artifact Ecosystem&lt;/h2>
&lt;p>因为 Clojure 托管在 Java 虚拟机（JVM）上，所以 Clojure 的工件是以 JAR 文件的形式分发的（在第 12 章有介绍）。Java 地已经有一个处理 JAR 文件的完整的工件生态系统，Clojure 也使用它。&lt;em>神器生态系统&lt;/em>并不是一个官方的编程术语；我用它来指代用于识别和分发神器的一套工具、资源和惯例。Java 的生态系统是围绕着 Maven 构建工具发展起来的，由于 Clojure 使用这个生态系统，你会经常看到对 Maven 的引用。Maven 是一个巨大的工具，可以执行各种古怪的项目管理任务。值得庆幸的是，你不需要获得 Maven 学的博士学位就能成为一名有效的 Clojurist。你需要知道的唯一特征是，Maven 规定了一种识别 Clojure 项目所遵守的工件的模式，它还规定了如何在 Maven &lt;em>仓库&lt;/em>中托管这些工件，Maven *仓库只是存储工件以供分发的服务器。&lt;/p>
&lt;h3 id="identification">Identification&lt;/h3>
&lt;p>Maven 工件需要一个&lt;em>组 ID&lt;/em>，一个&lt;em>工件 ID&lt;/em>，以及一个&lt;em>版本&lt;/em>。你可以在&lt;em>project.clj&lt;/em>文件中为你的项目指定这些。以下是你在第一章创建的&lt;code>clojure-noob&lt;/code>项目的&lt;em>project.clj&lt;/em>第一行的内容。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defproject clojure-noob &amp;#34;0.1.0-SNAPSHOT&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>clojure-noob&lt;/code>是你项目的组 ID 和工件 ID，&lt;code>&amp;quot;0.1.0-SNAPSHOT&amp;quot;&lt;/code>是其版本。一般来说，版本是永久性的；如果你将一个版本为 0.1.0 的工件部署到存储库，你不能对该工件进行修改并使用相同的版本号进行部署。您需要改变版本号。(许多程序员喜欢 Semantic Versioning 系统，您可以在*&lt;a class="link" href="http://semver.org/" target="_blank" rel="noopener"
>Semantic Versioning 2.0.0 | Semantic Versioning&lt;/a>.*中阅读到这一系统。） 如果你想表明该版本是一个正在进行的工作，并且你计划不断地更新它，你可以在你的版本号后面加上&lt;code>-SNAPSHOT&lt;/code>。&lt;/p>
&lt;p>如果你想让你的组 ID 与你的工件 ID 不同，你可以用斜线将两者分开，像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defproject group-id/artifact-id &amp;#34;0.1.0-SNAPSHOT&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通常，开发者会使用他们的公司名称或 GitHub 用户名作为组的 ID。&lt;/p>
&lt;h3 id="依赖">依赖&lt;/h3>
&lt;p>你的&lt;em>project.clj&lt;/em>文件还包括一行看起来像这样的内容，它列出了你项目的依赖。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> :dependencies [[org.clojure/clojure &amp;#34;1.9.0&amp;#34;]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果你想使用一个库，使用与你命名项目时相同的命名模式将其添加到这个依赖 Vector 中。例如，如果你想轻松地处理日期和时间，你可以添加 clj-time 库，像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> :dependencies [[org.clojure/clojure &amp;#34;1.9.0&amp;#34;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [clj-time &amp;#34;0.9.0&amp;#34;]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下次你启动你的项目时，无论是通过运行它还是通过启动 REPL，Leiningen 都会自动下载 clj-time 并使其在你的项目中可用。&lt;/p>
&lt;p>Clojure 社区创造了大量有用的库，寻找它们的好地方是*&lt;a class="link" href="http://www.clojure-toolbox.com/" target="_blank" rel="noopener"
>http://www.clojure-toolbox.com&lt;/a>*的 Clojure 工具箱，它根据项目的目的进行分类。几乎每一个 Clojure 库都在其 README 的顶部提供了它的标识符，使你很容易找出如何把它添加到你的 Leiningen 依赖项中。&lt;/p>
&lt;p>有时你可能想使用一个 Java 库，但标识符并不那么容易获得。例如，如果你想添加 Apache Commons Email，你必须在网上搜索，直到你找到一个包含这样内容的网页。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">&amp;lt;dependency&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;artifactId&amp;gt;commons-email&amp;lt;/artifactId&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;version&amp;gt;1.3.3&amp;lt;/version&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;lt;/dependency&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>该 XML 是 Java 项目沟通其 Maven 标识符的方式。要把它添加到 Clojure 项目中，你需要修改&lt;code>:dependencies&lt;/code>Vector，使其看起来像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> :dependencies [[org.clojure/clojure &amp;#34;1.9.0&amp;#34;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [clj-time &amp;#34;0.9.0&amp;#34;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [org.apache.commons/commons-email &amp;#34;1.3.3&amp;#34;]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>主要的 Clojure 库是 Clojars（&lt;em>&lt;a class="link" href="https://clojars.org/" target="_blank" rel="noopener"
>Clojars&lt;/a>&lt;/em>），主要的 Java 库是 The Central Repository（&lt;em>&lt;a class="link" href="http://search.maven.org/" target="_blank" rel="noopener"
>Maven Central Repository Search&lt;/a>&lt;/em>），人们通常只把它称为&lt;em>Central&lt;/em>，就像旧金山居民把旧金山称为&lt;em>the city&lt;/em>一样。你可以使用这些网站来寻找库和它们的标识符。&lt;/p>
&lt;p>要把你自己的项目部署到 Clojars，你所要做的就是在那里创建一个账户，然后在你的项目中运行&lt;code>lein deploy clojars&lt;/code>。该任务会生成 Maven 工件所需的一切，包括 POM 文件（我就不多说了）和 JAR 文件，以便储存在仓库中。然后将它们上传到 Clojars。&lt;/p>
&lt;h3 id="插件">插件&lt;/h3>
&lt;p>Leiningen 让你使用&lt;em>插件&lt;/em>，这是一些在你写代码时能帮助你的库。例如，Eastwood 插件是一个 Clojure 检查工具；它可以识别写得不好的代码。你通常要在*$HOME/.lein/profiles.clj&lt;em>文件中指定你的插件。要添加 Eastwood，你要把&lt;/em>profiles.clj*改成这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">{:user {:plugins [[jonase/eastwood &amp;#34;0.2.1&amp;#34;]] ] 。}}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就为你的所有项目启用了一个&lt;code>eastwood'Leiningen任务，你可以在项目的根目录下用&lt;/code>lein eastwood&amp;rsquo;运行。&lt;/p>
&lt;p>Leiningen 的 GitHub 项目页面有关于如何使用配置文件和插件的优秀文档，它包括一个方便的插件列表。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本附录着重介绍了项目管理中那些重要但又难以了解的方面，比如什么是 Maven 以及 Clojure 与它的关系。它向你展示了如何使用 Leiningen 来命名你的项目，指定依赖关系，并部署到 Clojars。Leiningen 为软件开发任务提供了很多功能，但并不涉及实际编写代码。如果你想了解更多，请在网上查看 Leiningen 教程*[leiningen/TUTORIAL.md at stable - technomancy/leiningen - GitHub]（&lt;a class="link" href="https://github.com/technomancy/leiningen/blob/stable/doc/TUTORIAL.md" target="_blank" rel="noopener"
>https://github.com/technomancy/leiningen/blob/stable/doc/TUTORIAL.md&lt;/a>）*.&lt;/p></description></item><item><title>Chapter13 抽象</title><link>https://example.com/p/chapter13-%E6%8A%BD%E8%B1%A1/</link><pubDate>Sat, 15 Jan 2022 21:29:04 +0800</pubDate><guid>https://example.com/p/chapter13-%E6%8A%BD%E8%B1%A1/</guid><description>&lt;h1 id="用-multimethods协议和记录创建和扩展抽象概念">用 Multimethods、协议和记录创建和扩展抽象概念&lt;/h1>
&lt;p>花一分钟思考一下，作为大自然的顶级产品之一：人类是多么伟大。作为一个人类，你可以在社交媒体上闲聊，玩龙与地下城，戴帽子。也许更重要的是，你可以用抽象的概念来思考和交流。&lt;/p>
&lt;p>抽象思考的能力确实是人类最好的特征之一。它可以让你规避你的认知极限，将不同的细节捆绑在一起，形成一个整齐的概念包，让你可以在工作记忆中持有。你不需要去想 &amp;ldquo;可挤压的红球鼻子装饰 &amp;ldquo;这种笨重的想法，而只需要 &amp;ldquo;小丑鼻子 &amp;ldquo;这个概念。&lt;/p>
&lt;p>在 Clojure 中，一个&lt;em>抽象&lt;/em>是一个操作的集合，而&lt;em>数据类型&lt;/em>实现抽象。例如，seq 抽象由 &amp;ldquo;first &amp;ldquo;和 &amp;ldquo;rest &amp;ldquo;等操作组成，而 Vector 数据类型是该抽象的实现；它对所有 seq 操作做出响应。像&lt;code>[:seltzer :water]&lt;/code>这样的特定 Vector 是该数据类型的*实例。&lt;/p>
&lt;p>编程语言越是让你以抽象的方式思考和写作，你的生产力就越高。例如，如果你知道一个数据结构是 seq 抽象的一个实例，你就可以立即调用一个大的知识网，了解哪些函数可以与数据结构一起工作。因此，你会花时间去实际使用这个数据结构，而不是不断地去查找关于它如何工作的文档。同样地，如果你扩展一个数据结构，使其与 seq 抽象一起工作，你就可以在上面使用大量的 seq 函数库。&lt;/p>
&lt;p>在第四章中，你了解到 Clojure 是以抽象的方式编写的。这很强大，因为在 Clojure 中，你可以专注于你可以用数据结构实际做的事情，而不用担心实现的细枝末节。本章向你介绍了创建和实现你自己的抽象的世界。你将学习 Multimethods、协议和记录的基础知识。&lt;/p>
&lt;h2 id="多态">多态&lt;/h2>
&lt;p>我们在 Clojure 中实现抽象的主要方式是将一个操作名称与一个以上的算法联系起来。这种技术被称为&lt;em>多态&lt;/em>。例如，在列表上执行 &amp;ldquo;conj &amp;ldquo;的算法与 Vector 的算法不同，但我们把它们统一在同一个名字下，以表明它们实现了同一个概念，即&lt;em>向&lt;/em>这个数据结构添加一个元素。&lt;/p>
&lt;p>因为 Clojure 的许多数据类型都依赖于 Java 的标准库，所以本章中使用了一点 Java。例如，Clojure 的字符串只是 Java 的字符串，是 Java 类&lt;code>java.lang.String&lt;/code>的实例。要在 Java 中定义你自己的数据类型，你要使用类。Clojure 提供了额外的类型结构。 &lt;em>记录&lt;/em>和&lt;em>类型&lt;/em>。本书只涉及记录。&lt;/p>
&lt;p>在我们学习记录之前，让我们看看 Multimethods，这是我们定义多态行为的第一个工具。&lt;/p>
&lt;h3 id="multimethods">Multimethods&lt;/h3>
&lt;p>&lt;em>Multimethods&lt;/em>为你提供了一种直接的、灵活的方法，将多态引入你的代码中。使用 Multimethods，你可以通过定义一个&lt;em>调度函数&lt;/em>将一个名字与多个实现联系起来，该函数产生&lt;em>调度值&lt;/em>，用来决定使用哪个&lt;em>方法&lt;/em>。调度函数就像餐厅里的主人。主人会问你一些问题，比如 &amp;ldquo;你有预订吗？&amp;ldquo;和 &amp;ldquo;聚会人数？&amp;quot;，然后给你安排相应的座位。同样，当你调用一个 Multimethods 时，调度函数将询问参数，并将它们发送到正确的方法，正如这个例子所显示的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns were-creatures)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➊ (defmulti full-moon-behavior (fn [were-creature] (:were-type were-creature)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➋ (defmethod full-moon-behavior :wolf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [were-creature]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str (:name were-creature) &amp;#34; will howl and murder&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➌ (defmethod full-moon-behavior :simmons
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [were-creature]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str (:name were-creature) &amp;#34; will encourage people and sweat to the oldies&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(full-moon-behavior {:were-type :wolf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➍ :name &amp;#34;Rachel from next door&amp;#34;})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Rachel from next door will howl and murder&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(full-moon-behavior {:name &amp;#34;Andy the baker&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➎ :were-type :simmons})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Andy the baker will encourage people and sweat to the oldies&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个 Multimethods 显示了你如何定义不同种类的狼人生物的满月行为。大家都知道狼人变成了狼，到处嚎叫着杀人。一种不太知名的狼人，即狼-西蒙斯，变成理查德-西蒙斯，烫着头发，到处跑，鼓励人们做最好的自己，为老人们流汗。你不想被这两种生物咬到，否则你就会变成它们。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/multimethods-records-protocols/weresimmons.png"
loading="lazy"
>&lt;/p>
&lt;p>我们在➊处创建 Multimethods。这告诉 Clojure，&amp;ldquo;嘿，创建一个名为&lt;code>full-moon-behavior'的新Multimethods。每当有人调用&lt;/code>full-moon-behavior&lt;code>时，在参数上运行调度函数&lt;/code>(fn [were-creature] (:were-type were-creature))`。使用该函数的结果，也就是调度值，来决定使用哪个具体方法！&amp;rdquo;&lt;/p>
&lt;p>接下来，我们定义了两个方法，一个是当调度函数返回的值是➋的&lt;code>:wolf&lt;/code>时，另一个是当它是➌的&lt;code>:simmons&lt;/code>时。方法定义看起来很像函数定义，但主要的区别是，方法名称后面紧跟着&lt;em>dispatch 值&lt;/em>。 &lt;code>:wolf&lt;/code>和&lt;code>:simmons&lt;/code>都是&lt;em>dispatch 值&lt;/em>。这与调度*值不同，后者是调度函数的返回值。完整的调度序列是这样的。&lt;/p>
&lt;ol>
&lt;li>形式&lt;code>(full-moon-behavior {:wer-type :wolf :name &amp;quot;Rachel from next door&amp;quot;})&lt;/code>被求值。&lt;/li>
&lt;li>运行&lt;code>full-moon-behavior&lt;/code>的调度函数，返回&lt;code>:wolf&lt;/code>作为调度值。&lt;/li>
&lt;li>Clojure 将调度值&lt;code>:wolf&lt;/code>与为&lt;code>full-moon-behavior&lt;/code>定义的所有方法的调度值相比较。这些调度值是&lt;code>:wolf&lt;/code>和&lt;code>:simmons&lt;/code>。&lt;/li>
&lt;li>因为调度值&lt;code>:wolf&lt;/code>等于调度值&lt;code>:wolf&lt;/code>，所以&lt;code>:wolf&lt;/code>的算法运行。&lt;/li>
&lt;/ol>
&lt;p>不要让术语把你绊倒! 主要的想法是，调度函数返回一些值，这个值被用来决定使用哪个方法定义。&lt;/p>
&lt;p>回到我们的例子! 接下来我们调用该方法两次。在➍处，调度函数返回值&amp;rdquo;:wolf&amp;rdquo;，并使用相应的方法，通知你 &amp;ldquo;隔壁的 Rachel 将嚎叫并杀人&amp;rdquo;。在➏，该函数的行为类似，只是&lt;code>:simmons&lt;/code>是调度值。&lt;/p>
&lt;p>你可以定义一个以&lt;code>nil&lt;/code>为调度值的方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmethod full-moon-behavior nil
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [were-creature]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str (:name were-creature) &amp;#34; will stay at home and eat ice cream&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(full-moon-behavior {:were-type nil
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :name &amp;#34;Martin the nurse&amp;#34;})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Martin the nurse will stay at home and eat ice cream&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当你这次调用&lt;code>full-moon-behavior&lt;/code>时，你给它的参数&lt;code>:wer-type&lt;/code>是&lt;code>nil&lt;/code>，所以对应于&lt;code>nil&lt;/code>的方法被求值，你被告知`&amp;ldquo;护士 Martin 将呆在家里吃冰淇淋&amp;rdquo;。&lt;/p>
&lt;p>你也可以通过指定&lt;code>:default&lt;/code>作为调度值，定义一个默认方法，在没有其他方法匹配的情况下使用。在这个例子中，给出的参数的&lt;code>:were-type&lt;/code>与之前定义的方法都不匹配，所以使用了默认方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmethod full-moon-behavior :default
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [were-creature]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str (:name were-creature) &amp;#34; will stay up all night fantasy footballing&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(full-moon-behavior {:were-type :office-worker
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :name &amp;#34;Jimmy from sales&amp;#34;})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Jimmy from sales will stay up all night fantasy footballing&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Multimethods 的一个很酷的地方是，你可以随时添加新的方法。如果你发布了一个包括&lt;code>wer-creatures&lt;/code>命名空间的库，其他人可以继续扩展 Multimethods 来处理新的派发值。这个例子显示，你创建了自己的随机命名空间并包括了&lt;code>wer-creatures&lt;/code>命名空间，然后为&lt;code>full-moon-behavior&lt;/code>Multimethods 定义了另一个方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns random-namespace
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (:require [were-creatures]))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defmethod were-creatures/full-moon-behavior :bill-murray
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [were-creature]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str (:name were-creature) &amp;#34; will be the most likeable celebrity&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(were-creatures/full-moon-behavior {:name &amp;#34;Laura the intern&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :were-type :bill-murray})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Laura the intern will be the most likeable celebrity&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你的调度函数可以使用它的任何或所有参数返回任意的值。下一个例子定义了一个 Multimethods，它接收两个参数，并返回一个包含每个参数类型的 Vector。它还定义了该方法的一个实现，当每个参数都是字符串时，该方法将被调用。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns user)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defmulti types (fn [x y] [(class x) (class y)]))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defmethod types [java.lang.String java.lang.String]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [x y]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Two strings!&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(types &amp;#34;String 1&amp;#34; &amp;#34;String 2&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Two strings!&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>顺便说一下，这就是为什么它们被称为&lt;em>multi&lt;/em>methods：它们允许对多个参数进行调度。我没有经常使用这个功能，但我可以看到它被用于角色扮演游戏中，根据法师的主要魔法学校和他的魔法专长来编写方法。无论如何，有它而不需要它总比需要它而没有它好。&lt;/p>
&lt;p>注意 Multimethods 也允许分层调度。Clojure 可以让你建立自定义的层次结构，我不会介绍这些，但你可以通过阅读&lt;a class="link" href="http://clojure.org/multimethods/" target="_blank" rel="noopener"
>http://clojure.org/multimethods/&lt;/a> 的文档来了解它们。&lt;/p>
&lt;h3 id="协议">协议&lt;/h3>
&lt;p>在大约 93.58%的情况下，你会希望根据参数的类型来调度方法。例如，&lt;code>count&lt;/code>需要对 Vector 使用不同的方法，而不是对 map 或 list 使用不同的方法。尽管可以用 Multimethods 进行类型调度，但&lt;em>协议&lt;/em>是为类型调度而优化的。它们比 Multimethods 更有效，而且 Clojure 让你很容易简洁地指定协议的实现。&lt;/p>
&lt;p>Multimethods 只是一个多态的操作，而协议是一个&lt;em>集合&lt;/em>的一个或多个多态操作。协议操作被称为方法，就像 Multimethods 操作一样。与 Multimethods 不同的是，Multimethods 对调度函数返回的任意值进行调度，而协议方法是根据第一个参数的类型进行调度，如本例所示。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns data-psychology)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➊(defprotocol ➋Psychodynamics
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ➌&amp;#34;Plumb the inner depths of your data types&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ➍(thoughts [x] &amp;#34;The data type&amp;#39;s innermost thoughts&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ➎(feelings-about [x] [x y] &amp;#34;Feelings about self or other&amp;#34;))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>首先，在➊有&lt;code>defprotocol&lt;/code>。这需要一个名字，&lt;code>Psychodynamics&lt;/code> ➋，和一个可选的文件串，&lt;code>&amp;quot;探究你的数据类型的内部深度&amp;quot;&lt;/code>➌。接下来是方法签名。一个&lt;em>方法签名&lt;/em>由一个名称、一个参数说明和一个可选的文档串组成。第一个方法签名被命名为&lt;code>thoughts&lt;/code>➍，只能接受一个参数。第二个名为&lt;code>feelings-about&lt;/code>➎，可以接受一个或两个参数。协议有一个限制：方法不能有其余参数。所以像下面这样的行是不允许的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(feels-about [x] [x &amp;amp; others])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通过定义一个协议，你在定义一个抽象，但你还没有定义如何实现这个抽象。这就像你为行为保留了名字（在这个例子中，你保留了&lt;code>思想&lt;/code>和&lt;code>感觉-关于&lt;/code>），但你还没有定义具体的行为。如果你要求值&lt;code>(thoughts &amp;quot;blorb&amp;quot;)&lt;/code>，你会得到一个异常，内容是：&amp;ldquo;没有为 java.lang.String 类找到方法的实现：protocol: data-psychology/psychodynamics 的 thoughts。&amp;rdquo; 协议是根据第一个参数的类型分配的，所以当你调用&lt;code>(thoughts &amp;quot;blorb&amp;quot;)&lt;/code>时，Clojure 试图为字符串查找&lt;code>thoughts&lt;/code>方法的实现，但失败了。&lt;/p>
&lt;p>你可以通过&lt;em>扩展&lt;/em>字符串数据类型来&lt;em>实现&lt;/em>&lt;code>Psychodynamics&lt;/code>协议来解决这一遗憾。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">➊ (extend-type java.lang.String
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➋ Psychodynamics
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➌ (thoughts [x] (str x &amp;#34; thinks, &amp;#39;Truly, the character defines the data type&amp;#39;&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➍ (feelings-about
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([x] (str x &amp;#34; is longing for a simpler way of life&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([x y] (str x &amp;#34; is envious of &amp;#34; y &amp;#34;&amp;#39;s simpler way of life&amp;#34;))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(thoughts &amp;#34;blorb&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➎ ; =&amp;gt; &amp;#34;blorb thinks, &amp;#39;Truly, the character defines the data type&amp;#39;&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(feelings-about &amp;#34;schmorb&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;schmorb is longing for a simpler way of life&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(feelings-about &amp;#34;schmorb&amp;#34; 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;schmorb is envious of 2&amp;#39;s simpler way of life&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>extend-type&lt;/code>后面是你想扩展的类或类型的名称和你想让它支持的协议&amp;ndash;在这个例子中，你在➊处指定了类&lt;code>java.lang.String&lt;/code>和你想让它支持的协议&lt;code>Psychodynamics&lt;/code>，在➋。之后，你在➌为 &amp;ldquo;thoughts &amp;ldquo;方法和➍为 &amp;ldquo;feelings-about &amp;ldquo;方法提供一个实现。如果你要扩展一个类型来实现一个协议，你必须实现协议中的每一个方法，否则 Clojure 会抛出一个异常。在这种情况下，你不能只实现&lt;code>思想'或只实现&lt;/code>感觉&amp;rsquo;；你必须同时实现这两种方法。&lt;/p>
&lt;p>注意，这些方法的实现不像 Multimethods 那样以&lt;code>defmethod&lt;/code>开头。事实上，它们看起来类似于函数定义，只是没有&lt;code>defn'。要定义一个方法的实现，你要写一个以方法名称开头的表格，像&lt;/code>thoughts&amp;rsquo;，然后提供一个参数 Vector 和方法的主体。这些方法也允许重载，就像函数一样，你定义多重性的方法实现与多重性的函数类似。你可以在➍的 &amp;ldquo;feelings-about &amp;ldquo;实现中看到这一点。&lt;/p>
&lt;p>在你扩展了&lt;code>java.lang.String&lt;/code>类型以实现&lt;code>Psychodynamics&lt;/code>协议后，Clojure 知道如何调度调用&lt;code>(thoughts &amp;quot;blorb&amp;quot;)&lt;/code>，你会在➎得到字符串`&amp;ldquo;blorb thinks, &amp;lsquo;Truly, the character defines the data type&amp;rsquo;&amp;quot;。&lt;/p>
&lt;p>如果你想提供一个默认的实现，就像你对 multimethods 所做的那样呢？要做到这一点，你可以扩展&lt;code>java.lang.Object&lt;/code>。这样做是因为 Java（也就是 Clojure）中的每个类型都是&lt;code>java.lang.Object&lt;/code>的后代。如果这不是很有意义（也许是因为你不熟悉面向对象的编程），不要担心，只要知道它是有效的。下面是你如何使用这个技术为&lt;code>Psychodynamics&lt;/code>协议提供一个默认实现。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(extend-type java.lang.Object
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Psychodynamics
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (thoughts [x] &amp;#34;Maybe the Internet is just a vector for toxoplasmosis&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (feelings-about
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([x] &amp;#34;meh&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([x y] (str &amp;#34;meh about &amp;#34; y))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(thoughts 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Maybe the Internet is just a vector for toxoplasmosis&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(feelings-about 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;meh&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(feelings-about 3 &amp;#34;blorb&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;meh about blorb&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>因为我们还没有为数字定义一个&lt;code>心理动力学'的实现，Clojure将对&lt;/code>思想&amp;rsquo;和&lt;code>感觉-关于'的调用分派给为&lt;/code>java.lang.Object&amp;rsquo;定义的实现。&lt;/p>
&lt;p>你可以使用&lt;code>extend-protocol'来代替多次调用&lt;/code>extend-type&amp;rsquo;来扩展多个类型，它可以让你一次为多个类型定义协议实现。下面是你如何定义前面的协议实现。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(extend-protocol Psychodynamics
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> java.lang.String
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (thoughts [x] &amp;#34;Truly, the character defines the data type&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (feelings-about
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([x] &amp;#34;longing for a simpler way of life&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([x y] (str &amp;#34;envious of &amp;#34; y &amp;#34;&amp;#39;s simpler way of life&amp;#34;)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> java.lang.Object
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (thoughts [x] &amp;#34;Maybe the Internet is just a vector for toxoplasmosis&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (feelings-about
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([x] &amp;#34;meh&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([x y] (str &amp;#34;meh about &amp;#34; y))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可能会发现这个技术比使用&lt;code>extend-type&lt;/code>更方便。然后，你也可能不觉得。&lt;code>extend-type&lt;/code>让你感觉如何？&lt;code>extend-protocol&lt;/code>怎么样？来坐在这个沙发上，告诉我这一切。&lt;/p>
&lt;p>值得注意的是，一个协议的方法 &amp;ldquo;属于 &amp;ldquo;它们所定义的命名空间。在这些例子中，&amp;ldquo;心理动力学 &amp;ldquo;方法的完全限定名称是 &amp;ldquo;数据-心理学/想法 &amp;ldquo;和 &amp;ldquo;数据-心理学/感觉-关于&amp;rdquo;。如果你有面向对象的背景，这可能看起来很奇怪，因为方法属于 OOP 中的数据类型。但不要吓坏了! 这只是 Clojure 赋予抽象优先权的另一种方式。这个事实的一个后果是，如果你想让两个不同的协议包括具有相同名称的方法，你需要把协议放在不同的命名空间中。&lt;/p>
&lt;h2 id="记录">记录&lt;/h2>
&lt;p>Clojure 允许你创建&lt;em>records&lt;/em>，它是自定义的、类似 Map 的数据类型。它们类似于 Map，因为它们将键和值联系起来，你可以像使用 Map 一样查询它们的值，而且它们像 Map 一样是不可改变的。它们的不同之处在于，你为记录指定*字段。字段是数据的槽；使用它们就像指定一个数据结构应该有哪些键。记录也与 Map 不同，你可以扩展它们来实现协议。&lt;/p>
&lt;p>要创建一个记录，你可以使用&lt;code>defrecord&lt;/code>来指定它的名字和字段。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns were-records)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defrecord WereWolf [name title])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个记录的名字是&lt;code>WereWolf&lt;/code>，它的两个字段是&lt;code>name&lt;/code>和&lt;code>title&lt;/code>。你可以通过三种方式创建这个记录的实例。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">➊ (WereWolf. &amp;#34;David&amp;#34; &amp;#34;London Tourist&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #were_records.WereWolf{:name &amp;#34;David&amp;#34;, :title &amp;#34;London Tourist&amp;#34;}.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➋ (-&amp;gt;WereWolf &amp;#34;Jacob&amp;#34; &amp;#34;Lead Shirt Discarder&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #were_records.WereWolf{:name &amp;#34;Jacob&amp;#34;, :title &amp;#34;Lead Shirt Discarder&amp;#34;}。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➌ (map-&amp;gt;WereWolf {:name &amp;#34;Lucian&amp;#34; :title &amp;#34;CEO of Melodrama&amp;#34;})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #were_records.WereWolf{:name &amp;#34;Lucian&amp;#34;, :title &amp;#34;CEO of Melodrama&amp;#34;}.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在➊，我们以创建 Java 对象的方式创建一个实例，使用类实例化的互操作调用。(&lt;em>Interop&lt;/em>指的是在 Clojure 中与本地 Java 结构交互的能力)。请注意，参数必须遵循与字段定义相同的顺序。这样做的原因是，记录实际上是被掩盖的 Java 类。&lt;/p>
&lt;p>➋的实例看起来与➊的实例几乎相同，但关键的区别在于&lt;code>-&amp;gt;WereWolf&lt;/code>是一个函数。当你创建一条记录时，工厂函数&lt;code>-&amp;gt;&lt;/code>RecordName 和&lt;code>map-&amp;gt;&lt;/code>RecordName 会自动创建。在➌，&lt;code>map-&amp;gt;WereWolf&lt;/code>接收一个 map 作为参数，其关键字与记录类型的字段相对应，并返回一个记录。&lt;/p>
&lt;p>如果你想使用其他命名空间的记录类型，你必须导入它，就像你在第 12 章中对 Java 类所做的那样。请注意将命名空间中的所有破折号替换为下划线。这个简单的例子显示了如何在另一个命名空间导入&lt;code>WereWolf&lt;/code>记录类型。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns monster-mash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (:import [were_records WereWolf])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(WereWolf. &amp;#34;David&amp;#34; &amp;#34;London Tourist&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #were_records.WereWolf{:name &amp;#34;David&amp;#34;, :title &amp;#34;London Tourist&amp;#34;}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，&lt;code>were_records&lt;/code>有一个下划线，而不是破折号。&lt;/p>
&lt;p>你可以用查询 Map 值的方式查询记录值，也可以使用 Java 字段访问互操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def jacob (-&amp;gt;WereWolf &amp;#34;Jacob&amp;#34; &amp;#34;Lead Shirt Discarder&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➊ (.name jacob)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Jacob&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➋ (:name jacob)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Jacob&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➌ (get jacob :name)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">;=&amp;gt; &amp;#34;Jacob&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>第一个例子&lt;code>(.name jacob)&lt;/code>在➊，使用了 Java 互操作，➋和➌的例子访问&lt;code>:name&lt;/code>的方式与使用 map 相同。&lt;/p>
&lt;p>当测试相等时，Clojure 将检查所有字段是否相等，以及两个比较体是否具有相同的类型。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">➊ (= jacob (-&amp;gt;WereWolf &amp;#34;Jacob&amp;#34; &amp;#34;Lead Shirt Discarder&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➋ (= jacob (WereWolf. &amp;#34;David&amp;#34; &amp;#34;London Tourist&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; false
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➌ (= jacob {:name &amp;#34;Jacob&amp;#34; :title &amp;#34;Lead Shirt Discarder&amp;#34;})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; false
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>➊处的测试返回&lt;code>true&lt;/code>，因为&lt;code>jacob'和新创建的记录是同一类型，并且它们的字段是相等的。➋处的测试返回 &amp;quot;false&amp;quot;，因为字段不相等。最后在➌处的测试返回 &amp;quot;false&amp;quot;，因为两个比较对象的类型不一样。&lt;/code>jacob&amp;rsquo;是一个`WereWolf&amp;rsquo;记录，而另一个参数是一个 Map。&lt;/p>
&lt;p>任何你能在 Map 上使用的函数，你也能在记录上使用。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(assoc jacob :title &amp;#34;Lead Third Wheel&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #were_records.WereWolf{:name &amp;#34;Jacob&amp;#34;, :title &amp;#34;Lead Third Wheel&amp;#34;}。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然而，如果你&lt;code>dissoc&lt;/code>一个字段，结果的类型将是一个普通的&amp;rsquo;Clojure map；它将不会有与原始记录相同的数据类型。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(dissoc jacob :title)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:name &amp;#34;Jacob&amp;#34;} &amp;lt;- that&amp;#39;s not a were_records.WereWolf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这至少有两个原因：第一，访问 Map 值比访问记录值要慢，所以如果你要建立一个高性能的程序，就要注意了。第二，当你创建一个新的记录类型时，你可以扩展它来实现一个协议，类似于你之前使用&lt;code>extend-type&lt;/code>扩展一个类型。如果你&lt;code>dissoc&lt;/code>一个记录，然后试图在结果上调用一个协议方法，记录的协议方法就不会被调用。&lt;/p>
&lt;p>下面是你在定义记录时如何扩展一个协议。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">➊ (defprotocol WereCreature
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➋ (full-moon-behavior [x]))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➌ (defrecord WereWolf [name title]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> WereCreature
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (full-moon-behavior [x]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str name &amp;#34; will howl and murder&amp;#34;)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(full-moon-behavior (map-&amp;gt;WereWolf {:name &amp;#34;Lucian&amp;#34; :title &amp;#34;CEO of Melodrama&amp;#34;}))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Lucian will howl and murder&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们创建了一个新的协议，&lt;code>WereCreature&lt;/code> ➊，有一个方法，&lt;code>full-moon-behavior&lt;/code> ➋。在➌，&lt;code>defrecord&lt;/code>为&lt;code>WereWolf&lt;/code>实现了&lt;code>WereCreature&lt;/code>。在&lt;code>full-moon-behavior&lt;/code>实现中最有趣的部分是你可以访问&lt;code>name&lt;/code>。你还可以访问&lt;code>title'和任何其他可能为你的记录定义的字段。你也可以使用&lt;/code>extend-type&lt;code>和&lt;/code>extend-protocol`来扩展记录。&lt;/p>
&lt;p>你什么时候应该使用记录，什么时候应该使用 Map？一般来说，如果你发现自己在创建 Map 时反复使用相同的字段，你应该考虑使用记录。这告诉你，这组数据代表了你的应用程序领域的信息，如果你提供一个基于你试图建模的概念的名称，你的代码将更好地传达其目的。不仅如此，记录访问比 Map 访问更有表现力，所以你的程序会变得更有效率一些。最后，如果你想使用协议，你就需要创建一个记录。&lt;/p>
&lt;h2 id="进一步研究">进一步研究&lt;/h2>
&lt;p>Clojure 提供了其他的工具来处理抽象和数据类型。这些工具，我认为是高级的，包括&lt;code>deftype&lt;/code>，&lt;code>reify&lt;/code>，和&lt;code>proxy&lt;/code>。如果你有兴趣了解更多，请查看*&lt;a class="link" href="http://clojure.org/reference/datatypes/" target="_blank" rel="noopener"
>http://clojure.org/datatypes/&lt;/a>*上关于数据类型的文档。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>Clojure 的设计原则之一就是要写到抽象。在本章中，你学到了如何使用 Multimethods 和原型来定义你自己的抽象概念。这些结构提供了多态，允许同一个操作根据它的参数有不同的表现。你还学会了如何用&lt;code>defrecord&lt;/code>创建和使用自己的关联数据类型，以及如何扩展记录来实现协议。&lt;/p>
&lt;p>当我刚开始学习 Clojure 时，我对使用 Multimethods、协议和记录感到很害羞。然而，它们在 Clojure 库中经常被使用，所以了解它们的工作原理是很好的。一旦你掌握了它们，它们会帮助你写出更干净的代码。&lt;/p>
&lt;h2 id="练习">练习&lt;/h2>
&lt;ol>
&lt;li>扩展&lt;code>full-moon-behavior&lt;/code>Multimethods，为你自己的 were-creature 类型添加行为。&lt;/li>
&lt;li>创建一个&lt;code>WereSimmons&lt;/code>记录类型，然后扩展&lt;code>WereCreature&lt;/code>协议。&lt;/li>
&lt;li>创建你自己的协议，然后使用&lt;code>extend-type&lt;/code>和&lt;code>extend-protocol&lt;/code>来扩展它。&lt;/li>
&lt;li>创建一个角色扮演游戏，使用多重调度来实现行为。&lt;/li>
&lt;/ol></description></item><item><title>Chapter12 与 Java 的互操作</title><link>https://example.com/p/chapter12-%E4%B8%8E-java-%E7%9A%84%E4%BA%92%E6%93%8D%E4%BD%9C/</link><pubDate>Sat, 15 Jan 2022 20:55:18 +0800</pubDate><guid>https://example.com/p/chapter12-%E4%B8%8E-java-%E7%9A%84%E4%BA%92%E6%93%8D%E4%BD%9C/</guid><description>&lt;h1 id="与-jvm-一起工作">与 JVM 一起工作&lt;/h1>
&lt;p>在每个 Clojurist 的生命中都会有这么一天，她必须从纯函数和不可变数据结构的庇护所冒险进入野蛮的 Java 大陆。这段艰难的旅程是必要的，因为 Clojure 是在 Java 虚拟机（JVM）上托管的，这赋予了它三个基本特性。&lt;/p>
&lt;p>赋予它三个基本特征。首先，你运行 Clojure 应用程序的方式与你运行 Java 应用程序的方式相同。第二，你需要使用 Java 对象来实现核心功能，如读取文件和处理日期。第三，Java 有一个庞大的有用库的生态系统，你需要对 Java 有一定的了解才能使用它们。&lt;/p>
&lt;p>这样一来，Clojure 就有点像一个乌托邦社区，被放置在一个乌托邦国家的中间。显然，你更愿意与其他乌托邦人互动，但偶尔你也需要与当地人交谈，以便完成工作。&lt;/p>
&lt;p>这一章就像一本短语书和 Java 国家的文化介绍之间的交叉。你将了解什么是 JVM，它是如何运行程序的，以及如何为它编译程序。本章还将为你简要介绍常用的 Java 类和方法，并解释如何使用 Clojure 与它们互动。你将学会如何思考和理解 Java，以便将任何 Java 库纳入你的 Clojure 程序中。&lt;/p>
&lt;p>要运行本章的例子，你需要在电脑上安装 1.6 或更高版本的 Java 开发工具包（JDK）。你可以通过在终端运行&lt;code>javac -version&lt;/code>来检查。你应该看到类似 &amp;ldquo;java 1.8.0_40 &amp;ldquo;的内容；如果没有，请访问&lt;a class="link" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener"
>&lt;em>http://www.oracle.com/&lt;/em>&lt;/a>，下载最新的 JDK。&lt;/p>
&lt;h2 id="jvm">JVM&lt;/h2>
&lt;p>开发人员用 JVM 这个词来指代一些不同的东西。你会听到他们说，&amp;ldquo;Clojure 在&lt;em>the&lt;/em> JVM 上运行&amp;rdquo;，你也会听到，&amp;ldquo;Clojure 程序在&lt;em>a&lt;/em> JVM 中运行&amp;rdquo;。在第一种情况下，JVM 指的是一个抽象概念&amp;ndash;Java 虚拟机的一般模型。在第二种情况下，它指的是一个进程&amp;ndash;一个正在运行的程序的实例。我们将专注于 JVM 模型，但当我们谈论运行中的 JVM 进程时，我将指出来。&lt;/p>
&lt;p>为了理解 JVM，让我们回头看看普通的计算机是如何工作的。在计算机心脏的深处是它的 CPU，而 CPU 的工作是执行像&lt;em>加和&lt;/em>无符号乘法这样的操作。你可能听说过程序员将这些指令编码在打卡机上、灯泡里、乌龟壳的神圣缝隙里，或者&lt;em>什么的，但现在这些操作在汇编语言中用 ADD 和 MUL 这样的记忆符号表示。CPU 架构（X86、ARMv7，等等）决定了哪些操作可以作为该架构的&lt;/em>指令集的一部分。&lt;/p>
&lt;p>由于用汇编语言编程并不有趣，人们发明了像 C 和 C++这样的高级语言，将其编译成 CPU 可以理解的指令。大体上说，这个过程是&lt;/p>
&lt;ol>
&lt;li>编译器读取源代码。&lt;/li>
&lt;li>编译器输出一个包含机器指令的文件。&lt;/li>
&lt;li>CPU 执行这些指令。&lt;/li>
&lt;/ol>
&lt;p>在图 12-1 中注意到，最终，你必须将程序翻译成 CPU 能够理解的指令，而 CPU 并不关心你用哪种编程语言来产生这些指令。&lt;/p>
&lt;p>JVM 类似于计算机，它也需要将代码翻译成低级别的指令，称为&lt;em>Java 字节码&lt;/em>。然而，作为一个&lt;em>虚拟&lt;/em>机器，这种翻译是作为软件而不是硬件实现的。运行中的 JVM 通过将字节码实时翻译成主机可以理解的机器代码来执行，这个过程被称为&lt;em>及时**编译&lt;/em>。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/java/compile.png"
loading="lazy"
>&lt;/p>
&lt;p>图 12-1：C 语言程序如何被翻译成机器码的高级概述&lt;/p>
&lt;p>为了让一个程序在 JVM 上运行，它必须被编译成 Java 字节码。通常，当你编译程序时，产生的字节码被保存在一个*.class&lt;em>文件中。然后你会把这些文件打包在&lt;/em>Java 归档*文件（JAR 文件）中。就像 CPU 不关心你用哪种编程语言来生成机器指令一样，JVM 也不关心你如何创建字节码。它不关心你是否使用 Scala、JRuby、Clojure，甚至是 Java 来创建 Java 字节码。一般来说，这个过程就像图 12-2 中所示的那样。&lt;/p>
&lt;ol>
&lt;li>Java 编译器读取源代码。&lt;/li>
&lt;li>编译器输出字节码，通常是在一个 JAR 文件中。&lt;/li>
&lt;li>JVM 执行字节码。&lt;/li>
&lt;li>VM 向 CPU 发送机器指令。&lt;/li>
&lt;/ol>
&lt;p>当有人说 Clojure 在 JVM 上运行时，他们的意思之一是 Clojure 程序被编译成 Java 字节码，JVM 进程执行它们。从操作的角度来看，这意味着你对待 Clojure 程序和 Java 程序是一样的。你把它们编译成 JAR 文件，并使用&lt;code>java&lt;/code>命令运行它们。如果客户需要一个在 JVM 上运行的程序，你可以偷偷地用 Clojure 而不是 Java 来编写，他们不会知道的。从外面看，你无法分辨 Java 和 Clojure 程序之间的区别，就像你无法分辨 C 和 C++程序之间的区别一样。Clojure 可以让你变得富有成效，而且是偷偷摸摸的。&lt;/p>
&lt;p>！&lt;a class="link" href="https://www.braveclojure.com/assets/images/cftbat/java/jvm-compile.png" target="_blank" rel="noopener"
>&lt;/a>&lt;/p>
&lt;p>图 12-2：Java 程序产生 JVM 字节码，但 JVM 仍然需要产生机器指令，就像 C 语言编译器一样。&lt;/p>
&lt;h2 id="编写编译和运行一个-java-程序">编写、编译和运行一个 Java 程序&lt;/h2>
&lt;p>让我们来看看一个真正的 Java 程序是如何工作的。在本节中，你将了解到 Java 所使用的面向对象的范式。然后，你将用 Java 建立一个简单的海盗短语书。这将帮助你对 JVM 感到更加舒适，它将为即将到来的 Java 互操作（编写直接使用 Java 类、对象和方法的 Clojure 代码）一节做好准备，如果有一个恶棍试图在公海上破坏你的战利品，它就会派上用场。为了把所有的信息联系在一起，你将在本章的最后偷看一些 Clojure 的 Java 代码。&lt;/p>
&lt;h3 id="面向对象的编程在世界最微小的果壳中的应用">面向对象的编程在世界最微小的果壳中的应用&lt;/h3>
&lt;p>Java 是一种面向对象的语言，所以如果你想了解你在 Clojure 编程中使用 Java 库或编写 Java 互操作代码时发生了什么，你就需要了解面向对象编程（OOP）是如何工作的。你也会在 Clojure 文档中发现面向对象的术语，所以学习这些概念很重要。如果你精通 OOP，可以随意跳过本节。对于那些需要两分钟了解的人来说，这里是：OOP 的核心角色是&lt;em>类&lt;/em>、&lt;em>对象&lt;/em>和&lt;em>方法&lt;/em>。&lt;/p>
&lt;p>我认为对象是真正的、真正的、可笑的蠢货机器人。它们是那种永远不会引起哲学辩论的机器人，即强迫有知觉的生物进行永久的奴役的伦理。这些机器人只做两件事：他们响应命令和维护数据。在我的想象中，它们通过在小 Hello Kitty 剪贴板上写下东西来做这件事。&lt;/p>
&lt;p>想象一下，一个制造这些机器人的工厂。机器人所理解的命令集和它所维护的数据集都是由制造机器人的工厂决定的。在 OOP 术语中，工厂对应于类，androids 对应于对象，而命令对应于方法。例如，你可能有一个&lt;code>ScaryClown'工厂（类），它生产的androids（对象）响应&lt;/code>makeBalloonArt&amp;rsquo;命令（方法）。这个安卓机一直跟踪它所拥有的气球的数量，然后在气球的数量发生变化时更新这个数字。它可以用&lt;code>balloonCount&lt;/code>报告这个数字，用&lt;code>receiveBalloons&lt;/code>接收任何数量的气球。下面是你如何与代表小丑 Belly Rubs 的 Java 对象进行交互。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ScaryClown bellyRubsTheClown = new ScaryClown();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bellyRubsTheClown.balloonCount();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// =&amp;gt; 0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bellyRubsTheClown.receiveBalloons(2);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bellyRubsTheClown.balloonCount();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// =&amp;gt; 2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bellyRubsTheClown.makeBalloonArt();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// =&amp;gt; &amp;#34;Belly Rubs makes a balloon shaped like a clown, because Belly Rubs
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// =&amp;gt; is trying to scare you and nothing is scarier than clowns.&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个例子告诉你如何使用&lt;code>ScaryClown&lt;/code>类创建一个新的对象&lt;code>bellyRubsTheClown&lt;/code>。它还向你展示了如何在该对象上调用方法（如&lt;code>气球计数'、&lt;/code>接收气球&amp;rsquo;和`制作气球艺术&amp;rsquo;），大概是为了让你能吓唬孩子。&lt;/p>
&lt;p>你应该知道 OOP 的最后一个方面，或者至少是它在 Java 中的实现方式，就是你也可以向工厂发送命令。在 OOP 术语中，你会说，类也有方法。例如，内置类&lt;code>Math&lt;/code>有许多类方法，包括&lt;code>Math.abs&lt;/code>，它返回一个数字的绝对值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Math.abs(-50)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// =&amp;gt; 50
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我希望这些小丑没有给你造成太大的创伤。现在让我们把你的 OOP 知识用在工作上吧!&lt;/p>
&lt;h3 id="ahoy-world">Ahoy, World&lt;/h3>
&lt;p>继续前进，创建一个名为&lt;em>phrasebook&lt;/em>的新目录。在该目录中，创建一个名为&lt;em>PiratePhrases.java&lt;/em>的文件，并编写以下内容。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public class PiratePhrases
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(&amp;#34;Shiver me timbers!!&amp;#34;);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个非常简单的程序将在你运行时向你的终端打印 &amp;ldquo;Shiver me timbers!!!&amp;ldquo;这句话。(这就是海盗说 &amp;ldquo;你好，世界！&amp;ldquo;的方式），当你运行它时，它将打印到你的终端。它由一个类&lt;code>PiratePhrases&lt;/code>和一个属于该类的静态方法&lt;code>main&lt;/code>组成。静态方法本质上是类的方法。&lt;/p>
&lt;p>在你的终端，用 javac PiratePhrases.java 命令编译&lt;code>PiratePhrases&lt;/code>源代码。如果你打的字都是正确的，**你的心是纯洁的，你应该看到一个名为&lt;em>PiratePhrases.class&lt;/em>的文件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">$ ls
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">PiratePhrases.class PiratePhrases.java
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你刚刚编译了你的第一个 Java 程序，我的朋友! 现在用&lt;code>java PiratePhrases&lt;/code>运行它。你应该看到这个。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Shiver me timbers!!!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里发生的事情是你用 Java 编译器&lt;code>javac&lt;/code>创建了一个 Java 类文件，&lt;em>PiratePhrases.class&lt;/em>。这个文件包含了大量的 Java 字节码（好吧，对于这么大的程序，也许只有一个字节）。&lt;/p>
&lt;p>当你运行 &amp;ldquo;java PiratePhrases &amp;ldquo;时，JVM 首先查看了你的&lt;em>classpath&lt;/em>，寻找一个名为 &amp;ldquo;PiratePhrases &amp;ldquo;的类。classpath 是文件系统的路径列表，JVM 通过搜索来寻找定义类的文件。默认情况下，classpath 包括你运行 java 时所在的目录。试着运行 java -classpath /tmp PiratePhrases，你会得到一个错误，尽管&lt;em>PiratePhrases.class&lt;/em>就在你的当前目录中。&lt;/p>
&lt;p>注意 你可以在你的 classpath 上有多个路径，如果你在 Mac 上或运行 Linux，可以用冒号隔开，如果你在使用 Windows，可以用分号。例如，classpath /tmp:/var/maven:.包括/tmp、/var/maven 和.目录。&lt;/p>
&lt;p>在 Java 中，每个文件只允许有一个公有类，而且文件名必须与类名一致。这就是为什么&lt;code>java&lt;/code>知道要尝试在&lt;em>PiratePhrases.class&lt;/em>中寻找&lt;code>PiratePhrases&lt;/code>类的字节码。在&lt;code>java&lt;/code>找到&lt;code>PiratePhrases&lt;/code>类的字节码后，它执行了该类的&lt;code>main&lt;/code>方法。Java 与 C 语言类似，只要你说 &amp;ldquo;运行某些东西，并使用这个类作为入口点&amp;rdquo;，它就会一直运行这个类的&lt;code>main'方法；因此，这个方法必须是&lt;/code>public&amp;rsquo;，你可以在`PiratePhrases&amp;rsquo;的源代码中看到。&lt;/p>
&lt;p>在下一节，你将学习如何处理跨越多个文件的程序代码，以及如何使用 Java 库。&lt;/p>
&lt;h2 id="包和导入">包和导入&lt;/h2>
&lt;p>为了了解如何使用多文件程序和 Java 库，我们将编译并运行一个程序。本节对 Clojure 有直接的影响，因为你将使用同样的想法和术语来与 Java 库进行交互。&lt;/p>
&lt;p>让我们从几个定义开始。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>包&lt;/strong>与 Clojure 的命名空间类似，包提供了代码组织。包包含类，包名对应于文件系统的目录。如果一个文件中有 &amp;ldquo;package com.shapemaster &amp;ldquo;一行，那么目录&lt;em>com/shapemaster&lt;/em>一定存在于你的 classpath 上。在该目录中会有定义类的文件。&lt;/li>
&lt;li>&lt;strong>import&lt;/strong> Java 允许你导入类，这基本上意味着你可以不使用它们的命名空间前缀来引用它们。所以如果你在&lt;code>com.shapemaster&lt;/code>中有一个名为&lt;code>Square&lt;/code>的类，你可以在&lt;code>.java&lt;/code>文件的顶部写上&lt;code>import``com.shapemaster.Square;&lt;/code>或&lt;code>import com.shapemaster.*;&lt;/code>，以便在你的代码中使用&lt;code>Square&lt;/code>而不是&lt;code>com.shapemaster.Square&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>让我们试试使用&lt;code>package&lt;/code>和&lt;code>import&lt;/code>。在这个例子中，你将创建一个名为&lt;code>pirate_phrases&lt;/code>的包，它有两个类，&lt;code>问候'和&lt;/code>告别&amp;rsquo;。 首先，浏览你的&lt;em>phrasebook&lt;/em>，在该目录下创建另一个目录，&lt;em>pirate_phrases&lt;/em>。创建&lt;em>pirate_phrases&lt;/em>是必要的，因为 Java 包的名称与文件系统的目录相对应。然后，在&lt;em>pirate_phrases&lt;/em>目录下创建&lt;em>Greetings.java&lt;/em>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="err">➊&lt;/span> &lt;span class="kn">package&lt;/span> &lt;span class="nx">pirate_phrases&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">public&lt;/span> &lt;span class="nx">class&lt;/span> &lt;span class="nx">Greetings&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">public&lt;/span> &lt;span class="nx">static&lt;/span> &lt;span class="nx">void&lt;/span> &lt;span class="nf">hello&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nb">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Shiver me timbers!!!&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在➊，&lt;code>package pirate_phrases;&lt;/code>表示这个类将是&lt;code>pirate_phrases&lt;/code>包的一部分。现在在&lt;em>pirate_phrases&lt;/em>目录下创建&lt;em>Farewells.java&lt;/em>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span> &lt;span class="nx">pirate_phrases&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">public&lt;/span> &lt;span class="nx">class&lt;/span> &lt;span class="nx">Farewells&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">public&lt;/span> &lt;span class="nx">static&lt;/span> &lt;span class="nx">void&lt;/span> &lt;span class="nf">goodbye&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nb">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;A fair turn of the tide ter ye thar, ye magnificent sea friend!!&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在在&lt;em>phrasebook&lt;/em>目录下创建&lt;em>PirateConversation.java&lt;/em>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">import pirate_phrases.*;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">public class PirateConversation
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Greetings greetings = new Greetings();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> greetings.hello();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Farewells farewells = new Farewells();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> farewells.goodbye();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>第一行，&lt;code>import pirate_phrases.*;&lt;/code>，导入了&lt;code>pirate_phrases&lt;/code>包中的所有类，其中包含&lt;code>问候'和&lt;/code>告别&amp;rsquo;类。&lt;/p>
&lt;p>如果你在&lt;em>phrasebook&lt;/em>目录下运行&lt;code>javac PirateConversation.java&lt;/code>，接着运行&lt;code>java PirateConversation&lt;/code>，你应该看到这个。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Shiver me timbers!!!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">A fair turn of the tide ter ye thar, ye magnificent sea friend!!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>亲爱的读者，她在那里吹了起来。她确实在吹。&lt;/p>
&lt;p>注意，当你编译一个 Java 程序时，Java 会在你的 classpath 中搜索包。试着输入以下内容。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">cd pirate_phrases
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">javac ../PirateConversation.java
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你会得到这个结果。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="p">..&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nx">PirateConversation&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">java&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kn">package&lt;/span> &lt;span class="nx">pirate_phrases&lt;/span> &lt;span class="nx">does&lt;/span> &lt;span class="nx">not&lt;/span> &lt;span class="nx">exist&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nx">pirate_phrases&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">^&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>轰隆隆! Java 编译器刚刚告诉你，让你羞愧地垂下头来，也许还会哭泣一下。&lt;/p>
&lt;p>为什么？它认为&lt;code>pirate_phrases&lt;/code>包不存在。但这很愚蠢，对吗？你是在&lt;em>pirate_phrases&lt;/em>目录下！你是在&lt;em>pirate_phrases&lt;/em>目录下。&lt;/p>
&lt;p>这里发生的情况是，默认的 classpath 只包括当前的目录，在这种情况下是&lt;em>pirate_phrases&lt;/em>。 &lt;code>javac&lt;/code>试图找到&lt;em>phrasebook/pirate_phrases/pirate_phrases&lt;/em>目录，但该目录并不存在。当你在&lt;em>phrasebook&lt;/em>目录下运行&lt;code>javac ../PirateConversation.java&lt;/code>时，&lt;code>javac&lt;/code>试图找到&lt;em>phrasebook/pirate_phrases&lt;/em>目录，该目录确实存在。在不改变目录的情况下，尝试运行 javac -classpath ../ ../PirateConversation.java。吓我一跳，居然成功了! 这是因为你手动将 classpath 设置为&lt;em>pirate_phrases&lt;/em>的父目录，也就是&lt;em>phrasebook&lt;/em>。从那里，&lt;code>javac&lt;/code>可以成功地找到&lt;em>pirate_phrases&lt;/em>目录。&lt;/p>
&lt;p>综上所述，包组织了代码，并要求有一个匹配的目录结构。导入类可以让你引用它们，而不需要预留整个类的包名。 &lt;code>javac&lt;/code>和 Java 使用 classpath 查找包。&lt;/p>
&lt;h2 id="jar-文件">JAR 文件&lt;/h2>
&lt;p>JAR 文件允许你将所有的*.class&lt;em>文件捆绑成一个单一的文件。导航到你的&lt;/em>phrasebook*目录并运行以下程序。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">jar cvfe conversation.jar PirateConversation PirateConversation.class
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pirate_phrases/*.class
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">java -jar conversation.jar
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这样就能正确显示海盗对话了。你把所有的类文件捆绑在&lt;em>conversation.jar&lt;/em>中。使用&lt;code>e&lt;/code>标志，你还指出&lt;code>PirateConversation&lt;/code>类是&lt;em>入口点&lt;/em>。入口点是包含 JAR 整体运行时应该执行的&lt;code>main'方法的类，&lt;/code>jar&amp;rsquo;将这些信息存储在 JAR 文件中的&lt;em>META-INF/MANIFEST.MF&lt;/em>文件中。如果你要阅读该文件，它将包含这一行。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Main-Class: PirateConversation
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>顺便说一下，当你执行 JAR 文件时，你不必担心你在哪个目录下，相对于文件而言。你可以换到&lt;em>pirate_phrases&lt;/em>目录，然后运行&lt;code>java -jar .../conversation.jar&lt;/code>，就可以正常工作了。原因是 JAR 文件维护了目录结构。你可以用 jar tf conversation.jar 查看它的内容，它的输出是这样的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">META-INF/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">meta-inf/manifest.mf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">PirateConversation.class
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pirate_phrases/Farewells.class
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Pirate_phrases/Greetings.class
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以看到，JAR 文件包括&lt;em>pirate_phrases&lt;/em>目录。关于 JARs 还有一个有趣的事实：它们实际上只是带有*.jar*扩展名的 ZIP 文件。你可以像对待其他 ZIP 文件一样对待它们。&lt;/p>
&lt;h2 id="clojurejar">clojure.jar&lt;/h2>
&lt;p>现在你已经准备好看看 Clojure 在引擎盖下是如何工作的了! 下载[1.9.0 稳定版]（&lt;a class="link" href="http://repo1.maven.org/maven2/org/clojure/clojure/1.7.0/clojure-1.9.0.zip" target="_blank" rel="noopener"
>http://repo1.maven.org/maven2/org/clojure/clojure/1.7.0/clojure-1.9.0.zip&lt;/a>）并运行它。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">java -jar clojure-1.7.0.jar
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你应该看到最舒心的景象，Clojure REPL。它究竟是如何启动的呢？让我们看看 JAR 文件中的&lt;em>META-INF/MANIFEST.MF&lt;/em>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Manifest-Version: 1.0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Archiver-Version: Plexus Archiver
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Created-By: Apache Maven
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Built-By: hudson
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Build-Jdk: 1.7.0_20
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Main-Class: clojure.main
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看起来，&lt;code>clojure.main&lt;/code>被指定为入口点。这个类是怎么来的？嗯，看看 GitHub 上的&lt;em>clojure/main.java&lt;/em>，网址是*&lt;a class="link" href="https://github.com/clojure/clojure/blob/master/src/jvm/clojure/main.java" target="_blank" rel="noopener"
>https://github.com/clojure/clojure/blob/master/src/jvm/clojure/main.java&lt;/a>*。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * Copyright (c) Rich Hickey. All rights reserved.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * The use and distribution terms for this software are covered by the
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * which can be found in the file epl-v10.html at the root of this distribution.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * By using this software in any fashion, you are agreeing to be bound by
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * the terms of this license.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * You must not remove this notice, or any other, from this software.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> **/&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">package&lt;/span> &lt;span class="nx">clojure&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nx">clojure&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lang&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Symbol&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nx">clojure&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lang&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Var&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nx">clojure&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lang&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">RT&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">public&lt;/span> &lt;span class="nx">class&lt;/span> &lt;span class="nx">main&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">final&lt;/span> &lt;span class="nx">static&lt;/span> &lt;span class="nx">private&lt;/span> &lt;span class="nx">Symbol&lt;/span> &lt;span class="nx">CLOJURE_MAIN&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">Symbol&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">intern&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;clojure.main&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">final&lt;/span> &lt;span class="nx">static&lt;/span> &lt;span class="nx">private&lt;/span> &lt;span class="nx">Var&lt;/span> &lt;span class="nx">REQUIRE&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">RT&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="kd">var&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;clojure.core&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;require&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">final&lt;/span> &lt;span class="nx">static&lt;/span> &lt;span class="nx">private&lt;/span> &lt;span class="nx">Var&lt;/span> &lt;span class="nx">LEGACY_REPL&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">RT&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="kd">var&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;clojure.main&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;legacy-repl&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">final&lt;/span> &lt;span class="nx">static&lt;/span> &lt;span class="nx">private&lt;/span> &lt;span class="nx">Var&lt;/span> &lt;span class="nx">LEGACY_SCRIPT&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">RT&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="kd">var&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;clojure.main&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;legacy-script&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">final&lt;/span> &lt;span class="nx">static&lt;/span> &lt;span class="nx">private&lt;/span> &lt;span class="nx">Var&lt;/span> &lt;span class="nx">MAIN&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">RT&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="kd">var&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;clojure.main&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;main&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">public&lt;/span> &lt;span class="nx">static&lt;/span> &lt;span class="nx">void&lt;/span> &lt;span class="nf">legacy_repl&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">String&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="nx">args&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">REQUIRE&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">invoke&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">CLOJURE_MAIN&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">LEGACY_REPL&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">invoke&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">RT&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">seq&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">args&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">public&lt;/span> &lt;span class="nx">static&lt;/span> &lt;span class="nx">void&lt;/span> &lt;span class="nf">legacy_script&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">String&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="nx">args&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">REQUIRE&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">invoke&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">CLOJURE_MAIN&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">LEGACY_SCRIPT&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">invoke&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">RT&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">seq&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">args&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">public&lt;/span> &lt;span class="nx">static&lt;/span> &lt;span class="nx">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">String&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="nx">args&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">REQUIRE&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">invoke&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">CLOJURE_MAIN&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">MAIN&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">applyTo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">RT&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">seq&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">args&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>正如你所看到的，该文件定义了一个名为&lt;code>main&lt;/code>的类。它属于 &amp;ldquo;clojure &amp;ldquo;包，并定义了一个 &amp;ldquo;公共静态 &amp;ldquo;的 &amp;ldquo;main &amp;ldquo;方法，JVM 完全乐意将其作为一个入口点。以这种方式来看，Clojure 是一个 JVM 程序，就像其他程序一样。&lt;/p>
&lt;p>这并不是一个深入的 Java 教程，但我希望它有助于澄清程序员在谈论 Clojure &amp;ldquo;在 JVM 上运行 &amp;ldquo;或成为一种 &amp;ldquo;托管 &amp;ldquo;语言时的意思。在下一节中，你将继续探索 JVM 的魅力，学习如何在你的 Clojure 项目中使用额外的 Java 库。&lt;/p>
&lt;p>Clojure 应用程序 JARs&lt;/p>
&lt;p>你现在知道 Java 是如何运行 Java JARs 的，但它是如何运行捆绑为 JARs 的 Clojure 应用程序的呢？毕竟，Clojure 应用程序没有类，不是吗？&lt;/p>
&lt;p>事实证明，你可以通过在命名空间声明中加入&lt;code>(:gen-class)&lt;/code>指令，让 Clojure 编译器为一个命名空间生成一个类。(你可以在你创建的第一个 Clojure 程序中看到这一点，即第一章的&lt;em>clojure-noob&lt;/em>。还记得那个程序吗，小茶壶？） 这意味着编译器会产生必要的字节码，使 JVM 把命名空间当作定义了一个 Java 类。&lt;/p>
&lt;p>你在程序的&lt;em>project.clj&lt;/em>文件中，使用&lt;code>:main&lt;/code>属性，为你的程序设置入口点的命名空间。对于&lt;em>clojure-noob&lt;/em>，你应该看到&lt;code>:main ^:skip-aot clojure-noob.core&lt;/code>。当 Leiningen 编译这个文件时，它将添加一个&lt;em>meta-inf/manifest.mf&lt;/em>文件，该文件包含了生成的 JAR 文件的入口点。&lt;/p>
&lt;p>因此，如果你在命名空间中定义了一个&lt;code>-main&lt;/code>函数，并包括&lt;code>(:gen-class)&lt;/code>指令，同时在你的&lt;em>project.clj&lt;/em>文件中设置了&lt;code>:main&lt;/code>，你的程序在被编译为 JAR 时，将拥有 Java 运行它所需的一切。你可以在你的终端中试用这个方法，浏览你的&lt;em>clojure-noob&lt;/em>目录并运行这个。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">lein uberjar
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">java -jar target/uberjar/clojure-noob-0.1.0-SNAPSHOT-standalone.jar
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你应该看到打印出来的两条信息。&amp;ldquo;清洁度仅次于神性 &amp;ldquo;和 &amp;ldquo;I&amp;rsquo;m a little teapot!&amp;rdquo; 注意，你不需要 Leiningen 来运行这个 JAR 文件；你可以把它发送给朋友和邻居，只要他们安装了 Java，就可以运行它。&lt;/p>
&lt;h2 id="java-interop">Java Interop&lt;/h2>
&lt;p>Rich Hickey 对 Clojure 的设计目标之一是创造一种&lt;em>实用的语言。出于这个原因，Clojure 的设计是为了使你能够轻松地与 Java 类和对象进行交互，这意味着你可以使用 Java 广泛的本地功能和它的巨大生态系统。使用 Java 类、对象和方法的能力被称为&lt;/em>Java interop*。在本节中，你将学习如何使用 Clojure 的互操作语法，如何导入 Java 包，以及如何使用最常用的 Java 类。&lt;/p>
&lt;h3 id="互通语法">互通语法&lt;/h3>
&lt;p>使用 Clojure 的互操作语法，与 Java 对象和类的交互是很直接的。让我们从对象互操作语法开始。&lt;/p>
&lt;p>你可以使用&lt;code>(.&lt;/code>methodName object)来调用一个对象的方法。例如，因为所有的 Clojure 字符串都是作为 Java 字符串实现的，所以你可以对它们调用 Java 方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(.toUpperCase &amp;#34;By Bluebeard&amp;#39;s bananas!&amp;#34; )
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;by bluebeard&amp;#39;s bananas!&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➊ (.indexOf &amp;#34;Let&amp;#39;s synergize our bleeding edges&amp;#34; &amp;#34;y&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 7
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这些等同于这个 Java。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">&amp;#34;By Bluebeard&amp;#39;s bananas!&amp;#34;.toUpperCase()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;#34;Let&amp;#39;s synergize our bleeding edges&amp;#34;.indexOf(&amp;#34;y&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，Clojure 的语法允许你向 Java 方法传递参数。在这个例子中，在➊，你把参数&lt;code>&amp;quot;y&amp;quot;&lt;/code>传给了&lt;code>indexOf&lt;/code>方法。&lt;/p>
&lt;p>你也可以调用类上的静态方法和访问类的静态字段。观察一下!&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">➊ (java.lang.Math/abs -3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➋ java.lang.Math/PI
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 3.141592653589793
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在➊，你调用了&lt;code>java.lang.Math&lt;/code>类的&lt;code>abs&lt;/code>静态方法，在➋，你访问了该类的&lt;code>PI&lt;/code>静态字段。&lt;/p>
&lt;p>所有这些例子（除了&lt;code>java.lang.Math/PI&lt;/code>）都使用了扩展到使用*dot 特殊形式的宏。一般来说，你不需要使用点的特殊形式，除非你想写自己的宏来与 Java 对象和类交互。尽管如此，下面是每个例子后面的宏扩展。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(macroexpand-1 &amp;#39;(.toUpperCase &amp;#34;By Bluebeard&amp;#39;s bananas!&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (. &amp;#34;By Bluebeard&amp;#39;s bananas!&amp;#34; toUpperCase)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(macroexpand-1 &amp;#39;(.indexOf &amp;#34;Let&amp;#39;s synergize our bleeding edges&amp;#34; &amp;#34;y&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (. &amp;#34;Let&amp;#39;s synergize our bleeding edges&amp;#34; indexOf &amp;#34;y&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(macroexpand-1 &amp;#39;(Math/abs -3))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (. Math abs -3)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这是点运算符的一般形式。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(. object-expr-or-classname-symbol method-or-member-symbol optional-args*)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>点运算符还有一些功能，如果你有兴趣进一步探索它，你可以看看 clojure.org 关于 Java 互操作的文档*&lt;a class="link" href="http://clojure.org/java_interop#Java%20Interop-The%20Dot%20special%20form" target="_blank" rel="noopener"
>http://clojure.org/java_interop#Java%20Interop-The%20Dot%20special%20form&lt;/a>*。&lt;/p>
&lt;p>创建和变异对象&lt;/p>
&lt;p>上一节告诉你如何调用已经存在的对象的方法。本节向你展示如何创建新的对象以及如何与它们进行交互。&lt;/p>
&lt;p>你可以通过两种方式创建一个新的对象。&lt;code>(new ClassName optional-args)&lt;/code>和&lt;code>(ClassName. optional-args)&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(new String)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(String.)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(String. &amp;#34;To Davey Jones&amp;#39;s Locker with ye hardies&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;To Davey Jones&amp;#39;s Locker with ye hardies&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>大多数人使用点的版本，&lt;code>(ClassName.)&lt;/code>。&lt;/p>
&lt;p>要修改一个对象，你要像上一节那样调用其上的方法。为了研究这个问题，让我们使用&lt;code>java.util.Stack&lt;/code>。这个类代表了一个后进先出（LIFO）的对象堆栈，或者只是&lt;em>堆栈&lt;/em>。&lt;em>堆栈&lt;/em>是一种常见的数据结构，它们之所以被称为堆栈，是因为你可以把它们想象成一摞实物，比如说，一摞你刚刚掠夺来的金币。当你向你的堆栈添加一个硬币时，你就把它添加到堆栈的顶部。当你取出一枚金币时，你就把它从上面移走。因此，最后添加的对象就是第一个被移除的对象。&lt;/p>
&lt;p>与 Clojure 数据结构不同，Java 堆栈是可变的。你可以向它们添加项目和删除项目，改变对象而不是派生出一个新的值。下面是你如何创建一个堆栈并向其添加一个对象。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(java.util.Stack.)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; []
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➊ (let [stack (java.util.Stack.)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (.push stack &amp;#34;Latest episode of Game of Thrones, ho!&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> stack)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [&amp;#34;Latest episode of Game of Thrones, ho!&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里有几个有趣的细节。首先，你需要为&lt;code>stack&lt;/code>创建一个&lt;code>let&lt;/code>绑定，就像你在➊看到的那样，并把它作为&lt;code>let&lt;/code>形式的最后一个表达式。如果你不这样做，整个表达式的值将是字符串&lt;code>&amp;quot;Game of Thrones, ho!&amp;quot;&lt;/code>，因为那是&lt;code>push&lt;/code>的返回值。&lt;/p>
&lt;p>第二，Clojure 用方括号来打印堆栈，与它用于 Vector 的文本表示法相同，这可能会让你感到困惑，因为它不是一个 Vector。然而，你可以使用 Clojure 的&lt;code>seq&lt;/code>函数来读取堆栈中的数据结构，比如&lt;code>first&lt;/code>，。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [stack (java.util.Stack.)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (.push stack &amp;#34;Latest episode of Game of Thrones, ho!&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (first stack))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Latest episode of Game of Thrones, ho!&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但是你不能使用像&lt;code>conj&lt;/code>和&lt;code>into&lt;/code>这样的函数来添加元素到栈中。如果你这样做，你会得到一个异常。使用 Clojure 函数读取堆栈是可能的，因为 Clojure 扩展了对&lt;code>java.util.Stack&lt;/code>的抽象，这个主题你将在第 13 章学习。&lt;/p>
&lt;p>Clojure 提供了&lt;code>doto&lt;/code>宏，它允许你更简洁地在同一个对象上执行多个方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(doto (java.util.Stack.)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (.push &amp;#34;Latest episode of Game of Thrones, ho!&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (.push &amp;#34;Whoops, I meant &amp;#39;Land, ho!&amp;#39;&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [&amp;#34;Latest episode of Game of Thrones, ho!&amp;#34; &amp;#34;Whoops, I meant &amp;#39;Land, ho!&amp;#39;&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>doto&lt;/code>宏返回对象，而不是任何方法调用的返回值，它更容易理解。如果你用&lt;code>macroexpand-1&lt;/code>展开它，你可以看到它的结构与你刚才在前面的例子中看到的&lt;code>let&lt;/code>表达式相同。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(macroexpand-1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#39;(doto (java.util.Stack.)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (.push &amp;#34;Latest episode of Game of Thrones, ho!&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (.push &amp;#34;Whoops, I meant &amp;#39;Land, ho!&amp;#39;&amp;#34;)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (clojure.core/let
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [G__2876 (java.util.Stack.)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (.push G__2876 &amp;#34;Latest episode of Game of Thrones, ho!&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (.push G__2876 &amp;#34;Whoops, I meant &amp;#39;Land, ho!&amp;#39;&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> G__2876)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>很方便!&lt;/p>
&lt;h3 id="导入">导入&lt;/h3>
&lt;p>在 Clojure 中，导入的效果和 Java 中的一样：你可以使用类，而不需要打出整个包的前缀。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(import java.util.Stack)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(Stack.)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; []
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你也可以使用这种一般形式一次导入多个类。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(import [package.name1 ClassName1 ClassName2]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [package.name2 ClassName3 ClassName4])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下面是一个例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(import [java.util Date Stack]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [java.net Proxy URI])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(Date.)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #inst &amp;#34;2016-09-19T20:40:02.733-00:00&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但通常情况下，你会在&lt;code>ns&lt;/code>宏中做所有的导入工作，像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns pirate.talk
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (:import [java.util Date Stack].
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [java.net Proxy URI])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这两种不同的导入类的方法有相同的结果，但通常第二种方法更可取，因为对于阅读你的代码的人来说，在&lt;code>ns&lt;/code>声明中看到所有涉及命名的代码很方便。&lt;/p>
&lt;p>这就是你导入类的方法! 很简单。为了使生活更加简单，Clojure 自动导入了&lt;code>java.lang&lt;/code>中的类，包括&lt;code>java.lang.String&lt;/code>和&lt;code>java.lang.Math&lt;/code>，这就是为什么你能够使用&lt;code>String&lt;/code>而不用前面的包名。&lt;/p>
&lt;h2 id="常用的-java-类">常用的 Java 类&lt;/h2>
&lt;p>为了完善本章，让我们快速浏览一下你最可能用到的 Java 类。&lt;/p>
&lt;h3 id="系统类">系统类&lt;/h3>
&lt;p>系统 &amp;ldquo;类具有有用的类字段和方法，可以与程序运行的环境进行交互。你可以用它来获取环境变量，与标准输入、标准输出和错误输出流进行交互。&lt;/p>
&lt;p>最有用的方法和成员是&lt;code>exit&lt;/code>、&lt;code>getenv&lt;/code>和&lt;code>getProperty&lt;/code>。你可能在第 5 章中认识&lt;code>System/exit&lt;/code>，在那里你用它来退出 Peg Thing 游戏。`System/exit&amp;rsquo;可以终止当前程序，你可以把状态代码作为参数传给它。如果你对状态代码不熟悉，我推荐维基百科的 &amp;ldquo;退出状态 &amp;ldquo;文章，网址是*&lt;a class="link" href="http://en.wikipedia.org/wiki/Exit_status" target="_blank" rel="noopener"
>退出状态-维基百科&lt;/a>*。&lt;/p>
&lt;p>&lt;code>System/getenv&lt;/code>将以 Map 形式返回所有系统的环境变量。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(System/getenv)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">{&amp;#34;USER&amp;#34; &amp;#34;the-incredible-bulk&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;JAVA_ARCH&amp;#34; &amp;#34;x86_64&amp;#34; }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>环境变量的一个常见用途是配置你的程序。&lt;/p>
&lt;p>JVM 有自己的属性列表，与计算机的环境变量分开，如果需要读取它们，可以使用&lt;code>System/getProperty&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">➊ (System/getProperty &amp;#34;user.dir&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;/Users/dabulk/projects/dabook&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➋ (System/getProperty &amp;#34;java.version&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;1.7.0_17&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>第一个调用➊返回 JVM 启动的目录，第二个调用➋返回 JVM 的版本。&lt;/p>
&lt;h3 id="日期类">日期类&lt;/h3>
&lt;p>Java 有很好的工具来处理日期问题。我不会对&lt;code>java.util.Date&lt;/code>类做太多的介绍，因为在线的 API 文档（可在*&lt;a class="link" href="http://docs.oracle.com/javase/7/docs/api/java/util/Date.html" target="_blank" rel="noopener"
>Date (Java Platform SE 7 )&lt;/a>*)很详尽。&lt;!-- raw HTML omitted -->作为&lt;!-- raw HTML omitted -->一个 Clojure 开发者，你应该知道这个&lt;code>date&lt;/code>类的三个特点。首先，Clojure 允许你使用这样的形式将日期表示为字面意义。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">#inst &amp;#34;2016-09-19T20:40:02.733-00:00&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>第二，如果你想自定义如何将日期转换成字符串，或者你想将字符串转换成日期，你需要使用&lt;code>java.util.DateFormat&lt;/code>类。第三，如果你要做的任务是比较日期或试图在日期上添加分钟、小时或其他时间单位，你应该使用极其有用的 clj-time 库（你可以在*&lt;a class="link" href="https://github.com/clj-time/clj-time" target="_blank" rel="noopener"
>GitHub - clj-time/clj-time: 一个用于 Clojure 的日期和时间库，包装了 Joda 时间库。&lt;/a>*)。&lt;/p>
&lt;h2 id="文件和输入输出">文件和输入/输出&lt;/h2>
&lt;p>在这一节中，你将了解到 Java 的输入/输出（IO）方法，以及 Clojure 如何简化它。&lt;code>clojure.java.io&lt;/code>命名空间提供了许多方便的函数来简化 IO（&lt;em>&lt;a class="link" href="https://clojure.github.io/clojure/clojure.java.io-api.html" target="_blank" rel="noopener"
>clojure.java.io - Clojure v1.10.3 API 文档&lt;/a>&lt;/em>）。这很好，因为 Java 的 IO 并不完全是简单的。因为在你的编程生涯中，你可能会在某些时候想要执行 IO，让我们开始把你的思想触角缠绕在它上面。&lt;/p>
&lt;p>IO 涉及到资源，无论是文件、套接字、缓冲区，还是其他什么。Java 有独立的类来读取资源的内容，写入其内容，以及与资源的属性进行交互。&lt;/p>
&lt;p>例如，&lt;code>java.io.File&lt;/code>类用于与文件的属性进行交互。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [file (java.io.File. &amp;#34;/&amp;#34;)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➊ (println (.exists file))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➋ (println (.canWrite file))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➌ (println (.getPath file)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; false
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; /
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/java/lion.png"
loading="lazy"
>&lt;/p>
&lt;p>在其他任务中，你可以用它来检查一个文件是否存在，获得文件的读/写/执行权限，并获得其文件系统路径，你可以在➊、➋和➌分别看到。&lt;/p>
&lt;p>在这个能力列表中，明显缺少读和写。要读一个文件，你可以使用&lt;code>java.io.BufferedReader&lt;/code>类或者&lt;code>java.io.FileReader&lt;/code>。同样地，你可以使用&lt;code>java.io.BufferedWriter&lt;/code>或&lt;code>java.io.FileWriter&lt;/code>类来写。其他类也可用于读写，你选择哪一个取决于你的具体需求。读取器和写入器类的接口都有相同的基本方法集；读取器实现了&lt;code>读取'、&lt;/code>关闭&amp;rsquo;等，而写入器实现了&lt;code>添加'、&lt;/code>写入&amp;rsquo;、&lt;code>关闭'和&lt;/code>刷新&amp;rsquo;。Java 给你提供了各种 IO 工具。一个愤世嫉俗的人可能会说，Java 给你的绳子足以让你上吊，如果你找到这样一个人，我希望你能给他一个拥抱。&lt;/p>
&lt;p>不管怎么说，Clojure 使你的读写更容易，因为它包括了统一不同种类资源的读写的函数。例如，&lt;code>spit&lt;/code>写到一个资源，而&lt;code>slurp&lt;/code>从一个资源中读出。下面是一个使用它们来写和读一个文件的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(spit &amp;#34;/tmp/hercules-todo-list&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;#34;- kill dat lion brov
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- chop up what nasty multi-headed snake thing&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(slurp &amp;#34;/tmp/hercules-todo-list&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;- kill dat lion brov
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - chop up what nasty multi-headed snake thing&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你也可以对代表文件以外的资源的对象使用这些函数。下一个例子使用了一个&lt;code>StringWriter&lt;/code>，它允许你对一个字符串进行 IO 操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [s (java.io.StringWriter.)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (spit s &amp;#34;- capture cerynian hind like for real&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (.toString s))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;- capture cerynian hind like for real&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你也可以使用 &amp;ldquo;slurp &amp;ldquo;从&lt;code>StringReader&lt;/code>中读取。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [s (java.io.StringReader. &amp;#34;- get erymanthian pig what with the tusks&amp;#34;)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (slurp s))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;- get erymanthian pig what with the tusks&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>此外，你可以对资源使用&lt;code>读&lt;/code>和&lt;code>写&lt;/code>方法。使用哪种方法并没有什么区别；&lt;code>spit&lt;/code>和&lt;code>slurp&lt;/code>很方便，因为它们只需使用一个代表文件系统路径或 URL 的字符串。&lt;/p>
&lt;p>&lt;code>with-open&lt;/code>宏是另一种便利：它在其主体的末尾隐含地关闭一个资源，确保你不会因为忘记手动关闭资源而意外地占用资源。&lt;code>reader&lt;/code>函数是一个方便的工具，根据&lt;code>clojure.java.io&lt;/code>API 文档，&amp;ldquo;试图将其参数强制到一个开放的&lt;code>java.io.Reader&lt;/code>&amp;quot;。当你不想使用&lt;code>slurp&lt;/code>时，这很方便，因为你不想尝试完整地读取一个资源，你也不想弄清楚你需要使用哪个 Java 类。如果你想一行一行地读取一个文件，你可以使用&lt;code>reader&lt;/code>和&lt;code>with-open&lt;/code>以及&lt;code>line-seq&lt;/code>函数。下面是如何打印 Hercules 待办事项清单的第一项的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(with-open [todo-list-rdr (clojure.java.io/reader &amp;#34;/tmp/hercules-todo-list&amp;#34;)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (first (line-seq todo-list-rdr))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; - kill dat lion brov
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这应该足以让你在 Clojure 中开始使用 IO。如果你想做更复杂的任务，一定要看看&lt;a class="link" href="https://clojure.github.io/clojure/clojure.java.io-api.html" target="_blank" rel="noopener"
>&lt;code>clojure.java.io&lt;/code> docs&lt;/a>，&lt;code>[java.nio.file](https://docs.oracle.com/javase/7/docs/api/java/nio/file/package-summary.html)&lt;/code>包文档，或&lt;code>[java.io](http://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html)&lt;/code>包文档。&lt;/p>
&lt;h2 id="资源">资源&lt;/h2>
&lt;ul>
&lt;li>&amp;ldquo;Java 虚拟机和编译器的解释&amp;rdquo;。 &lt;em>&lt;a class="link" href="https://www.youtube.com/watch?v=XjNwyXx2os8" target="_blank" rel="noopener"
>Java 虚拟机和编译器的解释&amp;ndash;YouTube&lt;/a>&lt;/em>&lt;/li>
&lt;li>clojure.org Java 互操作文档。 &lt;em>&lt;a class="link" href="http://clojure.org/java_interop" target="_blank" rel="noopener"
>Clojure - Java Interop&lt;/a>&lt;/em>&lt;/li>
&lt;li>维基百科的 &amp;ldquo;退出状态 &amp;ldquo;文章。 &lt;em>&lt;a class="link" href="http://en.wikipedia.org/wiki/Exit_status" target="_blank" rel="noopener"
>退出状态 - 维基百科&lt;/a>&lt;/em>&lt;/li>
&lt;/ul>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>在本章中，你了解了 Clojure 被托管在 JVM 上的含义。Clojure 程序被编译成 Java 字节码并在 JVM 进程中执行。Clojure 程序也可以访问 Java 库，你可以使用 Clojure 的互操作设施轻松地与它们交互。&lt;/p></description></item><item><title>Chapter11 core.async</title><link>https://example.com/p/chapter11-core.async/</link><pubDate>Sat, 15 Jan 2022 12:56:01 +0800</pubDate><guid>https://example.com/p/chapter11-core.async/</guid><description>&lt;h1 id="用-coreasync-掌握并发进程">用 core.async 掌握并发进程&lt;/h1>
&lt;p>有一天，当你走在大街上时，你会惊讶、好奇，并有点厌恶地发现一台热狗自动贩卖机。你的头皮被有罪的好奇心刺痛，你会忍不住掏出三块钱，看看这个装置是否真的能工作。在 &amp;ldquo;咔嚓 &amp;ldquo;一声接受了你的钱后，它弹出了一个新鲜的热狗，包括面包和所有的东西。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/core-async/hotdog-vending-machine.png"
loading="lazy"
>&lt;/p>
&lt;p>自动售货机表现出简单的行为：当它收到钱时，它会放出一个热狗，然后为下一次购买做准备。当它的热狗用完时，它就会停止。我们周围的热狗自动售货机以不同的面貌出现，它们是独立的实体，同时对世界上的事件作出反应。你最喜欢的咖啡店的浓缩咖啡机，你小时候喜欢的宠物仓鼠&amp;ndash;所有的东西都可以被分解成一组行为，这些行为遵循一般的形式 &amp;ldquo;当&lt;em>x&lt;/em>发生时，做&lt;em>y&lt;/em>&amp;quot;。甚至我们写的程序也只是美化的热狗贩卖机，每一个都是独立的进程，等待着下一个事件的发生，无论是击键、超时，还是套接字上的数据到达。&lt;/p>
&lt;p>Clojure 的 core.async 库允许你在一个程序中创建多个独立进程。 本章描述了思考这种编程风格的有用模型，以及你在实际编写代码时需要了解的实际细节。你将学习如何使用通道在由 go 块和&lt;code>thread&lt;/code>创建的独立进程之间进行通信；了解一些关于 Clojure 如何通过停放和阻塞有效地管理线程；如何使用&lt;code>alts!!&lt;/code>；以及一种更直接的创建队列的方法。最后，你将学习如何用进程管道来踢回调的屁股。&lt;/p>
&lt;h2 id="进程的入门">进程的入门&lt;/h2>
&lt;p>core.async 的核心是*进程，一个并发运行的逻辑单元，对事件做出反应。进程对应于我们对现实世界的心理模型：实体之间的互动和响应是独立的，没有某种中央控制机制的牵制。你把钱放进机器里，就会有一个热狗出来，所有这些都不需要光照派或老大哥来策划整个事情。这与你迄今为止一直在探索的并发性观点不同，在那里，你定义的任务要么只是控制主线程的扩展（例如，用&lt;code>pmap&lt;/code>实现数据并行），要么是你没有兴趣与之交流的任务（如用&lt;code>future&lt;/code>创建的一次性任务）。&lt;/p>
&lt;p>把自动售货机看成是一个进程可能很奇怪：自动售货机是名词和事物，而进程是动词和行为。为了获得正确的思维方式，可以尝试将现实世界的物体定义为其事件驱动的行为的总和。当一粒种子被浇水时，它就会发芽；当母亲看着她的新生儿时，她就会感受到爱；而当你观看《&lt;em>星&lt;/em>战》第一集时，你会充满愤怒和绝望。如果你想变得超级哲学，可以考虑是否有可能将每个事物的本质定义为它所识别的事件的集合，以及它如何做出反应。现实是否只是热狗售卖机的组成？&lt;/p>
&lt;p>总之，我说得够多了! 让我们通过创建一些简单的过程，从理论上走向具体。首先，用 &amp;ldquo;lein new app playsync &amp;ldquo;创建一个新的 Leiningen 项目，名为&lt;em>playsync&lt;/em>。然后，打开&lt;em>project.clj&lt;/em>文件，将 core.async 添加到&lt;code>:dependencies&lt;/code>Vector 中，使其内容如下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[[org.clojure/clojure &amp;#34;1.9.0&amp;#34;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">[org.clojure/core.async &amp;#34;0.1.346.0-17112a-alpha&amp;#34;]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意 自从我写完这篇文章后，core.async 的版本有可能有所进步。关于最新的版本，请查看 core.async 的 GitHub 项目页面。但为了这些练习的目的，请使用这里列出的版本。&lt;/p>
&lt;p>接下来，打开&lt;em>src/playsync/core.clj&lt;/em>，使其看起来像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns playsync.core
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (:require [clojure.core.async
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :as a
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :refer [&amp;gt;! &amp;lt;! &amp;gt;!! &amp;lt;!! go chan buffer close! thread
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> alts! alts!! timeout]]))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在，当你在 REPL 中打开它时，你将拥有最常用的 core.async 函数供你使用。很好! 在创建像热狗售卖机那样复杂和革命性的东西之前，先创建一个进程，简单地打印它收到的消息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def echo-chan (chan))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(go (println (&amp;lt;! echo-chan)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(&amp;gt;!! echo-chan &amp;#34;ketchup&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; ketchup
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在第一行代码中，你用&lt;code>chan&lt;/code>函数创建了一个名为&lt;code>echo-chan&lt;/code>的&lt;em>通道。通道传达&lt;/em>消息*。你可以把&lt;em>消息放到一个通道上，也可以把&lt;/em>消息从一个通道上拿下来。进程&lt;em>等待&lt;/em>放和取的完成&amp;ndash;这些是进程所响应的事件。你可以认为进程有两个规则。1）当试图把一个消息放到通道上或从通道上取走一个消息时，等待并不做任何事情，直到放或取成功；2）当放或取成功时，继续执行。&lt;/p>
&lt;p>在下一行，你用&lt;code>go&lt;/code>来创建一个新的进程。&lt;code>go&lt;/code>表达式中的所有内容都被称为&lt;em>go 块&lt;/em>，在一个单独的线程上并发运行。Go 块在一个线程池上运行你的进程，该线程池包含的线程数量等于你的机器上的核心数量的两倍，这意味着你的程序不必为每个进程创建一个新的线程。这通常会带来更好的性能，因为你避免了与创建线程有关的开销。&lt;/p>
&lt;p>在这个例子中，进程&lt;code>(println (&amp;lt;! echo-chan))&lt;/code>表达了 &amp;ldquo;当我从`echo-chan&amp;rsquo;那里得到一个消息时，打印它&amp;rdquo;。该进程被分流到另一个线程，释放了当前线程，使你能够继续与 REPL 交互。&lt;/p>
&lt;p>在表达式&lt;code>(&amp;lt;! echo-chan)&lt;/code>中，&lt;code>&amp;lt;!&lt;/code>是&lt;em>take&lt;/em>函数。它监听你给它作为参数的通道，它所属的进程等待，直到另一个进程在该通道上放出一个消息。当&lt;code>&amp;lt;!&lt;/code>检索到一个值时，该值被返回并执行&lt;code>println&lt;/code>表达式。&lt;/p>
&lt;p>表达式&lt;code>(&amp;gt;!! echo-chan &amp;quot;ketchup&amp;quot;)&lt;/code>将字符串&lt;code>&amp;quot;ketchup&amp;quot;&lt;/code>放到&lt;code>echo-chan&lt;/code>上并返回&lt;code>true&lt;/code>。当你把一个消息放在一个通道上时，该进程会阻塞，直到另一个进程接收该消息。在这种情况下，REPL 进程根本不需要等待，因为已经有一个进程在监听该通道，等待从该通道中获取信息。然而，如果你做了以下事情，你的 REPL 将无限期地阻塞。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(&amp;gt;!! (chan) &amp;#34;mustard&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你已经创建了一个新的通道，并在上面放了一些东西，但没有进程在监听这个通道。进程不仅仅是等待接收消息，他们也在等待他们放在通道上的消息被接收。&lt;/p>
&lt;h3 id="缓冲">缓冲&lt;/h3>
&lt;p>值得注意的是，前面的练习包含&lt;em>两个&lt;/em>进程：你用&lt;code>go&lt;/code>创建的进程和 REPL 进程。这些进程相互之间没有明确的知识，而且它们独立行动。&lt;/p>
&lt;p>让我们想象一下，这些过程发生在一个餐厅里。REPL 是番茄酱厨师，当他完成一个批次时，他大声说：&amp;ldquo;番茄酱！&amp;rdquo; 完全有可能的是，其他员工都在外面欣赏他们有机花园里最新的一批牛至，而厨师只是坐着等待，直到有人来取他的番茄酱。反过来说，&amp;ldquo;去 &amp;ldquo;的过程代表了其中一个工作人员，他正在耐心地等待着什么回应。可能是什么都没有发生，他只是无限期地等待，直到餐厅关门。&lt;/p>
&lt;p>这种情况似乎有点傻：哪个自尊心强的番茄酱厨师会在制作更多的番茄酱之前，只是坐等别人拿走他最新的一批番茄酱？为了避免这种悲剧的发生，你可以创建缓冲通道。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def echo-buffer (chan 2))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(&amp;gt;!! echo-buffer &amp;#34;ketchup&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(&amp;gt;!! echo-buffer &amp;#34;ketchup&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(&amp;gt;!! echo-buffer &amp;#34;ketchup&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; This blocks because the channel buffer is full
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>(小心求值最后一个&lt;code>(&amp;gt;! ! echo-buffer &amp;quot;ketchup&amp;quot;)&lt;/code>，因为它将阻塞你的 REPL。如果你使用的是 Leiningen REPL，ctrl-C 会解除封锁）。&lt;/p>
&lt;p>在这种情况下，你已经创建了一个缓冲区大小为 2 的通道。这意味着你可以在通道上放两个值而不需要等待，但放第三个值意味着进程将等待，直到另一个进程从通道上取值。你还可以用&lt;code>sliding-buffer&lt;/code>创建&lt;em>滑动&lt;/em>缓冲区，它以先入先出的方式丢弃数值；用&lt;code>dropping-buffer&lt;/code>创建&lt;em>丢弃&lt;/em>缓冲区，它以后入先出的方式丢弃数值。这两种缓冲区都不会导致&lt;code>&amp;gt;!!&lt;/code>阻塞。&lt;/p>
&lt;p>通过使用缓冲区，番茄酱大师可以继续制作成批令人垂涎欲滴的番茄酱，而不必等待他的员工把它们带走。如果他使用普通的缓冲器，就像他有一个架子，可以把所有的番茄酱批次放在上面；一旦架子满了，他还得等待空间的打开。如果他用的是滑动缓冲器，当架子上的番茄酱满了，他就会把最旧的一批扔掉，把所有的番茄酱滑下来，然后把新的一批放到空出来的地方。如果是跌落式缓冲器，他就会把最新鲜的一批番茄酱从货架上打下来，然后把新的一批番茄酱放在那个空间里。&lt;/p>
&lt;p>缓冲区只是对核心模型的阐述：进程是独立的、并发执行的逻辑单元，对事件作出反应。你可以用 go 块来创建进程，并通过通道来沟通事件。&lt;/p>
&lt;h3 id="堵塞和停车">堵塞和停车&lt;/h3>
&lt;p>你可能已经注意到，take 函数&lt;code>&amp;lt;!&lt;/code>只使用了一个感叹号，而 put 函数&lt;code>&amp;gt;!&lt;/code>则使用了两个感叹号。事实上，put 和 take 都有一个感叹号和两个感叹号的种类。什么时候使用哪个？简单的答案是，你可以在 go 块内使用一个感叹号，但你必须在 go 块外使用两个感叹号。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Inside go block&lt;/th>
&lt;th>Outside go block&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>put&lt;/td>
&lt;td>&lt;code>&amp;gt;!&lt;/code> or &lt;code>&amp;gt;!!&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;gt;!!&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>take&lt;/td>
&lt;td>&lt;code>&amp;lt;!&lt;/code> or &lt;code>&amp;lt;!!&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;lt;!!&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>这一切都归结为效率问题。因为 go 块使用一个固定大小的线程池，你可以创建 1000 个 go 进程，但只使用少量的线程。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def hi-chan (chan))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(doseq [n (range 1000)])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (go (&amp;gt;! hi-chan (str &amp;#34;hi &amp;#34; n)))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>为了理解 Clojure 是如何做到这一点的，我们需要探索进程如何&lt;em>等待。等待是使用 core.async 进程的一个关键方面：我们已经确定，&lt;em>put&lt;/em>会等待到另一个进程在同一通道上做&lt;/em>take*，反之亦然。在这个例子中，1,000 个进程在等待另一个进程从 &amp;ldquo;hi-chan &amp;ldquo;中提取。&lt;/p>
&lt;p>有两种类型的等待。 &lt;em>停车&lt;/em>和&lt;em>阻塞&lt;/em>。阻塞是你熟悉的那种等待：一个线程停止执行，直到一个任务完成。通常这发生在你进行某种 I/O 操作的时候。这个线程仍然活着，但不做任何工作，所以如果你想让你的程序继续工作，你必须创建一个新的线程。在第 9 章中，你学到了如何用 &amp;ldquo;future &amp;ldquo;来做这件事。&lt;/p>
&lt;p>停车释放了线程，这样它就可以继续工作了。假设你有一个线程和两个进程，Process A 和 Process B，Process A 在线程上运行，然后等待放或取。Clojure 将进程 A 移出线程，并将进程 B 移到线程上。如果进程 B 开始等待，而进程 A 的 put 或 take 已经完成，那么 Clojure 将把进程 B 移出线程，把进程 A 放回线程上。停放允许多个进程的指令在一个线程上交错，类似于使用多个线程允许在一个核心上交错的方式。停放的实现并不重要；只需说它只在 go 块内实现，并且只在使用&lt;code>&amp;gt;!&lt;/code>和&lt;code>&amp;lt;!&lt;/code>，或&lt;em>停放 put&lt;/em>和&lt;em>停放 take&lt;/em>时实现。&lt;code>&amp;gt;!!&lt;/code>和&lt;code>&amp;lt;!!&lt;/code>是&lt;em>停放的放&lt;/em>和&lt;em>停放的取&lt;/em>。&lt;/p>
&lt;h3 id="线程">线程&lt;/h3>
&lt;p>肯定有一些时候你会想使用阻塞而不是停放，比如你的进程要花很长时间才能放或取，在这些场合你应该使用&lt;code>线程&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(thread (println (&amp;lt;!! echo-chan)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(&amp;gt;!! echo-chan &amp;#34;mustard&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; mustard
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>thread&lt;/code>的行为几乎与&lt;code>future&lt;/code>完全一样：它创建一个新的线程并在该线程上执行一个进程。与&lt;code>future'不同的是，&lt;/code>thread&amp;rsquo;不是返回一个可以反推的对象，而是返回一个通道。当&lt;code>thread&lt;/code>的进程停止时，该进程的返回值会被放在&lt;code>thread&lt;/code>返回的通道上。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [t (thread &amp;#34;chili&amp;#34;) ]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (&amp;lt;!! t))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;chili&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这种情况下，进程不等待任何事件；相反，它立即停止。它的返回值是 &amp;ldquo;chili&amp;rdquo;，它被放在与&lt;code>t绑定的通道上。&lt;/code>我们从&lt;code>t&lt;/code>中获取，返回`&amp;ldquo;chili&amp;rdquo;。&lt;/p>
&lt;p>当你执行一个长期运行的任务时，你应该使用&lt;code>thread&lt;/code>而不是 go block，原因是你不会堵塞你的线程池。想象一下，你正在运行四个进程，下载巨大的文件，保存它们，然后把文件的路径放在一个通道上。当这些进程在下载文件和保存这些文件时，Clojure 不能停放它们的线程。它只能在最后一步停放线程，即进程将文件的路径放在通道上时。因此，如果你的线程池只有四个线程，所有四个线程都将被用于下载，在其中一个下载完成之前，不允许其他进程运行。&lt;/p>
&lt;p>&lt;code>go&lt;/code>、&lt;code>thread&lt;/code>、&lt;code>chan&lt;/code>、&lt;code>&amp;lt;!&lt;/code>、&lt;code>&amp;lt;!&lt;/code>、&lt;code>&amp;gt;!&lt;/code>和&lt;code>&amp;gt;!&lt;/code>是你用来创建和与进程通信的核心工具。put 和 take 都会使一个进程等待，直到它的补码在给定的通道上被执行。&lt;code>go&lt;/code>允许你使用 put 和 take 的停车变体，这可以提高性能。如果你在 put 和 take 之前执行长期运行的任务，你应该使用阻塞式变体，以及&lt;code>thread&lt;/code>。&lt;/p>
&lt;p>这应该能满足你的一切需求，让你实现你的心愿，创造一台把钱变成热狗的机器。&lt;/p>
&lt;h2 id="你一直渴望的热狗机过程">你一直渴望的热狗机过程&lt;/h2>
&lt;p>看哪，你的梦想成真了!&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn hot-dog-machine
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> []
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [in (chan)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> out (chan)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (go (&amp;lt;! in)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (&amp;gt;! out &amp;#34;hot dog&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [in out]))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个函数创建了一个&lt;code>in&lt;/code>通道用于接收钱，一个&lt;code>out&lt;/code>通道用于发放热狗。然后用&lt;code>go&lt;/code>创建一个异步进程，等待钱，然后发放热狗。最后，它将&lt;code>in&lt;/code>和&lt;code>out&lt;/code>通道作为一个 Vector 返回。&lt;/p>
&lt;p>是时候吃热狗了!&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [[in out] (hot-dog-machine)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (&amp;gt;!! in &amp;#34;pocket lint&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (&amp;lt;!! out))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;hot dog&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个片段中，你用 destructuring（在第三章中讲到）和&lt;code>let&lt;/code>将&lt;code>in&lt;/code>和&lt;code>out&lt;/code>通道绑定到&lt;code>in&lt;/code>和&lt;code>out&lt;/code>符号。然后你把 &amp;ldquo;pocket lint &amp;ldquo;放在 &amp;ldquo;in &amp;ldquo;通道上。热狗机器进程等待着一些东西，任何东西，到达&lt;code>in&lt;/code>通道；一旦&lt;code>&amp;quot;pocket lint&amp;quot;&lt;/code>到达，热狗机器进程恢复执行，将&lt;code>&amp;quot;hot dog&amp;quot;&lt;/code>放在&lt;code>out&lt;/code>通道上。&lt;/p>
&lt;p>等一下……这不对。我的意思是，是的，免费的热狗，但是一定会有人因为机器接受小棉絮作为付款而不高兴。不仅如此，这台机器在关闭前只能发放一个热狗。让我们改变热狗机的功能，让你可以指定它有多少个热狗，并且当你给它数字 3 时，它才会发放一个热狗。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn hot-dog-machine-v2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [hot-dog-count]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [in (chan)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> out (chan)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (go (loop [hc hot-dog-count]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if (&amp;gt; hc 0)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [input (&amp;lt;! in)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ➊(if (= 3 input)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (do (&amp;gt;! out &amp;#34;hot dog&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (recur (dec hc)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (do (&amp;gt;! out &amp;#34;wilted lettuce&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (recur hc))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ➋(do (close! in)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (close! out)))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [in out]))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里有很多代码，但策略是直接的。新函数&lt;code>hot-dog-machine-v2&lt;/code>允许你指定&lt;code>hot-dog-count&lt;/code>。在➊的 go 块内，只有当数字 3（意思是三块钱）被放在`in&amp;rsquo;通道上时，它才会派发热狗；否则，它派发枯萎的生菜，这绝对不是热狗。一旦一个进程采取了输出，热狗机进程就会带着更新的热狗数量循环回来，并准备再次接收钱。&lt;/p>
&lt;p>当机器进程的热狗用完时，该进程就会在➋处&lt;em>关闭&lt;/em>通道。当你关闭一个通道时，你就不能再对它执行 put，而且一旦你从一个关闭的通道上取走所有的值，任何后续的取值都将返回 &amp;ldquo;nil&amp;rdquo;。&lt;/p>
&lt;p>让我们来试试清单 11-1 中的升级版热狗机，把钱和口袋里的棉絮放进去。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [[in out] (hot-dog-machine-v2 2)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (&amp;gt;!! in &amp;#34;pocket lint&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (&amp;lt;!! out))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (&amp;gt;!! in 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (&amp;lt;!! out))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (&amp;gt;!! in 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (&amp;lt;!! out))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (&amp;gt;!! in 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (&amp;lt;!! out))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; wilted lettuce
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; hotdog
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; hotdog
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; nil
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>清单 11-1. 与一个健壮的热狗售货机进程交互&lt;/li>
&lt;/ol>
&lt;p>首先，我们尝试了 &amp;ldquo;口袋里的棉絮 &amp;ldquo;这一招，得到了打蔫的生菜。接下来，我们两次投入 3 美元，两次都得到一个热狗。然后，我们试图再投入 3 美元，但这被忽略了，因为通道已经关闭；数字 3 没有被放在通道上。当我们试图从 &amp;ldquo;出 &amp;ldquo;通道取钱时，我们得到的是 &amp;ldquo;零&amp;rdquo;，这也是因为该通道是关闭的。你可能会注意到&lt;code>hot-dog-machine-v2&lt;/code>的几个有趣的细节。首先，它在同一个 go 块中做了一个 put 和一个 take。这并不罕见，这也是创建进程&lt;em>管道的一种方法：只要让一个进程的&lt;/em>入&lt;em>通道成为另一个进程的&lt;/em>出*通道。下面的例子就是这样做的，把一个字符串通过一系列的进程进行转换，直到最后一个进程打印出这个字符串。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [c1 (chan)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> c2 (chan)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> c3 (chan)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (go (&amp;gt;! c2 (clojure.string/upper-case (&amp;lt;! c1))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (go (&amp;gt;! c3 (clojure.string/reverse (&amp;lt;! c2))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (go (println (&amp;lt;! c3)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (&amp;gt;!! c1 &amp;#34;redrum&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; MURDER
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在本章的最后，我将会有更多关于进程管道以及如何使用它们来代替回调的内容。&lt;/p>
&lt;p>回到清单 11-1! 另一件需要注意的事情是，热狗机在你处理完它所发放的东西之前，不会接受更多的钱。这允许你建立类似于状态机的行为模型，其中通道操作的完成会触发状态转换。例如，你可以认为自动售货机有两个状态。&lt;em>准备接收钱&lt;/em>和&lt;em>发放&lt;/em>物品*。插入钱和取走物品会触发这两者之间的转换。&lt;/p>
&lt;h2 id="alts">alts&lt;/h2>
&lt;p>core.async 函数&lt;code>alts!!&lt;/code>可以让你使用一个操作集合中第一个成功的通道操作的结果。我们在第 198 页的 &amp;ldquo;延迟 &amp;ldquo;中用延迟和 Future 做了类似的事情。在那个例子中，我们把一组头像上传到一个头像分享网站，并在第一张照片上传时通知头像所有者。下面是你如何用&lt;code>alts!!&lt;/code>做同样的事情。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn upload
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [headshot c]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (go (Thread/sleep (rand 100))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (&amp;gt;! c headshot)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➊ (let [c1 (chan)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> c2 (chan)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> c3 (chan)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (upload &amp;#34;serious.jpg&amp;#34; c1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (upload &amp;#34;fun.jpg&amp;#34; c2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (upload &amp;#34;sassy.jpg&amp;#34; c3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➋ (let [[headshot channel] (alts!! [c1 c2 c3])]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;Sending headshot notification for&amp;#34; headshot)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Sending headshot notification for sassy.jpg
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这里，&lt;code>upload&lt;/code>函数接收一个头像和一个频道，并创建一个新的进程，该进程将随机睡眠一段时间（模拟上传），然后将头像放到频道上。从➊开始的&lt;code>let&lt;/code>绑定和&lt;code>upload&lt;/code>函数调用应该是有意义的：我们创建了三个通道，然后用它们来执行上传。&lt;/p>
&lt;p>事情在➋处变得有趣。&lt;code>alts!!&lt;/code>函数需要一个通道的 Vector 作为其参数。这就好比说，&amp;ldquo;试着在这些通道上同时做一个阻塞性的拍摄。一旦取值成功，返回一个 Vector，其第一个元素是取值，第二个元素是获胜的通道&amp;rdquo;。在这个例子中，与&lt;em>sassy.jpg&lt;/em>相关的通道首先收到了一个值。如果你想获取它们的值并对它们进行处理，其他通道仍然可用。&lt;code>alts!!&lt;/code>所做的只是从第一个有值的通道中获取一个值；它并不触及其他通道。&lt;/p>
&lt;p>&lt;code>alts!!&lt;/code>的一个很酷的方面是，你可以给它一个&lt;em>timeout 通道&lt;/em>，它等待指定的毫秒数，然后关闭。这是一个优雅的机制，可以为并发操作设置一个时间限制。下面是你如何在上传服务中使用它。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [c1 (chan)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (upload &amp;#34;serious.jpg&amp;#34; c1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [[headshot channel] (alts!! [c1 (timeout 20)])]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if headshot
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;Sending headshot notification for&amp;#34; headshot)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;Timed out!&amp;#34;))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Timed out!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这种情况下，我们将超时设置为 20 毫秒。因为上传没有在这个时间段完成，我们得到了一个超时消息。&lt;/p>
&lt;p>你也可以使用&lt;code>alts!!&lt;/code>来指定 put 操作。要做到这一点，在你传递给&lt;code>alts!!&lt;/code>的 Vector 内放置一个 Vector，就像本例中的➊。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [c1 (chan)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> c2 (chan)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (go (&amp;lt;! c2))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➊ (let [[value channel] (alts!! [c1 [c2 &amp;#34;put!&amp;#34;]])]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println value)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (= channel c2)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里你创建了两个通道，然后创建了一个进程，等待对&lt;code>c2&lt;/code>进行处理。你提供给&lt;code>alts!!&lt;/code>的 Vector 告诉它，&amp;ldquo;尝试对&lt;code>c1'进行取舍，并尝试将&lt;/code>&amp;ldquo;put!&amp;quot;&lt;code>放在&lt;/code>c2&amp;rsquo;上。如果在&lt;code>c1&lt;/code>上的取值首先完成，返回其值和通道。如果在&lt;code>c2&lt;/code>上的投放先完成，如果投放成功，返回&lt;code>true&lt;/code>，否则返回&lt;code>false&lt;/code>。&amp;rdquo; 最后，&lt;code>value&lt;/code>的结果（是&lt;code>true&lt;/code>，因为&lt;code>c2&lt;/code>的通道是开放的）打印出来，显示返回的通道确实是&lt;code>c2&lt;/code>。&lt;/p>
&lt;p>像&lt;code>&amp;lt;!!&lt;/code>和&lt;code>&amp;gt;!!&lt;/code>一样，&lt;code>alts!!&lt;/code>有一个停车的选择，&lt;code>alts!&lt;/code>，你可以在 go 块中使用它。 &lt;code>alts!&lt;/code>是一个很好的方法，可以对一组通道中的哪一个进行投入或取出的选择。它仍然执行放和取，所以使用停放或阻塞变量的理由同样适用。&lt;/p>
&lt;p>这就涵盖了 core.async 的基础知识! 本章的其余部分解释了协调进程的两种常见模式。&lt;/p>
&lt;h2 id="队列">队列&lt;/h2>
&lt;p>在第 202 页的 &amp;ldquo;滚动你自己的队列 &amp;ldquo;中，你写了一个宏，让你对 Future 进行排队。进程让你以一种更直接的方式使用类似的技术。假设你想从一个网站上获得一堆随机的报价，并把它们写到一个文件中。你想确保每次只有一个报价被写入文件，这样文本就不会被交错，所以你把你的报价放在一个队列中。下面是完整的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn append-to-file
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Write a string to the end of a file&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [filename s]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (spit filename s :append true))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn format-quote
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Delineate the beginning and end of a quote because it&amp;#39;s convenient&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [quote]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str &amp;#34;=== BEGIN QUOTE ===\n&amp;#34; quote &amp;#34;=== END QUOTE ===\n\n&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn random-quote
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Retrieve a random quote and format it&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> []
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (format-quote (slurp &amp;#34;http://www.braveclojure.com/random-quote&amp;#34;)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn snag-quotes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [filename num-quotes]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [c (chan)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (go (while true (append-to-file filename (&amp;lt;! c))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (dotimes [n num-quotes] (go (&amp;gt;! c (random-quote))))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>函数&lt;code>append-to-file&lt;/code>、&lt;code>format-quote&lt;/code>和&lt;code>random-quote&lt;/code>有文档说明它们的作用。&lt;code>snag-quotes&lt;/code>是发生有趣工作的地方。首先，它创建一个通道，在产生报价的进程和消费报价的进程之间共享。然后，它创建了一个使用 &amp;ldquo;while true &amp;ldquo;来创建一个无限循环的进程。在循环的每一次迭代中，它等待一个报价到达&lt;code>c&lt;/code>，然后将其追加到一个文件中。最后，&lt;code>snag-quotes&lt;/code>创建一个&lt;code>num-quotes&lt;/code>数量的进程来获取一个引号，然后把它放在&lt;code>c&lt;/code>上。如果你求值&lt;code>(snag-quotes &amp;quot;quotes&amp;quot; 2)&lt;/code>并检查你启动 REPL 的目录中的&lt;em>quotes&lt;/em>文件，它应该有两个引号。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">=== BEGIN QUOTE ===
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Nobody&amp;#39;s gonna believe that computers are intelligent until they start
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">coming in late and lying about it.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">=== END QUOTE ===
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">=== BEGIN QUOTE ===
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Give your child mental blocks for Christmas.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">=== END QUOTE ===
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这种排队方式与第 9 章中的例子不同。在那个例子中，每个任务都是按照其创建的顺序来处理的。在这里，每个获取报价的任务是按照它完成的顺序来处理的。在这两种情况下，你都要确保每次只有一个报价被写入文件。&lt;/p>
&lt;h2 id="用进程管道逃离回调地狱">用进程管道逃离回调地狱&lt;/h2>
&lt;p>在没有通道的语言中，你需要用 &amp;ldquo;回调 &amp;ldquo;来表达 &amp;ldquo;当&lt;em>x&lt;/em>发生时，做&lt;em>y&lt;/em>&amp;ldquo;的想法。在像 JavaScript 这样的语言中，回调是一种定义代码的方式，一旦其他代码完成就会异步执行。如果你使用过 JavaScript，你可能已经花了一些时间在&lt;em>回调地狱&lt;/em>中沉溺。&lt;/p>
&lt;p>它被称为回调地狱的原因是，在回调层之间很容易产生不明显的依赖关系。它们最终会共享状态，使得在回调被触发时很难推理整个系统的状态。你可以通过创建一个流程管道来避免这种令人沮丧的结果。这样一来，每个逻辑单元都生活在自己独立的进程中，逻辑单元之间的所有通信都通过明确定义的输入和输出通道进行。&lt;/p>
&lt;p>在下面的例子中，我们创建了三个通过通道连接的无限循环进程，将一个进程的&lt;em>输出&lt;/em>通道作为管道中下一个进程的&lt;em>输入&lt;/em>通道。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn upper-caser
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [in］
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [out (chan)] (让 [out (chan)])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (go (while true (&amp;gt;! out (clojure.string/upper-case (&amp;lt;! in))))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> out))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn reverser
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [in］
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [out (chan)] (go (while true (&amp;gt;!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (go (while true (&amp;gt;! out (clojure.string/reverse (&amp;lt;! in))))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> out))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn printer
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [in］
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (go (while true (println (&amp;lt;! in))))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def in-chan (chan))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def upper-caser-out (upper-caser in-chan))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def reverser-out (reverser upper-caser-out))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(Printer reverser-out)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(&amp;gt;！！in-chan &amp;#34;redrum&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; MURDER
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(&amp;gt;!! in-chan &amp;#34;repaid&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; DIAPER
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通过使用这样的流程处理事件，推理整个数据转换系统的各个步骤就更容易了。你可以查看每个步骤并理解它的作用，而不必参考之前可能发生的事情或之后可能发生的事情；每个过程就像一个纯函数一样容易推理。&lt;/p>
&lt;h2 id="额外资源">额外资源&lt;/h2>
&lt;p>Clojure 的 core.async 库在很大程度上受到 Go 的并发模型的启发，它是基于 Tony Hoare 在&lt;em>Communicating Sequential&lt;/em> &lt;em>Processes&lt;/em>中的工作，可在*&lt;a class="link" href="http://www.usingcsp.com/" target="_blank" rel="noopener"
>http://www.usingcsp.com/&lt;/a>。*&lt;/p>
&lt;p>Go 的共同创造者 Rob Pike 有一个很好的关于并发的演讲，可在*&lt;a class="link" href="https://www.youtube.com/watch?v=f6kdp27TYZs" target="_blank" rel="noopener"
>Google I/O 2012 - Go 并发模式 - YouTube&lt;/a>*。&lt;/p>
&lt;p>ClojureScript，也被称为浏览器的最佳选择，使用 core.async。不再有回调的地狱! 你可以在*&lt;a class="link" href="https://github.com/clojure/clojurescript%3C/span%3E" target="_blank" rel="noopener"
>https://github.com/clojure/clojurescript&lt;/a>*了解 ClojureScript 的情况。&lt;/p>
&lt;p>最后，在*&lt;a class="link" href="http://clojure.github.io/core.async/" target="_blank" rel="noopener"
>clojure.core.async - core.async 1.2.599-SNAPSHOT API documentation&lt;/a>*查看 API 文档。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>在本章中，你了解了 core.async 如何允许你创建并发进程，以响应通道上的 put 和 take 通信事件。你了解了如何使用&lt;code>go&lt;/code>和&lt;code>thread&lt;/code>来创建并发进程，通过停放和阻塞来等待通信事件。你还学习了如何通过使一个进程的&lt;em>出&lt;/em>通道成为另一个进程的&lt;em>入&lt;/em>通道来创建进程管道，以及这如何使你写的代码比嵌套回调更容易理解。最后，你思考了你是否只是一台花哨的热狗售货机。&lt;/p></description></item><item><title>Chapter10 形而上学</title><link>https://example.com/p/chapter10-%E5%BD%A2%E8%80%8C%E4%B8%8A%E5%AD%A6/</link><pubDate>Sat, 15 Jan 2022 12:42:26 +0800</pubDate><guid>https://example.com/p/chapter10-%E5%BD%A2%E8%80%8C%E4%B8%8A%E5%AD%A6/</guid><description>&lt;h1 id="clojure-metaphysics-原子refsvars-和拥抱僵尸">Clojure Metaphysics: 原子、Refs、Vars 和拥抱僵尸&lt;/h1>
&lt;p>三个并发性的小妖精都是从同一个邪恶的坑里生出来的：对可变状态的共享访问。你可以在第九章的引用单元讨论中看到这一点。当两个线程对引用单元进行不协调的更改时，结果是不可预测的。&lt;/p>
&lt;p>Rich Hickey 设计 Clojure 是为了专门解决共享访问易变状态所产生的问题。事实上，Clojure 体现了一种非常清晰的状态概念，使其在本质上比大多数流行的编程语言更安全。它是安全的，一直到它的&lt;em>meta-freakin-physics&lt;/em>。&lt;/p>
&lt;p>在本章中，你将了解 Clojure 的底层形而上学，与典型的面向对象（OO）语言的形而上学相比较。学习这种哲学将使你准备好处理 Clojure 剩下的并发工具，&lt;em>atom&lt;/em>、&lt;em>ref&lt;/em>和&lt;em>var&lt;/em>引用类型。(Clojure 还有一个额外的引用类型，&lt;em>agents&lt;/em>，本书没有涉及。) 这些类型中的每一个都能让你安全地同时执行状态修改操作。你还会学到一些简单的方法，使你的程序更有效率，而不需要引入状态。&lt;/p>
&lt;p>形而上学试图用最广泛的术语来回答两个基本问题。&lt;/p>
&lt;ul>
&lt;li>那里有什么？&lt;/li>
&lt;li>它是什么样子的？&lt;/li>
&lt;/ul>
&lt;p>为了引出 Clojure 和 OO 语言之间的差异，我将解释两种不同的拥抱僵尸的建模方式。与普通的僵尸不同，拥抱僵尸并不想要吞噬你的大脑。它只想用勺子舀你，也许还想闻闻你的脖子。这使得它的不死、摇晃、腐烂的状态更加悲惨。你怎么能试图杀死只想要爱的东西呢？谁是这里真正的怪物？&lt;/p>
&lt;h2 id="面向对象的形而上学">面向对象的形而上学&lt;/h2>
&lt;p>OO 形而上学将拥抱僵尸视为存在于世界上的一个对象。这个对象的属性可能会随着时间的推移而改变，但它仍然被当作一个单一的、不变的对象。如果这看起来是一个完全明显的、没有争议的僵尸形而上学的方法，那么你可能没有在哲学入门课上花几个小时来争论一把椅子的存在意味着什么，以及什么真正使它首先成为一把椅子。&lt;/p>
&lt;p>棘手的部分是，拥抱的僵尸总是在变化。它的身体慢慢恶化。随着时间的推移，它对拥抱的不灭渴望越来越强烈。在 OO 术语中，我们会说拥抱僵尸是一个具有可改变状态的对象，它的状态是不断波动的。但是不管这个僵尸有多大的变化，我们仍然把它认定为同一个僵尸。下面是你如何在 Ruby 中对抱团僵尸进行建模和交互。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">class CuddleZombie
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> # attr_accessor is just a shorthand way for creating getters and
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> # setters for the listed instance variables
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> attr_accessor :cuddle_hunger_level, :percent_deteriorated
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> def initialize(cuddle_hunger_level = 1, percent_deteriorated = 0)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> self.cuddle_hunger_level = cuddle_hunger_level
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> self.percent_deteriorated = percent_deteriorated
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> end
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">end
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fred = CuddleZombie.new(2, 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fred.cuddle_hunger_level # =&amp;gt; 2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fred.percent_deteriorated # =&amp;gt; 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fred.cuddle_hunger_level = 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fred.cuddle_hunger_level # =&amp;gt; 3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>10-1. 用 Ruby 建立抱团僵尸行为模型&lt;/li>
&lt;/ol>
&lt;p>在这个例子中，你创建了一个抱团僵尸，&lt;code>fred&lt;/code>，有两个属性。&lt;code>cuddle_hunger_level&lt;/code>和&lt;code>percent_deteriorated&lt;/code>。&lt;code>fred&lt;/code>一开始的&lt;code>cuddle_hunger_level&lt;/code>是 2，但是你可以把它改成任何你想要的东西，它仍然是好的&amp;rsquo;Fred，同一个拥抱僵尸。在这种情况下，你把它的`cuddle_hunger_level&amp;rsquo;改为 3。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/zombie-metaphysics/cuddle-zombie.png"
loading="lazy"
>&lt;/p>
&lt;p>你可以看到，这个对象只是一个花哨的引用单元。在多线程环境下，它也会受到同样的非确定性结果的影响。例如，如果两个线程试图用&lt;code>fred.cuddle_hunger_level = fred.cuddle_hunger_level + 1&lt;/code>这样的方式来增加 Fred 的饥饿度，其中一个增量可能会丢失，就像《三个小妖精》中两个线程向&lt;code>X&lt;/code>写入的例子一样。参考单元格、相互排斥和矮人狂战士 &amp;ldquo;中的例子。&lt;/p>
&lt;p>即使你只在一个单独的线程上进行读取，程序仍将是非确定性的。例如，假设你正在进行关于抱团僵尸行为的研究。你想记录一个僵尸的饥饿程度，只要它达到 50%的恶化程度，但你想在另一个线程上进行，以提高性能，使用类似清单 10-1 中的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">if fred.percent_deteriorated &amp;gt;= 50
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Thread.new { database_logger.log(fred.cuddle_hunger_level) }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">end
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>这段 Ruby 代码在并发执行时并不安全。&lt;/li>
&lt;/ol>
&lt;p>问题是，另一个线程可能在实际写入之前改变&lt;code>fred&lt;/code>。&lt;/p>
&lt;p>例如，图 10-1 显示了两个从上到下执行的线程。在这种情况下，将 5 写入数据库是正确的，但 10 却被写入了。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/zombie-metaphysics/fred-read.png"
loading="lazy"
>&lt;/p>
&lt;p>图 10-1：记录不一致的抱团僵尸数据&lt;/p>
&lt;p>这将是很不幸的。当你试图从拥抱僵尸的启示中恢复时，你不希望你的数据是不一致的。然而，没有办法保留一个对象在某一特定时刻的状态。&lt;/p>
&lt;p>此外，为了同时改变&lt;code>cuddle_hunger_level&lt;/code>和&lt;code>percent_deteriorated&lt;/code>，你必须特别小心。否则，&lt;code>fred&lt;/code>有可能被视为不一致的状态，因为另一个线程可能会在你打算同时进行的两个变化之间&lt;code>读取&lt;/code>fred`对象，像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">fred.cuddle_hunger_level = fred.cuddle_hunger_level + 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># At this time, another thread could read fred&amp;#39;s attributes and
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># &amp;#34;perceive&amp;#34; fred in an inconsistent state unless you use a mutex
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fred.percent_deteriorated = fred.percent_deteriorated + 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这是另一个版本的互斥问题。在面向对象编程（OOP）中，你可以用&lt;em>mutex&lt;/em>来手动解决这个问题，它可以确保在 mutex 的持续时间内，每次只有一个线程可以访问一个资源（在本例中，就是&lt;code>fred&lt;/code>对象）。&lt;/p>
&lt;p>对象永远不稳定的事实并不妨碍我们把它们当作程序的基本构件。事实上，这被认为是 OOP 的一个优势。状态如何变化并不重要；你仍然可以与一个稳定的接口进行交互，一切都会正常工作。这符合我们对世界的直观感觉。一块蜡仍然是同一块蜡，即使它的属性发生了变化：如果我改变了它的颜色，融化了它，然后把它倒在我的敌人的脸上，我仍然会认为它是我开始时的那个蜡对象。&lt;/p>
&lt;p>另外，在 OOP 中，对象也会做事。它们相互作用，在程序运行时改变状态。同样，这也符合我们对世界的直观感觉：变化是对象相互作用的结果。一个人的对象推到一个门的对象上，进入一个房子的对象。&lt;/p>
&lt;h2 id="clojure-形而上学">Clojure 形而上学&lt;/h2>
&lt;p>在 Clojure 形而上学中，我们会说，我们永远不会遇到两次相同的拥抱僵尸。拥抱僵尸并不是一个独立于其变异而存在于世界上的离散事物：它实际上是一连串的&lt;em>价值&lt;/em>。&lt;/p>
&lt;p>术语&lt;em>值&lt;/em>经常被 Clojurists 使用，其具体含义可能与你的习惯不同。价值是*原子性的，即它们在一个更大的系统中形成一个单一的不可还原的单位或组成部分；它们是不可分割的、不变的、稳定的实体。数字是价值：数字 15 变异为另一个数字是没有意义的。当你从 15 加减时，你并没有改变 15 这个数字；你只是得到了一个不同的数字。Clojure 的数据结构也是价值，因为它们是不可改变的。当你在一个 Map 上使用&lt;code>assoc&lt;/code>时，你不会修改原来的 Map；相反，你会派生出一个新的 Map。&lt;/p>
&lt;p>所以一个值不会改变，但是你可以对一个值应用一个&lt;em>过程来产生一个新的值。例如，假设我们从一个值&lt;/em>F1&lt;em>开始，然后我们把&lt;/em>拥抱僵尸&lt;em>过程应用到&lt;/em>F1*，产生值&lt;em>F2&lt;/em>。然后这个过程又被应用到&lt;em>F2&lt;/em>的值上，产生&lt;em>F3&lt;/em>的值，以此类推。&lt;/p>
&lt;p>这导致了对&lt;em>身份&lt;/em>的不同概念。Clojure 形而上学不是像 OO 形而上学那样把身份理解为变化的对象所固有的，而是把身份理解为我们人类强加给由一个过程随时间产生的一连串不变的值的东西。我们使用&lt;em>名字&lt;/em>来指定身份。名字&lt;em>Fred&lt;/em>是指一系列单独的状态&lt;em>F1&lt;/em>、&lt;em>F2&lt;/em>、&lt;em>F3&lt;/em>等等的方便方法。从这个角度来看，不存在所谓的可改变的状态。相反，&lt;em>state&lt;/em>指的是某个时间点上的身份值。&lt;/p>
&lt;p>Rich Hickey 用电话号码的比喻来解释状态。 &lt;em>Alan 的电话号码&lt;/em>已经改变了 10 次，但我们将永远用同一个名字来称呼这些号码，即&lt;em>Alan 的电话号码&lt;/em>。艾伦五年前的电话号码与今天的电话号码是不同的数值，两者是艾伦电话号码身份的两种状态。&lt;/p>
&lt;p>当你考虑到在你的程序中你是在处理关于世界的信息时，这是有意义的。与其说信息发生了变化，不如说你收到了新的信息。周五中午 12 点，&amp;ldquo;抱抱僵尸 &amp;ldquo;弗雷德处于 50%的腐烂状态。在下午 1 点，他是 60%的腐烂。这都是你可以处理的事实，引入一个新的事实并不会使以前的事实失效。即使弗雷德的衰变率从 50%增加到 60%，但在下午 12:00 时他处于 50%的衰变状态仍然是事实。&lt;/p>
&lt;p>图 10-2 显示了你可以如何将价值、过程、身份和状态可视化。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/zombie-metaphysics/fp-metaphysics.png"
loading="lazy"
>&lt;/p>
&lt;p>图 10-2：价值、过程、身份和状态&lt;/p>
&lt;p>这些价值不会相互作用，也不能被改变。它们不能*做任何事情。只有在以下情况下才会发生变化：a）一个过程产生了一个新的值；b）我们选择将身份与新的值联系起来。&lt;/p>
&lt;p>为了处理这种变化，Clojure 使用&lt;em>参考类型&lt;/em>。参考类型让你在 Clojure 中管理身份。使用它们，你可以命名一个身份并检索其状态。让我们来看看其中最简单的，&lt;em>原子&lt;/em>。&lt;/p>
&lt;h2 id="原子">原子&lt;/h2>
&lt;p>Clojure 的原子引用类型允许你赋予一连串的相关值以身份。下面是你如何创建一个原子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def fred (atom {:cuddle-hunger-level 0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :percent-deteriorated 0}))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这将创建一个新的原子，并将其与名称&lt;code>fred&lt;/code>绑定。这个原子*引用了&lt;code>{:cuddle-hunger-level 0 :percent-deteriorated 0}&lt;/code>的值，你可以说这是它的当前状态。&lt;/p>
&lt;p>要得到一个原子的当前状态，你要解除对它的引用。下面是 Fred 的当前状态。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">@fred
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:cuddle-hunger-level 0, :percent-deteriorated 0}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>与期货、延迟和承诺不同，解除对原子（或任何其他引用类型）的引用将永远不会阻塞。当你解除对期货、延迟和承诺的引用时，就像你在说 &amp;ldquo;我现在需要一个值，我会一直等到我得到它&amp;rdquo;，所以这个操作会阻塞是合理的。然而，当你解除引用类型的引用时，就像你在说 &amp;ldquo;给我我现在引用的值&amp;rdquo;，所以操作不会阻塞是有道理的，因为它不需要等待任何东西。&lt;/p>
&lt;p>在清单 10-1 中的 Ruby 例子中，我们看到当你试图在一个单独的线程上记录数据时，对象数据可能会发生变化。当使用原子来管理状态时就不会发生这种危险，因为每个状态都是不可改变的。下面是你如何用&lt;code>println&lt;/code>来记录一个僵尸的状态。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [zombie-state @fred]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if (&amp;gt;= (:percent-deteriorated zombie-state) 50)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (future (println (:cuddle-hunger-level zombie-state)))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>清单 10-1 中的 Ruby 例子的问题是，它需要两步来读取僵尸的两个属性，而其他线程可能在这两步之间改变这些属性。然而，通过使用原子来引用不可变的数据结构，你只需要执行一次读取，并且返回的数据结构不会被其他线程改变。&lt;/p>
&lt;p>要更新原子，使其指向一个新的状态，你可以使用&lt;code>swap!&lt;/code>。这似乎是矛盾的，因为我说过，原子值是不变的。的确，它们是不变的。但是现在我们正在使用原子的&lt;em>参考类型&lt;/em>，一个指向原子值的结构。原子值不会改变，但是引用类型可以被更新并被分配一个新的值。&lt;/p>
&lt;p>&lt;code>swap!&lt;/code>接收一个原子和一个函数作为参数。它将函数应用于原子的当前状态以产生一个新的值，然后它更新原子以引用这个新的值。新的值也被返回。下面是你如何将 Fred 的拥抱饥饿度提高 1。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(swap! fred
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (fn [current-state]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (merge-with + current-state {:cuddle-hunger-level 1})))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:cuddle-hunger-level 1, :percent-deteriorated 0}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>取消引用&lt;code>fred&lt;/code>将返回新的状态。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">@fred
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:cuddle-hunger-level 1, :percent-deteriorated 0}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>与 Ruby 不同，&lt;code>fred&lt;/code>不可能处于不一致的状态，因为你可以同时更新饥饿度和恶化百分比，像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(swap! fred
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (fn [current-state]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (merge-with + current-state {:cuddle-hunger-level 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :percent-deteriorated 1})))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:cuddle-hunger-level 2, :percent-deteriorated 1}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段代码传递给&lt;code>swap!&lt;/code>一个只需要一个参数的函数，&lt;code>current-state&lt;/code>。你也可以传递&lt;code>swap!&lt;/code>一个需要多个参数的函数。例如，你可以创建一个需要两个参数的函数，一个是僵尸状态，另一个是增加其拥抱饥饿度的数量。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn increase-cuddle-hunger-level
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [zombie-state increase-by]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (merge-with + zombie-state {:cuddle-hunger-level increase-by}))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>让我们在僵尸状态下快速测试一下&lt;code>increase-cuddle-hunger-level&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(increase-cuddle-hunger-level @fred 10)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:cuddle-hunger-level 12, :percent-deteriorated 1}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，这段代码实际上并没有更新&lt;code>fred&lt;/code>，因为我们没有使用&lt;code>swap!&lt;/code>，我们只是对&lt;code>increase-cuddle-&lt;/code>hunger&lt;code>-level&lt;/code>做了一个正常的函数调用，它返回一个结果。&lt;/p>
&lt;p>现在用附加参数调用&lt;code>swap!&lt;/code>，&lt;code>@fred&lt;/code>将被更新，就像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(swap! fred increase-cuddle-hunger-level 10)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:cuddle-hunger-level 12, :percent-deteriorated 1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">@fred
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:cuddle-hunger-level 12, :percent-deteriorated 1}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>或者你可以用 Clojure 的内置函数来表达整个事情。&lt;code>update-in&lt;/code>函数需要三个参数：一个集合，一个用于识别要更新的值的 Vector，以及一个更新该值的函数。它还可以接受额外的参数，这些参数将被传递给更新函数。下面是几个例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(update-in {:a {:b 3}} [:a :b] inc)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:a {:b 4}}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(update-in {:a {:b 3}} [:a :b] + 10)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:a {:b 13}}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在第一个例子中，你正在更新 Map&lt;code>{:a {:b 3}}。Clojure使用Vector&lt;/code>[:a :b]&lt;code>来遍历嵌套图；&lt;/code>:a&lt;code>产生嵌套图&lt;/code>{:b 3}&lt;code>，&lt;/code>:b&lt;code>产生值&lt;/code>3&lt;code>。Clojure将&lt;/code>inc&lt;code>函数应用于&lt;/code>3&lt;code>，并返回一个替换了&lt;/code>3`的新 Map。&lt;/p>
&lt;p>下面是你如何使用&lt;code>update-in&lt;/code>函数来改变 Fred 的状态。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(swap! fred update-in [:cuddle-hunger-level] + 10)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:cuddle-hunger-level 22, : percent-deteriorated 1}.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通过使用原子，你可以保留过去的状态。你可以解除引用一个原子来检索状态 1，然后更新该原子，创建状态 2，并仍然使用状态 1。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [num (atom 1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> s1 @num]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (swap! num inc)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;State 1:&amp;#34; s1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;Current state:&amp;#34; @num))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; State 1: 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Current state: 2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段代码创建了一个名为 &amp;ldquo;num &amp;ldquo;的原子，检索其状态，更新其状态，然后打印其过去的状态和当前的状态，表明当我说你可以保留过去的状态时，我并不是要欺骗你，因此你可以信任我所有的东西&amp;ndash;包括你的真实姓名，我保证只说出你的真实姓名，以拯救你脱离致命的危险。&lt;/p>
&lt;p>这一切都很有趣，但如果两个独立的线程调用&amp;rdquo;（交换！弗雷德增加-拥抱-饥饿等级 1）&amp;ldquo;会发生什么？是否有可能像清单 10-1 中的 Ruby 例子那样，其中一个增量被丢失？&lt;/p>
&lt;p>答案是否定的! &lt;code>swap!&lt;/code>实现了&lt;em>比较和设置&lt;/em>的语义，意味着它在内部做了以下工作。&lt;/p>
&lt;ol>
&lt;li>它读取原子的当前状态。&lt;/li>
&lt;li>然后将更新函数应用于该状态。&lt;/li>
&lt;li>接下来，它检查它在步骤 1 中读取的值是否与原子的当前值相同。&lt;/li>
&lt;li>如果是，那么&lt;code>swap!&lt;/code>就更新原子以引用步骤 2 的结果。&lt;/li>
&lt;li>如果不是，那么&lt;code>swap!&lt;/code>重试，从第 1 步开始再次经历这个过程。&lt;/li>
&lt;/ol>
&lt;p>这个过程保证了没有交换会丢失。&lt;/p>
&lt;p>关于&lt;code>swap!&lt;/code>需要注意的一个细节是，原子更新是同步发生的；它们将阻塞其线程。例如，如果你的更新函数由于某种原因调用了&lt;code>Thread/sleep 1000&lt;/code>，那么当&lt;code>swap!&lt;/code>完成时，线程将阻塞至少一秒钟。&lt;/p>
&lt;p>有时你会想更新一个原子而不检查它的当前值。例如，你可能会开发一种血清，将一个抱枕僵尸的饥饿度和恶化度设置为零。对于这些情况，你可以使用&lt;code>reset!&lt;/code>函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(reset! fred {:cuddle-hunger-level 0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :percent-deteriorated 0})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就涵盖了 atoms 的所有核心功能! 总结一下：原子实现了 Clojure 的状态概念。它们允许你为一系列不可变的值赋予一个身份。它们通过比较和设置语义为引用单元和互斥问题提供了解决方案。它们还允许你处理过去的状态，而不用担心它们会在原地变异。&lt;/p>
&lt;p>除了这些核心特性外，原子还与其他引用类型共享两个特性。你可以在原子上附加&lt;em>watches&lt;/em>和&lt;em>validators&lt;/em>。现在让我们来看看这些。&lt;/p>
&lt;h2 id="手表和验证器">手表和验证器&lt;/h2>
&lt;p>观察器允许你超级猥琐地检查你的参考类型的一举一动。验证器允许你有超强的控制力，限制哪些状态是可以允许的。钟表和验证器都是普通的函数。&lt;/p>
&lt;h3 id="手表">手表&lt;/h3>
&lt;p>一个&lt;em>watch&lt;/em>是一个函数，它需要四个参数：一个键，被监视的引用，它的前一个状态，以及它的新状态。你可以为一个引用类型注册任意数量的手表。&lt;/p>
&lt;p>比方说，一个僵尸的洗牌速度（以每小时洗牌次数衡量，或称 SPH）取决于其饥饿程度和恶化程度。下面是你的计算方法，用拥抱的饥饿程度乘以它的完整程度。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn shuffle-speed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [zombie]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (* (:cuddle-hunger-level zombie)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (- 100 (:percent-deteriorated zombie))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们还可以说，每当僵尸的洗牌速度达到 5000SPH 的危险水平时，你都想得到提醒。否则，你想被告知一切都很好。下面是一个观察函数，你可以用来在 SPH 超过 5000 时打印一个警告信息，否则打印一个一切正常的信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn shuffle-alert
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [key watched old-state new-state]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [sph (shuffle-speed new-state)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if (&amp;gt; sph 5000)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (do
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;Run, you fool!&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;The zombie&amp;#39;s SPH is now &amp;#34; sph)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;This message brought to your courtesy of &amp;#34; key))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (do
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;All&amp;#39;s well with &amp;#34; key)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;Cuddle hunger: &amp;#34; (:cuddle-hunger-level new-state))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;Percent deteriorated: &amp;#34; (:percent-deteriorated new-state))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;SPH: &amp;#34; sph)))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>观察函数有四个参数：一个可以用来报告的键，被观察的原子，原子更新前的状态，以及原子更新后的状态。这个观察函数计算新状态的洗牌速度，如果它过高，就打印一个警告信息，当洗牌速度安全时，就打印一个一切正常的信息，如上所述。在这两组信息中，&lt;code>key&lt;/code>被用来让你知道信息的来源。&lt;/p>
&lt;p>你可以用&lt;code>add-watch&lt;/code>把这个函数附加到&lt;code>fred&lt;/code>上。&lt;code>add-watch&lt;/code>的一般形式是&lt;code>（add-watch&lt;/code> ref key watch-fn&lt;code>）&lt;/code>。在这个例子中，我们要重置&lt;code>fred&lt;/code>的状态，添加&lt;code>shuffle-alert&lt;/code>的观察函数，然后多次更新&lt;code>fred&lt;/code>的状态以触发&lt;code>shuffle-alert&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(reset! fred {:cuddle-hunger-level 22
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :percent-deteriorated 2})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(add-watch fred :fred-shuffle-alert shuffle-alert)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(swap! fred update-in [:percent-deteriorated] + 1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; All&amp;#39;s well with :fred-shuffle-alert
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Cuddle hunger: 22
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Percent deteriorated: 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; SPH: 2134
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(swap! fred update-in [:cuddle-hunger-level] + 30)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Run, you fool!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; The zombie&amp;#39;s SPH is now 5044
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; This message brought to your courtesy of :fred-shuffle-alert
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个观察函数的例子没有使用&lt;code>watched&lt;/code>或&lt;code>old-state&lt;/code>，但如果有需要，它们就在那里。现在我们来谈谈验证器。&lt;/p>
&lt;h3 id="验证器">验证器&lt;/h3>
&lt;p>&lt;em>验证器&lt;/em>可以让你指定一个引用可以有哪些状态。例如，这里有一个验证器，你可以用来确保一个僵尸的&lt;code>:%-deteriorated&lt;/code>在 0 到 100 之间。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn percent-deteriorated-validator
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [{:keys [percent-deteriorated]}]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (and (&amp;gt;= percent-deteriorated 0)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (&amp;lt;= percent-deteriorated 100)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>正如你所看到的，验证器只需要一个参数。当你给一个引用添加验证器时，该引用被修改，这样，每当它被更新时，它将调用这个验证器，并将更新函数返回的值作为其参数。如果验证器因返回 &amp;ldquo;false &amp;ldquo;或抛出一个异常而失败，引用将不会改变以指向新的值。&lt;/p>
&lt;p>你可以在创建原子时附加一个验证器。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def bobby
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (atom
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:cuddle-hunger-level 0 :percent-deteriorated 0}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :validator percent-deteriorated-validator))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(swap! bobby update-in [:percent-deteriorated] + 200)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; This throws &amp;#34;Invalid reference state&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子中，&lt;code>percent-deteriorated-validator&lt;/code>返回&lt;code>false&lt;/code>，原子更新失败。&lt;/p>
&lt;p>你可以抛出一个异常，以获得一个更具描述性的错误信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn percent-deteriorated-validator
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [{:keys [percent-deteriorated]}]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (or (and (&amp;gt;= percent-deteriorated 0)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (&amp;lt;= percent-deteriorated 100))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (throw (IllegalStateException. &amp;#34;That&amp;#39;s not mathy!&amp;#34;))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def bobby
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (atom
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:cuddle-hunger-level 0 :percent-deteriorated 0}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :validator percent-deteriorated-validator))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(swap! bobby update-in [:percent-deteriorated] + 200)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; This throws &amp;#34;IllegalStateException: That&amp;#39;s not mathy!&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>相当不错! 现在让我们来看看裁判。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/zombie-metaphysics/sock-gnome.png"
loading="lazy"
>&lt;/p>
&lt;p>原子是管理独立身份状态的理想选择。但有时，我们需要表达一个事件应该同时更新一个以上的身份的状态。 &lt;em>Refs&lt;/em>是这种情况下的完美工具。&lt;/p>
&lt;p>一个典型的例子是记录 sock gnome 交易。我们都知道，袜子侏儒从世界各地的每一个干衣机中取出一只袜子。他们用这些袜子来孵化他们的孩子。作为对这种*&amp;quot;*礼物 &amp;ldquo;的回报，袜子地精保护你的家不被 El Chupacabra 入侵。如果你最近没有被 El Chupacabra 拜访，你要感谢袜子侏儒。&lt;/p>
&lt;p>为了建立袜子转移的模型，我们需要表达的是，一个烘干机失去了一只袜子，一个地精同时得到了一只袜子。这一刻，袜子属于烘干机；下一刻，它属于地精。这只袜子不应该同时属于烘干机和侏儒，也不应该同时属于这两个人。&lt;/p>
&lt;h3 id="为袜子转移建模">为袜子转移建模&lt;/h3>
&lt;p>你可以用 refs 来模拟这个 sock 传输。Refs 允许你使用事务语义来更新多个身份的状态。这些交易有三个特点。&lt;/p>
&lt;ul>
&lt;li>它们是&lt;em>原子性的&lt;/em>，意味着所有的参考文献都被更新，或者都不被更新。&lt;/li>
&lt;li>它们是&lt;em>一致的&lt;/em>，这意味着引用总是显示为有效的状态。一个 sock 总是属于一个 dryer 或一个 gnome，但绝不是两者都属于。&lt;/li>
&lt;li>它们是&lt;em>隔离的&lt;/em>，这意味着事务的行为就像它们是连续执行的一样；如果两个线程同时运行改变同一参考信息的事务，一个事务将重试。这类似于原子的比较和设置语义。&lt;/li>
&lt;/ul>
&lt;p>你可能认识到这些是数据库事务的 ACID 属性中的&lt;em>A&lt;/em>、&lt;em>C&lt;/em>和&lt;em>I&lt;/em>。你可以认为 Refs 给你提供了与数据库事务相同的并发安全性，只是在内存中的数据。&lt;/p>
&lt;p>Clojure 使用*软件事务性内存（STM）*来实现这种行为。STM 非常酷，但当你开始使用 Clojure 时，你不需要对它了解太多；你只需要知道如何使用它，这就是本节要告诉你的。&lt;/p>
&lt;p>让我们开始转移一些袜子吧! 首先，你需要编码一些袜子和 gnome 的创建技术。下面的代码定义了一些袜子品种，然后定义了几个辅助函数。 &lt;code>sock-count'将被用来帮助记录每一种袜子有多少只属于地精或烘干机，而&lt;/code>generate-sock-gnome&amp;rsquo;将创建一个新的、没有袜子的地精。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def sock-varieties
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> #{&amp;#34;darned&amp;#34; &amp;#34;argyle&amp;#34; &amp;#34;wool&amp;#34; &amp;#34;horsehair&amp;#34; &amp;#34;mulleted&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;passive-aggressive&amp;#34; &amp;#34;striped&amp;#34; &amp;#34;polka-dotted&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;athletic&amp;#34; &amp;#34;business&amp;#34; &amp;#34;power&amp;#34; &amp;#34;invisible&amp;#34; &amp;#34;gollumed&amp;#34;})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn sock-count
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [sock-variety count]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:variety sock-variety
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :count count})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn generate-sock-gnome
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Create an initial sock gnome state with no socks&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [name]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :socks #{}})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在你可以创建你的实际参照物了。侏儒将有 0 只袜子。另一方面，烘干机将有一组由袜子品种集生成的袜子对。下面是我们的参考文献。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def sock-gnome (ref (generate-sock-gnome &amp;#34;Barumpharumph&amp;#34;)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def dryer (ref {:name &amp;#34;LG 1337&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :socks (set (map #(sock-count % 2) sock-varieties))}))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以像解除对原子的引用一样解除对 ref 的引用。在这个例子中，你的袜子的顺序可能会不同，因为我们使用的是一个无序的集合。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(:socks @dryer)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #{{:variety &amp;#34;passive-aggressive&amp;#34;, :count 2} {:variety &amp;#34;power&amp;#34;, :count 2}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:variety &amp;#34;athletic&amp;#34;, :count 2} {:variety &amp;#34;business&amp;#34;, :count 2}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:variety &amp;#34;argyle&amp;#34;, :count 2} {:variety &amp;#34;horsehair&amp;#34;, :count 2}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:variety &amp;#34;gollumed&amp;#34;, :count 2} {:variety &amp;#34;darned&amp;#34;, :count 2}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:variety &amp;#34;polka-dotted&amp;#34;, :count 2} {:variety &amp;#34;wool&amp;#34;, :count 2}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:variety &amp;#34;mulleted&amp;#34;, :count 2} {:variety &amp;#34;striped&amp;#34;, :count 2}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:variety &amp;#34;invisible&amp;#34;, :count 2}}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在一切都准备好了，可以进行转移了。我们要修改&lt;code>sock-gnome&lt;/code>参数，以显示它获得了一只袜子，并修改&lt;code>dryer&lt;/code>参数，以显示它失去了一只袜子。你用&lt;code>alter'来修改引用，而且你必须在一个事务中使用&lt;/code>alter&amp;rsquo;。 &lt;code>dosync&lt;/code>启动一个事务并定义其范围；你把所有的事务操作放在其主体中。这里我们使用这些工具来定义一个`steal-sock&amp;rsquo;函数，然后在我们的两个参考文件上调用它。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn steal-sock
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [gnome dryer]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (dosync
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (when-let [pair (some #(if (= (:count %) 2) %) (:socks @dryer))]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [updated-count (sock-count (:variety pair) 1)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (alter gnome update-in [:socks] conj updated-count)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (alter dryer update-in [:socks] disj pair)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (alter dryer update-in [:socks] conj updated-count)))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(steal-sock sock-gnome dryer)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(:socks @sock-gnome)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #{{:variety &amp;#34;passive-aggressive&amp;#34;, :count 1}}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在团子有一只被动攻击型的袜子，而烘干机少了一只（你的团子可能偷了一只不同的袜子，因为袜子是以无序的方式存储的）。让我们确保所有被动攻击的袜子都被计算在内。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn similar-socks
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [target-sock sock-set]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (filter #(= (:variety %) (:variety target-sock)) sock-set))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(similar-socks (first (:socks @sock-gnome)) (:socks @dryer))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; ({:variety &amp;#34;passive-aggressive&amp;#34;, :count 1})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里有几个细节需要注意：当你&lt;code>改变&lt;/code>一个引用时，这个改变在当前事务之外并不立即可见。这使得你可以在一个事务中对&lt;code>dryer&lt;/code>调用&lt;code>alter&lt;/code>两次，而不用担心&lt;code>dryer&lt;/code>会在不一致的状态下被读取。同样的，如果你&lt;code>改变&lt;/code>一个引用，然后在同一个事务中&lt;code>deref&lt;/code>它，&lt;code>deref&lt;/code>将返回新的状态。&lt;/p>
&lt;p>这里有一个例子来证明这个交易中状态的想法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def counter (ref 0))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(future
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (dosync
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (alter counter inc)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println @counter)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (Thread/sleep 500)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (alter counter inc)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println @counter)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(Thread/sleep 250)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(println @counter)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这将依次打印出 1、0 和 2。首先，你创建了一个引用，&lt;code>counter&lt;/code>，用来保存数字 0。然后你用&lt;code>future&lt;/code>创建一个新的线程来运行一个事务。在事务线程中，你增加计数器并打印它，然后数字 1 被打印出来。同时，主线程等待了 250 毫秒，也打印了计数器的值。然而，主线程上的计数器的值仍然是 0&amp;ndash;主线程是在事务之外的，不能访问事务的状态。这就像事务有自己的私有区域，用于尝试对状态的改变，而世界上的其他人在事务完成之前不能知道它们。这在事务代码中得到了进一步说明：在它第一次打印之后，它再次将计数器从 1 增加到 2，并打印出结果 2。&lt;/p>
&lt;p>事务只有在结束时才会尝试提交其变更。提交的工作原理类似于原子的比较和设置语义。每个引用都会被检查，看它在你第一次试图改变它之后是否有变化。如果有任何&lt;em>个引用发生了变化，那么&lt;/em>个引用都不会被更新，事务会被重试。例如，如果事务 A 和事务 B 在同一时间被尝试，并且事件按以下顺序发生，事务 A 将被重试。&lt;/p>
&lt;ol>
&lt;li>事务 A： alter gnome&lt;/li>
&lt;li>交易 B: alter gnome&lt;/li>
&lt;li>交易 B：改变烘干机&lt;/li>
&lt;li>交易 B：改变烘干机&lt;/li>
&lt;li>事务 B：提交-成功地更新 gnome 和 dryer&lt;/li>
&lt;li>事务 A：改变 dryer&lt;/li>
&lt;li>事务 A：改变烘干机&lt;/li>
&lt;li>事务 A：提交失败，因为 dryer 和 gnome 已经改变；重试。&lt;/li>
&lt;/ol>
&lt;p>这就是你的工作! 安全、简单、并发地协调状态变化。但这还不是全部! Refs 还有一个可疑的长袖子的技巧：&lt;code>commute&lt;/code>。&lt;/p>
&lt;h3 id="commute">commute&lt;/h3>
&lt;p>&lt;code>commute&lt;/code>允许你在一个事务中更新一个 ref 的状态，就像 &lt;code>alter&lt;/code>一样。然而，它在提交时的行为是完全不同的。下面是`alter&amp;rsquo;的行为方式。&lt;/p>
&lt;ol>
&lt;li>在事务之外，读取 Ref 的当前状态。&lt;/li>
&lt;li>将当前状态与引用者在事务中开始时的状态进行比较。&lt;/li>
&lt;li>如果两者不同，则重试交易。&lt;/li>
&lt;li>否则，提交改变后的引用状态。&lt;/li>
&lt;/ol>
&lt;p>另一方面，&lt;code>commute&lt;/code>在提交时的行为是这样的。&lt;/p>
&lt;ol>
&lt;li>在事务之外，读取引用的当前状态。&lt;/li>
&lt;li>使用当前状态再次运行&lt;code>commute&lt;/code>函数。&lt;/li>
&lt;li>提交结果。&lt;/li>
&lt;/ol>
&lt;p>正如你所看到的，&lt;code>commute&lt;/code>并不强迫事务重试。这可以帮助提高性能，但重要的是，只有当你确定你的 refs 不可能最终处于无效状态时才使用 &lt;code>commute'。让我们看看&lt;/code>commute`的安全和不安全使用的例子。&lt;/p>
&lt;p>下面是一个安全使用的例子。&lt;code>sleep-print-update&lt;/code>函数返回更新的状态，但同时也睡眠了指定的毫秒数，所以我们可以强制事务重叠。它打印了它试图更新的状态，所以我们可以深入了解正在发生的事情。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn sleep-print-update
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [sleep-time thread-name update-fn]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (fn [state]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (Thread/sleep sleep-time)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (str thread-name &amp;#34;: &amp;#34; state))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (update-fn state)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def counter (ref 0))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(future (dosync (commute counter (sleep-print-update 100 &amp;#34;Thread A&amp;#34; inc))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(future (dosync (commute counter (sleep-print-update 150 &amp;#34;Thread B&amp;#34; inc))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下面是打印的时间线。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Thread A: 0 | 100ms
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Thread B: 0 | 150ms
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Thread A: 0 | 200ms
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Thread B: 1 | 300ms
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>请注意，最后打印的一行是 &amp;ldquo;线程 B：1&amp;rdquo;。这意味着&lt;code>sleep-print-update&lt;/code>在第二次运行时收到&lt;code>1&lt;/code>作为状态参数。这是有道理的，因为此时线程 A 已经提交了它的结果。如果你在事务运行后解除对&lt;code>counter&lt;/code>的引用，你会发现其值是&lt;code>2&lt;/code>。&lt;/p>
&lt;p>现在，这里有一个不安全交换的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def receiver-a (ref #{}))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def receiver-b (ref #{}))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def giver (ref #{1}))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(do (future (dosync (let [gift (first @giver)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (Thread/sleep 10)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (commute receiver-a conj gift)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (commute giver disj gift))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (future (dosync (let [gift (first @giver)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (Thread/sleep 50)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (commute receiver-b conj gift)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (commute giver disj gift)))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">@receiver-a
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #{1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">@receiver-b
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #{1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">@giver
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #{}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>1&lt;/code>被赋予了&lt;code>receiver-a&lt;/code>和&lt;code>receiver-b&lt;/code>，你最终得到了两个&lt;code>1&lt;/code>的实例，这对你的程序是无效的。这个例子的不同之处在于，应用的函数，基本上是&lt;code>#(conj % gift)&lt;/code>和&lt;code>#(disj % gift)&lt;/code>，是由&lt;code>giver&lt;/code>的状态派生的。一旦&lt;code>giver&lt;/code>发生变化，派生的函数就会产生一个无效的状态，但是&lt;code>commute&lt;/code>并不关心产生的状态是无效的，无论如何都会提交结果。这里的教训是，尽管&lt;code>commute&lt;/code>可以帮助你加快程序的速度，但你必须明智地决定何时使用它。&lt;/p>
&lt;p>现在你已经准备好开始安全、理智地使用 Refs 了。引用还有一些细微的差别，我在此不做介绍，但如果你对它们感到好奇，你可以研究&lt;code>ensure&lt;/code>函数和&lt;em>write skew&lt;/em>现象。&lt;/p>
&lt;p>接下来是本书涉及的最后一种参考文献类型。 &lt;em>vars&lt;/em>。&lt;/p>
&lt;h2 id="vars">Vars&lt;/h2>
&lt;p>你已经在第 6 章中了解了一些关于 vars 的知识。简单的说, &lt;em>vars&lt;/em>是符号和对象之间的关联。你可以用&lt;code>def&lt;/code>创建新的变量。&lt;/p>
&lt;p>尽管 vars 并不像原子和 refs 那样用来管理状态，但它们确实有一些并发的技巧：你可以动态地绑定它们，并且可以改变它们的根。让我们先来看看动态绑定。&lt;/p>
&lt;h3 id="动态绑定">动态绑定&lt;/h3>
&lt;p>当我第一次介绍&lt;code>def&lt;/code>时，我恳请你把它当作定义一个常量。事实证明，vars 比这更灵活：你可以创建一个&lt;em>动态&lt;/em>的 var，它的绑定可以被改变。动态变量对于创建一个全局名称是非常有用的，它应该在不同的情况下指代不同的值。&lt;/p>
&lt;h4 id="创建和绑定动态变量">创建和绑定动态变量&lt;/h4>
&lt;p>首先，创建一个动态 var。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def:dynamic *notification-address* &amp;#34;dobby@elf.org&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意这里有两个重要的细节。首先，你用&lt;code>^:dynamic&lt;/code>向 Clojure 发出信号，表明一个 var 是动态的。第二，var 的名字是由星号括起来的。Lispers 称这些为&lt;em>earmuffs&lt;/em>，这很可爱。Clojure 要求你将动态变量的名字用耳罩括起来。这有助于向其他程序员发出该变量的&lt;em>动态性&lt;/em>的信号。&lt;/p>
&lt;p>与普通变量不同，你可以通过使用&lt;code>binding&lt;/code>来临时改变动态变量的值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(binding [*notification-address* &amp;#34;test@elf.org&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> *notification-address*)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;test@elf.org&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你也可以堆叠绑定（就像你可以用&lt;code>let&lt;/code>）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(binding [*notification-address* &amp;#34;tester-1@elf.org&amp;#34;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println *notification-address*)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (binding [*notification-address* &amp;#34;tester-2@elf.org&amp;#34;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println *notification-address*))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println *notification-address*))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; tester-1@elf.org
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; tester-2@elf.org
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; tester-1@elf.org
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在你知道了如何动态绑定一个 var，让我们看看一个真实世界的应用。&lt;/p>
&lt;h4 id="动态-var-的用途">动态 var 的用途&lt;/h4>
&lt;p>比方说，你有一个发送通知邮件的函数。在这个例子中，我们将只是返回一个字符串，但假装这个函数真的发送了电子邮件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn notify
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [message]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str &amp;#34;TO: &amp;#34; *notification-address* &amp;#34;\n&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;MESSAGE: &amp;#34; message))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(notify &amp;#34;I fell.&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;TO: dobby@elf.org\nMESSAGE: I fell.&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果你想测试这个函数，而不在每次你的规格运行时向多比发送垃圾邮件，怎么办？这时就需要&lt;code>binding&lt;/code>来帮忙了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(binding [*notification-address* &amp;#34;test@elf.org&amp;#34;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (notify &amp;#34;test!&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;TO: test@elf.org\nMESSAGE: test!&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当然，你可以直接定义&lt;code>notify&lt;/code>来接受一个电子邮件地址作为参数。事实上，这通常是正确的选择。为什么要用动态变量来代替呢？&lt;/p>
&lt;p>动态变量最常被用来命名一个或多个函数的目标资源。在这个例子中，你可以把电子邮件地址看作是你写给它的资源。事实上，Clojure 为这个目的提供了大量的内置动态变量。 例如，&amp;quot;&lt;em>out&lt;/em>&amp;ldquo;代表打印操作的标准输出。在你的程序中，你可以重新绑定&lt;code>*out*&lt;/code>，使打印语句写到一个文件中，就像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(binding [*out* (clojure.java.io/writer &amp;#34;print-output&amp;#34;)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;A man who carries a cat by the tail learns
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">something he can learn in no other way.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-- Mark Twain&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(slurp &amp;#34;print-output&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; A man who carries a cat by the tail learns
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> something he can learn in no other way.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> -- Mark Twain
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这比每次调用 &amp;ldquo;println &amp;ldquo;都传递一个输出目的地要轻松得多。动态变量是一种指定通用资源的好方法，同时保留了在特殊情况下改变它的灵活性。&lt;/p>
&lt;p>动态变量也被用于配置。例如，内置的 var&lt;code>*print-length*&lt;/code>允许你指定 Clojure 应该打印一个集合中的多少个项目。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(println [&amp;#34;Print&amp;#34; &amp;#34;all&amp;#34; &amp;#34;the&amp;#34; &amp;#34;things!&amp;#34;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [Print all the things!]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(binding [*print-length* 1]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println [&amp;#34;Print&amp;#34; &amp;#34;just&amp;#34; &amp;#34;one!&amp;#34;]))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [Print ...]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/zombie-metaphysics/troll.png"
loading="lazy"
>&lt;/p>
&lt;p>最后，可以对已经绑定的动态变量进行&lt;code>set!&lt;/code>。到目前为止，你所看到的例子允许你将信息&lt;em>输入到一个函数，而不需要将信息作为参数传入，而&lt;code>set!&lt;/code>允许你将信息&lt;/em>输出到一个函数，而不需要将其作为参数返回。&lt;/p>
&lt;p>例如，假设你是一个心灵感应者，但你的读心能力有点延迟。你只有在了解别人的想法对你有用的时候，才能读懂他们的想法。不过，不要觉得太糟糕，你仍然是一个心灵感应者，这很了不起。总之，假设你想穿过一座由巨魔看守的桥，如果你不回答他的谜语，他就会吃掉你。他的谜语是 &amp;ldquo;我想的是 1 和 2 之间的哪个数字？&amp;rdquo; 在巨魔吞噬你的情况下，你至少可以知道巨魔到底在想什么而死。&lt;/p>
&lt;p>在这个例子中，你创建了动态 var &lt;code>*troll-thought*&lt;/code>来传达巨魔的想法，从&lt;code>troll-riddle&lt;/code>函数中出来。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def ^:dynamic *troll-thought* nil)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn troll-riddle
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [your-answer]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [number &amp;#34;man meat&amp;#34;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➊ (when (thread-bound? #&amp;#39;*troll-thought*)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➋ (set! *troll-thought* number))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if (= number your-answer)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;TROLL: You can cross the bridge!&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;TROLL: Time to eat you, succulent human!&amp;#34;)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(binding [*troll-thought* nil]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (troll-riddle 2))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;SUCCULENT HUMAN: Oooooh! The answer was&amp;#34; *troll-thought*))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; TROLL: Time to eat you, succulent human!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; SUCCULENT HUMAN: Oooooh! The answer was man meat
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你在➊处使用&lt;code>thread-bound?&lt;/code>函数来检查 var 是否已经被绑定，如果是，你就&lt;code>set! *troll-thought*&lt;/code>到➋处的巨魔的思想。&lt;/p>
&lt;p>变量在绑定之外返回到它的原始值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">*troll-thought*
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; nil
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，你必须将&lt;code>#'*troll-thought*&lt;/code>（包括&lt;code>#'），而不是&lt;/code>&lt;em>troll-thought&lt;/em>&lt;code>，传递给函数&lt;/code>thread-bound?&lt;code>。这是因为&lt;/code>thread-bound?`将 var 本身作为一个参数，而不是它所指向的值。&lt;/p>
&lt;h4 id="单线程绑定">单线程绑定&lt;/h4>
&lt;p>关于绑定的最后一点要注意：如果你从一个手动创建的线程中访问一个动态绑定的 var，该 var 将求值为原始值。如果你是 Clojure（和 Java）的新手，这个特性不会立即发生作用；你可以跳过这一节，以后再来讨论它。&lt;/p>
&lt;p>具有讽刺意味的是，这种绑定行为使我们无法在 REPL 中轻松创建一个有趣的演示，因为 REPL 绑定了&lt;code>*out*&lt;/code>。就好像你在 REPL 中运行的所有代码都被隐含地包裹在类似&lt;code>(&lt;/code>binding[&lt;em>out&lt;/em> repl-printer] your-code&lt;code>的东西中。如果你创建一个新的线程，&lt;/code>&lt;em>out&lt;/em>`就不会被绑定到 REPL 打印机上。&lt;/p>
&lt;p>下面的例子使用了一些基本的 Java 互操作。即使它看起来很陌生，下面代码的要点也应该很清楚，你将在第 12 章中准确地了解发生了什么。&lt;/p>
&lt;p>这段代码向 REPL 打印输出。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(.write *out* &amp;#34;prints to repl&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; prints to repl
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下面的代码没有打印输出到 REPL，因为&lt;code>*out*&lt;/code>没有绑定到 REPL 打印机。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(.start (Thread. #(.write *out* &amp;#34;prints to standard out&amp;#34;)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以通过使用这个愚蠢的代码来解决这个问题。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [out *out*]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (.start
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (Thread. #(binding [*out* out]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (.write *out* &amp;#34;prints to repl from thread&amp;#34;)))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>或者你可以使用&lt;code>bound-fn&lt;/code>，它将所有当前的绑定带到新的线程中。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(.start (Thread. (bound-fn [] (.write *out* &amp;#34;prints to repl from thread&amp;#34;))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>let&lt;/code>绑定捕获了&lt;code>*out*&lt;/code>，所以我们可以在子线程中重新绑定它，这是很傻的。重点是，绑定不会被传递到&lt;em>手动&lt;/em>创建的线程中。然而，它们确实被传递给了期货。这就是所谓的 &amp;ldquo;绑定传递&amp;rdquo;。在本章中，我们一直在从期货中打印，没有任何问题，比如说。&lt;/p>
&lt;p>关于动态绑定就到此为止。让我们把注意力转向最后一个 var 主题：改变 var 的&lt;em>根&lt;/em>。&lt;/p>
&lt;h3 id="改变变量根值">改变变量根值&lt;/h3>
&lt;p>当你创建一个新的 var 时，你提供的初始值是它的&lt;em>根&lt;/em>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def power-source &amp;#34;hair&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子中，&lt;code>&amp;quot;头发&amp;quot;&lt;/code>是&lt;code>power-source&lt;/code>的根值。Clojure 允许你用函数&lt;code>alter-var-root&lt;/code>永久地改变这个根值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(alter-var-root #&amp;#39;power-source (fn [_] &amp;#34;7-eleven parking lot&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">power-source
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;7-eleven parking lot&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就像使用&lt;code>swap!&lt;/code>来更新一个原子或&lt;code>alter!&lt;/code>来更新一个 ref 一样，你使用&lt;code>alter-var-root&lt;/code>和一个函数来更新一个 var 的状态。在这种情况下，函数只是返回一个新的字符串，与之前的值没有关系，不像&lt;code>alter!&lt;/code>的例子，我们使用&lt;code>inc&lt;/code>来从当前的数字衍生出一个新数字。&lt;/p>
&lt;p>你几乎不会想这样做。你尤其不想这样做来执行简单的变量赋值。如果你这样做了，你就会不顾一切地把绑定的变量创建为一个可变的变量，这与 Clojure 的理念相悖；最好是使用你在第 5 章学到的函数式编程技术。&lt;/p>
&lt;p>你也可以用&lt;code>with-redefs&lt;/code>暂时改变一个 var 的根。这与绑定的工作原理类似，只是改变的内容会出现在子线程中。下面是一个例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(with-redefs [*out* *out*]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (doto (Thread. #(println &amp;#34;with redefs allows me to show up in the REPL&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> .start
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> .join))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>with-redefs&lt;/code>可以用于任何 var，而不仅仅是动态的。因为它有如此深远的影响，你应该只在测试时使用它。例如，你可以用它来重新定义一个从网络调用中返回数据的函数，这样该函数就会返回模拟数据而不需要实际进行网络请求。&lt;/p>
&lt;p>现在你知道所有关于 vars 的知识了吧! 尽量不要用它们来伤害你自己或你认识的任何人。&lt;/p>
&lt;h2 id="使用-pmap-的无状态并发性和并行性">使用 pmap 的无状态并发性和并行性&lt;/h2>
&lt;p>到目前为止，本章的重点是那些旨在减少并发编程中固有风险的工具。你已经了解了共享访问可变状态所带来的危险，以及 Clojure 是如何实现状态的重新概念化，从而帮助你安全地编写并发程序。&lt;/p>
&lt;p>但通常情况下，你会想把那些完全独立的任务并发化。没有对易变状态的共享访问；因此，并发运行这些任务没有任何风险，你也不必费心使用我刚才说过的任何工具。&lt;/p>
&lt;p>事实证明，Clojure 让你可以很容易地编写代码来实现无状态并发。在这一节中，你将了解到&lt;code>pmap&lt;/code>，它几乎免费为你提供了并发性能的好处。&lt;/p>
&lt;p>&lt;code>map&lt;/code>是并行化的完美候选者：当你使用它时，你所做的只是通过对现有集合的每个元素应用一个函数，从现有集合中派生出一个新集合。不需要维护状态；每个函数的应用都是完全独立的。Clojure 通过&lt;code>pmap&lt;/code>使执行并行 Map 变得容易。通过&lt;code>pmap&lt;/code>，Clojure 在一个单独的线程上处理 Map 函数的每个应用的运行。&lt;/p>
&lt;p>为了比较&lt;code>map&lt;/code>和&lt;code>pmap&lt;/code>，我们需要大量的例子数据，为了生成这些数据，我们将使用&lt;code>repeatedly&lt;/code>函数。这个函数接收另一个函数作为参数，并返回一个懒惰序列。懒惰序列的元素是通过调用传递的函数生成的，像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn always-1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> []
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(take 5 (repeatedly always-1))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (1 1 1 1 1)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下面是你如何创建一个 0 到 9 之间的随机数的懒人序列。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(take 5 (repeatedly (partial rand-int 10)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (1 5 0 3 4)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>让我们使用&lt;code>repeatedly&lt;/code>来创建示例数据，该数据由 3000 个随机字符串序列组成，每个字符串长 7000 个字符。我们将比较&lt;code>map&lt;/code>和&lt;code>pmap&lt;/code>，用它们在这里创建的&lt;code>orc-names&lt;/code>序列上运行&lt;code>clojure.string/lowercase&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def alphabet-length 26)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">;; Vector of chars, A-Z
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def letters (mapv (comp str char (partial + 65)) (range alphabet-length)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn random-string
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Returns a random string of specified length&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [length]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (apply str (take length (repeatedly #(rand-nth letters)))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn random-string-list
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [list-length string-length]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (doall (take list-length (repeatedly (partial random-string string-length)))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def orc-names (random-string-list 3000 7000))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>因为&lt;code>map&lt;/code>和&lt;code>pmap&lt;/code>是懒惰的，我们必须强迫它们实现。但我们不希望将结果打印到 REPL 中，因为那会花费很多时间。&lt;code>dorun&lt;/code>函数做了我们需要的事情：它实现了序列，但返回&lt;code>nil&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(time (dorun (map clojure.string/lower-case orc-names)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Elapsed time: 270.182 msecs&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(time (dorun (pmap clojure.string/lower-case orc-names)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Elapsed time: 147.562 msecs&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>用&lt;code>map&lt;/code>串行执行的时间是&lt;code>pmap&lt;/code>的 1.8 倍，而你所要做的只是增加一个额外的字母 你的性能可能会更好，这取决于你的计算机有多少个内核；这段代码是在双核机器上运行的。&lt;/p>
&lt;p>你可能会想，为什么并行版本所花的时间不正好是串行版本的一半。毕竟，两个核心的时间应该只有单核心的一半，不是吗？原因是，在创建和协调线程的过程中，总是会有一些开销。有时，事实上，这种开销所花费的时间会使每个函数应用的时间相形见绌，&lt;code>pmap'实际上会比&lt;/code>map&amp;rsquo;花费更多时间。图 10-3 显示了你如何能直观地看到这一点。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/zombie-metaphysics/pmap-small-grain.png"
loading="lazy"
>&lt;/p>
&lt;p>图 10-3：并行化开销会使任务时间相形见绌，导致性能下降。&lt;/p>
&lt;p>如果我们对 20000 个缩写的兽人名字运行一个函数，每个 300 个字符的长度，我们就可以看到这种效果的作用。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def orc-name-abbrevs (random-string-list 20000 300))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(time (dorun (map clojure.string/lower-case orc-name-abbrevs)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Elapsed time: 78.23 msecs&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(time (dorun (pmap clojure.string/lower-case orc-name-abbrevs)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Elapsed time: 124.727 msecs&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在&lt;code>pmap&lt;/code>实际上需要 1.6 倍的*时间。&lt;/p>
&lt;p>解决这个问题的方法是增加&lt;em>粒度&lt;/em>，或者说每个并行化任务所做的工作量。在这种情况下，任务是对集合中的一个元素应用 Map 函数。粒度不是用任何标准单位来衡量的，但你会说&lt;code>pmap&lt;/code>的粒度默认是 1。将粒度增加到 2 意味着你将 Map 函数应用于两个元素，而不是一个，所以任务所在的线程正在做更多的工作。图 10-4 显示了增加粒度是如何提高性能的。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/zombie-metaphysics/ppmap.png"
loading="lazy"
>&lt;/p>
&lt;p>图 10-4：可视化的粒度与并行化开销的关系&lt;/p>
&lt;p>为了在 Clojure 中实现这一点，你可以通过使用&lt;code>partition-all&lt;/code>使每个线程对多个元素应用&lt;code>clojure.string/lower-case&lt;/code>，而不是仅仅一个元素，来增加粒度。 &lt;code>partition-all&lt;/code>接收一个 seq，并将其分成指定长度的 seq。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def numbers [1 2 3 4 5 6 7 8 9 10])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(partition-all 3 numbers)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; ((1 2 3) (4 5 6) (7 8 9) (10))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在假设你开始时的代码是这样的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(pmap inc numbers)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这种情况下，颗粒大小是 1，因为每个线程都对一个元素应用了&lt;code>inc&lt;/code>。&lt;/p>
&lt;p>现在假设你把代码改成这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(pmap (fn [number-group] (doall (map inc number-group))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (partition-all 3 numbers))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; ((2 3 4) (5 6 7) (8 9 10) (11))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里有几件事要做。首先，你现在将颗粒大小增加到了三个，因为每个线程现在执行了三个&lt;code>inc&lt;/code>函数的应用，而不是一个。第二，注意你必须在 Map 函数中调用&lt;code>doall&lt;/code>。这迫使由&lt;code>(map inc number-group)&lt;/code>返回的懒惰序列在线程内实现。第三，我们需要取消对结果的分组。下面是我们如何做到这一点。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(apply concat
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (pmap (fn [number-group] (doall (map inc number-group)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (partition-all 3 numbers)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>使用这个技术，我们可以增加 orc 名称低 ase 化的粒度，这样每个线程在 1000 个名称上运行&lt;code>clojure.string/lower-case&lt;/code>而不是只有一个。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(time
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (dorun
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (apply concat
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (pmap (fn [name] (doall (map clojure.string/lower-case name)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (partition-all 1000 orc-name-abbrevs)))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Elapsed time: 44.677 msecs&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>并行版本再次花费了近一半的时间。为了好玩，我们可以把这个技术概括为一个叫做 &amp;ldquo;ppmap &amp;ldquo;的函数，代表&lt;em>分区的 pmap&lt;/em>。它可以接收一个以上的集合，就像&lt;code>map&lt;/code>一样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn ppmap
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Partitioned pmap, for grouping map ops together to make parallel
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> overhead worthwhile&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [grain-size f &amp;amp; colls]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (apply concat
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (apply pmap
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (fn [&amp;amp; pgroups] (doall (apply map f pgroups)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (map (partial partition-all grain-size) colls))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(time (dorun (ppmap 1000 clojure.string/lower-case orc-name-abbrevs)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Elapsed time: 44.902 msecs&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我不知道你怎么想的，但我觉得这东西就是好玩。要想获得更多的乐趣，可以看看 clojure.core.reducers 库（&lt;em>&lt;a class="link" href="http://clojure.org/reducers/" target="_blank" rel="noopener"
>http://clojure.org/reducers/&lt;/a>&lt;/em>）。 这个库提供了 seq 函数的替代实现，如&lt;code>map&lt;/code>和&lt;code>reduce&lt;/code>，通常比它们在&lt;code>clojure.core&lt;/code>中的表亲更快。其代价是它们并不懒惰。总的来说，clojure.core.reducers 库为创建和使用&lt;code>ppmap&lt;/code>这样的函数提供了一种更精细和可组合的方式。&lt;/p>
&lt;h2 id="摘要">摘要&lt;/h2>
&lt;p>在本章中，你学到了比大多数人更多的关于安全处理并发任务的知识。你了解了支撑 Clojure 引用类型的形而上学。在 Clojure 的形而上学中，状态是某个时间点上的身份值，而身份是指由某个过程产生的一连串值的一种方便的方式。值是原子性的，就像数字是原子性的一样。它们是不可改变的，这使得它们可以安全地并发工作；你不必担心在你使用它们时其他线程会改变它们。&lt;/p>
&lt;p>原子引用类型允许你创建一个身份，你可以使用&lt;code>swap!&lt;/code>和&lt;code>reset!&lt;/code>安全地更新引用新值。当你想使用事务语义更新多个身份时，ref 引用类型很方便，你用&lt;code>alter!&lt;/code>和&lt;code>commute!&lt;/code>更新它。&lt;/p>
&lt;p>此外，你学会了如何通过使用&lt;code>pmap&lt;/code>和 core.reducers 库进行无状态数据转换来提高性能。呜呼!&lt;/p>
&lt;h2 id="练习">练习&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>创建一个初始值为 0 的原子，使用&lt;code>swap!&lt;/code>将其递增几次，然后取消引用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>创建一个函数，使用期货来并行处理从*&lt;a class="link" href="http://www.braveclojure.com/random-quote" target="_blank" rel="noopener"
>http://www.braveclojure.com/random-quote&lt;/a>*下载随机报价的任务，使用&lt;code>(slurp &amp;quot;http://www.braveclojure.com/random-quote&amp;quot;)&lt;/code>。期货应该更新一个原子，指的是所有引语的总字数。该函数将把要下载的引语数量作为参数，并返回原子的最终值。请记住，在返回原子的最终值之前，你需要确保所有的期货已经完成。下面是你如何调用它和一个示例结果。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(quote-word-count 5)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {&amp;#34;ochre&amp;#34; 8, &amp;#34;smoothie&amp;#34; 2}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>在一个游戏中创建两个角色的代表。第一个角色有 15 个命中率，总共有 40 个。第二个角色在他的库存中有一个治疗药水。使用参照物和交易来模拟治疗药水的消耗和第一个角色的治疗。&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Chapter9 并发的艺术</title><link>https://example.com/p/chapter9-%E5%B9%B6%E5%8F%91%E7%9A%84%E8%89%BA%E6%9C%AF/</link><pubDate>Sat, 15 Jan 2022 12:30:14 +0800</pubDate><guid>https://example.com/p/chapter9-%E5%B9%B6%E5%8F%91%E7%9A%84%E8%89%BA%E6%9C%AF/</guid><description>&lt;h1 id="并发和并行编程的神圣艺术">并发和并行编程的神圣艺术&lt;/h1>
&lt;p>如果我是一个庄园的主人，而你是我的继承人，我会在你的第 13 个命名日让你坐下来，告诉你：&amp;ldquo;计算的世界正在改变，小姑娘，你必须为多核处理器的新世界做好准备，以免你被它践踏。&lt;/p>
&lt;p>&amp;ldquo;好好听着。近年来，CPU 的时钟速度几乎没有增加，但双核和四核计算机已经变得很普遍。物理定律是残酷而绝对的，它们要求提高时钟速度需要成倍的功率。领域内最好的工程师不太可能很快克服这一限制，如果有的话。因此，你可以预期单台机器上的内核不断增加的趋势将继续下去&amp;ndash;作为一个程序员，你将知道如何充分利用现代硬件的期望也是如此。&lt;/p>
&lt;p>&amp;ldquo;在这种新模式下学习编程将是有趣和迷人的，真的。但请注意：它也充满了危险。你必须学习&lt;em>并发和&lt;/em>并行编程*，这是一门神圣的艺术，使你的应用结构安全地管理多个同时执行的任务。&lt;/p>
&lt;p>&amp;ldquo;你从对并发和并行概念的概述开始学习这门艺术。然后，你将学习困扰每个从业者的三个小妖精：参考单元、互斥和矮人狂战士。你还将学习三种有助于你的工具：Future、许诺和延迟&amp;rdquo;。&lt;/p>
&lt;p>然后我会用键盘拍拍你的肩膀，示意你可以开始了。&lt;/p>
&lt;h2 id="并发和并行的概念">并发和并行的概念&lt;/h2>
&lt;p>并发和并行编程在程序执行的各个层面都涉及到很多混乱的细节，从硬件到操作系统，到编程语言库，再到从你的内心涌出的、落在编辑器中的代码。但在你为这些细节烦恼之前，在这一节中，我将介绍围绕并发和并行的高级概念。&lt;/p>
&lt;h3 id="管理多个任务与同时执行任务">管理多个任务与同时执行任务&lt;/h3>
&lt;p>&lt;em>并发&lt;/em>指的是在同一时间管理一个以上的任务。 &lt;em>任务&lt;/em>只是意味着 &amp;ldquo;需要完成的事情&amp;rdquo;，它并不意味着任何有关硬件或软件的实现。我们可以用 Lady Gaga 的歌曲《电话》来说明并发性。Gaga 唱道&lt;/p>
&lt;blockquote>
&lt;p>I cannot text you with a drink in my hand, eh&lt;/p>
&lt;/blockquote>
&lt;p>这里，她在解释她只能管理一个任务（喝酒）。她断然拒绝了她可以处理一个以上的任务的建议。然而，如果她决定同时处理任务，她会唱歌。&lt;/p>
&lt;blockquote>
&lt;p>I will put down this drink to text you, then put my phone away and continue drinking, eh&lt;/p>
&lt;/blockquote>
&lt;p>在这个假设的宇宙中，Lady Gaga 正在处理两个任务：喝酒和发短信。然而，她并没有同时执行这两项任务。相反，她在这两个任务之间进行切换，或者说是&lt;em>交错&lt;/em>。请注意，在交错过程中，你不必在切换之前完全完成一项任务：Gaga 可以打一个字，放下手机，拿起饮料喝一口，然后换回手机，再打一个字。&lt;/p>
&lt;p>&lt;em>平行性&lt;/em>指的是同时执行一个以上的任务。如果加加夫人平行地执行她的两项任务，她会唱歌。&lt;/p>
&lt;blockquote>
&lt;p>I can text you with one hand while I use the other to drink, eh&lt;/p>
&lt;/blockquote>
&lt;p>平行性是并发性的一个子类：在你同时执行多个任务之前，你首先要管理多个任务。&lt;/p>
&lt;p>Clojure 有很多功能，可以让你轻松实现并行化。虽然 Lady Gaga 系统是通过在多只手上同时执行任务来实现并行的，但计算机系统一般是通过在多个处理器上同时执行任务来实现并行的。&lt;/p>
&lt;p>将并行性与&lt;em>分布式区分开来是很重要的。分布式计算是并行计算的一个特殊版本，处理器在不同的计算机中，任务通过网络分布到计算机上。这就像 Lady Gaga 问 Beyoncé，&amp;ldquo;请在我喝酒时给这家伙发短信&amp;rdquo;。尽管你可以借助库在 Clojure 中进行分布式编程，但本书只涉及并行编程，在这里我用&lt;/em>parallel&lt;em>只指同居的处理器。如果你对分布式编程感兴趣，可以去看看 Kyle Kingsbury 的&lt;/em>Call Me Maybe&lt;em>系列，网址是&lt;/em>&lt;a class="link" href="https://aphyr.com/" target="_blank" rel="noopener"
>https://aphyr.com/&lt;/a>*。&lt;/p>
&lt;h3 id="阻塞和异步任务">阻塞和异步任务&lt;/h3>
&lt;p>并发编程的主要用例之一是用于&lt;em>阻塞&lt;/em>操作。阻塞实际上是指等待一个操作的完成。你最常听到的是与 I/O 操作有关的，比如读取文件或等待 HTTP 请求的完成。让我们用 Lady Gaga 并发的例子来研究这个问题。&lt;/p>
&lt;p>如果 Lady Gaga 给她的对话者发短信，然后拿着手机站在那里，盯着屏幕等待回应，而不喝水，那么你会说&lt;em>读下一条短信&lt;/em>操作是阻塞的，这些任务是*同步执行的。&lt;/p>
&lt;p>相反，如果她把手机收起来，这样她就可以喝酒了，直到手机发出哔哔声或振动来提醒她，那么&lt;em>阅读下一条短信&lt;/em>任务就不是阻塞的，你会说她是在*异步地处理这个任务。&lt;/p>
&lt;h3 id="并发编程和并行编程">并发编程和并行编程&lt;/h3>
&lt;p>并发编程和并行编程指的是将一个任务分解成可以并行执行的子任务的技术，以及管理程序同时执行多个任务时产生的风险。在本章的其余部分，我将交替使用这两个术语，因为两者的风险几乎是一样的。&lt;/p>
&lt;p>为了更好地理解这些风险以及 Clojure 如何帮助你避免这些风险，让我们来看看 Clojure 中是如何实现并发和并行的。&lt;/p>
&lt;h2 id="clojure-实现jvm-线程">Clojure 实现。JVM 线程&lt;/h2>
&lt;p>我一直在抽象地使用*任务这个词，指的是一系列相关的操作，而不考虑计算机可能如何实现任务的概念。例如，发短信就是一个由一系列相关操作组成的任务，它与往你脸上倒饮料的操作完全不同。&lt;/p>
&lt;p>在 Clojure 中，你可以把你正常的、&lt;em>串行的代码看作是任务的序列。你可以通过把任务放在 JVM 的&lt;/em>线程*上来表示任务可以并发执行。&lt;/p>
&lt;h3 id="什么是线程">什么是线程&lt;/h3>
&lt;p>我很高兴你问这个问题! 一个线程是一个子程序。一个程序可以有很多线程，每个线程执行自己的指令集，同时享受对程序状态的共享访问。&lt;/p>
&lt;p>！&lt;a class="link" href="https://www.braveclojure.com/assets/images/cftbat/concurrency/alligator.png" target="_blank" rel="noopener"
>&lt;/a>&lt;/p>
&lt;p>线程管理功能可以存在于计算机的多个层面。例如，操作系统内核通常提供系统调用来创建和管理线程。JVM 提供了自己的独立于平台的线程管理功能，由于 Clojure 程序在 JVM 中运行，所以它们使用 JVM 线程。你将在第 12 章中了解更多关于 JVM 的信息。&lt;/p>
&lt;p>你可以把线程看作是一个实际的、物理的线段，它把一连串的指令串起来。在我看来，这些指令是棉花糖，因为棉花糖很好吃。处理器按顺序执行这些指令。我把这想象成一条鳄鱼在吃这些指令，因为鳄鱼喜欢吃棉花糖（这是事实！）。因此，执行一个程序看起来就像一堆棉花糖串在一条线上，一条鳄鱼沿着这条线逐一吃掉。图 9-1 显示了单核处理器执行单线程程序的这个模型。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/concurrency/single-thread.png"
loading="lazy"
>&lt;/p>
&lt;p>图 9-1：单核处理器执行一个单线程的程序&lt;/p>
&lt;p>一个线程可以*产生一个新的线程来并发地执行任务。在单处理器系统中，处理器在线程之间来回切换（交织）。这里就引入了潜在的并发性问题。尽管处理器按顺序执行每个线程的指令，但它不保证何时在线程之间来回切换。&lt;/p>
&lt;p>图 9-2 显示了两个线程，A 和 B，以及它们的指令如何执行的时间线。我对线程 B 的指令做了阴影处理，以帮助区分它们与线程 A 的指令。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/concurrency/two-threads-one-processor.png"
loading="lazy"
>&lt;/p>
&lt;p>单核处理器执行两个线程&lt;/p>
&lt;p>请注意，这只是一种可能的指令执行顺序。例如，处理器也可以按照 A1、A2、A3、B1、A4、B2、B3 的顺序执行指令。这使程序变得&lt;em>不确定&lt;/em>。你不能事先知道结果是什么，因为你无法知道执行顺序，不同的执行顺序会产生不同的结果。&lt;/p>
&lt;p>这个例子显示了通过交织在单个处理器上的并发执行，而多核系统为每个核分配一个线程，允许计算机同时执行一个以上的线程。每个核心按顺序执行其线程的指令，如图 9-3 所示。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/concurrency/two-threads-two-processors.png"
loading="lazy"
>&lt;/p>
&lt;p>两个线程，两个处理器。&lt;/p>
&lt;p>与单核上的交织一样，整体执行顺序没有保证，所以程序是不确定的。当你在程序中加入第二个线程时，它就变得不确定了，这使得你的程序有可能成为三种问题的牺牲品。&lt;/p>
&lt;h3 id="三个小妖精参考单元互斥和矮人狂战士">三个小妖精。参考单元、互斥和矮人狂战士&lt;/h3>
&lt;p>并发编程中有三个核心挑战，也被称为 &amp;ldquo;三个并发妖精&amp;rdquo;。要知道为什么这些是可怕的，想象一下图 9-3 中的程序包括表 9-1 中的假指令。&lt;/p>
&lt;ol>
&lt;li>非确定结果的程序的指令&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>ID&lt;/th>
&lt;th>Instruction&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>A1&lt;/td>
&lt;td>WRITE &lt;code>X = 0&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>A2&lt;/td>
&lt;td>READ &lt;code>X&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>A3&lt;/td>
&lt;td>WRITE &lt;code>X = X + 1&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>B1&lt;/td>
&lt;td>READ &lt;code>X&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>B2&lt;/td>
&lt;td>WRITE &lt;code>X = X + 1&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>如果处理器遵循 A1, A2, A3, B1, B2 的顺序，那么&lt;code>X&lt;/code>的值将是&lt;code>2&lt;/code>，正如你所期望的。但是如果它遵循 A1, A2, B1, A3, B2 的顺序，&lt;code>X'的值将是&lt;/code>1&amp;rsquo;，正如你在图 9-4 中看到的那样。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/concurrency/reference-cell.png"
loading="lazy"
>&lt;/p>
&lt;p>两个线程与一个引用单元进行交互&lt;/p>
&lt;p>我们把这称为&lt;em>参考单元&lt;/em>问题（第一个并发性妖精）。 当两个线程可以对同一个位置进行读写时，就会出现引用单元问题，而该位置的值取决于读写的顺序。&lt;/p>
&lt;p>第二个并发妖精是&lt;em>互斥&lt;/em>。想象一下，两个线程，每个人都试图向一个文件写一个咒语。如果没有任何方法可以要求对文件进行独占性的写入访问，那么这个咒语最终会变成乱码，因为写入指令会被交错使用。考虑一下以下两个咒语。&lt;/p>
&lt;blockquote>
&lt;p>By the power invested in me&lt;br>
by the state of California,&lt;br>
I now pronounce you man and wife
Thunder, lightning, wind, and rain,&lt;br>
a delicious sandwich, I summon again&lt;/p>
&lt;/blockquote>
&lt;p>如果你把这些写到一个没有相互排斥的文件中，你可能会得到这样的结果。&lt;/p>
&lt;blockquote>
&lt;p>By the power invested in me&lt;br>
by Thunder, lightning, wind, and rain,&lt;br>
the state of California,&lt;br>
I now pronounce you a delicious man sandwich, and wife&lt;br>
I summon again&lt;/p>
&lt;/blockquote>
&lt;p>第三个并发妖精就是我所说的&lt;em>矮人狂战士&lt;/em>问题（又称&lt;em>死锁&lt;/em>）。想象一下，四个狂暴者围坐在一张粗糙的圆形木桌旁，互相安慰。&amp;ldquo;我知道我对我的孩子很疏远，但我就是不知道如何与他们沟通，&amp;ldquo;一个人咆哮道。其余的人啜饮着咖啡，有意无意地点头，他们的眼角处都有护理纹。&lt;/p>
&lt;p>现在，每个人都知道，矮人狂战士结束舒适的咖啡聚会的仪式是拿起他们的 &amp;ldquo;安慰棒&amp;rdquo;（双刃战斧），互相抓挠对方的背部。每对矮人之间放一把战斧，如图 9-5 所示。&lt;/p>
&lt;p>他们的仪式是这样进行的。&lt;/p>
&lt;ol>
&lt;li>拿起&lt;em>左边&lt;/em>的战斧，如果有的话。&lt;/li>
&lt;li>拿起&lt;em>右边&lt;/em>战斧，如果有的话。&lt;/li>
&lt;li>用你的 &amp;ldquo;安慰棒 &amp;ldquo;大力挥舞来安慰你的邻居。&lt;/li>
&lt;li>释放两把战斧。&lt;/li>
&lt;li>重复。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/concurrency/deadlock.png"
loading="lazy"
>&lt;/p>
&lt;p>矮人狂热者在舒适的咖啡聚会中&lt;/p>
&lt;p>按照这个仪式，所有的矮人狂战士完全有可能拿起他们左边的安慰棒，然后无限期地阻挡，同时等待他们右边的安慰棒出现，导致僵局。(顺便说一下，如果你想进一步研究这种现象，它通常被称为&lt;em>吃饭的哲学家问题&lt;/em>，但这是一个更无聊的场景）。本书没有详细讨论死锁，但了解这个概念和术语是很好的。&lt;/p>
&lt;p>并发编程有它的小妖精，但有了正确的工具，它是可控的，甚至是有趣的。让我们开始看一下正确的工具。&lt;/p>
&lt;h2 id="futures-delays-and-promises">Futures, Delays, and Promises&lt;/h2>
&lt;p>Future、延迟和 Promise 是用于并发编程的简单、轻便的工具。在这一节中，你将学习每个工具的工作原理，以及如何一起使用它们来抵御引用单元的并发妖精和互斥的并发妖精。你会发现，虽然简单，但这些工具对满足你的并发需求有很大帮助。&lt;/p>
&lt;p>它们通过给予你比串行代码更多的灵活性来做到这一点。当你写串行代码时，你把这三个事件绑定在一起。&lt;/p>
&lt;ul>
&lt;li>任务定义&lt;/li>
&lt;li>任务执行&lt;/li>
&lt;li>要求任务的结果&lt;/li>
&lt;/ul>
&lt;p>作为一个例子，看一下这个假设的代码，它定义了一个简单的 API 调用任务。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(web-api/get :dwarven-beard-waxes)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>一旦 Clojure 遇到这个任务定义，它就会执行它。它也需要&lt;em>现在&lt;/em>的结果，阻塞直到 API 调用完成。学习并发编程的一部分是学会识别何时不需要这些时间上的联接。Future、延迟和 Promise 允许你把任务定义、任务执行和要求结果分开。继续前进!&lt;/p>
&lt;h3 id="future">Future&lt;/h3>
&lt;p>在 Clojure 中，你可以使用&lt;em>futures&lt;/em>来定义一个任务，并把它放在另一个线程上，而不要求立即得到结果。你可以用&lt;code>future&lt;/code>宏来创建一个未来。在 REPL 中试试这个。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(future (Thread/sleep 4000)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;I&amp;#39;ll print after 4 seconds&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(println &amp;#34;I&amp;#39;ll print immediately&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>Thread/sleep&lt;/code>告诉当前线程在指定的毫秒数内坐着什么都不做。通常情况下，如果你在你的 REPL 中求值了&lt;code>Thread/sleep&lt;/code>，你就不能求值任何其他语句，直到 REPL 完成睡眠；执行你的 REPL 的线程将被阻塞。然而，&lt;code>future&lt;/code>创建了一个新的线程，并将你传递给它的每个表达式放在新的线程上，包括&lt;code>Thread/sleep&lt;/code>，允许 REPL 的线程继续运行，不受阻塞。&lt;/p>
&lt;p>你可以使用 future 在一个单独的线程上运行任务，然后忘记它们，但你经常想使用任务的结果。&lt;code>future&lt;/code>函数返回一个引用值，你可以用它来请求结果。参考值就像干洗店给你的票据：在任何时候你都可以用它来请求你的干净衣服，但是如果你的衣服还没有洗干净，你就必须等待。类似地，你可以使用参考值来请求一个未来的结果，但是如果未来还没有完成计算结果，你就必须等待。&lt;/p>
&lt;p>请求一个未来的结果被称为&lt;em>dereferencing&lt;/em>未来，你可以用&lt;code>deref&lt;/code>函数或&lt;code>@&lt;/code>读者宏来做。一个 future 的结果值是其主体中最后一个被求值的表达式的值。一个 future 的主体只执行一次，它的值被缓存起来。试试下面的方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [result (future (println &amp;#34;this prints once&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (+ 1 1))]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;deref: &amp;#34; (deref result))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;@: &amp;#34; @result))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;this prints once&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; deref: 2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; @: 2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>请注意，&amp;ldquo;this prints once &amp;ldquo;这个字符串确实只打印了一次，尽管你对 future 进行了两次推断。这表明 future 的主体只运行了一次，结果&lt;code>2&lt;/code>被缓存了。&lt;/p>
&lt;p>如果未来程序还没有完成运行，解指未来程序就会阻塞，就像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [result (future (Thread/sleep 3000)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (+ 1 1))]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;The result is: &amp;#34; @result)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;It will be at least 3 seconds before I print&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; The result is: 2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; It will be at least 3 seconds before I print
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>有时你想为一个未来的等待时间设置一个时间限制。要做到这一点，你可以给&lt;code>deref&lt;/code>一个等待的毫秒数，以及当&lt;code>deref&lt;/code>超时时要返回的值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(deref (future (Thread/sleep 1000) 0) 10 5)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 5
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段代码告诉&lt;code>deref&lt;/code>，如果 future 在 10 毫秒内没有返回一个值，则返回值&lt;code>5&lt;/code>。&lt;/p>
&lt;p>最后，你可以使用&lt;code>realized?&lt;/code>来询问一个 future，看看它是否已经运行完毕。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(realized? (future (Thread/sleep 1000)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; false
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(let [f (future)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @f
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (realized? f))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Future 是一种简单的方法，可以在你的程序中撒上一些并发性。&lt;/p>
&lt;p>就其本身而言，它们让你有能力将任务转移到其他线程上，这可以使你的程序更有效率。它们还可以让你的程序表现得更加灵活，让你控制何时需要一个任务的结果。&lt;/p>
&lt;p>当你解除对一个 future 的引用时，你表明&lt;em>现在&lt;/em>需要这个结果，并且在获得这个结果之前应该停止计算。你会看到这如何帮助你处理相互排斥的问题。另外，你也可以忽略这个结果。例如，你可以使用 Future 来异步写入一个日志文件，在这种情况下，你不需要解除对 Future 的引用来获得任何返回值。&lt;/p>
&lt;p>Future 给你带来的灵活性是非常酷的。Clojure 还允许你用延迟和 Promise 来独立处理任务定义和要求结果。&lt;/p>
&lt;h3 id="延迟">延迟&lt;/h3>
&lt;p>&lt;em>延迟&lt;/em>允许你定义一个任务，而不需要立即执行它或要求得到结果。你可以使用&lt;code>delay&lt;/code>创建一个延迟。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def jackson-5-delay
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (delay (let [message &amp;#34;Just call my name and I&amp;#39;ll be there&amp;#34;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;First deref:&amp;#34; message)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> message)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子中，没有任何东西被打印出来，因为我们还没有要求对&lt;code>let&lt;/code>形式进行求值。你可以求值延迟，并通过解构它或使用&lt;code>force&lt;/code>来获得其结果。 &lt;code>force&lt;/code>的行为与&lt;code>deref&lt;/code>相同，但它更清楚地表达了你正在使一个任务开始，而不是等待一个任务完成。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(force jackson-5-delay)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; First deref: Just call my name and I&amp;#39;ll be there
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Just call my name and I&amp;#39;ll be there&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>像 Future 一样，延迟只运行一次，其结果被缓存。后续的取消引用将返回 Jackson 5 的信息，而不打印任何东西。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">@jackson-5-delay
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Just call my name and I&amp;#39;ll be there&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以使用延迟的一种方式是在一组相关的 Future 中的一个 Future 第一次完成时启动一个语句。例如，假设你的应用程序将一组头像上传到一个头像分享网站，并在第一张头像完成后立即通知所有者，如下所示。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def gimli-headshots [&amp;#34;serious.jpg&amp;#34; &amp;#34;fun.jpg&amp;#34; &amp;#34;playful.jpg&amp;#34;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn email-user
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [email-address]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;Sending headshot notification to&amp;#34; email-address))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn upload-document
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Needs to be implemented&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [headshot]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> true)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(let [notify (delay ➊(email-user &amp;#34;and-my-axe@gmail.com&amp;#34;))]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (doseq [headshot gimli-headshots]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (future (upload-document headshot)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ➋(force notify))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子中，你定义了一个要上传头像的 Vector（&lt;code>gimli-headshots&lt;/code>）和两个函数（&lt;code>email-user&lt;/code>和&lt;code>upload-document&lt;/code>）来假装执行这两个操作。然后你用&lt;code>let&lt;/code>将&lt;code>notify&lt;/code>绑定到一个延迟。延迟的主体，&lt;code>(email-user &amp;quot;and-my-axe@gmail.com&amp;quot;)&lt;/code>➊，在创建延迟的时候并没有被求值。相反，当由&lt;code>doseq&lt;/code>Form 创建的 Future 之一第一次求值&lt;code>(force notify)&lt;/code>➋时，它就被求值了。即使&lt;code>(force notify)&lt;/code>将被求值三次，延迟主体只被求值一次。Gimli 会很高兴知道第一张头像什么时候可用，这样他就可以开始调整它并分享它。他也会感谢不被垃圾邮件，而你也会感谢不面对他的矮人之怒。&lt;/p>
&lt;p>这种技术可以帮助你避免相互排斥的并发妖精&amp;ndash;确保每次只有一个线程可以访问特定资源的问题。在这个例子中，延迟守护着电子邮件服务器资源。因为延迟的主体被保证只发射一次，所以你可以确定你永远不会遇到两个线程发送相同邮件的情况。当然，没有线程能够再次使用延迟来发送邮件。对于大多数情况来说，这可能是一个过于激烈的约束，但在像这个例子这样的情况下，它是完美的。&lt;/p>
&lt;h3 id="promise">Promise&lt;/h3>
&lt;p>&lt;em>Promise&lt;/em>允许你表达你期望的结果，而不需要定义应该产生结果的任务或该任务应该何时运行。你用&lt;code>promise'创建Promise，用&lt;/code>deliver&amp;rsquo;向他们传递一个结果。你通过取消引用来获得结果。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def my-promise (promise))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(deliver my-promise (+ 1 2))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">@my-promise
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里，你创建了一个 promise，然后向它传递一个值。最后，你通过解除对 Promise 的引用来获得该值。解除引用是你表达你期望一个结果的方式，如果你试图在没有首先传递一个值的情况下解除引用`my-promise&amp;rsquo;，程序将阻塞，直到一个 Promise 被传递，就像 Future 和延迟一样。你只能向一个 Promise 传递一次结果。&lt;/p>
&lt;p>Promise 的一个用途是在一个数据集合中找到第一个满意的元素。例如，假设你正在收集成分以使你的鹦鹉听起来像詹姆斯-厄尔-琼斯。因为詹姆斯-厄尔-琼斯的声音是世界上最顺畅的，所以其中一种成分是顺畅度达到 97 以上的优质牦牛油。你的预算是 100 美元一磅。&lt;/p>
&lt;p>你是一个现代神奇鸟类学艺术的实践者，因此，与其繁琐地浏览每个牦牛油零售网站，不如创建一个脚本，给你提供第一个符合你需求的牦牛油的 URL。&lt;/p>
&lt;p>下面的代码定义了一些牦牛油产品，创建了一个函数来模拟 API 调用，并创建了另一个函数来测试产品是否满意。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def yak-butter-international
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:store &amp;#34;Yak Butter International&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :price 90
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :smoothness 90})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def butter-than-nothing
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:store &amp;#34;Butter Than Nothing&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :price 150
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :smoothness 83})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">;; This is the butter that meets our requirements
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def baby-got-yak
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:store &amp;#34;Baby Got Yak&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :price 94
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :smoothness 99})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn mock-api-call
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [result]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (Thread/sleep 1000)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> result)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn satisfactory?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;If the butter meets our criteria, return the butter, else return false&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [butter]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (and (&amp;lt;= (:price butter) 100)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (&amp;gt;= (:smoothness butter) 97)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> butter))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>该 API 调用在返回结果前等待一秒钟，以模拟执行实际调用的时间。&lt;/p>
&lt;p>为了说明同步检查网站需要多长时间，我们将使用&lt;code>some&lt;/code>对集合中的每个元素应用&lt;code>satisfactory?&lt;/code>函数，并返回第一个真实的结果，如果没有，则返回 nil。当你同步检查每个站点时，每个站点可能需要超过一秒钟的时间来获得结果，正如下面的代码所示。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(time (some (comp satisfactory? mock-api-call)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [yak-butter-international butter-than-nothing baby-got-yak]))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Elapsed time: 3002.132 msecs&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:store &amp;#34;Baby Got Yak&amp;#34;, :smoothness 99, :price 94}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里我用&lt;code>comp&lt;/code>来组合函数，我用&lt;code>time&lt;/code>来打印求值一个 Form 的时间。你可以使用 promise 和 futures 来在一个单独的线程上执行每个检查。如果你的计算机有多个核心，这可以把时间减少到一秒钟左右。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(time
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [butter-promise (promise)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (doseq [butter [yak-butter-international butter-than-nothing baby-got-yak]]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (future (if-let [satisfactory-butter (satisfactory? (mock-api-call butter))]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (deliver butter-promise satisfactory-butter))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;And the winner is:&amp;#34; @butter-promise)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Elapsed time: 1002.652 msecs&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; And the winner is: {:store Baby Got Yak, :smoothness 99, :price 94}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子中，你首先创建了一个 Promise，&lt;code>butter-promise&lt;/code>，然后创建了三个访问该 Promise 的 Future。每个 Future 的任务是求值一个牦牛黄油网站，如果该网站令人满意，则向 Promise 提供该网站的数据。最后，你解除对&lt;code>butter-promise&lt;/code>的引用，导致程序阻塞，直到网站数据被交付。这需要一秒钟而不是三秒钟，因为网站的求值是平行进行的。通过将对结果的要求与结果的实际计算方式脱钩，你可以并行地进行多个计算，并节省一些时间。&lt;/p>
&lt;p>你可以把这看作是一种保护自己不受参考单元格并发性妖精影响的方法。因为 Promise 只能被写入一次，你可以防止非确定性读写产生的那种不一致的状态。&lt;/p>
&lt;p>你可能想知道，如果牦牛油都不满意会怎么样。如果发生这种情况，解除引用将永远阻塞，并绑住线程。为了避免这种情况，你可以加入一个超时。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(让 [p (promise)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (deref p 100 &amp;#34;timed out&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这将创建一个 Promise，&lt;code>p'，并试图解除对它的引用。数字100告诉&lt;/code>deref&lt;code>等待100毫秒，如果届时没有可用的值，就使用超时值，&lt;/code>&amp;ldquo;timed out&amp;rdquo;`。&lt;/p>
&lt;p>我应该提到的最后一个细节是，你也可以使用 Promise 来注册回调，实现与你在 JavaScript 中可能习惯的相同功能。JavaScript 的回调是一种定义代码的方式，一旦其他代码完成，就应该异步执行。下面是如何在 Clojure 中做到这一点。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [ferengi-wisdom-promise (promise)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (future (println &amp;#34;Here&amp;#39;s some Ferengi wisdom:&amp;#34; @ferengi-wisdom-promise))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (Thread/sleep 100)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (deliver ferengi-wisdom-promise &amp;#34;Whisper your way to success.&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Here&amp;#39;s some Ferengi wisdom: Whisper your way to success.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个例子创建了一个立即开始执行的未来。然而，未来的线程是阻塞的，因为它在等待一个值被传递给&lt;code>ferengi-wisdom-promise&lt;/code>。100 毫秒后，你交付了值，未来中的`println&amp;rsquo;语句开始运行。&lt;/p>
&lt;p>Future、延迟和 Promise 是在你的应用程序中管理并发性的伟大而简单的方法。在下一节中，我们将看到一个更有趣的方法来控制你的并发应用程序。&lt;/p>
&lt;h3 id="滚动你自己的队列">滚动你自己的队列&lt;/h3>
&lt;p>到目前为止，你已经看到了一些简单的方法来结合 Future、延迟和 Promise，使你的并发程序更加安全。在这一节中，你将使用一个宏来以一种稍微复杂的方式结合 Future 和 Promise。你可能不一定会用到这段代码，但它会更多地展示这些适度的工具的力量。这个宏需要你在头脑中同时持有运行时逻辑和宏扩展逻辑，以了解正在发生的事情；如果你被卡住了，就跳过前面。&lt;/p>
&lt;p>三个并发妖精的一个共同特点是，它们都涉及到任务以不协调的方式并发地访问一个共享资源&amp;ndash;变量、打印机、矮人战斧。如果你想确保每次只有一个任务会访问一个资源，你可以把任务的资源访问部分放在一个序列执行的队列中。这有点像做蛋糕：你和一个朋友可以分别取回原料（鸡蛋、面粉、蝾螈的眼睛，等等），但有些步骤你必须连续执行。你必须在把面糊放进烤箱之前准备好它。图 9-6 说明了这个策略。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/concurrency/enqueue.png"
loading="lazy"
>&lt;/p>
&lt;p>将任务分为串行部分和并发部分，可以让你安全地使你的代码更有效率。&lt;/p>
&lt;p>为了实现排队宏，你要向英国人致敬，因为他们发明了队列。你将使用一个队列来确保英国人习惯的问候语 &amp;ldquo;Ello, gov&amp;rsquo;na! Pip Pip! Cheerio!&amp;ldquo;的正确顺序进行传递。这个演示将涉及到大量的 &amp;ldquo;睡眠&amp;rdquo;，所以这里有一个宏来更简洁地完成这个任务。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-mysql" data-lang="mysql">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="n">defmacro&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;Sleep `timeout` seconds before evaluating body&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">timeout&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">body&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">do&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Thread&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">~&lt;/span>&lt;span class="n">timeout&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">~@&lt;/span>&lt;span class="n">body&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段代码所做的就是接受你给它的任何形式，并在它们之前插入对&lt;code>Thread/sleep&lt;/code>的调用，所有这些都被&lt;code>do&lt;/code>包裹起来。&lt;/p>
&lt;p>清单 9-1 中的代码将任务分成了并发部分和序列化部分。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [saying3 (promise)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (future (deliver saying3 (wait 100 &amp;#34;Cheerio!&amp;#34;)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @(let [saying2 (promise)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (future (deliver saying2 (wait 400 &amp;#34;Pip pip!&amp;#34;)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➊ @(let [saying1 (promise)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (future (deliver saying1 (wait 200 &amp;#34;&amp;#39;Ello, gov&amp;#39;na!&amp;#34;)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println @saying1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> saying1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println @saying2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> saying2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println @saying3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> saying3)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>9-1. 一个 enqueue 宏调用的扩展&lt;/li>
&lt;/ol>
&lt;p>整体策略是为每个任务（在本例中，打印问候语的一部分）创建一个 Promise，以创建一个相应的未来，将并发计算的值交付给该 Promise。这确保了在任何一个 Promise 被解除引用之前，所有的未来都被创建，并且确保序列化的部分以正确的顺序执行。首先打印&lt;code>saying1'的值-&lt;/code>&amp;quot;&amp;lsquo;Ello, gov&amp;rsquo;na!&amp;quot;-然后是&lt;code>saying2'的值，最后是&lt;/code>saying3&amp;rsquo;。在&lt;code>let&lt;/code>块中返回&lt;code>saying1&lt;/code>，并在➊处解除对&lt;code>let&lt;/code>块的引用，可以确保在代码继续对&lt;code>saying2&lt;/code>做任何事情之前，你已经完全完成了&lt;code>saying1&lt;/code>，而且这种模式在&lt;code>saying2&lt;/code>和&lt;code>saying3&lt;/code>上重复。&lt;/p>
&lt;p>解除对&lt;code>let&lt;/code>块的引用似乎很傻，但这样做可以让你用一个宏来抽象这段代码。你肯定想使用宏，因为像前面的例子那样写出的代码会让你发疯（英国人会这么说）。理想情况下，这个宏的工作方式如清单 9-2 所示。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(-&amp;gt; (enqueue ➊saying ➋(wait 200 &amp;#34;&amp;#39;Ello, gov&amp;#39;na!&amp;#34;) ➌(println @saying))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ➍(enqueue saying (wait 400 &amp;#34;Pip pip!&amp;#34;) (println @saying))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (enqueue saying (wait 100 &amp;#34;Cheerio!&amp;#34;) (println @saying)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>这就是你使用 enqueue 的方法。&lt;/li>
&lt;/ol>
&lt;p>该宏让你命名被创建的 Promise➊，定义如何获取价值以交付该 Promise➋，并定义如何处理该 Promise➌。这个宏也可以把另一个&lt;code>enqueue&lt;/code>宏调用作为它的第一个参数，这样你就可以把它变成线程➍。清单 9-3 显示了你如何定义&lt;code>enqueue&lt;/code>宏。定义完&lt;code>enqueue&lt;/code>后，清单 9-2 中的代码将扩展为清单 9-1 中的代码，其中包含所有嵌套的&lt;code>let&lt;/code>表达式。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmacro enqueue
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➊ ([q concurrent-promise-name concurrent serialized]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➋ `(let [~concurrent-promise-name (promise)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (future (deliver ~concurrent-promise-name ~concurrent))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➌ (deref ~q)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ~serialized
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ~concurrent-promise-name))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➍ ([concurrent-promise-name concurrent serialized]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> `(enqueue (future) ~concurrent-promise-name ~concurrent ~serialized)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>1.enqueue 的实现&lt;/p>
&lt;p>首先注意这个宏有两个 arities，以便提供一个缺省值。第一个 arity ➊是真正的工作所在。它有参数&lt;code>q&lt;/code>，而第二个 arity 则没有。第二个 arity ➍调用第一个 arity，为&lt;code>q&lt;/code>提供了&lt;code>(future)&lt;/code>的值；你将在一分钟内看到原因。在➋中，宏返回一个 Form，该 Form 创建了一个 Promise，在一个 future 中传递它的值，取消对提供给&lt;code>q&lt;/code>的任何 Form 的引用，求值序列化代码，最后返回 Promise。&lt;code>q&lt;/code>通常是一个嵌套的&lt;code>let&lt;/code>表达式，由另一个对&lt;code>enqueue&lt;/code>的调用返回，如清单 9-2 所示。如果没有为&lt;code>q&lt;/code>提供值，宏会提供一个未来，这样在➌的&lt;code>deref&lt;/code>就不会引起异常。&lt;/p>
&lt;p>现在我们已经写好了&lt;code>enqueue&lt;/code>宏，让我们试试它是否能减少执行时间&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(time @(-&amp;gt; (enqueue saying (wait 200 &amp;#34;&amp;#39;Ello, gov&amp;#39;na!&amp;#34;) (println @saying))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (enqueue saying (wait 400 &amp;#34;Pip pip!&amp;#34;) (println @saying))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (enqueue saying (wait 100 &amp;#34;Cheerio!&amp;#34;) (println @saying))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#39;Ello, gov&amp;#39;na!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Pip pip!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Cheerio!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Elapsed time: 401.635 msecs&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>天哪! 问候语是按照正确的顺序传递的，你可以通过耗时看到，睡眠的 &amp;ldquo;工作 &amp;ldquo;是同时进行的。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>对于像你这样的程序员来说，学习并发和并行编程技术很重要，这样你就可以设计出在现代硬件上高效运行的程序。并发是指一个程序能够执行一个以上的任务，在 Clojure 中，你可以通过将任务放在不同的线程上来实现。当计算机有一个以上的 CPU 时，程序就会并行执行，这样就可以在同一时间执行一个以上的线程。&lt;/p>
&lt;p>并发编程指的是用于管理三种并发风险的技术：引用单元、互斥和死锁。Clojure 为你提供了三个基本工具，帮助你减轻这些风险：Future、延迟和 Promise。每个工具都可以让你把定义任务、执行任务和要求任务结果这三个事件解耦。Future 让你定义一个任务并立即执行它，允许你稍后或永远不要求结果。 Future 也会缓存其结果。延迟（Delay）让你定义一个稍后才执行的任务，并且延迟的结果会被缓存起来。许诺让你表达你需要一个结果，而不需要知道产生该结果的任务。你只能向一个 Promise 传递一次值。&lt;/p>
&lt;p>在下一章中，你将探索并发编程的哲学层面，并学习更复杂的工具来管理风险。&lt;/p>
&lt;h2 id="练习">练习&lt;/h2>
&lt;ol>
&lt;li>编写一个函数，将一个字符串作为参数，使用&lt;code>slurp&lt;/code>函数在 Bing 和 Google 上搜索它。你的函数应该返回搜索到的第一个页面的 HTML。&lt;/li>
&lt;li>更新你的函数，使其接受第二个参数，包括要使用的搜索引擎。&lt;/li>
&lt;li>创建一个新的函数，将搜索词和搜索引擎作为参数，并从每个搜索引擎的第一页搜索结果中返回一个 URL 的 Vector。&lt;/li>
&lt;/ol></description></item><item><title>Chapter8 宏</title><link>https://example.com/p/chapter8-%E5%AE%8F/</link><pubDate>Sat, 15 Jan 2022 12:22:42 +0800</pubDate><guid>https://example.com/p/chapter8-%E5%AE%8F/</guid><description>&lt;h1 id="编写宏">编写宏&lt;/h1>
&lt;p>当我 18 岁时，我在新墨西哥州圣菲的一家酒店找到了一份夜班审计师的工作，每周工作四个晚上，从晚上 11 点到早上 7 点。经过几个月的这种不眠不休的工作，我的情绪有了自己的变化。一天晚上，大约在&lt;/p>
&lt;p>凌晨 3 点，我正在看一个信息广告，该产品声称可以恢复男人的头发。当我看到一个曾经秃头的人的故事时，我被真诚的喜悦所淹没。&amp;ldquo;终于来了！&amp;ldquo;我的大脑涌动着。&amp;ldquo;这个人得到了他应得的爱和成功! 多么不可思议的产品，给无望的人以希望！&amp;rdquo;&lt;/p>
&lt;p>从那时起，我发现自己一直在想，我是否能以某种方式重新创造因长期睡眠不足而引起的情感放弃和对生命的欣赏。也许是某种药水&amp;ndash;喝上几口，释放我内心的理查德-西蒙斯，但时间不会太长。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/writing-macros/simmons-potion.png"
loading="lazy"
>&lt;/p>
&lt;p>就像药水可以让我暂时改变我的基本性质一样，宏允许你以其他语言无法实现的方式修改 Clojure。有了宏，你可以扩展 Clojure 以适应你的问题空间，建立起语言。&lt;/p>
&lt;p>在这一章中，你将彻底研究如何编写宏，从基本的例子开始，逐步提高复杂性。最后，你将戴上你的假想帽，用宏来验证你想象中的在线药水店的客户订单。&lt;/p>
&lt;p>在本章结束时，你将了解你用来编写宏的所有工具：引号、语法引号、解引号、解引号拼接（又称皮纳塔工具）和 gensym。你还会了解到对毫无戒心的宏作者来说隐藏着的危险：双重求值、变量捕获和宏感染。&lt;/p>
&lt;h2 id="宏是必不可少的">宏是必不可少的&lt;/h2>
&lt;p>在你开始编写宏之前，我想帮助你把它们放在适当的环境中。是的，宏比北极熊的脚趾甲还要酷，但你不应该把宏看成是一些深奥的工具，当你想对你的代码进行额外的花哨处理时，就把它拿出来。事实上，宏允许 Clojure 从一个很小的函数和特殊形式的核心中获得大量的内置功能。以&lt;code>when&lt;/code>为例。 &lt;code>when&lt;/code>有这样的一般形式。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(when boolean-expression
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> expression-1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> expression-2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> expression-3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> expression-x)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可能认为&lt;code>when&lt;/code>是一个像&lt;code>if&lt;/code>一样的特殊形式。那么你猜怎么着？它不是! 在大多数其他语言中，你只能使用特殊的关键字来创建条件表达式，而没有办法创建你自己的条件运算符。然而，&lt;code>when&lt;/code>实际上是一个宏。&lt;/p>
&lt;p>在这个宏扩展中，你可以看到&lt;code>when&lt;/code>是用&lt;code>if&lt;/code>和&lt;code>do&lt;/code>来实现的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(macroexpand &amp;#39;(when boolean-expression
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> expression-1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> expression-2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> expression-3))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (if boolean-expression
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (do expression-1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> expression-2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> expression-3))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这表明宏是 Clojure 开发中不可或缺的一部分&amp;ndash;它们甚至被用来提供基本操作。宏并不是为奇特的特殊情况而保留的；你应该把写宏看作是你工具包中的另一个工具。当你学会编写自己的宏时，你会发现它们是如何让你进一步扩展语言，使其适合你的特定问题领域的形状。&lt;/p>
&lt;h2 id="解剖巨集">解剖巨集&lt;/h2>
&lt;p>巨集定义看起来很像函数定义。它们有一个名称，一个可选的文档字符串，一个参数列表，以及一个主体。主体几乎总是返回一个列表。这是有道理的，因为宏是将数据结构转化为 Clojure 可以求值的形式的一种方式，而 Clojure 使用列表来表示函数调用、特殊形式调用和宏调用。你可以在宏主体中使用任何函数、宏或特殊形式，你调用宏就像调用函数或特殊形式一样。&lt;/p>
&lt;p>作为一个例子，这里有我们的老朋友&lt;code>infix&lt;/code>宏。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmacro infix
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Use this macro when you pine for the notation of your childhood&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [infixed]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (list (second infixed) (first infixed) (last infixed)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个宏将一个列表重新排列成正确的 infix 记号顺序。下面是一个例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(infix (1 + 1))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>函数和宏之间的一个关键区别是，函数参数在传递给函数之前被完全求值，而宏是以未求值的数据形式接收参数。你可以在这个例子中看到这一点。如果你试图单独求值&lt;code>(1+1)&lt;/code>，你会得到一个异常。然而，因为你在进行一个宏调用，未求值的列表&lt;code>(1 + 1)&lt;/code>被传递给&lt;code>infix&lt;/code>。然后宏可以使用&lt;code>first&lt;/code>、&lt;code>second&lt;/code>和&lt;code>last&lt;/code>来重新排列列表，这样 Clojure 就可以求值它。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(macroexpand &amp;#39;(infix (1 + 1))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (+ 1 1)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通过扩展宏，你可以看到&lt;code>infix&lt;/code>将&lt;code>(1 + 1)&lt;/code>重新排列成&lt;code>(+ 1 1)&lt;/code>。很方便!&lt;/p>
&lt;p>你也可以在宏定义中使用参数重构，就像你可以使用函数一样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmacro infix-2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [[operand1 op operand2]] (list op operand1 operand2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (list op operand1 operand2))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>解构参数可以让你根据序列参数中的位置简洁地将值与符号绑定。在这里，&lt;code>infix-2&lt;/code>将一个顺序数据结构作为参数，并按位置进行解构，因此第一个值被命名为&lt;code>operand1&lt;/code>，第二个值被命名为&lt;code>op&lt;/code>，第三个值在宏中被命名为&lt;code>operand2&lt;/code>。&lt;/p>
&lt;p>你也可以创建多属性的宏，事实上，基本的布尔运算&lt;code>and&lt;/code>和&lt;code>or&lt;/code>都被定义为宏。下面是&lt;code>and&lt;/code>的源代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmacro and
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Evaluates exprs one at a time, from left to right. If a form
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> returns logical false (nil or false), and returns that value and
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> doesn&amp;#39;t evaluate any of the other expressions, otherwise it returns
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> the value of the last expr. (and) returns true.&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:added &amp;#34;1.0&amp;#34;}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([] true)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([x] x)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([x &amp;amp; next]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> `(let [and# ~x]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if and# (and ~@next) and#))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子中发生了很多事情，包括符号和&lt;code>~@&lt;/code>，你很快就会了解到这些。现在重要的是，这里有三个宏体：一个总是返回 &amp;ldquo;true &amp;ldquo;的 0-arity 宏体，一个返回操作数的 1-arity 宏体，以及一个递归调用自身的&lt;em>n&lt;/em>-arity 宏体。这是正确的：宏可以是递归的，它们也可以使用其余的参数（&lt;em>n&lt;/em>-arity 宏主体中的&lt;code>&amp;amp; next&lt;/code>），就像函数一样。&lt;/p>
&lt;p>现在你对宏的解剖已经很熟悉了，现在是时候把你自己绑在你的奥德修斯式思维的桅杆上，学习写宏体了。&lt;/p>
&lt;h2 id="为求值建立列表">为求值建立列表&lt;/h2>
&lt;p>编写宏就是要为 Clojure 建立一个列表来进行求值，这需要颠覆你的正常思维方式。首先，你经常需要引用表达式，以便在你的最终列表中获得未求值的数据结构（我们稍后会回到这个问题）。更普遍的是，你需要特别注意&lt;em>符号&lt;/em>和&lt;em>值&lt;/em>之间的区别。&lt;/p>
&lt;h3 id="区分符号和值">区分符号和值&lt;/h3>
&lt;p>假设你想创建一个宏，它接收一个表达式，并同时打印和返回其值。(这与&lt;code>println'不同，&lt;/code>println&amp;rsquo;总是返回`nil&amp;rsquo;。)你希望你的宏能够返回类似这样的列表。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [result expression]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println result)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> result)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你的宏的第一个版本可能看起来像这样，使用&lt;code>list&lt;/code>函数来创建 Clojure 应该求值的列表。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> (defmacro my-print-whoopsie
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [expression]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (list let [result expression]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (list println result)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> result))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然而，如果你尝试这样做，你会得到一个异常`不能接受一个宏的值。#&amp;lsquo;clojure.core/let&amp;rsquo;。这到底是怎么回事？&lt;/p>
&lt;p>发生这种情况的原因是，你的宏主体试图获取&lt;em>符号&lt;/em> &lt;code>let&lt;/code>所指的*值，而你实际想做的是返回&lt;code>let&lt;/code>符号本身。还有其他的问题：你试图获得&lt;code>result&lt;/code>的值，这是不绑定的，你试图获得&lt;code>println&lt;/code>的值，而不是返回其符号。下面是你如何写宏来做你想要的事情。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmacro my-print
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [expression]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (list &amp;#39;let [&amp;#39;result expression]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (list &amp;#39;println &amp;#39;result)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#39;result))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这里，你通过在每个符号前加上单引号&amp;rdquo;&amp;lsquo;&amp;lsquo;来引出你想作为一个符号使用。这告诉 Clojure&lt;em>关闭&lt;/em>后面的求值，在这种情况下，防止 Clojure 试图解决这些符号，而只是返回这些符号。使用引号来关闭求值的能力是编写宏的核心，所以让我们给这个主题一个独立的章节。&lt;/p>
&lt;h3 id="简单的引号">简单的引号&lt;/h3>
&lt;p>你几乎总是在你的宏中使用引号来获得一个未求值的符号。让我们简单地复习一下引号，然后看看你如何在宏中使用它。&lt;/p>
&lt;p>首先，这里是一个没有引号的简单函数调用。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(+ 1 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果我们在开头加上&lt;code>quote&lt;/code>，它就会返回一个未求值的数据结构。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(quote (+ 1 2))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (+ 1 2)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里在返回的列表中，&lt;code>+&lt;/code>是一个符号。如果我们求值这个加号，就会产生加号函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #&amp;lt;core$_PLUS_ clojure.core$_PLUS_@47b36583&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而如果我们引用这个加号，它只是产生加号。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(quote +)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; +
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>求值一个未绑定的符号会引发一个异常。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">sweating-to-the-oldies
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Unable to resolve symbol: sweating-to-the-oldies in this context
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但是引用符号会返回一个符号，不管这个符号是否有一个与之相关的值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(quote sweating-to-the-oldies)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; sweating-to-the-oldies
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>单引号字符是&lt;code>(quote&lt;/code>x&lt;code>)&lt;/code>的读者宏。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">&amp;#39;(+ 1 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (+ 1 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;#39;dr-jekyll-and-richard-simmons
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; dr-jekyll-and-richard-simmons
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以在&lt;code>when&lt;/code>宏中看到引用的工作。这是&lt;code>when&lt;/code>的实际源代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmacro when
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Evaluates test. If logical true, evaluates body in an implicit do.&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:added &amp;#34;1.0&amp;#34;}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [test &amp;amp; body]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (list &amp;#39;if test (cons &amp;#39;do body)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，宏的定义同时引用了&lt;code>if&lt;/code>和&lt;code>do&lt;/code>。这是因为你想让这些符号出现在`when&amp;rsquo;返回的最终列表中进行计算。下面是一个返回列表的例子，它可能是这样的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(macroexpand &amp;#39;(when (the-cows-come :home)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (call me :pappy)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (slap me :silly)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (if (the-cows-come :home)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (do (call me :pappy)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (slap me :silly)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下面是另一个内置宏的源代码的例子，这次是关于&lt;code>unless&lt;/code>的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmacro unless
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Inverted &amp;#39;if&amp;#39;&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [test &amp;amp; branches]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (conj (reverse branches) test &amp;#39;if))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>同样，你必须引用&lt;code>if&lt;/code>，因为你想让未求值的符号放在结果列表中，就像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(macroexpand &amp;#39;(unless (done-been slapped? me)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (slap me :silly)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (say &amp;#34;I reckon that&amp;#39;ll learn me&amp;#34;)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (if (done-been slapped? me)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (say &amp;#34;I reckon that&amp;#39;ll learn me&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (slap me :silly))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在许多情况下，在编写宏时，你会使用这样的简单引号，但大多数情况下你会使用更强大的语法引号。&lt;/p>
&lt;h3 id="语法引用">语法引用&lt;/h3>
&lt;p>到目前为止, 你已经看到了通过使用&lt;code>list&lt;/code>函数来建立列表的宏，以及对列表进行操作的函数，如&lt;code>first&lt;/code>, &lt;code>second&lt;/code>, &lt;code>last&lt;/code>，等等。事实上，你可以这样写宏，直到奶牛回家。但有时，这将导致繁琐和冗长的代码。&lt;/p>
&lt;p>语法引号返回未求值的数据结构，与普通引号类似。然而，有两个重要的区别。一个区别是，语法引用将返回&lt;em>完全合格的&lt;/em>符号（即包括符号的命名空间）。让我们比较一下引号和语法引号。&lt;/p>
&lt;p>如果你的代码中不包括名字空间，那么引用就不包括名字空间。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">&amp;#39;+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; +
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>写出命名空间，它将被正常的引用所返回。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">&amp;#39;clojure.core/+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; clojure.core/+
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>语法引号将总是包括符号的完整命名空间。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">`+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; clojure.core/+
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>对一个列表的引用会递归地引用所有的元素。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">&amp;#39;(+ 1 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (+ 1 2)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>语法引用一个列表递归地引用所有的元素。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">`(+ 1 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (clojure.core/+ 1 2)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>语法引号包括名字空间的原因是为了帮助你避免名字的碰撞，这个话题在第 6 章中涉及。&lt;/p>
&lt;p>引号和语法引号之间的另一个区别是，后者允许你使用 &amp;ldquo;tilde&amp;rdquo;，即&amp;rdquo;~&amp;quot;，来*解除引号的形式。这有点像氪星石：只要超人在氪星石周围，他的能力就会消失。每当在一个语法引号的 Form 中出现 tilde，语法引号返回未求值的、完全命名的 Form 的能力就会消失。这里有一个例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">`(+ 1 ~(inc 1))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (clojure.core/+ 1 2)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>因为它在 tilde 之后，&lt;code>(inc 1)&lt;/code>被求值而不是被引号。如果没有 unquote，语法引号会返回未求值的形式，并带有完全限定的符号。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">`(+ 1 (inc 1))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (clojure.core/+ 1 (clojure.core/inc 1))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果你熟悉字符串插值，你可以类似地考虑语法引用/非引用的问题。在这两种情况下，你都在创建一种模板，将一些变量放在一个更大的静态结构中。例如，在 Ruby 中，你可以通过连接来创建字符串&lt;code>&amp;quot;Churn your butter, Jebediah!&amp;quot;&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">name = &amp;#34;Jebediah&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;#34;Churn your butter, &amp;#34; + name + &amp;#34;!&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>或通过内插法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">&amp;#34;Churn your butter, #{name}!&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就像字符串插值可以使代码更清晰、更简洁一样，语法引号和解引号可以使你更清晰、更简洁地创建列表。比较一下使用&lt;code>list&lt;/code>函数和使用语法引号。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(list &amp;#39;+ 1 (inc 1))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (+ 1 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">`(+ 1 ~(inc 1))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (clojure.core/+ 1 2)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>正如你所看到的，语法引号版本更加简洁。而且，它的视觉形式更接近列表的最终形式，使其更容易理解。&lt;/p>
&lt;h2 id="在宏中使用语法引语">在宏中使用语法引语&lt;/h2>
&lt;p>现在你已经很好地掌握了语法引号的工作原理，来看看&lt;code>code-critic&lt;/code>宏。你将使用语法引号编写一个更简洁的版本。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmacro code-critic
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Phrases are courtesy Hermes Conrad from Futurama&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [bad good]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (list &amp;#39;do
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (list &amp;#39;println
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Great squid of Madrid, this is bad code:&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (list &amp;#39;quote bad))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (list &amp;#39;println
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Sweet gorilla of Manila, this is good code:&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (list &amp;#39;quote good))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(code-critic (1 + 1) (+ 1 1))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Great squid of Madrid, this is bad code: (1 + 1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Sweet gorilla of Manila, this is good code: (+ 1 1)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>仅仅是看着那些乏味的重复的&lt;code>list&lt;/code>和单引号，就让我感到害怕。但是如果你用语法引号重写&lt;code>code-critic&lt;/code>，你就可以使它变得圆滑简洁。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmacro code-critic
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Phrases are courtesy Hermes Conrad from Futurama&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [bad good]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> `(do (println &amp;#34;Great squid of Madrid, this is bad code:&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (quote ~bad))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;Sweet gorilla of Manila, this is good code:&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (quote ~good))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这种情况下，你想引用除符号&lt;code>good&lt;/code>和&lt;code>bad&lt;/code>以外的所有内容。在原来的版本中，你必须单独引用每一块，并明确地把它放在一个不方便的列表中，只是为了防止这两个符号被引用。有了语法引号，你只需将整个&lt;code>do&lt;/code>表达式包裹在一个引号中，并简单地取消你要求值的两个符号的引号。&lt;/p>
&lt;p>宏的编写方法介绍到此结束! 亲爱的西萨摩亚和东萨摩亚的神圣蟒蛇，这是很重要的!&lt;/p>
&lt;p>总而言之，宏接收未经求值的、任意的数据结构作为参数，并返回 Clojure 求值的数据结构。在定义宏的时候，你可以使用参数重构，就像你可以使用函数和&lt;code>let&lt;/code>绑定一样。你也可以编写多属性和递归的宏。&lt;/p>
&lt;p>大多数情况下，你的宏会返回列表。你可以通过使用&lt;code>list&lt;/code>函数或使用语法引号来建立要返回的列表。语法引号通常会使代码更清晰、更简洁，因为它可以让你创建一个你想返回的数据结构的模板，更容易进行视觉上的解析。无论你使用语法引号还是普通引号，重要的是在建立你的列表时要清楚地了解符号和它所求值的值之间的区别。如果你想让你的宏返回多种形式供 Clojure 求值，一定要用&lt;code>do&lt;/code>来包装它们。&lt;/p>
&lt;h2 id="重构一个宏和取消引号拼接">重构一个宏和取消引号拼接&lt;/h2>
&lt;p>上一节中的 &amp;ldquo;code-critic &amp;ldquo;宏仍然需要一些改进。看看这个重复的地方! 两个 &amp;ldquo;println &amp;ldquo;的调用几乎是一样的。让我们把它清理一下。首先，让我们创建一个函数来生成这些`println&amp;rsquo;列表。函数比宏更容易思考和使用，所以把宏的内容移到辅助函数中通常是个好主意。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn criticize-code
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [criticism code]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> `(println ~criticism (quote ~code)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defmacro code-critic
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [bad good]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> `(do ~(criticize-code &amp;#34;Cursed bacteria of Liberia, this is bad code:&amp;#34; bad)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ~(criticize-code &amp;#34;Sweet sacred boa of Western and Eastern Samoa, this is good code:&amp;#34; good)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意到&lt;code>criticize-code&lt;/code>函数如何返回一个语法引号的列表。这就是你如何建立起宏将返回的列表。&lt;/p>
&lt;p>不过，还有更多的改进空间。这段代码仍然有多个几乎相同的函数调用。在这种情况下，你想对一个值的集合应用同一个函数，使用像&lt;code>map&lt;/code>这样的 seq 函数是有意义的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmacro code-critic
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [bad good]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> `(do ~(map #(apply criticize-code %)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [[&amp;#34;Great squid of Madrid, this is bad code:&amp;#34; bad]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [&amp;#34;Sweet gorilla of Manila, this is good code:&amp;#34; good]])))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这看起来好一点了。你正在 Map 每个批评/代码对，并将 &amp;ldquo;批评-代码 &amp;ldquo;函数应用于该对。让我们试着运行这段代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(code-critic (1 + 1) (+ 1 1))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; NullPointerException
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>哦，不！这根本就没有用! 发生了什么？问题是，&lt;code>map&lt;/code>返回一个列表，在这种情况下，它返回一个&lt;code>println&lt;/code>表达式的列表。我们只想得到每个&lt;code>println&lt;/code>调用的结果，但是相反，这段代码把两个结果都放在一个列表中，然后试图求值这个列表。&lt;/p>
&lt;p>换句话说，当它求值这段代码时，Clojure 会得到类似这样的结果。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(do
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ((clojure.core/println &amp;#34; criticism&amp;#34; &amp;#39; (1 + 1))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (clojure.core/println &amp;#34;critism&amp;#34; &amp;#39;(+ 1 1)))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后求值第一个 &amp;ldquo;println &amp;ldquo;的调用，给我们提供这个。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(do
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (nil
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (clojure.core/println &amp;#34;criticism&amp;#34; &amp;#39;(+ 1 1))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>并在求值了第二个`println&amp;rsquo;调用后，这样做。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(do
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (nil nil))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就是导致异常的原因。&lt;code>println&lt;/code>求值为&lt;code>nil&lt;/code>，所以我们最后得到的结果是&lt;code>(nil nil)&lt;/code>。&lt;code>nil&lt;/code>是不可调用的，我们得到一个&lt;code>NullPointerException&lt;/code>。&lt;/p>
&lt;p>多么不方便啊 但恰恰相反，无引号拼接正是为了处理这种情况而发明的。取消引号拼接是用&lt;code>~@&lt;/code>来完成的。如果你只是取消引用一个列表，你会得到这样的结果。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">`(+ ~(list 1 2 3))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (clojure.core/+ (1 2 3))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然而，如果你使用 unquote 拼接，你会得到这样的结果。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">`(+ ~@(list 1 2 3))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (clojure.core/+ 1 2 3)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Unquote 拼接将一个可排序的数据结构解开，将其内容直接放在包围的语法引号数据结构中。这就像&lt;code>~@&lt;/code>是一把大锤子，后面的东西是一个皮纳塔，其结果是你曾经参加过的最可怕和最棒的聚会。&lt;/p>
&lt;p>总之，如果你在你的代码批评中使用非引号拼接，那么一切都会很顺利。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmacro code-critic
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [{:keys [good bad]}]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> `(do ~@(map #(apply criticize-code %)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [[&amp;#34;Sweet lion of Zion, this is bad code:&amp;#34; bad]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [&amp;#34;Great cow of Moscow, this is good code:&amp;#34; good]])))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(code-critic (1 + 1) (+ 1 1))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Sweet lion of Zion, this is bad code: (1 + 1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Great cow of Moscow, this is good code: (+ 1 1)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>呜呼! 你已经成功地将重复的代码提取到一个函数中，并使你的宏代码更加简洁。温尼伯的可爱豚鼠，这是很好的代码!&lt;/p>
&lt;h2 id="需要注意的事项">需要注意的事项&lt;/h2>
&lt;p>宏有一些偷偷摸摸的问题，你应该注意到。在本节中，你将了解到一些宏的陷阱以及如何避免它们。我希望你还没有把自己从你的思想桅杆上解下来。&lt;/p>
&lt;h3 id="变量捕获">变量捕获&lt;/h3>
&lt;p>&lt;em>变量捕获&lt;/em>发生在一个宏引入了一个绑定，而这个绑定对宏的用户来说是未知的，它使一个现有的绑定黯然失色。例如，在下面的代码中，一个宏顽皮地引入了它自己的&lt;code>let&lt;/code>绑定，这就把代码搞乱了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def message &amp;#34;Good job!&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defmacro with-mischief
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [&amp;amp; stuff-to-do]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (concat (list &amp;#39;let [&amp;#39;message &amp;#34;Oh, big deal!&amp;#34;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> stuff-to-do))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(with-mischief
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;Here&amp;#39;s how I feel about that thing you did: &amp;#34; message))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Here&amp;#39;s how I feel about that thing you did: Oh, big deal!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>println&lt;/code>调用引用了符号&lt;code>message&lt;/code>，我们认为它与字符串&lt;code>&amp;quot;好样的！&amp;quot;&lt;/code>绑定。然而，&lt;code>with-mischief&lt;/code>宏为&lt;code>message&lt;/code>创建了一个新的绑定。&lt;/p>
&lt;p>注意，这个宏没有使用语法引号。这样做会导致一个异常。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def message &amp;#34;Good job!&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defmacro with-mischief
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [&amp;amp; stuff-to-do]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> `(let [message &amp;#34;Oh, big deal!&amp;#34;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ~@stuff-to-do))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(with-mischief
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;Here&amp;#39;s how I feel about that thing you did: &amp;#34; message))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; Exception: Can&amp;#39;t let qualified name: user/message
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个异常是为了你自己好：语法引号的设计是为了防止你在宏中意外地捕捉到变量。如果你想在你的宏中引入&lt;code>let&lt;/code>绑定，你可以使用一个&lt;em>gensym&lt;/em>。&lt;code>gensym&lt;/code>函数在每次连续调用时产生唯一的符号。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(gensym)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; G__655
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(gensym)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; G__658
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你也可以传递一个符号前缀。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(gensym &amp;#39;message)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; message4760
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(gensym &amp;#39;message)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; message4763
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下面是你如何改写&lt;code>with-mischief&lt;/code>，使之不那么调皮。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmacro without-mischief
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [&amp;amp; stuff-to-do]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [macro-message (gensym &amp;#39;message)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> `(let [~macro-message &amp;#34;Oh, big deal!&amp;#34;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ~@stuff-to-do
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;I still need to say: &amp;#34; ~macro-message))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(without-mischief
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;Here&amp;#39;s how I feel about that thing you did: &amp;#34; message))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Here&amp;#39;s how I feel about that thing you did: Good job!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; I still need to say: Oh, big deal!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个例子通过使用&lt;code>gensym&lt;/code>来创建一个新的、唯一的符号，然后与&lt;code>macro-message&lt;/code>绑定，避免了变量捕获。在语法引用的&lt;code>let&lt;/code>表达式中，&lt;code>macro-message&lt;/code>没有被引用，被解析为 gensym 的符号。这个源码符号与&lt;code>stuff-to-do&lt;/code>中的任何符号都不同，所以你可以避免变量捕获。因为这是一个常见的模式，你可以使用&lt;em>自动源码&lt;/em>。自动源码是使用源码的更简洁和方便的方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">`(blarg# blarg#)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(blarg__2869__auto__ blarg__2869__auto__)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">`(let [name# &amp;#34;Larry Potter&amp;#34;] name#)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (clojure.core/let [name__2872__auto__ &amp;#34;Larry Potter&amp;#34;] name__2872__auto__)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子中，你通过在语法引号列表中的一个符号上附加一个哈希标记（或者&lt;em>哈希标记&lt;/em>，如果你一定要坚持的话）来创建一个自动源码。Clojure 会自动确保 x&lt;code>#&lt;/code>的每个实例在同一个语法引号列表中解析为相同的符号，y&lt;code>#&lt;/code>的每个实例也是如此，以此类推。&lt;/p>
&lt;p>&lt;code>gensym&lt;/code>和 auto-gensym 在编写宏时经常使用，它们允许你避免变量捕获。&lt;/p>
&lt;h3 id="双重求值">双重求值&lt;/h3>
&lt;p>编写宏时要注意的另一个问题是&lt;em>双重求值&lt;/em>，当一个作为参数传递给宏的表格被求值了不止一次时，就会出现这种情况。请看下面的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmacro report
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [to-try]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> `(if ~to-try
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (quote ~to-try) &amp;#34;was successful:&amp;#34; ~to-try)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (quote ~to-try) &amp;#34;was not successful:&amp;#34; ~to-try)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">;; Thread/sleep takes a number of milliseconds to sleep for
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(report (do (Thread/sleep 1000) (+ 1 1)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段代码是为了测试其参数的真实性。如果参数是真实的，它被认为是成功的；如果是虚假的，它是不成功的。该宏打印出其参数是否成功。在这种情况下，你实际上会睡两秒钟，因为&lt;code>(Thread/sleep 1000)&lt;/code>被求值了两次：一次在&lt;code>if&lt;/code>之后，另一次在&lt;code>println&lt;/code>被调用时。这是因为&lt;code>(do (Thread/sleep 1000) (+ 1 1))&lt;/code>的代码在整个宏扩展中被重复。这就像你写的一样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(if (do (Thread/sleep 1000) (+ 1 1))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#39;(do (Thread/sleep 1000) (+ 1 1))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;was successful:&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (do (Thread/sleep 1000) (+ 1 1)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#39;(do (Thread/sleep 1000) (+ 1 1))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;was not successful:&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (do (Thread/sleep 1000) (+ 1 1))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&amp;ldquo;大问题！&amp;ldquo;你内心的例子评论家说。好吧，如果你的代码是在银行账户之间转账，这将是一个非常大的问题。以下是你如何避免这个问题的方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmacro report
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [to-try]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> `(let [result# ~to-try]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if result#
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (quote ~to-try) &amp;#34;was successful:&amp;#34; result#)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (quote ~to-try) &amp;#34;was not successful:&amp;#34; result#))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>将 &amp;ldquo;to-try &amp;ldquo;放在一个 &amp;ldquo;let &amp;ldquo;表达式中，你只需求值一次该代码，并将结果绑定到一个自动标示的符号 &amp;ldquo;result#&amp;ldquo;上，现在你可以引用该符号而无需重新求值 &amp;ldquo;to-try &amp;ldquo;代码。&lt;/p>
&lt;h3 id="宏的所有方式">宏的所有方式&lt;/h3>
&lt;p>使用宏的一个微妙的缺陷是，你可能最终不得不写越来越多的宏来完成任何事情。这是由于宏的扩展发生在求值之前。&lt;/p>
&lt;p>例如，假设你想用&lt;code>report&lt;/code>宏来&lt;code>doseq&lt;/code>。而不是多次调用报告。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(report (= 1 1))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (= 1 1) was successful: true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(report (= 1 2))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (= 1 2) was not successful: false
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>让我们进行迭代。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(doseq [code [&amp;#39;(= 1 1) &amp;#39;(= 1 2)]]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (report code))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; code was successful: (= 1 1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; code was successful: (= 1 2)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当我们单独传递函数时，报告宏工作正常，但当我们使用&lt;code>doseq&lt;/code>对多个函数进行&lt;code>report&lt;/code>迭代时，它是一个毫无价值的失败。下面是其中一个&lt;code>doseq&lt;/code>迭代的宏扩展的样子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(if
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> code
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (clojure.core/println &amp;#39;code &amp;#34;was successful:&amp;#34; code)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (clojure.core/println &amp;#39;code &amp;#34;was not successful:&amp;#34; code))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>正如你所看到的，&lt;code>report&lt;/code>在每个迭代中接收未求值的符号&lt;code>code&lt;/code>；然而，我们希望它在求值时接收任何&lt;code>code&lt;/code>被绑定的内容。但是&lt;code>report&lt;/code>在宏扩展时操作，就是不能访问这些值。这就像它有 T.Rex 的手臂，运行时的值永远不在它的掌握之中。&lt;/p>
&lt;p>为了解决这种情况，我们可以再写一个宏，像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmacro doseq-macro
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [macroname &amp;amp; args]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> `(do
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ~@(map (fn [arg] (list macroname arg)) args)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(doseq-macro report (= 1 1) (= 1 2))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (= 1 1) was successful: true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (= 1 2) was not successful: false
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果你遇到这种情况，请花些时间重新思考你的方法。这很容易使你自己陷入困境，使你无法通过普通的函数调用来完成任何事情。你会被卡住，不得不写更多的宏。宏是非常强大和令人敬畏的，你不应该害怕使用它们。它们把 Clojure 处理数据的设施变成了创造新语言的设施，而这些新语言是根据你的编程问题来设计的。对于某些程序来说，你的代码 90%以上都是宏，这是合适的。尽管它们很棒，但它们也增加了新的组合挑战。它们只是真正的相互组合，所以通过使用它们，你可能会错过 Clojure 中其他类型的组合（函数式、面向对象）。&lt;/p>
&lt;p>我们现在已经涵盖了编写宏的所有机制。拍拍你的背吧! 这是一个相当大的交易!&lt;/p>
&lt;p>在本章的最后，终于到了戴上你的伪装帽，在本章最开始谈到的网上药水店工作的时候了。&lt;/p>
&lt;h2 id="为勇敢和真实的人而酿的酒">为勇敢和真实的人而酿的酒&lt;/h2>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/writing-macros/wizard.png"
loading="lazy"
>&lt;/p>
&lt;p>在这一章的开头，我透露了一个梦想：找到某种可饮用的东西，一旦摄入，就能暂时让我拥有 80 年代健身大师的力量和气质，把我从抑制和自我意识的牢笼中解放出来。我相信有一天某个地方会有人发明这样的灵丹妙药，所以我们不妨着手建立一个系统来销售这种神话般的药水。让我们把这种假想的混合物称为&lt;em>勇敢和真实的啤酒&lt;/em>。这个名字是我无缘无故想到的。&lt;/p>
&lt;p>在订单纷至沓来之前（双关语！击掌！），我们需要有一些验证的地方。本节向你展示了一种在功能上进行验证的方法，以及如何使用你将编写的名为 &amp;ldquo;if-valid &amp;ldquo;的宏更简洁地编写执行验证的代码。这将帮助你了解编写自己的宏的典型情况。如果你只想知道宏的定义，可以跳到&lt;a class="link" href="https://www.braveclojure.com/writing-macros/#Anchor" target="_blank" rel="noopener"
>&amp;quot;&lt;code>if-valid&lt;/code>&amp;rdquo; 第 182 页&lt;/a>。&lt;/p>
&lt;h3 id="验证函数">验证函数&lt;/h3>
&lt;p>为了简单起见，我们只担心验证每个订单的姓名和电子邮件。对于我们的商店，我想我们希望这些订单的细节能像这样表示。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def order-details
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;Mitchard Blimmons&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :email &amp;#34;mitchard.blimmonsgmail.com&amp;#34;})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个特殊的 Map 有一个无效的电子邮件地址（缺少&lt;code>@&lt;/code>符号），所以这正是我们的验证代码应该捕捉的订单类型 理想情况下，我们希望编写的代码能产生这样的结果。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(validate order-details order-details-validations)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:email [&amp;#34;Your email address doesn&amp;#39;t look like an email address.&amp;#34;]}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>也就是说，我们希望能够调用一个函数，`validate&amp;rsquo;，其中包含需要验证的数据和如何验证的定义。结果应该是一个 Map，其中每个键对应一个无效的字段，每个值是该字段的一个或多个验证信息的 Vector。下面的两个函数完成了这项工作。&lt;/p>
&lt;p>让我们先看看&lt;code>order-details-validations&lt;/code>。以下是你如何表示验证信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def order-details-validations
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [&amp;#34;Please enter a name&amp;#34; not-empty]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :email
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [&amp;#34;Please enter an email address&amp;#34; not-empty
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Your email address doesn&amp;#39;t look like an email address&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> #(or (empty? %) (re-seq #&amp;#34;@&amp;#34; %))]})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这是一个 Map，每个键都与错误信息和验证函数对的 Vector 相关。例如，&lt;code>:name&lt;/code>有一个验证函数，&lt;code>not-empty&lt;/code>；如果验证失败，你应该得到&lt;code>&amp;quot;请输入一个名字&amp;quot;&lt;/code>的错误信息。&lt;/p>
&lt;p>接下来，我们需要写出&lt;code>validate'函数。&lt;/code>validate&lt;code>函数可以分解成两个函数：一个是对单个字段进行验证，另一个是将这些错误信息累积成一个最终的错误信息Map，如&lt;/code>{:email [&amp;ldquo;你的邮箱地址看起来不像邮箱地址。&amp;rdquo;]}&lt;code>。这里有一个叫做&lt;/code>error-messages-for`的函数，对一个单一的值进行验证。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn error-messages-for
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Return a seq of error messages&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [to-validate message-validator-pairs]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (map first (filter #(not ((second %) to-validate))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (partition 2 message-validator-pairs))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>第一个参数，&lt;code>to-validate&lt;/code>，是你要验证的字段。第二个参数，&lt;code>message-validator-pairs&lt;/code>，应该是一个有偶数元素的序列。这个序列被分组为&lt;code>(partition 2 message-validator-pairs)'的对。对中的第一个元素应该是一个错误信息，对中的第二个元素应该是一个函数（就像在&lt;/code>order-details-validations&lt;code>中安排的对）。&lt;/code>error-messages-for&lt;code>函数的工作原理是过滤出所有错误信息和验证对，其中验证函数在应用于&lt;/code>to-validate&lt;code>时返回&lt;/code>true&lt;code>。然后，它使用&lt;/code>map first`来获取每对元素的第一个元素，即错误信息。下面是它的操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(error-messages-for &amp;#34;&amp;#34; [&amp;#34;Please enter a name&amp;#34; not-empty])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (&amp;#34;Please enter a name&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在我们需要将这些错误信息积累到一个 Map 中。&lt;/p>
&lt;p>下面是完整的&lt;code>validate&lt;/code>函数，以及我们将其应用于&lt;code>order-details&lt;/code>和&lt;code>order-details-validations&lt;/code>时的输出。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn validate
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Returns a map with a vector of errors for each key&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [to-validate validations]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (reduce (fn [errors validation]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [[fieldname validation-check-groups] validation
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> value (get to-validate fieldname)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> error-messages (error-messages-for value validation-check-groups)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if (empty? error-messages)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> errors
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (assoc errors fieldname error-messages))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> validations))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(validate order-details order-details-validations)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:email (&amp;#34;Your email address doesn&amp;#39;t look like an email address&amp;#34;)}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>成功了! 这个函数是通过减少&lt;code>order-details-validations'并将&lt;/code>order-details&amp;rsquo;的每个键的错误信息（如果有的话）关联到一个最终的错误信息 Map。&lt;/p>
&lt;h3 id="if-valid">if-valid&lt;/h3>
&lt;p>有了我们的验证代码，我们现在可以随心所欲地验证记录了。大多数情况下，验证会像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [errors (validate order-details order-details-validations)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if (empty? errors)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println :success)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println :failure errors)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>该模式是做以下工作。&lt;/p>
&lt;ol>
&lt;li>验证一条记录并将结果绑定到&lt;code>errors&lt;/code>。&lt;/li>
&lt;li>检查是否有任何错误&lt;/li>
&lt;li>3.如果有，做成功的事情，这里&lt;code>(println :success)&lt;/code>。&lt;/li>
&lt;li>否则，做失败的事情，这里&lt;code>(println :failure errors)&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>我已经在实际生产的网站中使用了这个验证代码。起初，我发现自己不断重复代码的微小变化，这无疑表明我需要引入一个抽象，以隐藏重复的部分：应用&lt;code>validate&lt;/code>函数，将结果绑定到一些符号，并检查结果是否为空。为了创建这种抽象，你可能会想写一个这样的函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn if-valid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [record validations success-code failure-code]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [errors (validate record validations)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if (empty? errors)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> success-code
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> failure-code)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然而，这不会起作用，因为&lt;code>success-code&lt;/code>和&lt;code>failure-code&lt;/code>每次都会被求值。宏会起作用，因为宏允许你控制求值。下面是你如何使用宏的方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(if-valid order-details order-details-validations errors
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (render :success)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (render :failure errors))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个宏隐藏了重复的细节，帮助你更简洁地表达你的意图。这就像要求别人给你开瓶器，而不是说：&amp;ldquo;请给我手动装置，用于去除玻璃容器中液体的临时密封剂。&amp;rdquo; 下面是实施方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmacro if-valid
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Handle validation more concisely&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [to-validate validations errors-name &amp;amp; then-else]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> `(let [~errors-name (validate ~to-validate ~validations)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if (empty? ~errors-name)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ~@then-else)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个宏需要四个参数。 &lt;code>to-validate&lt;/code>, &lt;code>validations&lt;/code>, &lt;code>errors-name&lt;/code>, 和其余参数&lt;code>then-else&lt;/code>. 像这样使用&lt;code>errors-name&lt;/code>是一个新的策略。我们想在&lt;code>then-else&lt;/code>语句中访问&lt;code>validate&lt;/code>函数返回的错误。要做到这一点，我们要告诉宏它应该把结果绑定到什么符号上。下面的宏扩展显示了它是如何工作的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> (macroexpand
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#39;(if-valid order-details order-details-validations my-error-name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println :success)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println :failure my-error-name)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(let*
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [my-error-name (user/validate order-details order-details-validations)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if (clojure.core/empty? my-error-name)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println :success)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println :failure my-error-name)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>语法引号抽象了你之前看到的&lt;code>let/validate/if&lt;/code>模式的一般形式。然后我们使用 unquote 拼接来解压&lt;code>if&lt;/code>分支，这些分支被打包到&lt;code>then-else&lt;/code>其余参数中。&lt;/p>
&lt;p>这真是太简单了! 说了这么多关于宏的内容，并详细介绍了它们的机制，我打赌你一定以为会有更复杂的东西。对不起，朋友。如果你对你的失望感到难以接受，我知道有一种饮料可以帮助你。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>在本章中，你学会了如何编写自己的宏。宏的定义与函数非常相似：它们有参数、文件串和主体。它们可以使用参数重构和休息参数，而且可以是递归的。你的宏几乎都会返回列表。你有时会使用&lt;code>list&lt;/code>和&lt;code>seq&lt;/code>函数来编写简单的宏，但大多数时候你会使用语法引号，，它让你使用安全模板来编写宏。&lt;/p>
&lt;p>当你编写宏时，重要的是要记住符号和值之间的区别：宏在代码被求值之前被展开，因此不能访问求值的结果。双重求值和变量捕获是另外两个微妙的陷阱，但你可以通过明智地使用 &amp;ldquo;let &amp;ldquo;表达式和代词来避免它们。&lt;/p>
&lt;p>宏是一种有趣的工具，可以让你在编码时少一些拘束。通过让你控制求值，宏给你一定程度的自由和表达，这是其他语言所不允许的。在你的 Clojure 旅程中，你可能会听到有人告诫你不要使用宏，说什么 &amp;ldquo;宏是邪恶的 &amp;ldquo;和 &amp;ldquo;你不应该使用宏&amp;rdquo;。不要听这些假正经的人的话&amp;ndash;至少在开始的时候不要听他们的。走出去，享受美好的时光。这是你学习在哪些情况下适合使用宏的唯一途径。你会从另一个角度知道如何有技巧地、潇洒地使用宏。&lt;/p>
&lt;h2 id="练习">练习&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>编写宏&lt;code>when-valid&lt;/code>，使它的行为与&lt;code>when&lt;/code>相似。下面是一个调用它的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(when-valid order-details order-details-validations
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(println &amp;#34;It&amp;#39;s a success!&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(render :success))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当数据有效时，应该求值&lt;code>println&lt;/code>和&lt;code>render&lt;/code>形式，如果数据无效，&lt;code>when-valid&lt;/code>应该返回&lt;code>nil&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你看到&lt;code>and&lt;/code>是作为一个宏实现的。把`or&amp;rsquo;作为一个宏来实现。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在第 5 章中，你创建了一系列函数（&lt;code>c-int&lt;/code>, &lt;code>c-str&lt;/code>, &lt;code>c-dex&lt;/code>）来读取一个 RPG 字符的属性。写一个宏，用一个宏调用来定义任意数量的属性检索函数。以下是你如何调用它。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>(defattrs c-int :intelligence
c-str :strength
c-dex :dexterity)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Chapter7 炼金术</title><link>https://example.com/p/chapter7-%E7%82%BC%E9%87%91%E6%9C%AF/</link><pubDate>Sat, 15 Jan 2022 12:14:36 +0800</pubDate><guid>https://example.com/p/chapter7-%E7%82%BC%E9%87%91%E6%9C%AF/</guid><description>&lt;h1 id="clojure-炼金术读取器求值器和宏">Clojure 炼金术：读取器、求值器和宏&lt;/h1>
&lt;p>哲学家之石，与生命之药和伟哥一样，是炼金术传说中最著名的标本之一，因其能将铅转化为金而受到追捧。然而，Clojure 提供了一种工具，使哲学家的石头看起来只是一个小饰品：*宏。&lt;/p>
&lt;p>宏允许你将任意的表达式转化为有效的 Clojure，因此你可以扩展语言本身以满足你的需求。而且，你甚至不需要是一个穿长袍的老家伙或老太太来使用它们&lt;/p>
&lt;p>为了获得这种能力，请考虑这个微不足道的宏。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmacro backwards
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [form]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (reverse form))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(backwards (&amp;#34; backwards&amp;#34; &amp;#34; am&amp;#34; &amp;#34;I&amp;#34; str))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;I am backwards&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>backwards&lt;/code>宏允许 Clojure 成功地 Eval 表达式&lt;code>(&amp;quot; backwards&amp;quot; &amp;quot; am&amp;quot; &amp;quot;I&amp;quot; str)&lt;/code>，尽管它没有遵循 Clojure 的内置语法规则，这些规则要求表达式的操作数首先出现（更不用说表达式不能按相反顺序书写的规则）。如果没有 &amp;ldquo;向后&amp;rdquo;，这个表达式会比几千年来的炼金术士用他们的一生来追求不可能实现的长生不老的方法更难失败。有了`向后&amp;rsquo;，*你就创造了你自己的语法！*你扩展了 Clojure，这样你就可以随心所欲地写代码了 我告诉你，这比把铅变成金子要好得多!&lt;/p>
&lt;p>本章为你提供了编写自己的宏所需的概念基础，使你能够疯狂地编写自己的宏。它解释了 Clojure 求值模型的元素：&lt;em>读取器&lt;/em>，&lt;em>求值器&lt;/em>，和&lt;em>宏扩展器&lt;/em>。这就像 Clojure 元素的周期表。想想周期表是如何揭示原子的特性的：同一列的元素行为相似，因为它们有相同的核电荷。如果没有元素周期表及其基础理论，我们就会像过去的炼金术士一样，随意地把东西混在一起，看看什么东西会爆炸。但是，随着对元素的深入了解，你可以看到为什么东西会爆炸，并学会如何有目的地炸毁东西。&lt;/p>
&lt;h2 id="a-overview-of-clojures-evaluation-model">A Overview of Clojure&amp;rsquo;s Evaluation Model&lt;/h2>
&lt;p>Clojure（像所有的 Lisps）有一个不同于大多数其他语言的求值模型：它有一个两阶段的系统，它&lt;em>读&lt;/em>文本源代码，产生 Clojure 数据结构。然后对这些数据结构进行*求值。Clojure 遍历数据结构，并根据数据结构的类型执行函数应用或 var 查找等操作。例如，当 Clojure 读取文本&lt;code>(+ 1 2)&lt;/code>时，结果是一个列表数据结构，其第一个元素是一个&lt;code>+&lt;/code>符号，后面是数字 1 和 2。这个数据结构被传递给 Clojure 的求值器，求值器查找&lt;code>+&lt;/code>对应的函数，并将该函数应用于 1 和 2。&lt;/p>
&lt;p>在源代码、数据和求值之间有这种关系的语言被称为&lt;em>homoiconic&lt;/em>（顺便说一句，如果你在浴室的镜子前熄灯说三次&lt;em>homoiconic&lt;/em>，约翰-麦卡锡的幽灵就会出现并给你一个小括号）。同源语言使你能够将你的代码作为一组数据结构进行推理，你可以通过程序进行操作。为了说明这一点，让我们在编译的土地上走一圈。&lt;/p>
&lt;p>编程语言需要一个编译器或解释器来将你写的代码（由 Unicode 字符组成）翻译成其他东西：机器指令、其他编程语言的代码，等等。在这个过程中，编译器会构建一个&lt;em>抽象语法树（AST）&lt;/em>，这是一个代表你的程序的数据结构。你可以把 AST 看作是&lt;em>求值器&lt;/em>的输入，你可以把它看作是一个遍历该树的函数，以产生机器代码或其他什么作为其输出。&lt;/p>
&lt;p>到目前为止，这听起来很像我为 Clojure 描述的那样。然而，在大多数语言中，AST 的数据结构在编程语言中是无法访问的；编程语言空间和编译器空间是永远分离的，两者永远不会相遇。图 7-1 显示了在非 Lisp 编程语言中表达式的编译过程的可视化情况。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/read-and-eval/non-lisp-eval.png"
loading="lazy"
>&lt;/p>
&lt;p>图 7-1：非 Lisp 编程语言的求值&lt;/p>
&lt;p>但 Clojure 是不同的，因为 Clojure 是 Lisp，而 Lisps 比偷来的 tamale 更热。Lisps 求值的是本地数据结构，而不是求值表示为某种无法访问的内部数据结构的 AST。Clojure 仍然求值树形结构，但树是用 Clojure 列表结构的，节点是 Clojure 值。&lt;/p>
&lt;p>列表是构建树形结构的理想选择。列表的第一个元素被视为根，每个后续元素被视为一个分支。要创建一个嵌套树，你可以直接使用嵌套列表，如图 7-2 所示。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/read-and-eval/trees.png"
loading="lazy"
>&lt;/p>
&lt;p>图 7-2：列表可以很容易地被当作树来处理。&lt;/p>
&lt;p>首先，Clojure 的&lt;em>读取器&lt;/em>将文本&lt;code>(+ 1 (* 6 7))&lt;/code>转换为一个嵌套列表。(你将在下一节了解更多关于读取器的信息。)然后，Clojure 的求值器将该数据作为输入并产生一个结果。(它还可以编译 Java 虚拟机（JVM）字节码，你会在第 12 章中了解到。现在，我们只关注概念层面上的求值模型）。&lt;/p>
&lt;p>考虑到这一点，图 7-3 显示了 Clojure 的求值过程是什么样的。&lt;/p>
&lt;p>S-表达式&lt;/p>
&lt;p>在你的 Lisp 冒险中，你会遇到一些资源，它们解释说 Lisp 求值 S-表达式。我在这里避免使用这个术语，因为它有歧义：你会看到它既指被求值的实际数据对象，也指表示该数据的源代码。对 Lisp 求值的两个不同组成部分（代码和数据）使用同一个术语，会掩盖重要的东西：你的文本代表了本地数据结构，而 Lisp 求值本地数据结构，这是独一无二的，令人敬畏的。关于 s-表达式的精彩处理，请查看&lt;a class="link" href="http://www.gigamonkeys.com/book/syntax-and-semantics.html" target="_blank" rel="noopener"
>http://www.gigamonkeys.com/book/syntax-and-semantics.html&lt;/a>。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/read-and-eval/lisp-eval.png"
loading="lazy"
>&lt;/p>
&lt;p>图 7-3：Clojure 中的求值&lt;/p>
&lt;p>然而，求值器实际上并不关心它的输入来自哪里；它不一定要来自读者。因此，你可以用&lt;code>eval&lt;/code>将你的程序的数据结构直接发送给 Clojure 求值器。看哪!&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def addition-list (list + 1 2))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(eval addition-list)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就对了，宝贝! 你的程序刚刚求值了一个 Clojure 列表。你很快就会读到关于 Clojure 求值规则的所有内容，但简单地说，这是发生了什么：当 Clojure 求值列表时，它查找了&lt;code>addition-list&lt;/code>所指的列表；然后它查找了与&lt;code>+&lt;/code>符号对应的函数；然后它用&lt;code>1&lt;/code>和&lt;code>2&lt;/code>作为参数调用了该函数，返回&lt;code>3&lt;/code>。你的运行程序的数据结构和求值器的数据结构生活在同一个空间，结果是你可以使用 Clojure 的全部力量和你写的所有代码来构建数据结构进行求值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(eval (concat addition-list [10]))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 13
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(eval (list &amp;#39;def &amp;#39;lucky-number (concat addition-list [10])))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #&amp;#39;user/lucky-number
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lucky-number
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 13
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>图 7-4 显示了你在这两个例子中发送给求值器的列表。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/read-and-eval/data-to-eval.png"
loading="lazy"
>&lt;/p>
&lt;p>图 7-4：你求值的列表&lt;/p>
&lt;p>你的程序可以直接与自己的求值器对话，使用自己的函数和数据在运行中修改自己 你是不是已经被权力冲昏了头脑？我希望是这样！我希望你能坚持你的理智。不过，请保持你的理智，因为还有更多的东西要学。&lt;/p>
&lt;p>所以，Clojure 是同源的：它用列表表示抽象的语法树，当你写 Clojure 代码时，你写的是列表的文本表示。因为你写的代码代表了你习惯于操作的数据结构，而求值器则消耗这些数据结构，所以很容易推理出如何以编程方式修改你的程序。&lt;/p>
&lt;p>宏就是让你轻松进行这些操作的东西。本章的其余部分详细介绍了 Clojure 的读取器和求值规则，让你对宏的工作原理有一个准确的理解。&lt;/p>
&lt;h2 id="读取器">读取器&lt;/h2>
&lt;p>读取器将你保存在文件中或在 REPL 中输入的文本源代码转换为 Clojure 数据结构。它就像人类的 Unicode 字符世界和 Clojure 的列表、Vector、Map、符号和其他数据结构世界之间的翻译。在本节中，你将直接与读取器器互动，并学习一个方便的功能，即&lt;em>读取器宏&lt;/em>，如何让你更简洁地编写代码。&lt;/p>
&lt;h3 id="读取器-1">读取器&lt;/h3>
&lt;p>为了理解读取器，让我们首先仔细看看 Clojure 是如何处理你在 REPL 中输入的文本的。首先，REPL 会提示你输入文本。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">user=&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后你输入一点文本。也许像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">user=&amp;gt; (str &amp;#34;To understand what recursion is,&amp;#34; &amp;#34; you must first understand recursion.&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段文字实际上只是一串 Unicode 字符，但它是为了表示 Clojure 数据结构的组合。这种数据结构的文本表示法被称为&lt;em>读取器的形式&lt;/em>。在这个例子中，该表格代表了一个列表数据结构，其中又包含了三个表格：&lt;code>str&lt;/code>符号和两个字符串。&lt;/p>
&lt;p>一旦你在提示符中输入这些字符并按下回车键，这些文本就会进入读取器（记得 REPL 是 read-eval-print-loop 的缩写）。Clojure 读取字符流并在内部产生相应的数据结构。然后它对数据结构进行求值，并打印出结果的文本表示。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">&amp;#34;To understand what recursion is, you must first understand recursion.&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>读取和求值是不连续的过程，你可以独立执行。一种直接与读者互动的方法是使用&lt;code>read-string&lt;/code>函数。 &lt;code>read-string&lt;/code>接收一个字符串作为参数，并使用 Clojure 的读取器进行处理，返回一个数据结构。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(read-string &amp;#34;(+ 1 2)&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (+ 1 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(list? (read-string &amp;#34;(+ 1 2)&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(conj (read-string &amp;#34;(+ 1 2)&amp;#34;) :zagglewag)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (:zagglewag + 1 2)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在第一个例子中，&lt;code>read-string&lt;/code>读取了一个包含加号和数字 1 和 2 的列表的字符串表示。返回值是一个实际的列表，正如第二个例子所证明的。最后一个例子使用&lt;code>conj&lt;/code>在列表中预置一个关键字。启示是，读取器和求值是相互独立的。你可以读取文本而不对其进行求值，你可以将结果传递给其他函数。如果你愿意，你也可以对结果进行求值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(eval (read-string &amp;#34;(+ 1 2)&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在到目前为止的所有例子中，读者形式和相应的数据结构之间一直是一对一的关系。下面是更多简单的读取器形式的例子，它们直接 Map 到它们所代表的数据结构。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>()&lt;/strong> 一个列表的读取形式&lt;/li>
&lt;li>*&lt;em>str&lt;/em> 一个符号读取器形式&lt;/li>
&lt;li>&lt;strong>[1 2]&lt;/strong> 一个 Vector 读取器形式，包含两个数字读取器形式&lt;/li>
&lt;li>&lt;strong>{:sound &amp;ldquo;hoot&amp;rdquo;}&lt;/strong> 一个包含关键字读取器形式和字符串读取器形式的 Map 读取器形式&lt;/li>
&lt;/ul>
&lt;p>然而，在将文本转换为数据结构时，读取器可以采用更复杂的行为。例如，还记得匿名函数吗？&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(#(+ 1 %) 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>好吧，试试这个。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(read-string &amp;#34;#(+ 1 %)&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (fn* [p1__423#] (+ 1 p1__423#))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>哇! 这不是我们所习惯的一对一的 Map。读取&lt;code>#(+ 1 %)&lt;/code>的结果是一个由&lt;code>fn*&lt;/code>符号组成的列表，一个包含一个符号的 Vector，和一个包含三个元素的列表。刚刚发生了什么？&lt;/p>
&lt;h3 id="读者宏">读者宏&lt;/h3>
&lt;p>我来回答我自己的问题：读者使用了一个&lt;em>读者宏&lt;/em>来转换&lt;code>#(+ 1 %)&lt;/code>。读者宏是一组将文本转换为数据结构的规则。它们通常允许你以更紧凑的方式表示数据结构，因为它们采用了一个简略的读者形式，并将其扩展为完整的形式。它们由&lt;em>宏字符&lt;/em>指定，如&lt;code>'&lt;/code>（单引号）、&lt;code>#&lt;/code>和&lt;code>@&lt;/code>。它们也完全不同于我们后面要讲的宏。为了不把两者混淆，我总是用&lt;em>读者宏&lt;/em>这个全称来指代读者宏。&lt;/p>
&lt;p>例如，你可以在这里看到引用读者宏是如何扩展单引号字符的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(read-string &amp;#34;&amp;#39;(a b c)&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (quote (a b c))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当读取器遇到单引号时，它将其扩展为一个列表，其第一个成员是符号&lt;code>quote&lt;/code>，第二个成员是单引号后面的数据结构。读取器的&lt;code>deref&lt;/code>宏对&lt;code>@&lt;/code>字符的作用与此类似。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(read-string &amp;#34;@var&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (clojure.core/deref var)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>读取器宏也可以做一些疯狂的事情，比如导致文本被忽略。分号指定了单行注释的读取器宏。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(read-string &amp;#34;; ignore!\n(+ 1 2)&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (+ 1 2)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就是读取器! 你卑微的伙伴，正在辛苦地将文本转化为数据结构。现在我们来看看 Clojure 是如何求值这些数据结构的。&lt;/p>
&lt;h2 id="求值器">求值器&lt;/h2>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/read-and-eval/simple-eval.png"
loading="lazy"
>&lt;/p>
&lt;p>图 7-5：（+ 1 2）的数据结构&lt;/p>
&lt;p>你可以把 Clojure 的求值器看作是一个函数，它接收一个数据结构作为参数，使用与数据结构类型相对应的规则处理该数据结构，并返回一个结果。要求值一个符号，Clojure 会查找该符号所指的内容。要求值一个列表，Clojure 会查看该列表的第一个元素，并调用一个函数、宏或特殊形式。任何其他的值（包括字符串、数字和关键字）只是简单地对其进行求值。&lt;/p>
&lt;p>例如，假设你在 REPL 中输入了&lt;code>(+ 1 2)&lt;/code>。图 7-5 显示了一个被发送到求值器的数据结构图。&lt;/p>
&lt;p>因为它是一个列表，求值器从求值列表中的第一个元素开始。第一个元素是加号，求值器通过返回相应的函数来解决这个问题。因为列表中的第一个元素是一个函数，所以求值器对每个操作数进行求值。操作数 1 和 2 求值为自己，因为它们不是列表或符号。然后求值器以 1 和 2 为操作数调用加法函数，并返回结果。&lt;/p>
&lt;p>本节的其余部分将更全面地解释求值器对每种数据结构的规则。为了显示求值器是如何工作的，我们将在 REPL 中运行每个例子。请记住，REPL 首先读取你的文本以获得一个数据结构，然后将该数据结构发送到求值器，然后将结果打印为文本。&lt;/p>
&lt;p>数据&lt;/p>
&lt;p>我在本章中写到 Clojure 如何求值数据结构，但这是不精确的。从技术上讲，数据结构指的是某种集合，如链接列表或 B-树，或其他什么，但我也用这个术语来指标量（单数，非集合）值，如符号和数字。我考虑过使用数据对象这个术语，但不想暗示面向对象的编程，或者只使用数据，但不想将其与数据这个概念混淆。所以，数据结构就是这样，如果你觉得这很冒犯，我会给你一千次的道歉，深思熟虑地组织成一棵 Van Emde Boas 树。&lt;/p>
&lt;h3 id="这些东西都是自己求值的">这些东西都是自己求值的&lt;/h3>
&lt;p>每当 Clojure 对不是列表或符号的数据结构进行求值时，其结果就是数据结构本身。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">false
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; false
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">{}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:huzzah
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; :huzzah
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>空的列表也会对自己进行求值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; ()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="符号">符号&lt;/h3>
&lt;p>作为一个程序员，你的基本任务之一是通过将名字和值联系起来来创建抽象。你在第 3 章中通过使用&lt;code>def&lt;/code>、&lt;code>let&lt;/code>和函数定义学会了如何做到这一点。Clojure 使用&lt;em>符号&lt;/em>来命名函数、宏、数据和其他任何你可以使用的东西，并通过&lt;em>解析&lt;/em>来求值它们。为了解析一个符号，Clojure 会遍历你所创建的任何绑定，然后在命名空间 Map 中查找该符号的条目，这一点你在第 6 章中了解过。最终，一个符号被解析为一个&lt;em>值&lt;/em>或一个&lt;em>特殊形式&lt;/em>&amp;ndash;一个内置的 Clojure 操作符，提供基本的行为。&lt;/p>
&lt;p>一般来说，Clojure 通过以下方式解析一个符号。&lt;/p>
&lt;ol>
&lt;li>查询该符号是否命名了一个特殊形式。如果它没有……。&lt;/li>
&lt;li>查询该符号是否对应于一个本地绑定。如果不是的话 .&lt;/li>
&lt;li>试图找到由&lt;code>def&lt;/code>引入的命名空间 Map。如果没有的话 . .&lt;/li>
&lt;li>抛出一个异常&lt;/li>
&lt;/ol>
&lt;p>让我们先看看一个符号解析到一个特殊形式。特殊形式，如&lt;code>if&lt;/code>，总是在一个操作的上下文中使用；它们总是一个列表中的第一个元素。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(if true :a :b)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; :a
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这种情况下，&lt;code>if&lt;/code>是一个特殊的形式，它被作为一个操作符使用。如果你试图引用这个上下文之外的特殊形式，你会得到一个异常。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">if
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; CompilerException java.lang.RuntimeException: Unable to resolve symbol: if in this context, compiling:(NO_SOURCE_PATH:0:0)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来，让我们求值一些本地绑定。本地绑定&lt;em>是指一个符号和一个不是由&lt;code>def&lt;/code>创建的值之间的任何关联。在下一个例子中，符号&lt;code>x&lt;/code>用&lt;code>let&lt;/code>与 5 绑定。当求值器解析&lt;code>x&lt;/code>时，它将&lt;/em>符号*&lt;code>x&lt;/code>解析为&lt;em>值&lt;/em> 5。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [x 5]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (+ x 3))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 8
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在，如果我们创建一个&lt;code>x&lt;/code>到 15 的命名空间 Map，Clojure 会相应地解决它。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def x 15)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(+ x 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 18
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在下一个例子中，&lt;code>x&lt;/code>被 Map 到 15，但是我们用&lt;code>let&lt;/code>引入了&lt;code>x&lt;/code>与 5 的局部绑定。所以&lt;code>x&lt;/code>被解析为 5。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def x 15)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(让 [x 5]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (+ x 3))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 8
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以对绑定进行嵌套，在这种情况下，最近定义的绑定具有优先权。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(让 [x 5]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (让 [x 6]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (+ x 3)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 9
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>函数还创建了局部绑定，将参数与函数体中的参数绑定。在下一个例子中，&lt;code>exclaim&lt;/code>被 Map 到一个函数。在函数主体中，参数名&lt;code>exclamation&lt;/code>被绑定到传递给函数的参数上。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn exclaim
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [exclamation]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str exclamation &amp;#34;!&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(exclaim &amp;#34;Hadoken&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Hadoken!&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后，在这最后一个例子中，&lt;code>map&lt;/code>和&lt;code>inc&lt;/code>都指的是函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(map inc [1 2 3])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (2 3 4)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当 Clojure 求值这段代码时，它首先求值&lt;code>map&lt;/code>符号，查找相应的函数并将其应用于参数。符号&lt;code>map&lt;/code>指的是 map 函数，但它不应该与函数本身相混淆。&lt;code>map&lt;/code>符号仍然是一个数据结构，就像字符串&lt;code>&amp;quot;fried salad&amp;quot;&lt;/code>是一个数据结构一样，但它与函数本身不同。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(read-string (&amp;#34;+&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; +
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(type (read-string &amp;#34;+&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; clojure.lang.Symbol
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(list (read-string &amp;#34;+&amp;#34;) 1 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (+ 1 2)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这些例子中，你正在与加号，&lt;code>+&lt;/code>，作为一个数据结构进行交互。你并没有与它所指的加法函数进行交互。如果你求值它，Clojure 会查找该函数并应用它。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(eval (list (read-string &amp;#34;+&amp;#34;) 1 2))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就其本身而言，符号和它们的参照物实际上不做任何事情；Clojure 通过求值列表执行工作。&lt;/p>
&lt;h3 id="列表">列表&lt;/h3>
&lt;p>如果数据结构是一个空列表，它就会被求值为一个空列表。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(eval (read-string &amp;#34;()&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; ()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>否则，它被求值为对列表中第一个元素的*调用。执行调用的方式取决于第一个元素的性质。&lt;/p>
&lt;h4 id="函数调用">函数调用&lt;/h4>
&lt;p>当执行一个函数调用时，每个操作数都被完全求值，然后作为参数传递给函数。在这个例子中，&lt;code>+&lt;/code>符号解析为一个函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(+ 1 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Clojure 看到列表的头部是一个函数，所以它继续求值列表中的其他元素。操作数 1 和 2 都对自己进行求值，在求值之后，Clojure 对它们应用加法函数。&lt;/p>
&lt;p>你也可以嵌套函数调用。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(+ 1 (+ 2 3))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 6
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>即使第二个参数是一个列表，Clojure 在这里也遵循同样的过程：查找&lt;code>+&lt;/code>符号并求值每个参数。为了求值列表&lt;code>(+ 2 3)&lt;/code>，Clojure 将第一个成员解析为加法函数并继续求值每个参数。通过这种方式，求值是递归的。&lt;/p>
&lt;h4 id="特殊形式">特殊形式&lt;/h4>
&lt;p>你也可以调用*特殊形式。*一般来说，特殊形式是特殊的，因为它们实现了不能用函数实现的核心行为。比如说&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(if true 1 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里，我们要求 Clojure 求值一个以符号&lt;code>if&lt;/code>开始的列表。这个&lt;code>if&lt;/code>符号被解析为&lt;code>if&lt;/code>特殊形式，Clojure 用操作数&lt;code>true&lt;/code>、&lt;code>1&lt;/code>和&lt;code>2&lt;/code>调用这个特殊形式。&lt;/p>
&lt;p>特殊形式不遵循与普通函数相同的求值规则。例如，当你调用一个函数时，每个操作数都被求值。然而，对于&lt;code>if&lt;/code>，你不希望每个操作数都被求值。你只希望某些操作数被求值，这取决于条件是真还是假。&lt;/p>
&lt;p>另一个重要的特殊形式是&lt;code>quote&lt;/code>。你已经见过这样的列表。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">&amp;#39;(a b c)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>正如你在&lt;a class="link" href="https://www.braveclojure.com/read-and-eval/#Anchor" target="_blank" rel="noopener"
>&amp;ldquo;读取器 &amp;ldquo;第 153 页&lt;/a>中所看到的，这将调用一个读取器宏，所以我们最终得到这样的结果。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(quote (a b c))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通常，Clojure 会尝试解析&lt;code>a&lt;/code>符号，然后调用它，因为它是一个列表中的第一个元素。&lt;code>quote&lt;/code>的特殊形式告诉求值器，&amp;ldquo;与其像正常一样求值我的下一个数据结构，不如直接返回数据结构本身。&amp;rdquo; 在这种情况下，你最终得到一个由符号&lt;code>a&lt;/code>, &lt;code>b&lt;/code>, 和&lt;code>c&lt;/code>组成的列表。&lt;/p>
&lt;p>&lt;code>def&lt;/code>、&lt;code>let&lt;/code>、&lt;code>loop&lt;/code>、&lt;code>fn&lt;/code>、&lt;code>do&lt;/code>和&lt;code>recur&lt;/code>也都是特殊形式。你可以看到为什么：它们的求值方式与函数不一样。例如，通常当求值器求值一个符号时，它会解析该符号，但是&lt;code>def&lt;/code>和&lt;code>let&lt;/code>显然不是这样的行为。它们不是解析符号，而是在符号和值之间建立关联。因此，求值器从读者那里接收到一个数据结构的组合，然后它去解析符号并调用每个列表开头的函数或特殊形式。但还有更多的东西! 你也可以在列表的开头放置一个&lt;em>宏&lt;/em>，而不是一个函数或特殊形式，这可以为你提供巨大的权力，让你知道其余的数据结构如何被求值。&lt;/p>
&lt;h3 id="巨集">巨集&lt;/h3>
&lt;p>嗯 . . Clojure 求值数据结构&amp;ndash;与我们在 Clojure 程序中编写和操作的数据结构相同。如果我们能用 Clojure 来操作 Clojure 求值的数据结构，那不是很好吗？是的，是的，会的。你猜怎么着？你可以用宏来做这件事。你的脑袋是不是爆炸了？我的就是这样。&lt;/p>
&lt;p>为了了解宏的作用，让我们看看一些代码。假设我们想写一个函数，让 Clojure 读出 infix 符号（如&lt;code>1 + 1&lt;/code>），而不是其正常符号中的运算符优先（&lt;code>+ 1 1&lt;/code>）。这个例子不是**一个宏。相反，它只是表明你可以用 infix 符号写代码，然后用 Clojure 来转换它，使其实际执行。首先，创建一个代表 infix 加法的列表。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(read-string &amp;#34;(1 + 1)&amp;#34; )
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (1 + 1)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果你试图让它求值这个列表，Clojure 将抛出一个异常。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(eval (read-string &amp;#34;(1 + 1)&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然而，&lt;code>read-string&lt;/code>返回一个列表，你可以用 Clojure 把这个列表重新组织成它&lt;em>可以&lt;/em>成功求值的东西。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [infix (read-string &amp;#34;(1 + 1)&amp;#34;)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (list (second infix) (first infix) (last infix)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (+ 1 1)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果你&lt;code>求值&lt;/code>这个，它返回&lt;code>2&lt;/code>，就像你所期望的那样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(eval
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [infix (read-string &amp;#34;(1 + 1)&amp;#34;)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (list (second infix) (first infix) (last infix))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这很酷，但它也很笨重。这就是宏的作用。宏给了你一个方便的方法，在 Clojure 求值列表之前对其进行操作。宏很像函数：它们接受参数并返回一个值，就像一个函数那样。它们在 Clojure 数据结构上工作，就像函数那样。它们的独特和强大之处在于它们与求值过程的配合。它们在读取器和求值器之间执行&amp;ndash;所以它们可以操作读取器吐出的数据结构，并在将其传递给求值器之前与这些数据结构进行转换。&lt;/p>
&lt;p>让我们看一个例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmacro ignore-last-operand
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [function-call]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (butlast function-call))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➊ (ignore-last-operand (+ 1 2 10))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">;; This will not print anything
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(ignore-last-operand (+ 1 2 (println &amp;#34;look at me!!!&amp;#34;)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在➊，宏 &amp;ldquo;ignore-last-operand &amp;ldquo;接收列表&amp;rdquo;(+ 1 2 10) &amp;ldquo;作为其参数，&lt;em>不是&lt;/em>值 &amp;ldquo;13&amp;rdquo;。这与函数调用有很大的不同，因为函数调用总是求值所有传入的参数，所以函数不可能接触到它的一个操作数并改变或忽略它。相比之下，当你调用一个宏时，操作数是&lt;em>不&lt;/em>被求值的。特别是，符号不被解析；它们被当作符号传递。列表也不被求值；也就是说，列表中的第一个元素不作为一个函数、特殊形式或宏被调用。相反，未求值的列表数据结构被传入。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/read-and-eval/whole-shebang.png"
loading="lazy"
>&lt;/p>
&lt;p>图 7-6: (infix (1 + 2)) 的完整求值过程&lt;/p>
&lt;p>另一个区别是，函数返回的数据结构是&lt;em>不&lt;/em>求值的，但是宏返回的数据结构是&lt;em>求值的。确定宏的返回值的过程被称为&lt;/em>宏扩展*，你可以使用函数&lt;code>macroexpand&lt;/code>来查看宏在求值数据结构之前返回什么数据结构。注意，你必须引用你传递给&lt;code>macroexpand&lt;/code>的形式。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(macroexpand &amp;#39;(ignore-last-operand (+ 1 2 10)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (+ 1 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(macroexpand &amp;#39;(ignore-last-operand (+ 1 2 (println &amp;#34;look at me!!!&amp;#34;))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (+ 1 2)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>正如你所看到的，这两种扩展的结果都是列表&lt;code>(+ 1 2)&lt;/code>。当这个列表被求值时，就像前面的例子一样，结果是&lt;code>3&lt;/code>。&lt;/p>
&lt;p>为了好玩，这里有一个做简单 infix 符号的宏。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defmacro infix
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [infixed]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (list (second infixed)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (first infixed)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (last infixed)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(infix (1 + 2))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>思考这整个过程的最好方法是想象在读取和求值之间的一个阶段：&lt;em>宏扩展&lt;/em>阶段。图 7-6 显示了如何将&lt;code>(infix (1 + 2))&lt;/code>的整个求值过程可视化。&lt;/p>
&lt;p>而这就是宏是如何融入求值过程的。但你为什么要这样做呢？原因是宏允许你将任意的数据结构，如&lt;code>(1 + 2)&lt;/code>转化为 Clojure 可以求值的结构，即&lt;code>(+ 1 2)&lt;/code>。这意味着&lt;em>你可以使用 Clojure 来扩展自己&lt;/em>，所以你可以随心所欲地编写程序。换句话说，宏能够实现&lt;em>句法抽象&lt;/em>。句法抽象可能听起来有点抽象（哈哈！），所以我们来探讨一下。&lt;/p>
&lt;h3 id="语法抽象和---宏">语法抽象和 -&amp;gt; 宏&lt;/h3>
&lt;p>通常，Clojure 代码由一堆嵌套的函数调用组成。例如，我在我的一个项目中使用了下面这个函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn read-resource
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Read a resource into a string&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [path]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (read-string (slurp (clojure.java.io/resource path))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>为了理解函数体，你必须找到最内部的形式，在本例中是&lt;code>(clojure.java.io/resource path)&lt;/code>，然后从右到左向外走，看每个函数的结果如何传递给另一个函数。这种从右到左的流程与非 Lisp 程序员所习惯的相反。当你习惯于用 Clojure 写作时，这种代码会越来越容易理解。但如果你想翻译 Clojure 代码，以便你能以更熟悉的、从左到右、从上到下的方式来阅读它，你可以使用内置的&lt;code>-&amp;gt;&lt;/code>宏，它也被称为&lt;em>threading&lt;/em>或&lt;em>stabby&lt;/em>宏。它可以让你像这样重写前面的函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn read-resource
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [path]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (-&amp;gt; path
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> clojure.java.io/resource
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> slurp
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> read-string))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以把这理解为一个从上到下的流水线，而不是从内括号到外括号。首先，&lt;code>path&lt;/code>被传递给&lt;code>io/&lt;/code>resource&lt;code>，然后结果被传递给&lt;/code>slurp&lt;code>，最后结果被传递给&lt;/code>read-string`。&lt;/p>
&lt;p>这两种定义 &amp;ldquo;read-resource &amp;ldquo;的方式是完全等价的。然而，第二种方式可能更容易理解，因为我们可以从上到下接近它，一个我们习惯的方向。&lt;code>-&amp;gt;&lt;/code>也让我们省略了括号，这意味着有更少的视觉噪音需要处理。这是一个&lt;em>句法抽象&lt;/em>，因为它可以让你用一种不同于 Clojure 内置语法的语法来写代码，但对于人类的消费来说是比较好的。胜过点石成金!!!&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>在本章中，你了解了 Clojure 的求值过程。首先，读取器将文本转换为 Clojure 数据结构。接下来，宏扩展器用宏来转换这些数据结构，将你的自定义语法转换为语法上有效的数据结构。最后，这些数据结构被发送到求值器。求值器根据数据结构的类型对其进行处理：符号被解析为它们的参照物；列表导致函数、宏或特殊形式的调用；其他一切都被求值为自身。&lt;/p>
&lt;p>这个过程最酷的地方是，它允许你使用 Clojure 来扩展它自己的语法。这个过程变得更加容易，因为 Clojure 是同源的：它的文本代表数据结构，而这些数据结构代表抽象的语法树，让你更容易推理出如何构建扩展语法的宏。&lt;/p>
&lt;p>有了所有这些新的概念，你现在就可以像我承诺的那样，故意炸毁东西了。下一章将教你关于编写宏的一切知识。请抓紧你的袜子，否则它们很可能会被打掉!&lt;/p>
&lt;h2 id="练习">练习&lt;/h2>
&lt;p>这些练习的重点是读取器和求值。第 8 章有关于编写宏的练习。&lt;/p>
&lt;ol>
&lt;li>使用&lt;code>list&lt;/code>函数, 引用, 和&lt;code>read-string&lt;/code>来创建一个列表, 当求值时, 打印出你的名字和你最喜欢的科幻电影.&lt;/li>
&lt;li>创建一个 infix 函数，该函数接收一个类似&lt;code>(1 + 3 * 4 - 5)&lt;/code>的列表，并将其转换为 Clojure 需要的列表，以便使用运算符优先规则正确求值该表达式。&lt;/li>
&lt;/ol></description></item><item><title>Chapter6 组织你的项目</title><link>https://example.com/p/chapter6-%E7%BB%84%E7%BB%87%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE/</link><pubDate>Fri, 14 Jan 2022 12:40:41 +0800</pubDate><guid>https://example.com/p/chapter6-%E7%BB%84%E7%BB%87%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE/</guid><description>&lt;h1 id="组织你的项目一个图书管理员的故事">组织你的项目：一个图书管理员的故事&lt;/h1>
&lt;p>在我们每个人心中都住着一个叫 Melvil 的图书管理员，一个以组织艺术为乐的奇异生物。日日夜夜，Melvil 都渴望为你的代码库带来秩序。幸运的是，Clojure 提供了一套工具，专门用来帮助这个侏儒与混乱的力量不断斗争。&lt;/p>
&lt;p>这些工具通过将相关的函数和数据分组来帮助你组织你的代码。它们还可以防止名称冲突，这样你就不会意外地覆盖别人的代码，反之亦然。在这个充满悬念和神秘的故事中，请和我一起学习如何使用这些工具，并解决一生中的抢劫案吧 在这个传奇故事的最后，你将了解以下内容。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>`def&amp;rsquo;是做什么的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>什么是命名空间以及如何使用它们&lt;/p>
&lt;/li>
&lt;li>
&lt;p>命名空间和文件系统之间的关系&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如何使用&lt;code>refer&lt;/code>、&lt;code>alias&lt;/code>、&lt;code>require&lt;/code>、&lt;code>use&lt;/code>和&lt;code>ns&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如何使用文件系统来组织 Clojure 项目&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>我先来介绍一下 Clojure 的组织系统，它的工作原理很像一个库。Melvil 兴奋地颤抖着!&lt;/p>
&lt;h2 id="你的项目是一个库">你的项目是一个库&lt;/h2>
&lt;p>现实世界中的图书馆存储对象的集合，如书籍、杂志和 DVD。他们使用寻址系统，所以当你得到一个物体的地址时，你可以导航到物理空间并检索到该物体。&lt;/p>
&lt;p>当然，没有人能够直接知道一本书或 DVD 的地址是什么。这就是为什么图书馆要记录一个物体的标题和它的地址之间的联系，并提供工具来搜索这些记录。在计算机之前的旧时代，图书馆提供卡片目录，即装满纸质卡片的柜子，其中包含每本书的标题、作者、&amp;ldquo;地址&amp;rdquo;（杜威十进制或国会图书馆编号）和其他信息。&lt;/p>
&lt;p>例如，要找到《达芬奇密码》，你可以翻阅书名目录（按书名排序的卡片），直到你找到正确的卡片。在那张卡片上，你会看到地址&lt;em>813.54&lt;/em>（如果它使用杜威十进制系统），浏览图书馆，找到&lt;em>达芬奇密码&lt;/em>所在的书架，并参与你一生中的文学和/或仇恨阅读冒险。&lt;/p>
&lt;p>在 Clojure 中想象一个类似的设置是很有用的。我认为 Clojure 是将对象（如数据结构和函数）存储在一组巨大的编号架上。没有人能够直接知道一个对象被存储在哪个架子上。相反，我们给 Clojure 一个标识符，它用来检索该对象。&lt;/p>
&lt;p>为了使之成功，Clojure 必须维护我们的标识符和货架地址之间的关联。它通过使用&lt;em>namespaces&lt;/em>来做到这一点。命名空间包含了人类友好的&lt;em>符号&lt;/em>和书架地址的引用之间的 Map，被称为&lt;em>vars&lt;/em>，很像卡片目录。&lt;/p>
&lt;p>从技术上讲，命名空间是 &amp;ldquo;clojure.lang.Namespace &amp;ldquo;类型的对象，你可以与它们互动，就像你可以与 Clojure 数据结构互动一样。例如，你可以用&lt;code>*ns*&lt;/code>来引用当前的命名空间，你可以用&lt;code>(ns-name *ns*)&lt;/code>来获得其名称。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns-name *ns*)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; user
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>例如，当你启动 REPL 时，你在&lt;code>user&lt;/code>命名空间中（正如你在这里看到的）。提示符显示当前名称空间，使用&lt;code>user=&amp;gt;&lt;/code>。&lt;/p>
&lt;p>当前名字空间的概念意味着你可以有多个名字空间，事实上 Clojure 允许你创建任意多的名字空间（尽管从技术上讲，你可以创建的名字数量可能有一个上限）。在 Clojure 程序中，你总是&lt;em>在&lt;/em>个命名空间中。&lt;/p>
&lt;p>至于符号，你一直在使用它们，甚至没有意识到。例如，当你写&lt;code>(map inc [1 2])&lt;/code>时，&lt;code>map&lt;/code>和&lt;code>inc&lt;/code>都是符号。符号是 Clojure 中的数据类型，我将在下一章中彻底解释它们。现在，你需要知道的是，当你给 Clojure 一个像&lt;code>map&lt;/code>这样的符号时，它会在当前命名空间中找到相应的 var，得到一个架子上的地址，并为你从那个架子上检索一个对象&amp;ndash;在这里，就是&lt;code>map&lt;/code>所指的那个函数。如果你想只使用符号本身，而不是它所指的东西，你必须引用它。引述任何 Clojure 的形式告诉 Clojure 不要求值它，而是把它当作数据。接下来的几个例子显示了当你引用一个 Form 时会发生什么。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">➊ inc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #&amp;lt;core$inc clojure.core$inc@30132014&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➋ &amp;#39;inc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; inc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➌ (map inc [1 2])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (2 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➍ &amp;#39;(map inc [1 2])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (map inc [1 2])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当你在 REPL 中求值 &lt;code>inc&lt;/code> 在 ➊ 处时，它会打印出 &lt;code>inc&lt;/code> 所指的函数的文本表述。接下来，你在➋引用&lt;code>inc&lt;/code>，所以结果是符号&lt;code>inc&lt;/code>。然后，你在➌处求值一个熟悉的&lt;code>map&lt;/code>应用程序，得到一个熟悉的结果。之后，你在➍处引用整个列表数据结构，结果是一个未求值的列表，包括&lt;code>map&lt;/code>符号、&lt;code>inc&lt;/code>符号和一个 Vector。&lt;/p>
&lt;p>现在你知道了 Clojure 的组织系统，让我们来看看如何使用它。&lt;/p>
&lt;h2 id="用-def-存储对象">用 def 存储对象&lt;/h2>
&lt;p>Clojure 中用于存储对象的主要工具是&lt;code>def&lt;/code>。其他的工具，如&lt;code>defn&lt;/code>，都是使用&lt;code>def&lt;/code>。下面是一个 def 的应用实例。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def great-books [&amp;#34;East of Eden&amp;#34; &amp;#34;The Glass Bead Game&amp;#34;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #&amp;#39;user/great-books
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">great-books
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [&amp;#34;East of Eden&amp;#34; &amp;#34;The Glass Bead Game&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段代码告诉 Clojure。&lt;/p>
&lt;ol>
&lt;li>用&lt;code>great-books&lt;/code>和 var 之间的关联更新当前命名空间的 Map。&lt;/li>
&lt;li>找到一个空闲的存储架。&lt;/li>
&lt;li>将&lt;code>[《伊甸园之东》《玻璃珠游戏》]&lt;/code>存放在架子上。&lt;/li>
&lt;li>将书架的地址写在 var 上。&lt;/li>
&lt;li>5.返回 var（在这个例子中，`#&amp;lsquo;user/great-books&amp;rsquo;）。&lt;/li>
&lt;/ol>
&lt;p>这个过程被称为&lt;em>interning&lt;/em>一个 var。 你可以使用`ns-interns&amp;rsquo;与命名空间的符号到内含变量的 Map 进行交互。下面是你如何获得一个内部变量的 Map。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns-interns *ns*)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {great-books #&amp;#39;user/great-books}.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以使用`get&amp;rsquo;函数来获取一个特定的 var。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(get (ns-interns *ns*) &amp;#39; great-books)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #&amp;#39;user/great-books
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通过求值&lt;code>(&lt;/code>ns-map &lt;em>ns&lt;/em>)&lt;code>,&lt;/code>你也可以得到命名空间在给定一个符号时用来查找 var 的完整 Map。&lt;code>(ns-map *ns*)&lt;/code>给你一个非常大的 Map，我不会在这里打印，但可以试试&lt;/p>
&lt;p>&lt;code>#'user/great-books'是var的*读者形式。 我将在第七章解释更多关于读者形式。现在，只需知道你可以使用&lt;/code>#&amp;lsquo;&amp;lsquo;来抓取与后面的符号对应的 var；&lt;code>#'user/great-books'让你在&lt;/code>user&amp;rsquo;命名空间中使用与符号&lt;code>great-books'相关的var。我们可以&lt;/code>deref&amp;rsquo;变量来获得它们所指向的对象。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(deref #&amp;#39;user/great-books)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [&amp;#34;East of Eden&amp;#34; &amp;#34;The Glass Bead Game&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就像告诉 Clojure，&amp;ldquo;从 var 中获取书架号，去那个书架号，抓住上面的东西，然后给我！&amp;rdquo;&lt;/p>
&lt;p>但是通常情况下，你只需要使用符号。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">great-books
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [&amp;#34;East of Eden&amp;#34; &amp;#34;The Glass Bead Game&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就像告诉 Clojure，&amp;ldquo;检索与 great-books 相关的 var，然后取消那个坏的杰克逊&amp;rdquo;。&lt;/p>
&lt;p>到目前为止还不错，对吗？好吧，请做好准备，因为这个田园诗般的组织天堂即将被颠覆 用同样的符号再次调用&lt;code>def&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def great-books [&amp;#34;The Power of Bees&amp;#34; &amp;#34;Journey to Upstairs&amp;#34;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">great-books
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [&amp;#34;The Power of Bees&amp;#34; &amp;#34;Journey to Upstairs&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/organization/bee-power.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>var 已经更新了新的 Vector 的地址。这就像你在卡片目录中的卡片上的地址用了白笔，然后写了一个新地址。其结果是，你不能再要求 Clojure 找到第一个 Vector。这被称为&lt;em>名称碰撞&lt;/em>。混乱! 无政府状态!&lt;/p>
&lt;p>你可能在其他编程语言中经历过这种情况。JavaScript 在这方面是臭名昭著的，它也发生在 Ruby 中。这是个问题，因为你可能无意中覆盖了你自己的代码，而且你也不能保证第三方库不会覆盖你的代码。Melvil 惊恐地退缩了! 幸运的是，Clojure 允许你创建任意多的命名空间，这样你就可以避免这些碰撞。&lt;/p>
&lt;h2 id="创建和切换到命名空间">创建和切换到命名空间&lt;/h2>
&lt;p>Clojure 有三种创建命名空间的工具：函数&lt;code>create-ns&lt;/code>，函数&lt;code>in-ns&lt;/code>，以及宏&lt;code>ns&lt;/code>。你将在你的 Clojure 文件中主要使用&lt;code>ns&lt;/code>宏，但我将推迟几页来解释它，因为它结合了许多工具，而且在我讨论其他工具之后，它更容易理解。&lt;/p>
&lt;p>&lt;code>create-ns&lt;/code>接收一个符号，如果它不存在，就用这个名字创建一个命名空间，并返回这个命名空间。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">user=&amp;gt; (create-ns &amp;#39;cheese.taxonomy)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #&amp;lt;Namespace cheese.taxonomy&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以使用返回的名字空间作为函数调用的参数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">user=&amp;gt; (ns-name (create-ns &amp;#39;cheese.taxonomy))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; cheese-taxonomy
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在实践中，你可能永远不会在你的代码中使用&lt;code>create-ns&lt;/code>，因为创建一个命名空间而不移入它并不是非常有用。使用&lt;code>in-ns&lt;/code>更常见，因为如果命名空间不存在，它会创建命名空间，并**切换到它，如清单 6-1 所示。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">user=&amp;gt; (in-ns &amp;#39;cheese.analysis)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #&amp;lt;Namespace cheese.analysis&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>6-1. 使用 in-ns 创建一个命名空间并切换到该空间&lt;/li>
&lt;/ol>
&lt;p>注意你的 REPL 提示符现在是&lt;code>cheese.analysis&amp;gt;&lt;/code>，表明你确实在你刚刚创建的新命名空间中。现在当你使用&lt;code>def&lt;/code>时，它将在&lt;code>cheese.analysis&lt;/code>命名空间中存储命名对象。&lt;/p>
&lt;p>但是如果你想使用其他命名空间的函数和数据怎么办？要做到这一点，你可以使用一个&lt;em>完全合格的&lt;/em>符号。一般的形式是 namespace&lt;code>/&lt;/code>name。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; (in-ns &amp;#39;cheese.taxonomy)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cheese.taxonomy=&amp;gt; (def cheddars [&amp;#34;mild&amp;#34; &amp;#34;medium&amp;#34; &amp;#34;strong&amp;#34; &amp;#34;sharp&amp;#34; &amp;#34;extra sharp&amp;#34;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cheese.taxonomy=&amp;gt; (in-ns &amp;#39;cheese.analysis)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; cheddars
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Exception: Unable to resolve symbol: cheddars in this context
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这创建了一个新的命名空间，&lt;code>cheese.taxonomy&lt;/code>，在该命名空间中定义了&lt;code>cheddars&lt;/code>，然后切换回&lt;code>cheese.analysis&lt;/code>命名空间。如果你试图在&lt;code>cheese.analysis&lt;/code>中引用&lt;code>cheese.taxonomy&lt;/code>命名空间的&lt;code>cheddars&lt;/code>，你会得到一个异常，但是使用完全合格的符号可以。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; cheese.taxonomy/cheddars
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [&amp;#34;mild&amp;#34; &amp;#34;medium&amp;#34; &amp;#34;strong&amp;#34; &amp;#34;sharp&amp;#34; &amp;#34;extra sharp&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>输入这些完全合格的符号很快就会成为一种困扰。 比如说，我是一个极不耐烦的学者，专门研究符号学-au-fromage，或者研究与奶酪有关的符号。&lt;/p>
&lt;p>突然间，可能发生的最糟糕的事情发生了！在全世界范围内，神圣的和有可能发生的事情都发生了。在世界各地，神圣的、具有历史意义的奶酪都失踪了。威斯康星州的标准切达干酪：不见了! 图坦卡蒙的大奶酪罐：被偷了! 都灵奶酪：被骗取的奶酪所取代! 这有可能使世界因某种原因而陷入完全的混乱! 自然，作为一个杰出的奶酪研究者，我有责任解开这个谜团。与此同时，我正被光明会、共济会和足部族追捕！因为我是一名学者，所以我必须为他们提供帮助。&lt;/p>
&lt;p>因为我是一个学者，我试图用我知道的最好的方式来解决这个谜团&amp;ndash;去图书馆研究这个狗屎。我可靠的助手 Clojure 陪着我。当我们从一个名字空间到另一个名字空间忙忙碌碌时，我喊着让 Clojure 把一个又一个东西交给我。&lt;/p>
&lt;p>但 Clojure 有点笨，很难弄清楚我指的是什么。在&lt;code>user&lt;/code>命名空间中，我大声说：&amp;quot;&lt;code>join&lt;/code>! 给我&lt;code>join'！&amp;quot;--我嘴里的唾沫星子飞了出来。&amp;quot;&lt;/code>RuntimeException: Unable to resolve symbol: join&lt;code>,&amp;quot; Clojure抱怨着回应。&amp;quot;看在布里的份上，把&lt;/code>clojure.string/join`交给我吧！&amp;rdquo; 我反驳道，Clojure 尽职尽责地把我要找的函数交给我。&lt;/p>
&lt;p>我的声音变得沙哑了。我需要一些方法来告诉 Clojure 要给我什么对象，而不必每次都使用完全合格的符号。&lt;/p>
&lt;p>幸运的是，Clojure 提供了 &amp;ldquo;refer &amp;ldquo;和 &amp;ldquo;alias &amp;ldquo;工具，让我可以更简洁地对它吼叫。&lt;/p>
&lt;h3 id="引用">引用&lt;/h3>
&lt;p>&lt;code>refer&lt;/code>使你能够精细地控制你如何引用其他命名空间的对象。启动一个新的 REPL 会话并尝试以下操作。请记住，在 REPL 中这样玩命名空间是可以的，但你不希望你的 Clojure 文件看起来像这样；正确的文件结构方式在&lt;a class="link" href="https://www.braveclojure.com/organization/#Anchor" target="_blank" rel="noopener"
>&amp;ldquo;真正的项目组织 &amp;ldquo;第 133 页&lt;/a>中涉及。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">user=&amp;gt; (in-ns &amp;#39;cheese.taxonomy)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cheese.taxonomy=&amp;gt; (def cheddars [&amp;#34;mild&amp;#34; &amp;#34;medium&amp;#34; &amp;#34;strong&amp;#34; &amp;#34;sharp&amp;#34; &amp;#34;extra sharp&amp;#34;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cheese.taxonomy=&amp;gt; (def bries [&amp;#34;Wisconsin&amp;#34; &amp;#34;Somerset&amp;#34; &amp;#34;Brie de Meaux&amp;#34; &amp;#34;Brie de Melun&amp;#34;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cheese.taxonomy=&amp;gt; (in-ns &amp;#39;cheese.analysis)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; (clojure.core/refer &amp;#39;cheese.taxonomy)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; bries
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [&amp;#34;Wisconsin&amp;#34; &amp;#34;Somerset&amp;#34; &amp;#34;Brie de Meaux&amp;#34; &amp;#34;Brie de Melun&amp;#34;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; cheddars
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [&amp;#34;mild&amp;#34; &amp;#34;medium&amp;#34; &amp;#34;strong&amp;#34; &amp;#34;sharp&amp;#34; &amp;#34;extra sharp&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段代码创建了一个 &amp;ldquo;cheese.taxonomy &amp;ldquo;命名空间和其中的两个 Vector。 &lt;code>cheddars&lt;/code>和&lt;code>bries&lt;/code>。然后它创建并移动到一个新的命名空间，称为&lt;code>cheese.analysis&lt;/code>。用命名空间的符号调用&lt;code>refer&lt;/code>可以让你引用相应的命名空间的对象，而不需要使用完全限定的符号。它通过更新当前命名空间的符号/对象 Map 来实现这一目的。你可以看到像这样的新条目。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; (clojure.core/get (clojure.core/ns-map clojure.core/*ns*) &amp;#39;bries)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #&amp;#39;cheese.taxonomy/bries
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; (clojure.core/get (clojure.core/ns-map clojure.core/*ns*) &amp;#39;cheddars)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #&amp;#39;cheese.taxonomy/cheddars
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就好像 Clojure&lt;/p>
&lt;ol>
&lt;li>在&lt;code>cheese.taxonomy&lt;/code>命名空间上调用&lt;code>ns-interns&lt;/code>。&lt;/li>
&lt;li>将其与当前命名空间的&lt;code>ns-map&lt;/code>合并。&lt;/li>
&lt;li>将结果作为当前命名空间的新的`ns-map&amp;rsquo;。&lt;/li>
&lt;/ol>
&lt;p>当你调用&lt;code>refer&lt;/code>时，你也可以把过滤器&lt;code>:only&lt;/code>, &lt;code>:exclude&lt;/code>, 和&lt;code>:rename&lt;/code>传递给它。正如名字所暗示的，&lt;code>:only&lt;/code>和&lt;code>:exclude&lt;/code>限制了哪些符号/变量 Map 被合并到当前命名空间的&lt;code>ns-map&lt;/code>。 &lt;code>:rename&lt;/code>允许你使用不同的符号来表示被合并的变量。如果我们将前面的例子修改为使用&lt;code>:only&lt;/code>，会发生以下情况。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; (clojure.core/refer &amp;#39;cheese.taxonomy :only [&amp;#39;bries])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; bries
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [&amp;#34;Wisconsin&amp;#34; &amp;#34;Somerset&amp;#34; &amp;#34;Brie de Meaux&amp;#34; &amp;#34;Brie de Melun&amp;#34;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; cheddars
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; RuntimeException: 无法解决符号：cheddars
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下面是&lt;code>:exclude&lt;/code>的操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; (clojure.core/refer &amp;#39;cheese.taxonomy :only [&amp;#39;bries])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; bries
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [&amp;#34;Wisconsin&amp;#34; &amp;#34;Somerset&amp;#34; &amp;#34;Brie de Meaux&amp;#34; &amp;#34;Brie de Melun&amp;#34;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; cheddars
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; RuntimeException: Unable to resolve symbol: cheddars
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后，一个&lt;code>:rename&lt;/code>的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; (clojure.core/refer &amp;#39;cheese.taxonomy :rename {&amp;#39;bries &amp;#39;yummy-bries})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; bries
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; RuntimeException: Unable to resolve symbol: bries
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; yummy-bries
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [&amp;#34;Wisconsin&amp;#34; &amp;#34;Somerset&amp;#34; &amp;#34;Brie de Meaux&amp;#34; &amp;#34;Brie de Melun&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，在这些最后的例子中，我们必须使用&lt;code>clojure.core&lt;/code>中所有对象的完全合格名称，如&lt;code>clojure.core/ns-map&lt;/code>和&lt;code>clojure.core/refer&lt;/code>。我们不需要在&lt;code>user&lt;/code>命名空间中这样做。这是因为 REPL 在&lt;code>user&lt;/code>命名空间中自动引用&lt;code>clojure.core&lt;/code>。当你创建一个新的命名空间时，你可以通过求值&lt;code>(clojure.core/refer-clojure)&lt;/code>来简化你的生活；这将引用 clojure.core 命名空间，从现在起我将使用它。在例子中你不会看到&lt;code>clojure.core/refer&lt;/code>，而只会看到&lt;code>refer&lt;/code>。&lt;/p>
&lt;p>另一件需要注意的事情是，你可以完全自由地组织你的函数和数据，跨越命名空间。这让你可以合理地将相关的函数和数据归入同一命名空间。&lt;/p>
&lt;p>有时你可能希望一个函数只对同一命名空间内的其他函数有效。Clojure 允许你使用&lt;code>defn-&lt;/code>来定义&lt;em>私有&lt;/em>的函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(in-ns &amp;#39;cheese.analysis)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">;; Notice the dash after &amp;#34;defn&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn- private-function
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Just an example function that does nothing&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果你试图从其他命名空间调用这个函数或引用它，Clojure 将抛出一个异常。你可以在求值➊和➋的代码时看到这一点。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; (in-ns &amp;#39;cheese.taxonomy)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cheese.taxonomy=&amp;gt; (clojure.core/refer-clojure)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➊ cheese.taxonomy=&amp;gt; (cheese.analysis/private-function)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➋ cheese.taxonomy=&amp;gt; (refer &amp;#39;cheese.analysis :only [&amp;#39;private-function])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>正如你所看到的，即使你明确地 &amp;ldquo;引用 &amp;ldquo;这个函数，你也不能使用其他命名空间的函数，因为你把它变成了私有的。(如果你想狡猾一点，你仍然可以使用神秘的语法`@#&amp;lsquo;some/private-var&amp;rsquo;来访问私有变量，但你很少想这样做)。&lt;/p>
&lt;h3 id="alias">alias&lt;/h3>
&lt;p>与&lt;code>refer&lt;/code>相比，&lt;code>alias&lt;/code>相对简单。它所做的只是让你缩短一个命名空间的名称，以便使用完全合格的符号。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; (clojure.core/alias &amp;#39;taxonomy &amp;#39;cheese.taxonomy)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cheese.analysis=&amp;gt; taxonomy/bries
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [&amp;#34;Wisconsin&amp;#34; &amp;#34;Somerset&amp;#34; &amp;#34;Brie de Meaux&amp;#34; &amp;#34;Brie de Melun&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段代码让我们使用来自&lt;code>cheese.taxonomy&lt;/code>命名空间的调用符号，并使用较短的别名&lt;code>taxonomy&lt;/code>。&lt;/p>
&lt;p>&lt;code>refer&lt;/code>和&lt;code>alias&lt;/code>是你引用当前命名空间以外的对象的两个基本工具! 它们是 REPL 开发的好帮手。&lt;/p>
&lt;p>然而，你不可能在 REPL 中创建整个程序。在下一节中，我将介绍你需要知道的一切，以组织一个真正的项目，使源代码在文件系统中生存。&lt;/p>
&lt;h2 id="真正的项目组织">真正的项目组织&lt;/h2>
&lt;p>现在我已经介绍了 Clojure 组织系统的构建模块，我将向你展示如何在实际项目中使用它们。我将讨论文件路径和命名空间名称之间的关系，解释如何用&lt;code>require&lt;/code>和&lt;code>use&lt;/code>加载文件，并展示如何使用&lt;code>ns&lt;/code>来设置一个命名空间。&lt;/p>
&lt;h3 id="文件路径和命名空间名称之间的关系">文件路径和命名空间名称之间的关系&lt;/h3>
&lt;p>为了一石二鸟（或者用一颗种子喂养两只鸟，这取决于你是多么的嬉皮士），我将介绍更多关于命名空间的内容，同时我们将通过绘制国际奶酪大盗的抢劫地点来抓捕这个讨厌的大盗。运行以下程序。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">lein new app the-divine-cheese-code
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这应该创建一个目录结构，看起来像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">| .gitignore
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| doc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| | intro.md
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| project.clj
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| README.md
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| resources
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| src
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| | the_divine_cheese_code
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| | | core.clj
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| test
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| | the_divine_cheese_code
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| | | core_test.clj
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在，打开&lt;em>src/the_divine_cheese_code/core.clj&lt;/em>。你应该在第一行看到这个。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns the-divine-cheese-code.core
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (:gen-class))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>ns&lt;/code>是在 Clojure 中创建和管理命名空间的主要方式。我很快就会对它进行全面的解释。不过现在，只需知道这一行与我们在清单 6-1 中使用的&lt;code>in-ns&lt;/code>函数非常相似。如果一个命名空间不存在，它就创建一个命名空间，然后切换到它。我在第 12 章也详细介绍了&lt;code>(:gen-class)&lt;/code>。&lt;/p>
&lt;p>命名空间的名字是&lt;code>the-divine-cheese-code.core&lt;/code>。在 Clojure 中，命名空间的名称和声明命名空间的文件路径之间有一个一对一的 Map，根据以下约定。&lt;/p>
&lt;ul>
&lt;li>当你用&lt;code>lein&lt;/code>创建一个目录时（就像你在这里做的那样），源代码的根默认为&lt;em>src&lt;/em>。&lt;/li>
&lt;li>名称空间中的破折号对应于文件系统中的下划线。所以&lt;code>the-divine-cheese-code&lt;/code>在文件系统中被 Map 为&lt;em>the_divine_cheese_code&lt;/em>。&lt;/li>
&lt;li>命名空间名称中的句号（&lt;code>.&lt;/code>）前面的成分对应于一个目录。例如，由于&lt;code>the-divine-cheese-code.core&lt;/code>是命名空间的名称，&lt;em>the_divine_cheese_code&lt;/em>是一个目录。&lt;/li>
&lt;li>命名空间的最后一个组成部分对应于扩展名为*.clj&lt;em>的文件；&lt;code>core&lt;/code>被 Map 到&lt;/em>core.clj*。&lt;/li>
&lt;/ul>
&lt;p>你的项目将有一个命名空间，&lt;code>the-divine-cheese-code.visualization.svg&lt;/code>。现在继续为它创建文件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">mkdir src/the_divine_cheese_code/visualization
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">touch src/the_divine_cheese_code/visualization/svg.clj
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，文件系统的路径遵循这些惯例。有了命名空间和文件系统之间的关系，我们来看看&lt;code>require&lt;/code>和&lt;code>use&lt;/code>。&lt;/p>
&lt;h3 id="要求和使用命名空间">要求和使用命名空间&lt;/h3>
&lt;p>在&lt;code>the-divine-cheese-code.core&lt;/code>命名空间的代码将使用&lt;code>the-divine-cheese-code.visualization.svg&lt;/code>命名空间的函数来创建 SVG 标记。为了使用&lt;code>svg&lt;/code>的函数，&lt;code>core&lt;/code>将不得不&lt;em>要求它。但首先，让我们在&lt;/em>svg.clj*中添加一些代码。让它看起来像这样（你以后会添加更多）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns the-divine-cheese-code.visualization.svg)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn latlng-&amp;gt;point
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Convert lat/lng map to comma-separated string&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [latlng]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str (:lat latlng) &amp;#34;,&amp;#34; (:lng latlng)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn points
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [locations]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (clojure.string/join &amp;#34; &amp;#34; (map latlng-&amp;gt;point locations)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这定义了两个函数，&lt;code>latlng-&amp;gt;point&lt;/code>和&lt;code>points&lt;/code>，你将用它们来把一串经纬度坐标转换成一串点。 要使用&lt;em>core.clj&lt;/em>文件中的这段代码，你必须&lt;code>require&lt;/code>它。&lt;code>require&lt;/code>接收一个指定命名空间的符号，并确保该命名空间存在并准备使用；在这种情况下，当你调用&lt;code>(require 'the-divine-cheese&lt;/code>-code.visualization.svg)&lt;code>，Clojure读取并求值相应的文件。通过求值该文件，它创建了&lt;/code>the-divine-cheese-code.visualization.svg&lt;code>命名空间，并在该命名空间中定义了函数&lt;/code>latlng-&amp;gt;point&lt;code>和&lt;/code>points`。即使文件&lt;em>svg.clj&lt;/em>在你的项目目录中，Clojure 在运行你的项目时也不会自动求值它；你必须明确告诉 Clojure 你想使用它。&lt;/p>
&lt;p>在要求命名空间之后，你可以&lt;em>参考&lt;/em>它，这样你就不必使用完全合格的名称来引用函数。继续要求&lt;code>the-divine-cheese-code.visualization.svg&lt;/code>，并添加&lt;code>heists&lt;/code>序列，使&lt;em>core.clj&lt;/em>与列表相符。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns the-divine-cheese-code.core)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">;; Ensure that the SVG code is evaluated
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(require &amp;#39;the-divine-cheese-code.visualization.svg)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">;; Refer the namespace so that you don&amp;#39;t have to use the
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">;; fully qualified name to reference svg functions
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(refer &amp;#39;the-divine-cheese-code.visualization.svg)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def heists [{:location &amp;#34;Cologne, Germany&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :cheese-name &amp;#34;Archbishop Hildebold&amp;#39;s Cheese Pretzel&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lat 50.95
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lng 6.97}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:location &amp;#34;Zurich, Switzerland&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :cheese-name &amp;#34;The Standard Emmental&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lat 47.37
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lng 8.55}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:location &amp;#34;Marseille, France&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :cheese-name &amp;#34;Le Fromage de Cosquer&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lat 43.30
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lng 5.37}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:location &amp;#34;Zurich, Switzerland&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :cheese-name &amp;#34;The Lesser Emmental&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lat 47.37
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lng 8.55}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:location &amp;#34;Vatican City&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :cheese-name &amp;#34;The Cheese of Turin&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lat 41.90
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lng 12.45}])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn -main
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [&amp;amp; args]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (points heists)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在你有一连串的 heist 位置可以使用，你可以使用&lt;code>visualization.svg&lt;/code>命名空间的函数。&lt;code>main&lt;/code>函数只是将&lt;code>points&lt;/code>函数应用于&lt;code>heists&lt;/code>。如果你用&lt;code>lein run&lt;/code>运行该项目，你应该看到这个。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">50.95,6.97 47.37,8.55 43.3,5.37 47.37,8.55 41.9,12.45
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>万岁! 你离抓到那个偷窃发酵乳的人又近了一步! 使用&lt;code>require&lt;/code>成功加载了&lt;code>the-divine-cheese-code.visualization.svg&lt;/code>以供使用。&lt;/p>
&lt;p>&lt;code>require&lt;/code>的细节实际上有点复杂，但为了实用，你可以认为&lt;code>require&lt;/code>是告诉 Clojure 以下内容。&lt;/p>
&lt;ol>
&lt;li>如果你已经用这个符号（&lt;code>the-divine-cheese-code.visualization.svg&lt;/code>）调用了&lt;code>require&lt;/code>，则不做任何事情。&lt;/li>
&lt;li>否则，使用&lt;a class="link" href="https://www.braveclojure.com/organization/#Anchor-3" target="_blank" rel="noopener"
>&amp;ldquo;文件路径和命名空间名称之间的关系 &amp;ldquo;第 133 页&lt;/a>中描述的规则找到与该符号对应的文件。在这种情况下，Clojure 找到&lt;code>src/the_divine_cheese_code/visualization/svg.clj&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>读取并求值该文件的内容。Clojure 希望该文件声明一个与它的路径相对应的命名空间（我们的文件就是如此）。&lt;/p>
&lt;p>&lt;code>require&lt;/code>也可以让你在需要一个命名空间时使用&lt;code>:as&lt;/code>或&lt;code>alias&lt;/code>来别名它。这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(require &amp;#39;[the-divine-cheese-code.visualization.svg :as svg] )
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>相当于这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(require &amp;#39;the-divine-cheese-code.visualization.svg)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(alias &amp;#39;svg &amp;#39;the-divine-cheese-code.visualization.svg)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在你可以使用别名的命名空间了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(svg/points heists)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;50.95,6.97 47.37,8.55 43.3,5.37 47.37,8.55 41.9,12.45&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Clojure 提供了另一种捷径。函数&lt;code>use&lt;/code>不需要单独调用&lt;code>require&lt;/code>和&lt;code>refer&lt;/code>，而是同时调用。在生产代码中使用&lt;code>use&lt;/code>是不可取的，但当你在 REPL 中做实验，想快速获得一些函数时，它就很方便。例如，这个。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(require &amp;#39;the-divine-cheese-code.visualization.svg)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(refer &amp;#39;the-divine-cheese-code.visualization.svg)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>相当于这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(use &amp;#39;the-divine-cheese-code.visualization.svg)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以用&lt;code>use&lt;/code>来别名一个命名空间，就像你可以用&lt;code>require&lt;/code>一样。这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(require &amp;#39;the-divine-cheese-code.visualization.svg)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(refer &amp;#39;the-divine-cheese-code.visualization.svg)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(alias &amp;#39;svg &amp;#39;the-divine-cheese-code.visualization.svg)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>相当于清单 6-2 中的代码，其中也显示了函数调用中使用的别名空间。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(use &amp;#39;[the-divine-cheese-code.visualization.svg :as svg])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(= svg/points points)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(= svg/latlng-&amp;gt;point latlng-&amp;gt;point)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>6-2. 有时，既使用又别名一个命名空间是很方便的。&lt;/li>
&lt;/ol>
&lt;p>在这里用&lt;code>use&lt;/code>别名命名空间似乎是多余的，因为&lt;code>use&lt;/code>已经引用了命名空间（这让你可以简单地调用&lt;code>points&lt;/code>而不是&lt;code>svg/points&lt;/code>）。但在某些情况下，这很方便，因为&lt;code>use&lt;/code>和&lt;code>refer&lt;/code>有相同的选项（&lt;code>:only&lt;/code>, &lt;code>:exclude&lt;/code>, &lt;code>:as&lt;/code>, 和&lt;code>:rename&lt;/code>）。当你跳过引用一个符号时，你可能想用&lt;code>use&lt;/code>来别名一个命名空间。你可以这样使用。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(require &amp;#39;the-divine-cheese-code.visualization.svg)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(refer &amp;#39;the-divine-cheese-code.visualization.svg :as :only [&amp;#39;point])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>或者你可以使用清单 6-3 中的&lt;code>use&lt;/code>形式（其中还包括如何调用函数的例子）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(use &amp;#39;[the-divine-cheese-code.visualization.svg :as svg :only [points]])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(refer &amp;#39;the-divine-cheese-code.visualization.svg :as :only [&amp;#39;points])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(= svg/points points)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">;; We can use the alias to reach latlng-&amp;gt;point
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">svg/latlng-&amp;gt;point
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; This doesn&amp;#39;t throw an exception
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">;; But we can&amp;#39;t use the bare name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">latlng-&amp;gt;point
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; This does throw an exception!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>在你使用一个命名空间后将其别名化，可以让你参考你排除的符号。&lt;/li>
&lt;/ol>
&lt;p>如果你在 REPL 中尝试清单 6-3，并且&lt;code>latlng-&amp;gt;point&lt;/code>没有抛出一个异常，这是因为你在清单 6-2 中引用了&lt;code>latlng-&amp;gt;point&lt;/code>。你需要重新启动你的 REPL 会话，使代码表现得如清单 6-3 所示。&lt;/p>
&lt;p>这里的启示是，&lt;code>require&lt;/code>和&lt;code>use&lt;/code>加载文件，并可选择&lt;code>alias&lt;/code>或&lt;code>refer&lt;/code>其命名空间。当你写 Clojure 程序和阅读别人写的代码时，你可能会遇到更多的&lt;code>require'和&lt;/code>use&amp;rsquo;的写法，这时，阅读 Clojure 的 API 文档（&lt;em>&lt;a class="link" href="http://clojure.org/libs/" target="_blank" rel="noopener"
>http://clojure.org/libs/&lt;/a>&lt;/em>）来了解发生了什么是有意义的。然而，到目前为止，你所学到的关于&lt;code>require&lt;/code>和&lt;code>use&lt;/code>的内容应该能满足你 95.3%的需求。&lt;/p>
&lt;h3 id="ns-宏">＃＃＃NS 宏&lt;/h3>
&lt;p>现在是时候看看&lt;code>ns&lt;/code>宏了。到目前为止所涉及的工具&amp;ndash;&lt;code>in-ns&lt;/code>, &lt;code>refer&lt;/code>, &lt;code>alias&lt;/code>, &lt;code>require&lt;/code>, 和 &lt;code>use&lt;/code>&amp;ndash;最常在你使用 REPL 时使用。在你的源代码文件中，你通常会使用&lt;code>ns&lt;/code>宏，因为它允许你简洁地使用迄今为止描述的工具，并提供其他有用的功能。在本节中，你将了解一个&lt;code>ns&lt;/code>调用如何结合&lt;code>require&lt;/code>、&lt;code>use&lt;/code>、&lt;code>in-ns&lt;/code>、&lt;code>alias&lt;/code>和&lt;code>refer&lt;/code>。&lt;/p>
&lt;p>&lt;code>ns&lt;/code>做的一个有用的任务是默认引用&lt;code>clojure.core&lt;/code>命名空间。这就是为什么你可以从&lt;code>the-divine-cheese-code.core&lt;/code>中调用&lt;code>println&lt;/code>，而不使用完全限定的名称&lt;code>clojure.core/println&lt;/code>。&lt;/p>
&lt;p>你可以用&lt;code>:refer-clojure&lt;/code>来控制从&lt;code>clojure-core&lt;/code>引用的内容，它的选项与&lt;code>refer&lt;/code>相同。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns the-divine-cheese-code.core
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (:refer-clojure :exclude [println])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果你在&lt;em>divine_cheese_code.core.clj&lt;/em>的开头调用这个，会破坏你的代码，迫使你在&lt;code>-main'函数中使用&lt;/code>clojure.core/println&amp;rsquo;。&lt;/p>
&lt;p>在&lt;code>ns&lt;/code>中，&lt;code>(:&lt;/code>refer-clojure)`的形式被称为&lt;em>reference&lt;/em>。这对你来说可能看起来很奇怪。这个引用是一个函数调用？一个宏？它是什么？你将在第 7 章中了解更多关于底层机器的知识。现在，你只需要了解每个引用如何 Map 到函数调用。例如，前面的代码就相当于这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(in-ns &amp;#39;the-divine-cheese-code.core)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(refer &amp;#39;clojure.core :exclude [&amp;#39;println])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在 &amp;ldquo;ns &amp;ldquo;中，有六种可能的引用。&lt;/p>
&lt;ul>
&lt;li>&lt;code>(:refer-clojure)&lt;/code>.&lt;/li>
&lt;li>&amp;ldquo;(:require)&amp;quot;。&lt;/li>
&lt;li>&lt;code>(:use)&lt;/code>&lt;/li>
&lt;li>&lt;code>(:import)&lt;/code>&lt;/li>
&lt;li>&lt;code>(:load)&lt;/code>&lt;/li>
&lt;li>&lt;code>(:gen-class)&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>&lt;code>(:import)&lt;/code>和&lt;code>(:gen-class)&lt;/code>将在第 12 章介绍。我将不介绍&lt;code>(:load)&lt;/code>，因为它很少被使用。&lt;/p>
&lt;p>&lt;code>(:require)&lt;/code>的工作方式很像&lt;code>require&lt;/code>函数。例如，这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns the-divine-cheese-code.core
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (:require the-divine-cheese-code.visualization.svg))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>相当于这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(in-ns &amp;#39;the-divine-cheese-code.core)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(require &amp;#39;the-divine-cheese-code.visualization.svg)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，在 &amp;ldquo;ns &amp;ldquo;形式中（与 &amp;ldquo;in-ns &amp;ldquo;函数调用不同），你不需要用&amp;rdquo;&amp;lsquo;&amp;lsquo;来引用你的符号。在 &amp;ldquo;ns &amp;ldquo;中，你从来不需要引用符号。&lt;/p>
&lt;p>你也可以&lt;code>alias&lt;/code>一个你在&lt;code>ns&lt;/code>内&lt;code>require&lt;/code>的库，就像你调用函数时一样。这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns the-divine-cheese-code.core
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (:require [the-divine-cheese-code.visualization.svg :as svg])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>相当于这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(in-ns &amp;#39;the-divine-cheese-code.core)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(require [&amp;#39;the-divine-cheese-code.visualization.svg :as &amp;#39;svg])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以在一个&lt;code>(:require)&lt;/code>引用中要求多个库，如下所示。 这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns the-divine-cheese-code.core
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (:require [the-divine-cheese-code.visualization.svg :as svg])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [clojure.java.browse :as browse]))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>相当于这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(in-ns &amp;#39;the-divine-cheese-code.core)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(require [&amp;#39;the-divine-cheese-code.visualization.svg :as &amp;#39;svg])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(require [&amp;#39;clojure.java.browse :as &amp;#39;browse])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然而，&lt;code>(:require)&lt;/code>引用和&lt;code>require&lt;/code>函数之间的一个区别是，引用也允许你引用名字。这一点。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns the-divine-cheese-code.core
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (:require [the-divine-cheese-code.visualization.svg :refer [point]))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>相当于这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(in-ns &amp;#39;the-divine-cheese-code.core)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(require &amp;#39;the-divine-cheese-code.visualization.svg)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(refer &amp;#39;the-divine-cheese-code.visualization.svg :only [&amp;#39;point])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你也可以引用所有的符号（注意&lt;code>:all&lt;/code>关键字）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns the-divine-cheese-code.core
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (:require [the-divine-cheese-code.visualization.svg :refer :all]))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就相当于这样做了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(in-ns &amp;#39;the-divine-cheese-code.core)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(require &amp;#39;the-divine-cheese-code.visualization.svg)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(refer &amp;#39;the-divine-cheese-code.visualization.svg)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这是要求代码、别名命名空间和引用符号的首选方式。建议你不要使用&lt;code>(:use)&lt;/code>，但由于你很可能会遇到它，所以知道它是如何工作的很好。你知道该怎么做。这个。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns the-divine-cheese-code.core
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (:use clojure.java.browse))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这样做。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(in-ns &amp;#39;the-divine-cheese-code.core)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(use &amp;#39;clojure.java.browse)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而这一点。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns the-divine-cheese-code.core
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (:use [clojure.java browse io])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这样做。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(in-ns &amp;#39;the-divine-cheese-code.core)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(use &amp;#39;clojure.java.browse)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(use &amp;#39;clojure.java.io)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，当你在&lt;code>:use&lt;/code>后面加上一个 Vector 时，它把第一个符号作为&lt;em>base&lt;/em>，然后用后面的每个符号调用&lt;code>use&lt;/code>。&lt;/p>
&lt;p>哦，我的天哪，就是这样! 现在你可以像专家一样使用&lt;code>ns&lt;/code>了! 你需要这样做，该死的，因为那个&lt;em>voleur des fromages&lt;/em>（他们可能在法语中这样说）仍然在肆意妄为。还记得他/她吗？&lt;/p>
&lt;p>∮∮抓小偷&lt;/p>
&lt;p>我们不能让这个掠夺帕尔马干酪的人带着更多的干酪离开！是时候完成根据坐标画线的工作了。现在是时候根据盗窃案的坐标来完成画线了！这肯定会发现一些问题。这肯定会发现一些问题!&lt;/p>
&lt;p>使用每个抢劫案的纬度坐标，你将在一个 SVG 图像中连接这些点。但是，如果你用给定的坐标画线，结果看起来就不对了，原因有二。首先，纬度坐标是由南向北上升的，而 SVG 的 Y 坐标是由上向下上升的。换句话说，你需要翻转坐标，否则绘图就会颠倒过来。&lt;/p>
&lt;p>第二，绘图会非常小。为了解决这个问题，你将通过平移和缩放来放大它。这就像把一张看起来像图 6-1a 的图变成图 6-1b。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/organization/svg-before.png"
loading="lazy"
>
&lt;img src="https://www.braveclojure.com/assets/images/cftbat/organization/svg-after.png"
loading="lazy"
>&lt;/p>
&lt;p>图 6-1：通过翻转、平移和缩放纬度坐标来制作一张 SVG 图片。&lt;/p>
&lt;p>说实话，这些都是完全随意的，它已经与代码组织没有直接关系了，但是它很有趣，我想你会有一个很好的时间来浏览这些代码的 使你的&lt;em>svg.clj&lt;/em>文件与清单 6-4 一致。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns the-divine-cheese-code.visualization.svg
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (:require [clojure.string :as s])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (:refer-clojure :exclude [min max])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➊ （defn comparator-over-maps
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [比较-fn ks］
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (fn [maps]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➋ (zipmap ks
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➌ (map (fn [k] (apply comparison-fn (map k maps)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ks))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➍ (def min (comparator-over-maps clojure.core/min [:lat :lng])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def max (comparator-over-maps clojure.core/max [:lat :lng]))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>6-3. 构建 Map 比较函数&lt;/li>
&lt;/ol>
&lt;p>你在➊处定义了&lt;code>comparator-over-maps&lt;/code>函数。这可能是最棘手的部分，所以请忍受一下。 &lt;code>comparator-over-maps&lt;/code>是一个返回一个函数的函数。返回的函数使用所提供的比较函数&lt;code>comparison-fn&lt;/code>对参数&lt;code>ks&lt;/code>提供的键值进行比较。&lt;/p>
&lt;p>你使用&lt;code>comparator-over-map&lt;/code>来构造&lt;code>min&lt;/code>和&lt;code>max&lt;/code>函数➍，你将用它们来寻找我们图形的左上角和右下角。下面是`min&amp;rsquo;的操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(min [{:a 1 :b 3} {:a 5 :b 0}] )
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:a 1 :b 0}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当你调用&lt;code>min&lt;/code>时，它调用&lt;code>zipmap&lt;/code>，它接受两个参数，都是 seq，并返回一个新的 map。第一个序列的元素成为键，第二个序列的元素成为值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(zipmap [:a :b] [1 2])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:a 1 :b 2}。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在 ，&lt;code>zipmap&lt;/code>的第一个参数是&lt;code>ks&lt;/code>，所以&lt;code>ks&lt;/code>的元素将是返回 Map 的键。第二个参数是在➌的 Map 调用的结果。那个 Map 调用实际上是在进行比较。&lt;/p>
&lt;p>最后，在➍，你使用&lt;code>comparator-over-maps&lt;/code>来创建比较函数。如果你把图纸看作是刻在一个矩形里，那么&lt;code>min&lt;/code>是矩形中最接近（0，0）的角，&lt;code>max&lt;/code>是离它最远的角。&lt;/p>
&lt;p>下面是代码的下一部分。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> (defn translate-to-00
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [locations]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [mincoords (min locations)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (map #(merge-with - % mincoords) locations)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (defn scale
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [width height locations]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [maxcoords (max locations)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ratio {:lat (/ height (:lat maxcoords))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lng (/ width (:lng maxcoords))}]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (map #(merge-with * % ratio) locations)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>translate-to-00&lt;/code>，定义在 ，工作原理是找到我们位置的&lt;code>min'，然后从每个位置减去这个值。它使用&lt;/code>merge-with`，其工作原理如下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(merge-with - {:lat 50 :lng 10} {:lat 5 :lng 5})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:lat 45 :lng 5}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后我们定义函数&lt;code>scale&lt;/code>，它将每个点乘以最大经纬度与所需高度和宽度之间的比率。&lt;/p>
&lt;p>下面是&lt;em>svg.clj&lt;/em>的其余代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn latlng-&amp;gt;point
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Convert lat/lng map to comma-separated string&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [latlng]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str (:lat latlng) &amp;#34;,&amp;#34; (:lng latlng)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn points
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Given a seq of lat/lng maps, return string of points joined by space&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [locations]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (s/join &amp;#34; &amp;#34; (map latlng-&amp;gt;point locations)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn line
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [points]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str &amp;#34;&amp;lt;polyline points=\&amp;#34;&amp;#34; points &amp;#34;\&amp;#34; /&amp;gt;&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn transform
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Just chains other functions&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [width height locations]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (-&amp;gt;&amp;gt; locations
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> translate-to-00
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (scale width height)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn xml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;svg &amp;#39;template&amp;#39;, which also flips the coordinate system&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [width height locations]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str &amp;#34;&amp;lt;svg height=\&amp;#34;&amp;#34; height &amp;#34;\&amp;#34; width=\&amp;#34;&amp;#34; width &amp;#34;\&amp;#34;&amp;gt;&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ;; These two &amp;lt;g&amp;gt; tags change the coordinate system so that
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ;; 0,0 is in the lower-left corner, instead of SVG&amp;#39;s default
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ;; upper-left corner
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;&amp;lt;g transform=\&amp;#34;translate(0,&amp;#34; height &amp;#34;)\&amp;#34;&amp;gt;&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;&amp;lt;g transform=\&amp;#34;rotate(-90)\&amp;#34;&amp;gt;&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (-&amp;gt; (transform width height locations)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> points
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> line)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;&amp;lt;/g&amp;gt;&amp;lt;/g&amp;gt;&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;&amp;lt;/svg&amp;gt;&amp;#34;))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里的函数非常简单明了。它们只是接收&lt;code>{:lat x :lng y}&lt;/code>Map，并对其进行转换，以便创建一个 SVG。&lt;code>latlng-&amp;gt;point&lt;/code>返回一个字符串，可用于在 SVG 标记中定义一个点。&lt;code>points&lt;/code>将&lt;code>lat&lt;/code>/&lt;code>lng&lt;/code>Map 的序列转换为一个以空格分隔的点的字符串。 &lt;code>line&lt;/code>返回连接所有给定空间分隔的点字符串的 SVG 标记。 &lt;code>transform&lt;/code>接收一个位置序列，将它们翻译成从(0, 0)开始的点，并将它们缩放到给定的宽度和高度。最后，&lt;code>xml&lt;/code>产生标记，用 SVG 显示给定的位置。&lt;/p>
&lt;p>有了&lt;em>svg.clj&lt;/em>的所有代码，现在让&lt;em>core.clj&lt;/em>看起来像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns the-divine-cheese-code.core
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (:require [clojure.java.browse :as browse]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [the-divine-cheese-code.visualization.svg :refer [xml]])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (:gen-class))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def heists [{:location &amp;#34;Cologne, Germany&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :cheese-name &amp;#34;Archbishop Hildebold&amp;#39;s Cheese Pretzel&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lat 50.95
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lng 6.97}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:location &amp;#34;Zurich, Switzerland&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :cheese-name &amp;#34;The Standard Emmental&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lat 47.37
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lng 8.55}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:location &amp;#34;Marseille, France&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :cheese-name &amp;#34;Le Fromage de Cosquer&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lat 43.30
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lng 5.37}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:location &amp;#34;Zurich, Switzerland&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :cheese-name &amp;#34;The Lesser Emmental&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lat 47.37
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lng 8.55}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:location &amp;#34;Vatican City&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :cheese-name &amp;#34;The Cheese of Turin&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lat 41.90
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :lng 12.45}])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn url
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [filename]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str &amp;#34;file:///&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (System/getProperty &amp;#34;user.dir&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;/&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> filename))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn template
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [contents]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str &amp;#34;&amp;lt;style&amp;gt;polyline { fill:none; stroke:#5881d8; stroke-width:3}&amp;lt;/style&amp;gt;&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> contents))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn -main
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [&amp;amp; args]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [filename &amp;#34;map.html&amp;#34;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (-&amp;gt;&amp;gt; heists
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (xml 50 100)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> template
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (spit filename))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (browse/browse-url (url filename))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里没有太复杂的事情发生。在 &amp;ldquo;main &amp;ldquo;中，你使用 &amp;ldquo;xml &amp;ldquo;和 &amp;ldquo;template &amp;ldquo;函数建立绘图，用 &amp;ldquo;spit &amp;ldquo;将绘图写入一个文件，然后用 &amp;ldquo;browse/browse-url &amp;ldquo;打开它。你现在应该试试! 运行&lt;code>lein run&lt;/code>，你会看到类似图 6-2 的东西。&lt;/p>
&lt;p>图 6-2: 抢劫模式的最终 SVG!&lt;/p>
&lt;p>等一下 ……这看起来很像 ……这看起来很像一个 lambda。Clojure 的标志是一个 lambda . ……哦，我的天啊! Clojure，一直以来都是你!&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>在本章中你学到了很多东西。在这一点上，你应该拥有所有你需要的工具来开始组织你的项目。你现在知道命名空间组织了符号和 vars 之间的 Map，vars 是对 Clojure 对象（数据结构、函数等）的引用。 &lt;code>def&lt;/code>存储一个对象，并用符号和指向该对象的 var 之间的 Map 来更新当前命名空间。你可以用&lt;code>defn-&lt;/code>创建私有函数。&lt;/p>
&lt;p>Clojure 允许你用&lt;code>create-ns&lt;/code>创建命名空间，但通常使用&lt;code>in-ns&lt;/code>更有用，它也会切换到命名空间。你可能只在 REPL 中使用这些函数。当你在 REPL 中时，你总是&lt;em>在&lt;/em>当前命名空间中。当你在文件中而不是在 REPL 中定义名字空间时，你应该使用 &lt;code>ns&lt;/code> 宏，名字空间和它在文件系统中的路径之间是一对一的关系。&lt;/p>
&lt;p>你可以通过使用完全限定的名称来引用其他命名空间中的对象，如&lt;code>cheese.taxonomy/cheddars&lt;/code>。 &lt;code>refer&lt;/code>可以让你使用其他命名空间的名字，而不需要完全限定它们，&lt;code>alias&lt;/code>可以让你在写出完全限定的名字时，使用一个更短的名字来命名空间。&lt;/p>
&lt;p>&lt;code>require&lt;/code>和&lt;code>use&lt;/code>确保一个名字空间的存在并准备好被使用，并且可以选择让你&lt;code>refer&lt;/code>和&lt;code>alias&lt;/code>相应的名字空间。你应该使用&lt;code>ns&lt;/code>在你的源文件中调用&lt;code>require&lt;/code>和&lt;code>use&lt;/code>。*&lt;a class="link" href="https://gist.github.com/ghoseb/287710/" target="_blank" rel="noopener"
>Clojure ns syntax cheat-sheet - GitHub&lt;/a>*是使用&lt;code>ns&lt;/code>的所有变化的一个很好的参考。&lt;/p>
&lt;p>最后，也是最重要的一点，做一个俗气的人并不容易。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/organization/cheese.png"
loading="lazy"
>&lt;/p></description></item><item><title>Chapter5 函数式编程</title><link>https://example.com/p/chapter5-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link><pubDate>Fri, 14 Jan 2022 10:00:07 +0800</pubDate><guid>https://example.com/p/chapter5-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid><description>&lt;h1 id="函数式编程">函数式编程&lt;/h1>
&lt;p>到目前为止，你已经专注于熟悉 Clojure 提供的工具：不可变的数据结构、函数、抽象，等等。在这一章中，你将学习如何思考你的编程任务，以最好的方式利用这些工具。你将开始把你的经验整合到一个新的函数式编程思维中。&lt;/p>
&lt;p>你将学到的核心概念包括：什么是纯函数，为什么它们很有用；如何使用不可变的数据结构，为什么它们比可变的表亲更有优势；如何将数据和函数分开，给你带来更多的力量和灵活性；以及为什么对一小部分数据抽象进行编程会很强大。一旦你把所有这些知识塞进你的大脑，你就会有一个全新的解决问题的方法&lt;/p>
&lt;p>在学习了这些主题之后，你将通过编写一个基于终端的游戏来运用你所学到的一切，这个游戏的灵感来自于美国各地 Cracker Barrel 餐馆中的一种古老而神秘的思维训练装置。Peg Thing!&lt;/p>
&lt;h2 id="纯函数是什么和为什么">纯函数：是什么和为什么&lt;/h2>
&lt;p>除了 &amp;ldquo;println &amp;ldquo;和 &amp;ldquo;rand&amp;rdquo;，到目前为止，你所使用的所有函数都是纯函数。是什么使它们成为纯函数，为什么会有这样的问题？如果一个函数符合两个条件，它就是纯函数。&lt;/p>
&lt;ul>
&lt;li>如果给出相同的参数，它总是返回相同的结果。这被称为&lt;em>引用透明度&lt;/em>，你可以把它添加到你的 5 美元编程术语列表中。&lt;/li>
&lt;li>它不能引起任何副作用。也就是说，该函数不能做出任何在函数本身之外可以观察到的改变&amp;ndash;例如，通过改变一个外部可访问的可改变对象或写到一个文件。&lt;/li>
&lt;/ul>
&lt;p>这些特性使你更容易推理你的程序，因为这些函数是完全隔离的，无法影响你系统的其他部分。当你使用它们时，你不必问自己，&amp;ldquo;我调用这个函数会破坏什么？&amp;rdquo; 它们也是一致的：你永远不需要搞清楚为什么给一个函数传递相同的参数会导致不同的返回值，因为这永远不会发生。&lt;/p>
&lt;p>纯函数和算术一样稳定，没有问题（你最后一次为两个数字相加而烦恼是什么时候？） 它们是巨大的函数小砖块，你可以自信地将其作为你程序的基础。让我们更详细地看看引用透明性和无副作用，看看它们到底是什么，以及它们是如何发挥作用的。&lt;/p>
&lt;h3 id="纯函数是引用透明的">纯函数是引用透明的&lt;/h3>
&lt;p>为了在调用相同参数时返回相同的结果，纯函数只依靠 1）自己的参数和 2）不可变的值来决定其返回值。例如，数学函数是引用透明的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; 3&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果一个函数依赖于一个不可变的值，那么它就是引用透明的。字符串`&amp;rdquo;, Daniel-san &amp;ldquo;是不可变的，所以下面的函数也是引用透明的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">wisdom&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">words&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">str &lt;/span>&lt;span class="nv">words&lt;/span> &lt;span class="s">&amp;#34;, Daniel-san&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">wisdom&lt;/span> &lt;span class="s">&amp;#34;Always bathe on Fridays&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; &amp;#34;Always bathe on Fridays, Daniel-san&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>相比之下，下面的函数在相同的参数下不会产生相同的结果；因此，它们在指称上是不透明的。任何依赖随机数生成器的函数都不可能是指称透明的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">year-end-evaluation&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">if &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">&amp;gt; &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">rand&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="mf">0.5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;You get a raise!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Better luck next year!&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果你的函数从一个文件中读出，它就不是引用透明的，因为文件的内容可以改变。下面的函数&lt;code>analyze-file&lt;/code>不是引用透明的，但函数&lt;code>analysis&lt;/code>是透明的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">analyze-file&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">filename&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">analysis&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">slurp &lt;/span>&lt;span class="nv">filename&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">analysis&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">text&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">str &lt;/span>&lt;span class="s">&amp;#34;Character count: &amp;#34;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">count &lt;/span>&lt;span class="nv">text&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当使用一个引用透明的函数时，你永远不必考虑哪些可能的外部条件会影响函数的返回值。如果你的函数在多个地方被使用，或者它被深深地嵌套在一个函数调用链中，这一点就特别重要。在这两种情况下，你可以高枕无忧地知道，外部条件的变化不会导致你的代码中断。&lt;/p>
&lt;p>另一种思考方式是，现实在很大程度上是引用透明的。如果你把重力看作一个函数，那么引力就是在两个物体上调用该函数的返回值。因此，当你下次参加编程面试时，你可以通过把面试官桌上的东西打掉来证明你的函数式编程知识（这也证明你知道如何在一个集合上应用一个函数）。&lt;/p>
&lt;h3 id="纯函数没有副作用">纯函数没有副作用&lt;/h3>
&lt;p>执行副作用就是在一个给定的范围内改变一个名字和它的值之间的关联。下面是一个 JavaScript 的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="k">var &lt;/span>&lt;span class="nv">haplessObject&lt;/span> &lt;span class="nb">= &lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">emotion&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="s">&amp;#34;Carefree!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;span class="c1">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">var &lt;/span>&lt;span class="nv">evilMutator&lt;/span> &lt;span class="nb">= &lt;/span>&lt;span class="nv">function&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">object&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">object.emotion&lt;/span> &lt;span class="nb">= &lt;/span>&lt;span class="s">&amp;#34;So emo :&amp;#39;(&amp;#34;&lt;/span>&lt;span class="c1">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">evilMutator&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">haplessObject&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="c1">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">haplessObject.emotion&lt;/span>&lt;span class="c1">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">//&lt;/span> &lt;span class="nv">=&amp;gt;&lt;/span> &lt;span class="s">&amp;#34;So emo :&amp;#39;(&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当然，你的程序必须要有一些副作用。它写入磁盘，改变了文件名和磁盘扇区集合之间的关联；它改变了显示器像素的 RGB 值；等等。否则，运行它就没有意义了。&lt;/p>
&lt;p>然而，副作用是潜在的有害的，因为它们带来了关于你的代码中的名称所指的不确定性。这就导致了很难追踪为什么以及如何将一个名字与一个值联系起来的情况，这就使程序的调试变得非常困难。当你调用一个没有副作用的函数时，你只需要考虑输入和输出之间的关系。你不必担心其他可能在你的系统中出现的变化。&lt;/p>
&lt;p>另一方面，有副作用的函数给你的思想葡萄带来了更多的负担：现在你必须担心当你调用这个函数时，世界是如何受到影响的。不仅如此，每一个依赖于副作用函数的函数都会被这种担忧所感染；它也会成为你在构建程序时需要格外小心和思考的另一个组件。&lt;/p>
&lt;p>如果你有使用 Ruby 或 JavaScript 等语言的重要经验，你可能已经遇到了这个问题。当一个对象被传来传去的时候，它的属性不知不觉地发生了变化，而你却不知道为什么。然后你不得不买一台新的电脑，因为你把你的电脑扔到了窗外。如果你读过任何关于面向对象设计的文章，你就会知道，很多文章都是关于管理状态和减少副作用的策略，正是因为这个原因。&lt;/p>
&lt;p>由于所有这些原因，在你的代码中寻找限制使用副作用的方法是个好主意。幸运的是，Clojure 通过不遗余力地限制副作用来使你的工作变得更容易&amp;ndash;它的所有核心数据结构都是不可改变的。无论你如何努力，你都无法在原地改变它们。然而，如果你不熟悉不可变的数据结构，你可能会觉得你最喜欢的工具被剥夺了。你怎么能*做没有副作用的事情呢？好吧，这就是下一节要讲的内容! 这段话怎么样，嗯？诶？&lt;/p>
&lt;h2 id="与不可变的数据结构共处">与不可变的数据结构共处&lt;/h2>
&lt;p>不可变的数据结构确保你的代码不会有副作用。正如你现在衷心知道的，这是一件好事。但你如何在没有副作用的情况下完成任何事情呢？&lt;/p>
&lt;h3 id="递归而不是-forwhile">递归而不是 for/while&lt;/h3>
&lt;p>如果你曾经在 JavaScript 中写过这样的东西，请举手。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="k">var &lt;/span>&lt;span class="nv">wrestlers&lt;/span> &lt;span class="nb">= &lt;/span>&lt;span class="nv">getAlligatorWrestlers&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="c1">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">var &lt;/span>&lt;span class="nv">totalBites&lt;/span> &lt;span class="nb">= &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="c1">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">var &lt;/span>&lt;span class="nv">l&lt;/span> &lt;span class="nb">= &lt;/span>&lt;span class="nv">wrestlers.length&lt;/span>&lt;span class="c1">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">var &lt;/span>&lt;span class="nv">i=0&lt;/span>&lt;span class="c1">; i &amp;lt; l; i++){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">totalBites&lt;/span> &lt;span class="nv">+=&lt;/span> &lt;span class="nv">wrestlers&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nv">.timesBitten&lt;/span>&lt;span class="c1">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>或者这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="k">var &lt;/span>&lt;span class="nv">allPatients&lt;/span> &lt;span class="nb">= &lt;/span>&lt;span class="nv">getArkhamPatients&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="c1">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">var &lt;/span>&lt;span class="nv">analyzedPatients&lt;/span> &lt;span class="nb">= &lt;/span>&lt;span class="p">[]&lt;/span>&lt;span class="c1">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">var &lt;/span>&lt;span class="nv">l&lt;/span> &lt;span class="nb">= &lt;/span>&lt;span class="nv">allPatients.length&lt;/span>&lt;span class="c1">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">var &lt;/span>&lt;span class="nv">i=0&lt;/span>&lt;span class="c1">; i &amp;lt; l; i++){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">allPatients&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nv">.analyzed&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">analyzedPatients.push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">allPatients&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="p">])&lt;/span>&lt;span class="c1">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意这两个例子都对循环变量&lt;code>i&lt;/code>以及循环外的一个变量（第一个例子中的&lt;code>totalBites&lt;/code>和第二个例子中的&lt;code>analyzedPatients&lt;/code>）产生了副作用。以这种方式使用副作用&amp;ndash;改变***内部的变量&amp;ndash;是相当无害的。你在创造新的值，而不是改变你从程序中其他地方得到的对象。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/functional-programming/bloodthunder.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>但是 Clojure 的核心数据结构甚至不允许这些无害的变异。那么，你能做什么呢？首先，忽略一个事实，你可以很容易地使用&lt;code>map&lt;/code>和&lt;code>reduce&lt;/code>来完成前面的工作。在这些情况下&amp;ndash;对一些集合进行迭代以建立一个结果&amp;ndash;替代突变的函数是递归。&lt;/p>
&lt;p>让我们看一下第一个例子，建立一个总和。Clojure 没有赋值运算符。如果不创建一个新的作用域，你就无法将一个新的值与一个名字联系起来。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="k">def &lt;/span>&lt;span class="nv">great-baby-name&lt;/span> &lt;span class="s">&amp;#34;Rosanthony&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">great-baby-name&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; &amp;#34;Rosanthony&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="k">let &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">great-baby-name&lt;/span> &lt;span class="s">&amp;#34;Bloodthunder&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">great-baby-name&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; &amp;#34;Bloodthunder&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">great-baby-name&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; &amp;#34;Rosanthony&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子中，你首先在全局作用域中将 &amp;ldquo;great-baby-name &amp;ldquo;与 &amp;ldquo;Rosanthony &amp;ldquo;绑定。接下来，你用&lt;code>let&lt;/code>引入一个新的作用域。在这个作用域中，你将&lt;code>great-baby-name&lt;/code>绑定到&lt;code>&amp;quot;Bloodthunder&amp;quot;&lt;/code>。一旦 Clojure 完成了对&lt;code>let&lt;/code>表达式的求值，你就回到了全局范围，&lt;code>great-baby-name&lt;/code>再次被求值为&lt;code>&amp;quot;Rosanthony&amp;quot;&lt;/code>。&lt;/p>
&lt;p>Clojure 让你用递归来解决这个明显的限制。下面的例子显示了解决递归问题的一般方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">sum&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">➊&lt;/span> &lt;span class="p">([&lt;/span>&lt;span class="nv">vals&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">sum&lt;/span> &lt;span class="nb">vals &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">([&lt;/span>&lt;span class="nb">vals &lt;/span>&lt;span class="nv">accumulating-total&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">➋&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">if &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">empty?&lt;/span> &lt;span class="nv">vals&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">accumulating-total&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">sum&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">rest &lt;/span>&lt;span class="nv">vals&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">first &lt;/span>&lt;span class="nv">vals&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nv">accumulating-total&lt;/span>&lt;span class="p">)))))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个函数需要两个参数，一个要处理的集合（&lt;code>vals&lt;/code>）和一个累加器（&lt;code>accumulating-total&lt;/code>），它使用了 arity 重载（在第三章有介绍），在➊为&lt;code>accumulating-total&lt;/code>提供一个默认值&lt;code>0&lt;/code>。&lt;/p>
&lt;p>像所有的递归解决方案一样，这个函数根据一个基本条件检查它所处理的参数。在这种情况下，我们检查&lt;code>vals&lt;/code>在➋是否为空。如果是，我们知道我们已经处理了集合中的所有元素，所以我们返回`累计-总数&amp;rsquo;。&lt;/p>
&lt;p>如果&lt;code>vals&lt;/code>不是空的，意味着我们还在处理这个序列，所以我们递归调用&lt;code>sum&lt;/code>，给它传递两个参数：用&lt;code>(其余的vals)&lt;/code>表示 vals 的*尾部，用&lt;code>(+(第一个vals)累加总数)&lt;/code>表示&lt;code>vals&lt;/code>的第一个元素与累加总数之和。通过这种方式，我们建立了&lt;code>累积总数&lt;/code>，同时减少&lt;code>vals&lt;/code>，直到它达到空集合的基本情况。&lt;/p>
&lt;p>下面是递归函数调用的情况，如果我们把它每次递归的情况分开，就会是这样的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">sum&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">39&lt;/span> &lt;span class="mi">5&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="c1">; single-arity body calls two-arity body&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">sum&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">39&lt;/span> &lt;span class="mi">5&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">sum&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">5&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="mi">39&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">sum&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="mi">44&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">sum&lt;/span> &lt;span class="p">[]&lt;/span> &lt;span class="mi">45&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">; base case is reached, so return accumulating-total&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; 45&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>对&lt;code>sum&lt;/code>的每次递归调用都会创建一个新的作用域，其中&lt;code>vals&lt;/code>和&lt;code>accumulating-total&lt;/code>被绑定到不同的值上，所有这些都不需要改变最初传递给函数的值或执行任何内部变异。正如你所看到的，你可以在没有突变的情况下顺利完成。&lt;/p>
&lt;p>请注意，出于性能的考虑，在进行递归时，你一般应该使用&lt;code>recur&lt;/code>。原因是 Clojure 不提供尾部调用的优化，这个话题我不会再提了！（请查看这个网址）。(查看这个网址以了解更多信息。&lt;em>&lt;a class="link" href="http://en.wikipedia.org/wiki/Tail_call" target="_blank" rel="noopener"
>http://en.wikipedia.org/wiki/Tail_call&lt;/a>&lt;/em>）。所以你可以用&lt;code>recur&lt;/code>来做这个。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">sum&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">([&lt;/span>&lt;span class="nv">vals&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">sum&lt;/span> &lt;span class="nb">vals &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">([&lt;/span>&lt;span class="nb">vals &lt;/span>&lt;span class="nv">accumulating-total&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">if &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">empty?&lt;/span> &lt;span class="nv">vals&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">accumulating-total&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">recur&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">rest &lt;/span>&lt;span class="nv">vals&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">first &lt;/span>&lt;span class="nv">vals&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nv">accumulating-total&lt;/span>&lt;span class="p">)))))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果你在一个小的集合上进行递归操作，使用&lt;code>recur&lt;/code>并不重要，但如果你的集合包含数千或数百万个值，你肯定需要使用&lt;code>recur&lt;/code>，这样你就不会因为堆栈溢出而使程序爆炸。&lt;/p>
&lt;p>最后一件事! 你可能会说，&amp;ldquo;等一下，如果我最终创造了成千上万的中间值怎么办？这不会因为垃圾收集或其他原因导致程序崩溃吗？&amp;rdquo;&lt;/p>
&lt;p>非常好的问题，鹰眼的读者! 答案是否定的。原因是，在幕后，Clojure 的不可变数据结构是使用&lt;em>结构共享&lt;/em>实现的，这完全超出了本书的范围。这有点像 Git! 如果你想了解更多，请阅读这篇伟大的文章。&lt;em>&lt;a class="link" href="http://hypirion.com/musings/understanding-persistent-vector-pt-1" target="_blank" rel="noopener"
>http://hypirion.com/musings/understanding-persistent-vector-pt-1&lt;/a>&lt;/em>。&lt;/p>
&lt;h3 id="函数组合而不是属性突变">函数组合而不是属性突变&lt;/h3>
&lt;p>你可能习惯于使用突变的另一种方式是建立起一个对象的最终状态。在下面的 Ruby 例子中，&lt;code>GlamourShotCaption&lt;/code>对象使用突变来清理输入，删除尾部的空格并将`&amp;ldquo;lol &amp;ldquo;大写。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">class &lt;/span>&lt;span class="nv">GlamourShotCaption&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">attr_reader&lt;/span> &lt;span class="ss">:text&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def &lt;/span>&lt;span class="nv">initialize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">text&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">@&lt;/span>&lt;span class="nv">text&lt;/span> &lt;span class="nb">= &lt;/span>&lt;span class="nv">text&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">clean!&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">end&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">private&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def &lt;/span>&lt;span class="nv">clean!&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">text.trim!&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">text.gsub!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">/lol/&lt;/span>, &lt;span class="s">&amp;#34;LOL&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">end&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">end&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">best&lt;/span> &lt;span class="nb">= &lt;/span>&lt;span class="nv">GlamourShotCaption.new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;My boa constrictor is so sassy lol! &amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">best.text&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; &amp;#34;My boa constrictor is so sassy LOL!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这段代码中，&lt;code>GlamourShotCaption&lt;/code>类封装了如何清理魅力镜头标题的知识。在创建&lt;code>GlamourShotCaption&lt;/code>对象时，你将文本分配给一个实例变量，并逐步改变它。&lt;/p>
&lt;p>清单 5-1 显示了你如何在 Clojure 中做到这一点。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">require&lt;/span> &lt;span class="o">&amp;#39;&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">clojure.string&lt;/span> &lt;span class="ss">:as&lt;/span> &lt;span class="nv">s&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">clean&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">text&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">s/replace&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">s/trim&lt;/span> &lt;span class="nv">text&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">#&lt;/span>&lt;span class="s">&amp;#34;lol&amp;#34;&lt;/span> &lt;span class="s">&amp;#34;LOL&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">clean&lt;/span> &lt;span class="s">&amp;#34;My boa constrictor is so sassy lol! &amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; &amp;#34;My boa constrictor is so sassy LOL!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>5-1. 使用函数组合来修改一个迷人的镜头标题&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/functional-programming/glamour-boa.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>在第一行，我们使用&lt;code>require&lt;/code>来访问字符串函数库（我将在第六章讨论这个函数和相关概念）。除此之外，这段代码很简单。不需要变异。&lt;code>clean&lt;/code>函数的工作方式是将一个不可变的值&lt;code>text&lt;/code>传递给一个纯函数&lt;code>s/trim&lt;/code>，该函数返回一个不可变的值（&lt;code>&amp;quot;我的蟒蛇真时髦 lol!&amp;quot;&lt;/code>；字符串末尾的空格已经被修剪）。然后，该值被传递给纯函数&lt;code>s/replace&lt;/code>，该函数返回另一个不可变的值（&amp;ldquo;我的蟒蛇是如此的时髦 LOL！&amp;quot;）。&lt;/p>
&lt;p>像这样组合函数&amp;ndash;使一个函数的返回值作为参数传递给另一个函数&amp;ndash;被称为&lt;em>函数组合&lt;/em>。事实上，这与之前使用递归的例子并没有什么不同，因为递归不断地将一个函数的结果传递给另一个函数；它只是碰巧是同一个函数。一般来说，函数式编程鼓励你通过组合更简单的函数来建立更复杂的函数。&lt;/p>
&lt;p>这种比较也开始揭示了面向对象编程（OOP）的一些限制。在 OOP 中，类的主要目的之一是防止对私有数据进行不必要的修改&amp;ndash;这在不可变的数据结构中是没有必要的。你还必须将方法与类紧密结合，从而限制了方法的可重用性。在 Ruby 的例子中，你必须做额外的工作来重复使用&lt;code>clean!&lt;/code>方法。在 Clojure 中，`clean&amp;rsquo;可以对任何字符串起作用。通过 a）将函数和数据解耦，以及 b）根据一组小的抽象进行编程，你最终会得到更多可重用的、可组合的代码。你获得了力量，却没有损失。&lt;/p>
&lt;p>除了直接的实际问题之外，你写面向对象的代码和函数式代码的方式之间的差异指向了两种思维方式之间更深层次的差异。编程是为了你自己邪恶的目的而操纵数据（就像你可以说它是&lt;em>关于&lt;/em>任何东西）。在 OOP 中，你把数据看成是可以体现在一个对象中的东西，你戳戳点点，直到它看起来合适。在这个过程中，你的原始数据会永远丢失，除非你非常小心地保存它。相比之下，在函数式编程中，你认为数据是不变的，你从现有的数据中导出新的数据。在这个过程中，原始数据仍然安全无恙。在前面的 Clojure 例子中，原始标题不会被修改。它是安全的，就像当你把数字加在一起时是安全的一样；当你把 3 加进去时，你不会以某种方式把 4 变成 7。&lt;/p>
&lt;p>一旦你有信心使用不可变的数据结构来完成工作，你会感到更加自信，因为你不必担心有什么肮脏的代码会在你宝贵的、可变的变量上沾上油腻的爪子。这将是很好的!&lt;/p>
&lt;h2 id="用纯函数做的酷事">用纯函数做的酷事&lt;/h2>
&lt;p>你可以从现有的函数中派生出新的函数，就像你从现有的数据中派生出新的数据一样。你已经看到了一个函数，&lt;code>partial&lt;/code>，它可以创建新的函数。本节将向你介绍另外两个函数, &lt;code>comp&lt;/code>和&lt;code>memoize&lt;/code>, 它们依赖于引用透明性, 不变性, 或两者兼有.&lt;/p>
&lt;h3 id="comp">comp&lt;/h3>
&lt;p>像我们在上一节中所做的那样，对纯函数进行组合总是安全的，因为你只需要担心它们的输入/输出关系。组合函数是如此的普遍，以至于 Clojure 提供了一个函数&lt;code>comp&lt;/code>，用于从任意数量的函数组合中创建一个新的函数。下面是一个简单的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">((&lt;/span>&lt;span class="nb">comp inc &lt;/span>&lt;span class="nv">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; 7&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这里，你通过组合&lt;code>inc&lt;/code>和&lt;code>*&lt;/code>函数来创建一个匿名函数。然后，你立即将这个函数应用于参数&lt;code>2&lt;/code>和&lt;code>3&lt;/code>。该函数将数字 2 和 3 相乘，然后将结果递增。使用数学符号，你会说，一般来说，对函数&lt;em>f&lt;/em>1, &lt;em>f&lt;/em>2, &amp;hellip; &lt;em>f&lt;/em>n，创建一个新的函数&lt;em>g&lt;/em>，使得&lt;em>g&lt;/em>(&lt;em>x&lt;/em>1, &lt;em>x&lt;/em>2, &amp;hellip; &lt;em>x&lt;/em>n)等于&lt;em>f&lt;/em>1( &lt;em>f&lt;/em>2( &lt;em>f&lt;/em>n(&lt;em>x&lt;/em>1, &lt;em>x&lt;/em>2, &amp;hellip; &lt;em>x&lt;/em>n))。这里需要注意的一个细节是，第一个应用的函数&amp;ndash;这里显示的代码中的&lt;code>*&lt;/code>&amp;ndash;可以接受任何数量的参数，而其余的函数必须只能接受一个参数。&lt;/p>
&lt;p>下面是一个例子，说明如何使用&lt;code>comp&lt;/code>来检索角色扮演游戏中的角色属性。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="k">def &lt;/span>&lt;span class="nv">character&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;Smooches McCutes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="ss">:attributes&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:intelligence&lt;/span> &lt;span class="mi">10&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="ss">:strength&lt;/span> &lt;span class="mi">4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="ss">:dexterity&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">}})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="k">def &lt;/span>&lt;span class="nv">c-int&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">comp &lt;/span>&lt;span class="ss">:intelligence&lt;/span> &lt;span class="ss">:attributes&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="k">def &lt;/span>&lt;span class="nv">c-str&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">comp &lt;/span>&lt;span class="ss">:strength&lt;/span> &lt;span class="ss">:attributes&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="k">def &lt;/span>&lt;span class="nv">c-dex&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">comp &lt;/span>&lt;span class="ss">:dexterity&lt;/span> &lt;span class="ss">:attributes&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">c-int&lt;/span> &lt;span class="nv">character&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; 10&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">c-str&lt;/span> &lt;span class="nv">character&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; 4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">c-dex&lt;/span> &lt;span class="nv">character&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; 5&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子中，你创建了三个函数来帮助你查询一个角色的属性。你可以不使用&lt;code>comp&lt;/code>，而是为每个属性写成这样的东西。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="k">fn &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">c&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="ss">:strength&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="ss">:attributes&lt;/span> &lt;span class="nv">c&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但&lt;code>comp&lt;/code>更优雅，因为它用更少的代码来表达更多的意思。当你看到 &lt;code>comp&lt;/code>时，你立即知道所产生的函数的目的是以一种众所周知的方式组合现有的函数。&lt;/p>
&lt;p>如果你想组合的一个函数需要接受一个以上的参数，你会怎么做？你把它包在一个匿名函数中。请看下面这个片段，它根据你的角色的智力属性来计算她的法术槽的数量。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">spell-slots&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">char&lt;/span>&lt;span class="err">］&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">int &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">inc &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">/ &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">c-int&lt;/span> &lt;span class="nv">char&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">))))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">spell-slots&lt;/span> &lt;span class="nv">character&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; 6&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>首先，你用智力除以 2，然后加 1，然后用&lt;code>int&lt;/code>函数来取整。下面是你如何用&lt;code>comp&lt;/code>做同样的事情。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="k">def &lt;/span>&lt;span class="nv">spell-slots-comp&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">comp int inc &lt;/span>&lt;span class="o">#&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">/ &lt;/span>&lt;span class="nv">%&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nv">c-int&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>要除以 2，你所要做的就是把除法包在一个匿名函数中。&lt;/p>
&lt;p>Clojure 的&lt;code>comp&lt;/code>函数可以组成任何数量的函数。为了了解它是如何做到这一点的，这里有一个实现，它只组合了两个函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">two-comp&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">f&lt;/span> &lt;span class="nv">g&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nv">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">fn &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="nv">args&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">f&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">apply &lt;/span>&lt;span class="nv">g&lt;/span> &lt;span class="nv">args&lt;/span>&lt;span class="p">))))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我鼓励你求值这段代码，并使用&lt;code>two-comp&lt;/code>来组合两个函数! 另外，尝试重新实现 Clojure 的&lt;code>comp&lt;/code>函数，这样你就可以组成任何数量的函数。&lt;/p>
&lt;h3 id="记忆化">记忆化&lt;/h3>
&lt;p>你可以用纯函数做的另一件很酷的事情是对它们进行备忘，这样 Clojure 就会记住某个特定函数调用的结果。你可以这样做，因为正如你前面所学到的，纯函数在指代上是透明的。例如，&lt;code>+&lt;/code>是指代透明的。你可以把&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="mi">3&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="mi">5&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>替换为&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="mi">3&lt;/span> &lt;span class="mi">13&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>或&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="mi">16&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而程序会有相同的行为。&lt;/p>
&lt;p>Memoization 让你通过存储传递给函数的参数和函数的返回值来利用引用的透明度。这样一来，以后用相同的参数调用该函数就可以立即返回结果。这对于需要大量时间运行的函数特别有用。例如，在这个没有备忘录的函数中，结果在一秒钟后被返回。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">sleepy-identity&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Returns the given value after 1 second&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">x&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">Thread/sleep&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">sleepy-identity&lt;/span> &lt;span class="s">&amp;#34;Mr. Fantastico&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; &amp;#34;Mr. Fantastico&amp;#34; after 1 second&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">sleepy-identity&lt;/span> &lt;span class="s">&amp;#34;Mr. Fantastico&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; &amp;#34;Mr. Fantastico&amp;#34; after 1 second&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然而，如果你用&lt;code>memoize&lt;/code>创建一个新的、记忆化的&lt;code>sleepy-identity&lt;/code>版本，只有第一次调用会等待一秒钟；随后的每个函数调用会立即返回。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="k">def &lt;/span>&lt;span class="nv">memo-sleepy-identity&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">memoize&lt;/span> &lt;span class="nv">sleepy-identity&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">memo-sleepy-identity&lt;/span> &lt;span class="s">&amp;#34;Mr. Fantastico&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; &amp;#34;Mr. Fantastico&amp;#34; after 1 second&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">memo-sleepy-identity&lt;/span> &lt;span class="s">&amp;#34;Mr. Fantastico&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; &amp;#34;Mr. Fantastico&amp;#34; immediately&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>很酷啊! 从这里开始，&lt;code>memo-sleepy-identity&lt;/code>在调用`&amp;ldquo;Mr.Fantastico &amp;ldquo;时将不会产生最初的一秒钟的费用。这个实现对于那些计算密集型的函数或者提出网络请求的函数很有用。&lt;/p>
&lt;h2 id="peg-thing">Peg Thing&lt;/h2>
&lt;p>是时候了! 是时候用你到目前为止所学到的一切来构建 Peg Thing 的终端实现了：不可变的数据结构、懒惰序列、纯函数、递归&amp;ndash;一切！这将有助于你理解如何将这些概念和技术结合起来解决更大的问题。这样做将帮助你理解如何结合这些概念和技术来解决更大的问题。最重要的是，你将学会如何对玩家的每一次移动所产生的变化进行建模，而不必像在 OOP 中那样对对象进行变异。&lt;/p>
&lt;p>为了构建游戏，你将首先学习游戏的机制以及如何启动和播放程序。然后，我将解释代码的组织。最后，我将对每个函数进行讲解。&lt;/p>
&lt;p>你可以在*&lt;a class="link" href="https://www.nostarch.com/clojure/" target="_blank" rel="noopener"
>https://www.nostarch.com/clojure/&lt;/a>*找到 Peg Thing 的完整代码库。&lt;/p>
&lt;h2 id="播放">播放&lt;/h2>
&lt;p>如前所述，Peg Thing 是基于从古至今流传下来的秘密思维磨练工具，现在由 Cracker Barrel 发行。&lt;/p>
&lt;p>如果你不熟悉这个游戏，以下是游戏的机制。你开始时有一个三角形的棋盘，上面布满了钉子的孔，其中一个孔缺少一个钉子，如图 5-1 所示。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/functional-programming/peg-thing-starting.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>图 5-1：Peg Thing 的初始设置&lt;/p>
&lt;p>游戏的目的是尽可能多地移除钉子。你通过*跳过钉子来实现这一目标。在图 5-2 中，图钉 A 跳过图钉 B 进入空洞，你就把图钉 B 从棋盘上移走。&lt;/p>
&lt;p>&lt;a class="link" href="https://www.braveclojure.com/assets/images/cftbat/functional-programming/peg-thing-jumping.png" target="_blank" rel="noopener"
>img&lt;/a>&lt;/p>
&lt;p>图 5-2：跳过一个钉子，把它从棋盘上移走。&lt;/p>
&lt;p>要启动 Peg Thing，请下载代码，然后在&lt;em>pegthing&lt;/em>目录下的终端运行&lt;code>lein run&lt;/code>。出现一个提示，看起来像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">Get&lt;/span> &lt;span class="nv">ready&lt;/span> &lt;span class="nv">to&lt;/span> &lt;span class="nv">play&lt;/span> &lt;span class="nv">Peg&lt;/span> &lt;span class="nv">Thing!&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">How&lt;/span> &lt;span class="nv">many&lt;/span> &lt;span class="nv">rows?&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在你可以输入棋盘的行数，使用&lt;code>5&lt;/code>作为默认值。如果你想要五行，就按回车键（否则，输入一个数字并按回车键）。然后你会看到这个。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">Here&lt;/span>&lt;span class="ss">&amp;#39;s&lt;/span> &lt;span class="nv">your&lt;/span> &lt;span class="nv">board&lt;/span>&lt;span class="err">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">a0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">b0&lt;/span> &lt;span class="nv">c0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">d0&lt;/span> &lt;span class="nv">e0&lt;/span> &lt;span class="nv">f0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">g0&lt;/span> &lt;span class="nv">h0&lt;/span> &lt;span class="nv">i0&lt;/span> &lt;span class="nv">j0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">k0&lt;/span> &lt;span class="nv">l0&lt;/span> &lt;span class="nv">m0&lt;/span> &lt;span class="nv">n0&lt;/span> &lt;span class="nv">o0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">Remove&lt;/span> &lt;span class="nv">which&lt;/span> &lt;span class="nv">peg?&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nv">e&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>每个字母代表棋盘上的一个位置。数字&lt;code>0&lt;/code>（应该是蓝色的，但如果不是，也没什么大不了的）表示一个位置被填满。在游戏开始之前，必须有一个钉子是空的，所以提示要求你输入第一个要移除的钉子的位置。默认是中间的钉子，`e&amp;rsquo;，但你可以选择一个不同的位置。移走棋子后，你会看到这个。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">Here&lt;/span>&lt;span class="ss">&amp;#39;s&lt;/span> &lt;span class="nv">your&lt;/span> &lt;span class="nv">board&lt;/span>&lt;span class="err">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">a0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">b0&lt;/span> &lt;span class="nv">c0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">d0&lt;/span> &lt;span class="nv">e-&lt;/span> &lt;span class="nv">f0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">g0&lt;/span> &lt;span class="nv">h0&lt;/span> &lt;span class="nv">i0&lt;/span> &lt;span class="nv">j0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">k0&lt;/span> &lt;span class="nv">l0&lt;/span> &lt;span class="nv">m0&lt;/span> &lt;span class="nv">n0&lt;/span> &lt;span class="nv">o0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">Move&lt;/span> &lt;span class="nv">from&lt;/span> &lt;span class="nv">where&lt;/span> &lt;span class="nv">to&lt;/span> &lt;span class="nv">where?&lt;/span> &lt;span class="nv">Enter&lt;/span> &lt;span class="nv">two&lt;/span> &lt;span class="nv">letters&lt;/span>&lt;span class="err">:&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，&lt;code>e&lt;/code>位置现在有一个破折号，&lt;code>-&lt;/code>（应该是红色的，但如果不是，也没什么大不了的）。这个破折号表示这个位置是空的。要移动，你要输入你想*拿起的棋子的位置，然后是你想把它放在的空位置的位置。例如，如果你输入`le&amp;rsquo;，你会得到这样的结果。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">Here&lt;/span>&lt;span class="ss">&amp;#39;s&lt;/span> &lt;span class="nv">your&lt;/span> &lt;span class="nv">board&lt;/span>&lt;span class="err">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">a0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">b0&lt;/span> &lt;span class="nv">c0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">d0&lt;/span> &lt;span class="nv">e0&lt;/span> &lt;span class="nv">f0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">g0&lt;/span> &lt;span class="nv">h-&lt;/span> &lt;span class="nv">i0&lt;/span> &lt;span class="nv">j0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">k0&lt;/span> &lt;span class="nv">l-&lt;/span> &lt;span class="nv">m0&lt;/span> &lt;span class="nv">n0&lt;/span> &lt;span class="nv">o0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">Move&lt;/span> &lt;span class="nv">from&lt;/span> &lt;span class="nv">where&lt;/span> &lt;span class="nv">to&lt;/span> &lt;span class="nv">where?&lt;/span> &lt;span class="nv">Enter&lt;/span> &lt;span class="nv">two&lt;/span> &lt;span class="nv">letters&lt;/span>&lt;span class="err">:&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你把棋子从&lt;code>l&lt;/code>移到&lt;code>e&lt;/code>，跳过&lt;code>h&lt;/code>，根据图 5-2 所示的规则移走它的棋子。游戏继续提示你走棋，直到没有棋子可用为止，这时它就会提示你再次下棋。&lt;/p>
&lt;h3 id="代码组织">代码组织&lt;/h3>
&lt;p>该程序必须处理四个主要任务，源代码也相应地组织起来，每个任务的函数都归为一组。&lt;/p>
&lt;ol>
&lt;li>创建一个新的棋盘&lt;/li>
&lt;li>返回一个带有棋手行动结果的棋盘&lt;/li>
&lt;li>用文字表示棋盘&lt;/li>
&lt;li>处理用户互动&lt;/li>
&lt;/ol>
&lt;p>关于组织结构还有两点。首先，代码有一个基本的&lt;em>架构&lt;/em>，或概念性的组织，由两层组成。顶层由处理用户交互的函数组成。这些函数产生了程序的所有副作用，打印出棋盘并为玩家的互动提供提示。这一层的函数使用底层的函数来创建一个新的棋盘，进行移动，并创建一个文本表述，但底层的函数完全不使用顶层的函数。即使是这么小的程序，一个小小的架构也有助于使代码更容易管理。&lt;/p>
&lt;p>第二，我尽可能地将任务分解成小的函数，以便每个函数都做一个微小的、可理解的任务。其中一些函数只被另外一个函数使用。我发现这很有帮助，因为它可以让我为每个微小的子任务命名，使我能够更好地表达代码的意图。&lt;/p>
&lt;p>但在所有的架构之前，还有这个。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">ns &lt;/span>&lt;span class="nv">pegthing.core&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">require&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nv">clojure.set&lt;/span> &lt;span class="ss">:as&lt;/span> &lt;span class="nv">set&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="ss">:gen-class&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">declare &lt;/span>&lt;span class="nv">successful-move&lt;/span> &lt;span class="nv">prompt-move&lt;/span> &lt;span class="nv">game-over&lt;/span> &lt;span class="nv">query-rows&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我将在第六章详细解释这里的函数。如果你好奇这是怎么回事，简短的解释是：&lt;code>(&lt;/code>require &lt;code>[&lt;/code>clojure&lt;code>.set :as set])&lt;/code>允许你轻松使用&lt;code>clojure.set&lt;/code>命名空间的函数，&lt;code>(:gen-class)&lt;/code>允许你从命令行运行程序，&lt;code>(declaration successful-move prompt-move game-over query-rows)&lt;/code>允许函数在被定义之前引用这些名称。如果这还不太明白，相信我很快就会解释。&lt;/p>
&lt;h3 id="创建棋盘">创建棋盘&lt;/h3>
&lt;p>你用来表示棋盘的数据结构应该使你能够很容易地打印棋盘，检查棋手是否下了一步有效的棋，实际执行一步棋，以及检查游戏是否结束。你可以用很多方式来构造棋盘，以实现这些任务。在这种情况下，你将用一个 Map 来表示棋盘，Map 上有对应于每个棋盘位置的数字键和包含该位置连接信息的值。该 Map 还将包含一个&lt;code>:rows&lt;/code>键，存储行的总数。图 5-3 显示了一个有每个位置编号的棋盘。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/functional-programming/peg-thing-data-structure.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>图 5-3：有编号的钉子板&lt;/p>
&lt;p>下面是为表示它而建立的数据结构。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:pegged&lt;/span> &lt;span class="nv">true&lt;/span>, &lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">6&lt;/span> &lt;span class="mi">3&lt;/span>, &lt;span class="mi">4&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">}}&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">2&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:pegged&lt;/span> &lt;span class="nv">true&lt;/span>, &lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">9&lt;/span> &lt;span class="mi">5&lt;/span>, &lt;span class="mi">7&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">}}&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">3&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:pegged&lt;/span> &lt;span class="nv">true&lt;/span>, &lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">10&lt;/span> &lt;span class="mi">6&lt;/span>, &lt;span class="mi">8&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">}}&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">4&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:pegged&lt;/span> &lt;span class="nv">true&lt;/span>, &lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">13&lt;/span> &lt;span class="mi">8&lt;/span>, &lt;span class="mi">11&lt;/span> &lt;span class="mi">7&lt;/span>, &lt;span class="mi">6&lt;/span> &lt;span class="mi">5&lt;/span>, &lt;span class="mi">1&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">}}&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">5&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:pegged&lt;/span> &lt;span class="nv">true&lt;/span>, &lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">14&lt;/span> &lt;span class="mi">9&lt;/span>, &lt;span class="mi">12&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">}}&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">6&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:pegged&lt;/span> &lt;span class="nv">true&lt;/span>, &lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">15&lt;/span> &lt;span class="mi">10&lt;/span>, &lt;span class="mi">13&lt;/span> &lt;span class="mi">9&lt;/span>, &lt;span class="mi">4&lt;/span> &lt;span class="mi">5&lt;/span>, &lt;span class="mi">1&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">}}&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">7&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:pegged&lt;/span> &lt;span class="nv">true&lt;/span>, &lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">9&lt;/span> &lt;span class="mi">8&lt;/span>, &lt;span class="mi">2&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">}}&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">8&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:pegged&lt;/span> &lt;span class="nv">true&lt;/span>, &lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">10&lt;/span> &lt;span class="mi">9&lt;/span>, &lt;span class="mi">3&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">}}&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">9&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:pegged&lt;/span> &lt;span class="nv">true&lt;/span>, &lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">7&lt;/span> &lt;span class="mi">8&lt;/span>, &lt;span class="mi">2&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">}}&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">10&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:pegged&lt;/span> &lt;span class="nv">true&lt;/span>, &lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">8&lt;/span> &lt;span class="mi">9&lt;/span>, &lt;span class="mi">3&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">}}&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">11&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:pegged&lt;/span> &lt;span class="nv">true&lt;/span>, &lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">13&lt;/span> &lt;span class="mi">12&lt;/span>, &lt;span class="mi">4&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">}}&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">12&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:pegged&lt;/span> &lt;span class="nv">true&lt;/span>, &lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">14&lt;/span> &lt;span class="mi">13&lt;/span>, &lt;span class="mi">5&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">}}&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">13&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:pegged&lt;/span> &lt;span class="nv">true&lt;/span>, &lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">15&lt;/span> &lt;span class="mi">14&lt;/span>, &lt;span class="mi">11&lt;/span> &lt;span class="mi">12&lt;/span>, &lt;span class="mi">6&lt;/span> &lt;span class="mi">9&lt;/span>, &lt;span class="mi">4&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">}}&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">14&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:pegged&lt;/span> &lt;span class="nv">true&lt;/span>, &lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">12&lt;/span> &lt;span class="mi">13&lt;/span>, &lt;span class="mi">5&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">}}&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">15&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:pegged&lt;/span> &lt;span class="nv">true&lt;/span>, &lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">13&lt;/span> &lt;span class="mi">14&lt;/span>, &lt;span class="mi">6&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">}}&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="ss">:rows&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可能会想，为什么在你玩游戏的时候，每个位置都用字母表示，而在这里，位置却用数字表示。使用数字作为内部表示，可以让你在验证和下棋时利用棋盘布局的一些数学特性。另一方面，字母则更适合于显示，因为它们只占用一个字符空间。一些转换函数在&lt;a class="link" href="https://www.braveclojure.com/functional-programming/#Anchor-19" target="_blank" rel="noopener"
>第 120 页的 &amp;ldquo;渲染和打印棋盘&amp;rdquo;&lt;/a>中有所介绍。&lt;/p>
&lt;p>在数据结构中，每个位置都与一个 Map 相关联，其内容是这样的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>&lt;span class="ss">:pegged&lt;/span> &lt;span class="nv">true&lt;/span>, &lt;span class="ss">:connection&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">6&lt;/span> &lt;span class="mi">3&lt;/span>, &lt;span class="mi">4&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">}}&lt;/span>&lt;span class="nv">.&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>pegged &amp;ldquo;的含义很清楚；它表示该位置是否有一个钉子。`:connections&amp;rsquo;就比较隐蔽了。它是一个 Map，每个键标识一个&lt;em>合法的目的地，每个值代表&lt;/em>将被&lt;em>跳过的位置。例如，位置 1 的棋子可以&lt;/em>跳到*位置 6，&lt;em>越过&lt;/em>位置 3。这可能看起来很落后，但当你看到棋步验证是如何实现的时候，你就会明白其中的道理。&lt;/p>
&lt;p>现在你已经看到了代表棋盘的最终 Map 应该是什么样子的，我们可以开始探索在程序中实际建立这个 Map 的函数了。你不会简单地开始随意地分配可变状态来表示每个位置以及它是否被钉住。相反，你将使用嵌套的递归函数调用来逐个建立最终的棋盘位置。这类似于你之前创建魅力镜头标题的方式，通过将参数传递给一连串的函数，从输入中获得新的数据，从而得到最终结果。&lt;/p>
&lt;p>本节代码中的前几个表达式是关于三角形数的。三角形数是由前&lt;em>n&lt;/em>个自然数相加产生的。第一个三角数是 1，第二个是 3（1+2），第三个是 6（1+2+3），以此类推。这些数字很好地与棋盘上每一行末尾的位置数字相一致，这将成为一个非常有用的属性。首先，你定义了函数&lt;code>tri*&lt;/code>，它可以创建一个三角形数字的懒散序列。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">tri*&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Generates 惰性序列uence of triangular numbers&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">([]&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">tri*&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">([&lt;/span>&lt;span class="nv">sum&lt;/span> &lt;span class="nv">n&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">let &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">new-sum&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="nv">sum&lt;/span> &lt;span class="nv">n&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">cons &lt;/span>&lt;span class="nv">new-sum&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">lazy-seq&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">tri*&lt;/span> &lt;span class="nv">new-sum&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">inc &lt;/span>&lt;span class="nv">n&lt;/span>&lt;span class="p">)))))))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>快速回顾一下工作原理，调用没有参数的&lt;code>tri*&lt;/code>会递归调用&lt;code>(tri* 0 1)&lt;/code>。这将返回一个懒惰列表，其元素是 &amp;ldquo;new-sum&amp;rdquo;，在本例中它的值为 &amp;ldquo;1&amp;rdquo;。懒惰列表包括一个配方，用于在请求时生成列表的下一个元素，如第四章所述。&lt;/p>
&lt;p>下一个表达式调用&lt;code>tri*&lt;/code>，实际上是创建懒惰序列并将其绑定到&lt;code>tri&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="k">def &lt;/span>&lt;span class="nv">tri&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">tri*&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以验证它是否真的有效。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">take &lt;/span>&lt;span class="mi">5&lt;/span> &lt;span class="nv">tri&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; (1 3 6 10 15)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来的几个函数对三角形数的序列进行操作。&lt;code>triangular?&lt;/code>找出它的参数是否在&lt;code>tri&lt;/code>懒惰序列中。它通过使用&lt;code>take-while&lt;/code>创建一个三角形数列，其最后一个元素是一个小于或等于参数的三角形数。然后它将最后一个元素与参数进行比较。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">triangular?&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Is the number triangular? e.g. 1, 3, 6, 10, 15, etc&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">n&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">= &lt;/span>&lt;span class="nv">n&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">last &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">take-while &lt;/span>&lt;span class="o">#&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">&amp;gt;= &lt;/span>&lt;span class="nv">n&lt;/span> &lt;span class="nv">%&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nv">tri&lt;/span>&lt;span class="p">))))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">triangular?&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">triangular?&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来是&lt;code>row-tri&lt;/code>，它接收一个行号，并给出该行末尾的三角形数字。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">row-tri&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;The triangular number at the end of row n&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">n&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">last &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">take &lt;/span>&lt;span class="nv">n&lt;/span> &lt;span class="nv">tri&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">row-tri&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; 1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">row-tri&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; 3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">row-tri&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; 6&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后，还有&lt;code>row-num&lt;/code>，它接收一个棋盘位置，并返回它所属的行。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">row-num&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Returns row number the position belongs to: pos 1 in row 1,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> positions 2 and 3 in row 2, etc&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">pos&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">inc &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">count &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">take-while &lt;/span>&lt;span class="o">#&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">&amp;gt; &lt;/span>&lt;span class="nv">pos&lt;/span> &lt;span class="nv">%&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nv">tri&lt;/span>&lt;span class="p">))))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">row-num&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; 1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">row-num&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; 3&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>之后是&lt;code>connect&lt;/code>，它被用来在两个位置之间实际形成相互连接。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">connect&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Form a mutual connection between two positions&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span> &lt;span class="nv">max-pos&lt;/span> &lt;span class="nv">pos&lt;/span> &lt;span class="nv">neighbor&lt;/span> &lt;span class="nv">destination&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">if &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">&amp;lt;= &lt;/span>&lt;span class="nv">destination&lt;/span> &lt;span class="nv">max-pos&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">reduce &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">fn &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">new-board&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nv">p1&lt;/span> &lt;span class="nv">p2&lt;/span>&lt;span class="p">]]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">assoc-in&lt;/span> &lt;span class="nv">new-board&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nv">p1&lt;/span> &lt;span class="ss">:connections&lt;/span> &lt;span class="nv">p2&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="nv">neighbor&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">board&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[[&lt;/span>&lt;span class="nv">pos&lt;/span> &lt;span class="nv">destination&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nv">destination&lt;/span> &lt;span class="nv">pos&lt;/span>&lt;span class="p">]])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">board&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">connect&lt;/span> &lt;span class="p">{}&lt;/span> &lt;span class="mi">15&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; {1 {:connections {4 2}}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">4&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">}}}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>connect&lt;/code>做的第一件事是检查目的地是否真的是棋盘上的一个位置，确认它是否小于棋盘的最大位置。例如，如果你有五行，最大位置是 15。然而，当游戏棋盘被创建时，&lt;code>connect&lt;/code>函数将被调用，参数为&lt;code>(connect {} 15 7 16 22)&lt;/code>。&lt;code>connect&lt;/code>开头的&lt;code>if&lt;/code>语句确保你的程序不允许这种离谱的连接，当你要求它做一些愚蠢的事情时，它只是返回未修改的棋盘。&lt;/p>
&lt;p>接下来，&lt;code>connect&lt;/code>通过&lt;code>reduce&lt;/code>使用递归，逐步建立起棋盘的最终状态。在这个例子中，你正在减少嵌套 Vector&lt;code>[[1 4] [4 1]]。这就是允许你返回一个更新的棋盘，&lt;/code>pos&amp;rsquo;和`destination&amp;rsquo;（1 和 4）在它们的连接中都指向对方。&lt;/p>
&lt;p>传给&lt;code>reduce&lt;/code>的匿名函数使用了一个你以前没有见过的函数&lt;code>assoc-in&lt;/code>。函数&lt;code>get-in&lt;/code>可以让你在嵌套的 Map 中查找值，而&lt;code>assoc-in&lt;/code>可以让你在指定的嵌套中返回一个带有给定值的新 Map。下面是几个例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">assoc-in&lt;/span> &lt;span class="p">{}&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="ss">:cookie&lt;/span> &lt;span class="ss">:monster&lt;/span> &lt;span class="ss">:vocals&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="s">&amp;#34;Finntroll&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; {:cookie {:monster {:vocals &amp;#34;Finntroll&amp;#34;}}}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">get-in&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:cookie&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:monster&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:vocals&lt;/span> &lt;span class="s">&amp;#34;Finntroll&amp;#34;&lt;/span>&lt;span class="p">}}}&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="ss">:cookie&lt;/span> &lt;span class="ss">:monster&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; {:vocals &amp;#34;Finntroll&amp;#34;}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">assoc-in&lt;/span> &lt;span class="p">{}&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="ss">:connections&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; {1 {:connections {4 2}}}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这些例子中，你可以看到，新的、嵌套的 Map 被创建，以适应所有提供的键。&lt;/p>
&lt;p>现在我们有了一个连接两个位置的方法，但程序首先应该如何选择两个位置来连接呢？这由&lt;code>connect-right&lt;/code>、&lt;code>connect-down-left&lt;/code>和&lt;code>connect-down-right&lt;/code>来处理。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">connect-right&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span> &lt;span class="nv">max-pos&lt;/span> &lt;span class="nv">pos&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">let &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">neighbor&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">inc &lt;/span>&lt;span class="nv">pos&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">destination&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">inc &lt;/span>&lt;span class="nv">neighbor&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">if-not &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">or &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">triangular?&lt;/span> &lt;span class="nv">neighbor&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">triangular?&lt;/span> &lt;span class="nv">pos&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">connect&lt;/span> &lt;span class="nv">board&lt;/span> &lt;span class="nv">max-pos&lt;/span> &lt;span class="nv">pos&lt;/span> &lt;span class="nv">neighbor&lt;/span> &lt;span class="nv">destination&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">board&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">connect-down-left&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span> &lt;span class="nv">max-pos&lt;/span> &lt;span class="nv">pos&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">let &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">row&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">row-num&lt;/span> &lt;span class="nv">pos&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">neighbor&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="nv">row&lt;/span> &lt;span class="nv">pos&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">destination&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="nv">row&lt;/span> &lt;span class="nv">neighbor&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">connect&lt;/span> &lt;span class="nv">board&lt;/span> &lt;span class="nv">max-pos&lt;/span> &lt;span class="nv">pos&lt;/span> &lt;span class="nv">neighbor&lt;/span> &lt;span class="nv">destination&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">connect-down-right&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span> &lt;span class="nv">max-pos&lt;/span> &lt;span class="nv">pos&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">let &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">row&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">row-num&lt;/span> &lt;span class="nv">pos&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">neighbor&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="nv">row&lt;/span> &lt;span class="nv">pos&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">destination&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="nv">row&lt;/span> &lt;span class="nv">neighbor&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">connect&lt;/span> &lt;span class="nv">board&lt;/span> &lt;span class="nv">max-pos&lt;/span> &lt;span class="nv">pos&lt;/span> &lt;span class="nv">neighbor&lt;/span> &lt;span class="nv">destination&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这些函数分别取了棋盘的最大位置和一个棋盘的位置，并使用一个小的三角形数学来计算出哪些数字要送入&lt;code>connect&lt;/code>。例如，&lt;code>connect-down-left&lt;/code>将试图连接位置 1 和位置 4。如果你想知道为什么没有定义&lt;code>connect-left&lt;/code>、&lt;code>connect-up-left&lt;/code>和&lt;code>connect-up-right&lt;/code>函数，原因是现有的函数实际上涵盖了这些情况。&lt;code>connect&lt;/code>返回一个建立了相互连接的棋盘；当 4&lt;em>向右&lt;/em>连接到 6 时，6&lt;em>向左&lt;/em>连接到 4。 下面是几个例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">connect-down-left&lt;/span> &lt;span class="p">{}&lt;/span> &lt;span class="mi">15&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; {1 {:connections {4 2}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">4&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">}}}}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">connect-down-right&lt;/span> &lt;span class="p">{}&lt;/span> &lt;span class="mi">15&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; {3 {:connections {10 6}}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">10&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">3&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">}}}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在第一个例子中，&lt;code>connect&lt;/code>-down-left&lt;code>接收一个最大位置为15的空棋盘，并返回一个新的棋盘，该棋盘上有1和它下面及左边的位置之间的相互连接。&lt;/code>connect&lt;code>-down-right&lt;/code>做了类似的事情，返回一个由 3 和它下面及右边的位置之间的相互连接组成的棋盘。&lt;/p>
&lt;p>下一个函数，`add-pos&amp;rsquo;，很有趣，因为它实际上是在一个&lt;em>函数&lt;/em>的 Vector 上进行还原，依次应用每个函数来建立结果的棋盘。但它首先更新棋盘，以表示一个棋子在给定的位置上。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">add-pos&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Pegs the position and performs connections&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span> &lt;span class="nv">max-pos&lt;/span> &lt;span class="nv">pos&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">let &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">pegged-board&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">assoc-in&lt;/span> &lt;span class="nv">board&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nv">pos&lt;/span> &lt;span class="ss">:pegged&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="nv">true&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">reduce &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">fn &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">new-board&lt;/span> &lt;span class="nv">connection-creation-fn&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">connection-creation-fn&lt;/span> &lt;span class="nv">new-board&lt;/span> &lt;span class="nv">max-pos&lt;/span> &lt;span class="nv">pos&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">pegged-board&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">connect-right&lt;/span> &lt;span class="nv">connect-down-left&lt;/span> &lt;span class="nv">connect-down-right&lt;/span>&lt;span class="p">])))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">add-pos&lt;/span> &lt;span class="p">{}&lt;/span> &lt;span class="mi">15&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">6&lt;/span> &lt;span class="mi">3&lt;/span>, &lt;span class="mi">4&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">}&lt;/span>, &lt;span class="ss">:pegged&lt;/span> &lt;span class="nv">true&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">4&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">}}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">6&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">}}}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就像这个函数首先在&lt;code>pegged-board&lt;/code>绑定中说：&amp;ldquo;在棋盘的 X 位置添加一个钉子。&amp;rdquo; 然后，在 &amp;ldquo;reduce &amp;ldquo;中，它说：&amp;ldquo;在 X 的位置上采取新钉子的棋盘，并尝试将 X 的位置连接到一个合法的、向右的位置。取该操作产生的棋盘，并尝试将位置 X 连接到一个合法的、向左下方的位置。最后，取该*操作产生的棋盘，并尝试将位置 X 连接到合法的右下位置。返回所得到的棋盘&amp;rdquo;。&lt;/p>
&lt;p>像这样对函数进行还原是组成函数的另一种方式。为了说明这一点，下面是清单 5-1（&lt;a class="link" href="https://www.braveclojure.com/functional-programming/#Anchor-20" target="_blank" rel="noopener"
>第 103 页&lt;/a>）中定义&lt;code>clean&lt;/code>函数的另一种方式。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">clean&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">text&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">reduce &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">fn &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">string&lt;/span> &lt;span class="nv">string-fn&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">string-fn&lt;/span> &lt;span class="nv">string&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">text&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">s/trim&lt;/span> &lt;span class="o">#&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">s/replace&lt;/span> &lt;span class="nv">%&lt;/span> &lt;span class="o">#&lt;/span>&lt;span class="s">&amp;#34;lol&amp;#34;&lt;/span> &lt;span class="s">&amp;#34;LOL&amp;#34;&lt;/span>&lt;span class="p">)]))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个对&lt;code>clean&lt;/code>的重新定义减少了一个函数 Vector，将第一个函数&lt;code>s/trim&lt;/code>应用于初始字符串，然后将下一个函数，匿名函数&lt;code>#(s/replace % #&amp;quot;lol&amp;quot; &amp;quot;LOL&amp;quot;)&lt;/code>，应用于结果。&lt;/p>
&lt;p>对一个函数集合进行缩减并不是一个你经常使用的技术，但它偶尔会很有用，而且它显示了函数式编程的多函数性。&lt;/p>
&lt;p>最后一个创建棋盘的函数是&lt;code>new-board&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">new-board&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Creates a new board with the given number of rows&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">rows&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">let &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">initial-board&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:rows&lt;/span> &lt;span class="nv">rows&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">max-pos&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">row-tri&lt;/span> &lt;span class="nv">rows&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">reduce &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">fn &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span> &lt;span class="nv">pos&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">add-pos&lt;/span> &lt;span class="nv">board&lt;/span> &lt;span class="nv">max-pos&lt;/span> &lt;span class="nv">pos&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">initial-board&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">range &lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">inc &lt;/span>&lt;span class="nv">max-pos&lt;/span>&lt;span class="p">)))))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段代码首先创建了初始的、空的棋盘，并得到了最大的位置。假设你使用的是 5 行，最大位置将是 15。接下来，该函数使用&lt;code>(range 1 (inc max-pos))&lt;/code>得到一个从 1 到 15 的数字列表，也就是棋盘的位置。最后，它对位置列表进行还原。缩减的每一次迭代都会调用&lt;code>(add-pos board max-pos pos)&lt;/code>，正如你前面所看到的，它获取一个现有的棋盘，并返回一个新的棋盘，并添加位置。&lt;/p>
&lt;h3 id="移动图钉">移动图钉&lt;/h3>
&lt;p>下一节代码将验证并执行钉子的移动。许多函数（&lt;code>pegged?&lt;/code>, &lt;code>remove-peg&lt;/code>, &lt;code>place-peg&lt;/code>, &lt;code>move-peg&lt;/code>）都是简单的、不言自明的单行代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">pegged?&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Does the position have a peg in it?&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span> &lt;span class="nv">pos&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">get-in&lt;/span> &lt;span class="nv">board&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nv">pos&lt;/span> &lt;span class="ss">:pegged&lt;/span>&lt;span class="p">]))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">remove-peg&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Take the peg at given position out of the board&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span> &lt;span class="nv">pos&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">assoc-in&lt;/span> &lt;span class="nv">board&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nv">pos&lt;/span> &lt;span class="ss">:pegged&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="nv">false&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">place-peg&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Put a peg in the board at given position&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span> &lt;span class="nv">pos&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">assoc-in&lt;/span> &lt;span class="nv">board&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nv">pos&lt;/span> &lt;span class="ss">:pegged&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="nv">true&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">move-peg&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Take peg out of p1 and place it in p2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span> &lt;span class="nv">p1&lt;/span> &lt;span class="nv">p2&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">place-peg&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">remove-peg&lt;/span> &lt;span class="nv">board&lt;/span> &lt;span class="nv">p1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nv">p2&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>让我们花点时间来欣赏一下这段代码是多么的整洁。在面向对象的程序中，你通常会在这里进行突变；毕竟，你还能如何改变棋盘？然而，这些都是纯函数，而且它们很好地完成了工作。我还喜欢你不需要类的开销来使用这些小家伙。这样的编程感觉更轻松。&lt;/p>
&lt;p>接下来是&lt;code>valid-moves&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">valid-moves&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Return a map of all valid moves for pos, where the key is the
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> destination and the value is the jumped position&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span> &lt;span class="nv">pos&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">into &lt;/span>&lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">filter &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">fn &lt;/span>&lt;span class="p">[[&lt;/span>&lt;span class="nv">destination&lt;/span> &lt;span class="nv">jumped&lt;/span>&lt;span class="p">]]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">and &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">not &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">pegged?&lt;/span> &lt;span class="nv">board&lt;/span> &lt;span class="nv">destination&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">pegged?&lt;/span> &lt;span class="nv">board&lt;/span> &lt;span class="nv">jumped&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">get-in&lt;/span> &lt;span class="nv">board&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nv">pos&lt;/span> &lt;span class="ss">:connections&lt;/span>&lt;span class="p">]))))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段代码浏览了给定位置的每个连接，并测试目的地位置是否为空，跳转的位置是否有钉子。为了看到这个动作，你可以创建一个 4 号位置为空的棋盘。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="k">def &lt;/span>&lt;span class="nv">my-board&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">assoc-in&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">new-board&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">4&lt;/span> &lt;span class="ss">:pegged&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="nv">false&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>图 5-4 显示了这个棋盘的样子。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/functional-programming/peg-thing-valid-moves.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>图 5-4：4 号位置为空的钉子板&lt;/p>
&lt;p>考虑到这个棋盘，1、6、11 和 13 位有有效的棋步，但其他位置都没有。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">valid-moves&lt;/span> &lt;span class="nv">my-board&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">; =&amp;gt; {4 2}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">valid-moves&lt;/span> &lt;span class="nv">my-board&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">; =&amp;gt; {4 5}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">valid-moves&lt;/span> &lt;span class="nv">my-board&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">; =&amp;gt; {4 7}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">valid-moves&lt;/span> &lt;span class="nv">my-board&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">; =&amp;gt; {}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">valid-moves&lt;/span> &lt;span class="nv">my-board&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">; =&amp;gt; {}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可能想知道为什么&lt;code>valid-moves&lt;/code>会返回一个 Map 而不是一个集合或 Vector。原因是，返回 Map 允许你轻松地查找目标位置，以检查特定的棋步是否有效，这就是&lt;code>valid-move?&lt;/code>（下一个函数）的作用。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">valid-move?&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Return jumped position if the move from p1 to p2 is valid, nil
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> otherwise&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span> &lt;span class="nv">p1&lt;/span> &lt;span class="nv">p2&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">get &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">valid-moves&lt;/span> &lt;span class="nv">board&lt;/span> &lt;span class="nv">p1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nv">p2&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">valid-move?&lt;/span> &lt;span class="nv">my-board&lt;/span> &lt;span class="mi">8&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">; =&amp;gt; nil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">valid-move?&lt;/span> &lt;span class="nv">my-board&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">; =&amp;gt; 2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，&lt;code>valid-move?&lt;/code>从 Map 上查找目标位置，然后返回将被跳过的钉子的位置。这是让&lt;code>valid-moves&lt;/code>返回 Map 的另一个很好的好处，因为从 Map 中获取的跳跃位置正是我们想要传递给下一个函数&lt;code>make-move&lt;/code>的东西。当你花时间构建一个丰富的数据结构时，执行有用的操作会更容易。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">make-move&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Move peg from p1 to p2, removing jumped peg&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span> &lt;span class="nv">p1&lt;/span> &lt;span class="nv">p2&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">if-let &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">jumped&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">valid-move?&lt;/span> &lt;span class="nv">board&lt;/span> &lt;span class="nv">p1&lt;/span> &lt;span class="nv">p2&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">move-peg&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">remove-peg&lt;/span> &lt;span class="nv">board&lt;/span> &lt;span class="nv">jumped&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nv">p1&lt;/span> &lt;span class="nv">p2&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>if-let&lt;/code>是一种很好的方式，表示 &amp;ldquo;如果一个表达式求值为一个真实的值，那么就把这个值绑定到一个名字上，就像我在&lt;code>let&lt;/code>表达式中一样。否则，如果我提供了一个 &amp;ldquo;else &amp;ldquo;子句，就执行该 &amp;ldquo;else &amp;ldquo;子句；如果我没有提供 &amp;ldquo;else &amp;ldquo;子句，就返回 &amp;ldquo;nil&amp;rdquo;。在这种情况下，测试表达式是&lt;code>(valid-move? board p1 p2)&lt;/code>，如果结果是真实的，你要把结果分配给&lt;code>jumped&lt;/code>这个名字。这将用于调用&lt;code>move-peg&lt;/code>，它将返回一个新棋盘。你没有提供 &amp;ldquo;else &amp;ldquo;子句，所以如果移动无效，整个表达式的返回值为 &amp;ldquo;nil&amp;rdquo;。&lt;/p>
&lt;p>最后，函数`can-move? 是用来确定游戏是否结束的，方法是找到第一个有棋步的钉子位置。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">can-move?&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Do any of the pegged positions have valid moves?&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">some &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">comp &lt;/span>&lt;span class="nv">not-empty&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">partial &lt;/span>&lt;span class="nv">valid-moves&lt;/span> &lt;span class="nv">board&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">map first &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">filter &lt;/span>&lt;span class="o">#&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">get &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">second &lt;/span>&lt;span class="nv">%&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ss">:pegged&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nv">board&lt;/span>&lt;span class="p">))))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个函数名称末尾的问号表明它是一个&lt;em>谓词函数&lt;/em>，这个函数是为了在布尔表达式中使用。&lt;em>谓词&lt;/em>取自谓词逻辑，它关注的是确定一个语句是真还是假。(你已经看到了一些内置的谓词函数，如&lt;code>empty?&lt;/code>和&lt;code>every?&lt;/code>。)&lt;/p>
&lt;p>&lt;code>can-move?&lt;/code>的工作原理是通过&lt;code>(map first (filter #(get (second %) :pegged) board))&lt;/code>获得一个所有挂点的序列。你可以将其进一步分解为&lt;code>filter'和&lt;/code>map&amp;rsquo;的函数调用：因为&lt;code>filter'是一个seq函数，它将&lt;/code>board&amp;rsquo;，一个 Map，转换成一个两元素 Vector 的 seq（也称为&lt;em>tuples&lt;/em>），看起来像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">([&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:connection&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">6&lt;/span> &lt;span class="mi">3&lt;/span>, &lt;span class="mi">4&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">}&lt;/span>, &lt;span class="ss">:pegged&lt;/span> &lt;span class="nv">true&lt;/span>&lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:connections&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">9&lt;/span> &lt;span class="mi">5&lt;/span>, &lt;span class="mi">7&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">}&lt;/span>, &lt;span class="ss">:pegged&lt;/span> &lt;span class="nv">true&lt;/span>&lt;span class="p">}])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>元组的第一个元素是一个位置号，第二个元素是该位置的信息。&lt;code>filter&lt;/code>然后将匿名函数&lt;code>#(get (second %) :pegged)&lt;/code>应用于这些元组中的每一个，过滤掉那些位置信息表明该位置目前没有挂点的元组。最后，结果被传递给&lt;code>map&lt;/code>，它在每个元组上调用&lt;code>first&lt;/code>，只从元组中抓取位置号。&lt;/p>
&lt;p>当你得到一连串的钉子位置号码后，你对每个位置调用一个谓词函数，找到第一个返回真值的位置。这个谓词函数是用&lt;code>(&lt;/code>comp not-empty (&lt;code>partial valid-moves board))&lt;/code>创建的。我们的想法是首先返回一个位置的所有有效棋步的 Map，然后测试该 Map 是否为空。&lt;/p>
&lt;p>首先，表达式&lt;code>(partial valid-moves board)&lt;/code>从&lt;code>valid-moves&lt;/code>派生出一个匿名函数，第一个参数&lt;code>board&lt;/code>用&lt;code>partial&lt;/code>填入（因为你每次调用&lt;code>valid-moves&lt;/code>时使用的是同一个棋盘）。这个新函数可以接受一个位置，并返回它在当前棋盘上的所有有效棋步的 Map。&lt;/p>
&lt;p>第二，你用&lt;code>comp&lt;/code>将这个函数与&lt;code>not-empty&lt;/code>组成。这个函数是自述的；如果给定的集合是空的，它返回 &amp;ldquo;true&amp;rdquo;，否则返回 &amp;ldquo;false&amp;rdquo;。&lt;/p>
&lt;p>这段代码最有趣的地方在于，你在使用一个函数链来推导一个新的函数，类似于你使用函数链来推导新的数据。在第三章中，你了解到 Clojure 将函数视为数据，因为函数可以接收函数作为参数并返回。希望这能说明为什么这个函数是有趣和有用的。&lt;/p>
&lt;h3 id="渲染和打印棋盘">渲染和打印棋盘&lt;/h3>
&lt;p>在棋盘表示和打印部分的前几个表达式只是定义常数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="k">def &lt;/span>&lt;span class="nv">alpha-start&lt;/span> &lt;span class="mi">97&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="k">def &lt;/span>&lt;span class="nv">alpha-end&lt;/span> &lt;span class="mi">123&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="k">def &lt;/span>&lt;span class="nv">letters&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">map &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">comp str &lt;/span>&lt;span class="nv">char&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">range &lt;/span>&lt;span class="nv">alpha-start&lt;/span> &lt;span class="nv">alpha-end&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="k">def &lt;/span>&lt;span class="nv">pos-chars&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>绑定 &amp;ldquo;alpha-start &amp;ldquo;和 &amp;ldquo;alpha-end &amp;ldquo;为字母&lt;em>a&lt;/em>到&lt;em>z&lt;/em>设定了数值的开始和结束。我们用这些来建立一个 &amp;ldquo;字母 &amp;ldquo;的序列。&lt;code>char&lt;/code>，当应用于一个整数时，返回该整数对应的字符，&lt;code>str&lt;/code>将&lt;code>char&lt;/code>变成一个字符串。&lt;code>pos-chars&lt;/code>被函数&lt;code>row-padding&lt;/code>使用，以确定在每一行的开头增加多少间距。接下来的几个定义，&lt;code>ansi-styles&lt;/code>，&lt;code>ansi&lt;/code>，和&lt;code>colorize&lt;/code>向终端输出彩色文本。&lt;/p>
&lt;p>函数&lt;code>render-pos&lt;/code>, &lt;code>row-positions&lt;/code>, &lt;code>row-padding&lt;/code>, 和&lt;code>render-row&lt;/code>创建字符串来表示棋盘。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">render-pos&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span> &lt;span class="nv">pos&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">str &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">nth &lt;/span>&lt;span class="nv">letters&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">dec &lt;/span>&lt;span class="nv">pos&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">if &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">get-in&lt;/span> &lt;span class="nv">board&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nv">pos&lt;/span> &lt;span class="ss">:pegged&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">colorize&lt;/span> &lt;span class="s">&amp;#34;0&amp;#34;&lt;/span> &lt;span class="ss">:blue&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">colorize&lt;/span> &lt;span class="s">&amp;#34;-&amp;#34;&lt;/span> &lt;span class="ss">:red&lt;/span>&lt;span class="p">))))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">row-positions&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Return all positions in the given row&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">row-num&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">range &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">inc &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">or &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">row-tri&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">dec &lt;/span>&lt;span class="nv">row-num&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">inc &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">row-tri&lt;/span> &lt;span class="nv">row-num&lt;/span>&lt;span class="p">))))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">row-padding&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;String of spaces to add to the beginning of a row to center it&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">row-num&lt;/span> &lt;span class="nv">rows&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">let &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">pad-length&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">/ &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">* &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">- &lt;/span>&lt;span class="nv">rows&lt;/span> &lt;span class="nv">row-num&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nv">pos-chars&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">apply str &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">take &lt;/span>&lt;span class="nv">pad-length&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">repeat &lt;/span>&lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="p">)))))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">render-row&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span> &lt;span class="nv">row-num&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">str &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">row-padding&lt;/span> &lt;span class="nv">row-num&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="ss">:rows&lt;/span> &lt;span class="nv">board&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">clojure.string/join&lt;/span> &lt;span class="s">&amp;#34; &amp;#34;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">map &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">partial &lt;/span>&lt;span class="nv">render-pos&lt;/span> &lt;span class="nv">board&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">row-positions&lt;/span> &lt;span class="nv">row-num&lt;/span>&lt;span class="p">)))))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果你从下往上看，你可以看到&lt;code>render-row&lt;/code>调用它上面的每个函数来返回给定行的字符串表示。注意表达式&lt;code>(map (partial render-pos board) (row-positions row-num))&lt;/code>。这展示了部分函数的一个很好的用例，即多次应用同一函数，并填入一个或多个参数，就像前面展示的&lt;code>can-move?&lt;/code>函数一样。&lt;/p>
&lt;p>还请注意，`render-pos&amp;rsquo;使用字母而不是数字来标识每个位置。这在棋盘显示时节省了一点空间，因为它允许每个位置只有一个字符来表示一个五行棋盘。&lt;/p>
&lt;p>最后，&lt;code>print-board&lt;/code>只是用&lt;code>doseq&lt;/code>遍历每一行的编号，打印该行的字符串表示。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">print-board&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">doseq &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">row-num&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">range &lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">inc &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="ss">:rows&lt;/span> &lt;span class="nv">board&lt;/span>&lt;span class="p">)))]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">println &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">render-row&lt;/span> &lt;span class="nv">board&lt;/span> &lt;span class="nv">row-num&lt;/span>&lt;span class="p">))))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当你想对一个集合中的元素进行副作用的操作（比如打印到终端）时，你可以使用&lt;code>doseq&lt;/code>。紧跟在名字&lt;code>doseq&lt;/code>后面的 Vector 描述了如何将一个集合中的所有元素逐一绑定到一个名字上，以便你可以对它们进行操作。在这个例子中，你要把数字 1 到 5（假设有五行）分配给&lt;code>row-num&lt;/code>这个名字，这样你就可以打印每一行。&lt;/p>
&lt;p>虽然打印棋盘在技术上属于&lt;em>交互&lt;/em>，但我想在这里用渲染函数来展示它。当我第一次开始写这个游戏时，&lt;code>print-board&lt;/code>函数也生成了棋盘的字符串表示。然而，现在&lt;code>print-board&lt;/code>将所有的渲染工作推迟到纯函数，这使得代码更容易理解，并减少了我们不纯函数的表面积。&lt;/p>
&lt;h3 id="玩家互动">玩家互动&lt;/h3>
&lt;p>下一个函数集合处理玩家互动。首先，有&lt;code>letter-&amp;gt;pos&lt;/code>，它将字母（这是玩家显示和识别位置的方式）转换为相应的位置编号。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">letter-&amp;gt;pos&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Converts a letter string to the corresponding position number&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">letter&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">inc &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">- &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">first &lt;/span>&lt;span class="nv">letter&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="nv">alpha-start&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来，辅助函数&lt;code>get-input&lt;/code>允许你读取和清理玩家的输入。你也可以提供一个默认值，如果玩家没有输入任何东西就按下回车键，就会使用这个值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">get-input&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Waits for user to enter text and hit enter, then cleans the input&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">([]&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">get-input&lt;/span> &lt;span class="nv">nil&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">([&lt;/span>&lt;span class="nv">default&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">let &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">input&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">clojure.string/trim&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">read-line&lt;/span>&lt;span class="p">))]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">if &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">empty?&lt;/span> &lt;span class="nv">input&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">default&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">clojure.string/lower-case&lt;/span> &lt;span class="nv">input&lt;/span>&lt;span class="p">)))))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下一个函数，&lt;code>characters-as-strings&lt;/code>，是一个很小的辅助函数，被&lt;code>prompt-move&lt;/code>用来接收一个字符串并返回一个字母集合，所有非字母的输入都被丢弃。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">characters-as-strings&lt;/span> &lt;span class="s">&amp;#34;a b&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; (&amp;#34;a&amp;#34; &amp;#34;b&amp;#34;)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">characters-as-strings&lt;/span> &lt;span class="s">&amp;#34;a cb&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; (&amp;#34;a&amp;#34; &amp;#34;c&amp;#34; &amp;#34;b&amp;#34;)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来，&lt;code>prompt-move&lt;/code>读取玩家的输入，并对其采取行动。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">prompt-move&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">println &lt;/span>&lt;span class="s">&amp;#34;\nHere&amp;#39;s your board:&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">print-board&lt;/span> &lt;span class="nv">board&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">println &lt;/span>&lt;span class="s">&amp;#34;Move from where to where? Enter two letters:&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">let &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">input&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">map &lt;/span>&lt;span class="nv">letter-&amp;gt;pos&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">characters-as-strings&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">get-input&lt;/span>&lt;span class="p">)))]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">if-let &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">new-board&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">make-move&lt;/span>&lt;span class="err">➊&lt;/span> &lt;span class="nv">board&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">first &lt;/span>&lt;span class="nv">input&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">second &lt;/span>&lt;span class="nv">input&lt;/span>&lt;span class="p">))]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">user-entered-valid-move&lt;/span> &lt;span class="nv">new-board&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">user-entered-invalid-move&lt;/span> &lt;span class="nv">board&lt;/span>&lt;span class="p">))))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在➊，如果棋手的棋步无效，&lt;code>make-move&lt;/code>返回&lt;code>nil&lt;/code>，你用&lt;code>user-entered-invalid-move&lt;/code>函数来通知她的错误。你将未经修改的棋盘传递给&lt;code>user-entered-invalid-move&lt;/code>，这样它就可以用棋盘再次提示棋手。下面是函数的定义。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">user-entered-invalid-move&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Handles the next step after a user has entered an invalid move&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">println &lt;/span>&lt;span class="s">&amp;#34;\n!!! That was an invalid move :(\n&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">prompt-move&lt;/span> &lt;span class="nv">board&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然而，如果这步棋是有效的，&amp;ldquo;new-board &amp;ldquo;将被传递给 &amp;ldquo;user-entered-valid-move&amp;rdquo;，如果还有棋步要走，它将控制权交还给 &amp;ldquo;prompt-move&amp;rdquo;。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">user-entered-valid-move&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Handles the next step after a user has entered a valid move&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">if &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">can-move?&lt;/span> &lt;span class="nv">board&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">prompt-move&lt;/span> &lt;span class="nv">board&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">game-over&lt;/span> &lt;span class="nv">board&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在我们的棋盘创建函数中，我们看到递归是如何使用不可变的数据结构来建立一个值的。同样的事情也发生在这里，只是它涉及两个相互递归的函数和一些用户输入。没有看到可变的属性!&lt;/p>
&lt;p>游戏结束后会发生什么？这就是所发生的事情。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">game-over&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Announce the game is over and prompt to play again&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">let &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">remaining-pegs&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">count &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">filter &lt;/span>&lt;span class="ss">:pegged&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">vals &lt;/span>&lt;span class="nv">board&lt;/span>&lt;span class="p">)))]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">println &lt;/span>&lt;span class="s">&amp;#34;Game over! You had&amp;#34;&lt;/span> &lt;span class="nv">remaining-pegs&lt;/span> &lt;span class="s">&amp;#34;pegs left:&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">print-board&lt;/span> &lt;span class="nv">board&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">println &lt;/span>&lt;span class="s">&amp;#34;Play again? y/n [y]&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">let &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">input&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">get-input&lt;/span> &lt;span class="s">&amp;#34;y&amp;#34;&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">if &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">= &lt;/span>&lt;span class="s">&amp;#34;y&amp;#34;&lt;/span> &lt;span class="nv">input&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">prompt-rows&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">do&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">println &lt;/span>&lt;span class="s">&amp;#34;Bye!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">System/exit&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">))))))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里发生的所有事情是，游戏告诉你你的表现，打印出最后的棋盘，并提示你再玩一次。如果你选择&lt;em>y&lt;/em>，游戏就会调用&lt;code>prompt-rows&lt;/code>，这就给我们带来了最后一组函数，用来开始新的游戏。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">prompt-empty-peg&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">board&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">println &lt;/span>&lt;span class="s">&amp;#34;Here&amp;#39;s your board:&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">print-board&lt;/span> &lt;span class="nv">board&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">println &lt;/span>&lt;span class="s">&amp;#34;Remove which peg? [e]&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">prompt-move&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">remove-peg&lt;/span> &lt;span class="nv">board&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">letter-&amp;gt;pos&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">get-input&lt;/span> &lt;span class="s">&amp;#34;e&amp;#34;&lt;/span>&lt;span class="p">)))))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">prompt-rows&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">println &lt;/span>&lt;span class="s">&amp;#34;How many rows? [5]&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">let &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">rows&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">Integer.&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">get-input&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">board&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">new-board&lt;/span> &lt;span class="nv">rows&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">prompt-empty-peg&lt;/span> &lt;span class="nv">board&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你使用&lt;code>prompt-rows&lt;/code>开始游戏，让玩家输入要包括多少行。然后你把控制权交给&lt;code>prompt-empty-peg&lt;/code>，这样玩家就可以告诉游戏要先移除哪个钉子。从这里开始，程序提示你走棋，直到没有任何棋步。&lt;/p>
&lt;p>尽管这个程序的所有副作用都是相对无害的（你所做的只是提示和打印），但像这样将它们封存在自己的函数中是函数式编程的最佳实践。一般来说，如果你能确定哪些函数是透明的、无副作用的，并将这些函数放在自己的函数中，你将从函数式编程中获得更多的好处。这些函数不可能在你的程序的不相关部分引起奇怪的错误。它们更容易在 REPL 中测试和开发，因为它们只依赖于你传递给它们的参数，而不是一些复杂的隐藏状态对象。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>纯函数在本质上是透明的，并且没有副作用，这使得它们很容易被推理。为了从 Clojure 中获得最大的收益，请尽量减少不纯函数的使用。在一个不可变的世界里，你可以使用递归而不是&lt;code>for&lt;/code>/&lt;code>while&lt;/code>循环，使用函数组合而不是连续的突变。纯函数允许强大的技术，如函数组合函数和备忘化。它们也是超级有趣的!&lt;/p>
&lt;h2 id="练习">练习&lt;/h2>
&lt;p>发展函数式编程技能的最好方法之一是尝试实现现有的函数。为此，下面的大多数练习都建议你实现一个函数，但不要止步于此；通过 Clojure 小抄（&lt;em>&lt;a class="link" href="http://clojure.org/cheatsheet/" target="_blank" rel="noopener"
>http://clojure.org/cheatsheet/&lt;/a>&lt;/em>），可以挑选更多的函数&lt;/p>
&lt;ol>
&lt;li>你用&lt;code>(comp :intelligence :attribute)&lt;/code>创建了一个函数来返回一个角色的智力。创建一个新的函数，&lt;code>attr&lt;/code>，你可以像&lt;code>(attr :intelligence)&lt;/code>那样调用它，做同样的事情。&lt;/li>
&lt;li>实现&lt;code>comp&lt;/code>函数。&lt;/li>
&lt;li>实现&lt;code>assoc-in&lt;/code>函数。提示：使用&lt;code>assoc&lt;/code>函数并将其参数定义为&lt;code>[m [k &amp;amp; ks] v]&lt;/code>。&lt;/li>
&lt;li>查阅并使用&lt;code>update-in&lt;/code>函数。&lt;/li>
&lt;li>实现 &amp;ldquo;update-in&amp;rdquo;。&lt;/li>
&lt;/ol></description></item><item><title>Chapter4 深入研究核心函数</title><link>https://example.com/p/chapter4-%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0/</link><pubDate>Thu, 13 Jan 2022 17:39:28 +0800</pubDate><guid>https://example.com/p/chapter4-%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0/</guid><description>&lt;h1 id="核心函数的深入研究">核心函数的深入研究&lt;/h1>
&lt;p>如果你像我一样是焦虑的、以青少年为中心的准肥皂剧*《吸血鬼日记》*的超级粉丝，你一定记得主角埃琳娜开始质疑她苍白的、神秘的暗恋者的行为的那一集。&amp;ldquo;为什么当我的膝盖被刮伤时，他立刻消失得无影无踪？&amp;ldquo;和 &amp;ldquo;为什么当我的手指被划破时，他的脸变成了一个怪异的死亡面具？&amp;ldquo;等等。&lt;/p>
&lt;p>如果你已经开始把玩 Clojure 的核心函数，你可能也会问自己类似的问题。&amp;ldquo;为什么&lt;code>map&lt;/code>会返回一个列表，而我给它的是一个 Vector？&amp;ldquo;和 &amp;ldquo;为什么&lt;code>reduce&lt;/code>会把我的 map 当成一个 Vector？&amp;ldquo;等等。(不过，有了 Clojure，你至少可以免于思考作为一个 17 岁孩子的深刻的存在恐惧，直到永远）。&lt;/p>
&lt;p>在这一章中，你将了解到 Clojure 的深邃、黑暗、嗜血、超自然的&lt;em>cough&lt;/em>，我的意思是，在这一章中，你将了解到 Clojure 的&lt;em>抽象的基本概念以及序列和集合的抽象&lt;/em>。你还会了解到&lt;em>疯狂的序列&lt;/em>。这将为你提供所需的基础，使你能够阅读你以前没有使用过的函数的文档，并理解当你试着使用它们时发生了什么。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/core-functions-in-depth/sparkly.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>接下来，你将获得更多关于你最需要使用的函数的经验。你将学习如何用函数&lt;code>map&lt;/code>、&lt;code>reduce&lt;/code>、&lt;code>into&lt;/code>、&lt;code>conj&lt;/code>、&lt;code>concat&lt;/code>、&lt;code>some&lt;/code>、&lt;code>filter&lt;/code>、&lt;code>take&lt;/code>、&lt;code>drop&lt;/code>、&lt;code>sort&lt;/code>、&lt;code>sort-by&lt;/code>和&lt;code>identity&lt;/code>来处理列表、Vector、Map 和 Set。你还将学习如何用&lt;code>apply&lt;/code>、&lt;code>partial&lt;/code>和&lt;code>complement&lt;/code>创建新的函数。所有这些信息将帮助你了解如何以 Clojure 的方式做事，它将为你编写自己的代码以及阅读和学习他人的项目打下坚实的基础。&lt;/p>
&lt;p>最后，你将学会如何解析和查询 CSV 中的吸血鬼数据，以确定在你的家乡潜伏着哪些诺斯费拉图。&lt;/p>
&lt;h2 id="从编程到抽象">从编程到抽象&lt;/h2>
&lt;p>为了理解从编程到抽象，让我们把 Clojure 与一种没有考虑到这个原则的语言进行比较。Emacs Lisp（elisp）。在 elisp 中，你可以使用&lt;code>mapcar&lt;/code>函数来导出一个新的列表，这与你在 Clojure 中使用&lt;code>map&lt;/code>的方式相似。然而，如果你想在 elisp 中 Map 一个哈希 Map（类似于 Clojure 的 map 数据结构），你需要使用&lt;code>maphash&lt;/code>函数，而在 Clojure 中你仍然可以只使用&lt;code>map&lt;/code>。换句话说，elisp 使用两个不同的、针对数据结构的函数来实现&lt;em>map&lt;/em>操作，而 Clojure 只使用一个。你也可以在 Clojure 中对 map 调用&lt;code>reduce&lt;/code>，而 elisp 并没有提供一个函数来减少散列 map。&lt;/p>
&lt;p>原因是 Clojure 在&lt;em>序列抽象&lt;/em>方面定义了&lt;code>map&lt;/code>和&lt;code>reduce&lt;/code>函数，而不是在具体的数据结构方面。只要数据结构响应核心序列操作（函数&lt;code>first&lt;/code>、&lt;code>rest&lt;/code>和&lt;code>cons&lt;/code>，我们稍后会仔细研究），它就能与&lt;code>map&lt;/code>、&lt;code>reduce&lt;/code>以及其他大量的序列函数免费工作。这就是 Clojurists 所说的抽象编程，也是 Clojure 哲学的一个核心原则。&lt;/p>
&lt;p>我认为抽象是操作的命名集合。如果你能在一个对象上执行一个抽象的所有操作，那么这个对象就是该抽象的一个实例。我甚至在编程之外也是这样想的。例如，&lt;em>电池&lt;/em>抽象包括 &amp;ldquo;将导电介质连接到其阳极和阴极 &amp;ldquo;的操作，而该操作的输出是&lt;em>电流&lt;/em>。电池是用锂还是用土豆做的并不重要。只要它对定义&lt;em>电池&lt;/em>的一系列操作做出反应，它就是一个电池。&lt;/p>
&lt;p>同样地，&lt;code>map&lt;/code>并不关心列表、Vector、Set 和 Map 是如何实现的。它只关心它是否能对它们进行序列操作。让我们看看&lt;code>map&lt;/code>是如何在序列抽象中定义的，这样你就能理解一般的抽象编程。&lt;/p>
&lt;h3 id="把列表vectorset-和-map-当作序列对待">把列表、Vector、Set 和 Map 当作序列对待&lt;/h3>
&lt;p>如果你把&lt;code>map&lt;/code>操作独立于任何编程语言，甚至是编程，它的基本行为是用一个函数&lt;em>ƒ&lt;/em>从现有的序列&lt;em>x&lt;/em>导出一个新的序列&lt;em>y&lt;/em>，这样 y1 = ƒ(x1), y2 = ƒ(x2), . . . yn = ƒ(xn)。图 4-1 说明了你如何将应用于序列的 Map 可视化。&lt;/p>
&lt;p>! &lt;a class="link" href="https://www.braveclojure.com/assets/images/cftbat/core-functions-in-depth/mapping.png" target="_blank" rel="noopener"
>img&lt;/a>&lt;/p>
&lt;p>图 4-1：Map 的可视化&lt;/p>
&lt;p>术语&lt;em>序列&lt;/em>在这里指的是以线性顺序组织的元素集合，而不是无序集合或节点之间没有前后关系的图。图 4-2 显示了你如何将一个序列可视化，与上述其他两个集合形成对比。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/core-functions-in-depth/collections.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>图 4-2：序列和非序列集合&lt;/p>
&lt;p>在这个关于 Map 和序列的描述中，没有提到列表、Vector 或其他具体的数据结构。Clojure 的设计是让我们尽可能地用这种抽象的术语来思考和编程，它通过用数据结构的抽象来实现函数。在这个例子中，&lt;code>map&lt;/code>是根据序列抽象来定义的。在对话中，你会说&lt;code>map&lt;/code>、&lt;code>reduce&lt;/code>和其他序列函数&lt;em>取一个序列&lt;/em>或甚至&lt;em>取一个 seq&lt;/em>。事实上，Clojurists 通常使用&lt;em>seq&lt;/em>而不是&lt;em>sequence&lt;/em>，使用&lt;em>seq 函数&lt;/em>和&lt;em>seq 库&lt;/em>等术语来指代执行顺序操作的函数。无论你使用&lt;em>sequence&lt;/em>还是&lt;em>seq&lt;/em>，你都表明有关的数据结构将被视为一个序列，在这种情况下，它实际上是什么最真实的心态并不重要。&lt;/p>
&lt;p>如果核心序列函数 &amp;ldquo;first&amp;rdquo;、&amp;ldquo;rest &amp;ldquo;和 &amp;ldquo;cons &amp;ldquo;在一个数据结构上工作，你可以说这个数据结构&lt;em>实现了&lt;/em>序列的抽象。列表、Vector、Set 和 Map 都实现了序列抽象，所以它们都可以用&lt;code>map&lt;/code>，如图所示。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn titleize
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [topic]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str topic &amp;#34; for the Brave and True&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(map titleize [&amp;#34;Hamsters&amp;#34; &amp;#34;Ragnarok&amp;#34;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (&amp;#34;Hamsters for the Brave and True&amp;#34; &amp;#34;Ragnarok for the Brave and True&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(map titleize &amp;#39;(&amp;#34;Empathy&amp;#34; &amp;#34;Decorating&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (&amp;#34;Empathy for the Brave and True&amp;#34; &amp;#34;Decorating for the Brave and True&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(map titleize #{&amp;#34;Elbows&amp;#34; &amp;#34;Soap Carving&amp;#34;})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (&amp;#34;Elbows for the Brave and True&amp;#34; &amp;#34;Soap Carving for the Brave and True&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(map #(titleize (second %)) {:uncomfortable-thing &amp;#34;Winking&amp;#34;})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (&amp;#34;Winking for the Brave and True&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>前两个例子表明&lt;code>map&lt;/code>对 Vector 和列表的工作方式是相同的。第三个例子显示&lt;code>map&lt;/code>可以与未排序的集合一起工作。在第四个例子中，你必须在匿名函数的参数上调用&lt;code>second&lt;/code>，然后再将其标题化，因为参数是一个 map。我将很快解释原因，但首先让我们看看定义序列抽象的三个函数。&lt;/p>
&lt;h3 id="first-rest-and-cons">first, rest, and cons&lt;/h3>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/core-functions-in-depth/hamster.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>在这一节中，我们将快速迂回到 JavaScript 中，实现一个链表和三个核心函数。&lt;code>first&lt;/code>,&lt;code>rest&lt;/code>, 和&lt;code>cons&lt;/code>。在这三个核心函数实现之后，我将展示如何用它们来构建&lt;code>map&lt;/code>。&lt;/p>
&lt;p>重点是要理解 Clojure 中的 seq 抽象和链接列表的具体实现之间的区别。如何实现一个特定的数据结构并不重要：当涉及到在一个数据结构上使用 seq 函数时，Clojure 所问的是 &amp;ldquo;我可以&lt;code>first&lt;/code>、&lt;code>rest&lt;/code>和&lt;code>cons&lt;/code>吗？&amp;rdquo; 如果答案是肯定的，你就可以在该数据结构上使用 seq 库。&lt;/p>
&lt;p>在一个链接列表中，节点是以线性顺序链接的。下面是你如何在 JavaScript 中创建一个。在这个片段中，&lt;code>next&lt;/code>是空的，因为它是列表中的最后一个节点。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">var node3 = {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> value: &amp;#34;last&amp;#34;,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> next: null
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个代码中，&lt;code>node2&lt;/code>的&lt;code>next&lt;/code>指向&lt;code>node3&lt;/code>，而&lt;code>node1&lt;/code>的&lt;code>next&lt;/code>指向&lt;code>node2&lt;/code>；这就是 &amp;ldquo;链表 &amp;ldquo;中的 &amp;ldquo;链接&amp;rdquo;。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">var node2 = {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> value: &amp;#34;middle&amp;#34;,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> next: node3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">};
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">var node1 = {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> value: &amp;#34;first&amp;#34;,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> next: node2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>从图形上看，你可以如图 4-3 所示表示这个列表。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/core-functions-in-depth/linked-list.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>图 4-3: 一个链接列表&lt;/p>
&lt;p>你可以在一个链表上执行三个核心函数。&lt;code>first&lt;/code>, &lt;code>rest&lt;/code>, 和&lt;code>cons&lt;/code>. &lt;code>first&lt;/code>返回请求的节点的值，&lt;code>rest&lt;/code>返回请求的节点之后的剩余值，&lt;code>cons&lt;/code>在列表的开头添加一个具有给定值的新节点。在这些实现之后，你可以在它们之上实现&lt;code>map&lt;/code>、&lt;code>reduce&lt;/code>、&lt;code>filter&lt;/code>和其他 seq 函数。&lt;/p>
&lt;p>下面的代码显示了我们如何用我们的 JavaScript 例子实现和使用&lt;code>first&lt;/code>、&lt;code>rest&lt;/code>和&lt;code>cons&lt;/code>，以及如何使用它们来返回特定的节点并导出一个新的列表。请注意，&lt;code>first&lt;/code>和&lt;code>rest&lt;/code>的参数被命名为&lt;em>node&lt;/em>。这可能会让人感到困惑，因为你可能会说：&amp;ldquo;我不是在获取一个&lt;em>列表&lt;/em>的第一个元素吗？&amp;rdquo; 好吧，你一次对列表中的元素进行操作，是一个节点一个节点地操作&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">var first = function(node) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return node.value;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">};
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">var rest = function(node) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return node.next;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">};
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">var cons = function(newValue, node) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> value: newValue,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> next: node
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> };
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">};
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">first(node1);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// =&amp;gt; &amp;#34;first&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">first(rest(node1));
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// =&amp;gt; &amp;#34;middle&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">first(rest(rest(node1)));
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// =&amp;gt; &amp;#34;last&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">var node0 = cons(&amp;#34;new first&amp;#34;, node1);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">first(node0);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// =&amp;gt; &amp;#34;new first&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">first(rest(node0));
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// =&amp;gt; &amp;#34;first&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如前所述，你可以用&lt;code>first&lt;/code>、&lt;code>rest&lt;/code>和&lt;code>cons&lt;/code>来实现&lt;code>map&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">var map = function (list, transform) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (list === null) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return null;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } else {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return cons(transform(first(list)), map(rest(list), transform));
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个函数转换了 list 的第一个元素，然后在 list 的其余部分再次调用自己，直到到达结尾（一个空值）。让我们看看它的运行情况 在这个例子中，你对以 &lt;code>node1&lt;/code> 开始的列表进行 Map，返回一个新的列表，字符串 &lt;code>&amp;quot; mapped!&amp;quot;&lt;/code> 被附加到每个节点的值上。然后你用&lt;code>first&lt;/code>来返回第一个节点的值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">first(
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> map(node1, function (val) { return val + &amp;#34; mapped!&amp;#34;})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// =&amp;gt; &amp;#34;first mapped!&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里有件很酷的事：因为&lt;code>map&lt;/code>是完全用&lt;code>cons&lt;/code>、&lt;code>first&lt;/code>和&lt;code>rest&lt;/code>实现的，你实际上可以把任何数据结构传给它，只要&lt;code>cons&lt;/code>、&lt;code>first&lt;/code>和&lt;code>rest&lt;/code>对该数据结构起作用，它就能工作。&lt;/p>
&lt;p>下面是它们对一个数组的作用。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">var first = function (array) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return array[0];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">var rest = function (array) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> var sliced = array.slice(1, array.length);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (sliced.length == 0) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return null;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } else {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return sliced;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">var cons = function (newValue, array) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return [newValue].concat(array);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">var list = [&amp;#34;Transylvania&amp;#34;, &amp;#34;Forks, WA&amp;#34;];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">map(list, function (val) { return val + &amp;#34; mapped!&amp;#34;})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// =&amp;gt; [&amp;#34;Transylvania mapped!&amp;#34;, &amp;#34;Forks, WA mapped!&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个代码片段用 JavaScript 的数组函数定义了&lt;code>first&lt;/code>、&lt;code>rest&lt;/code>和&lt;code>cons&lt;/code>。同时，&lt;code>map&lt;/code>继续引用名为&lt;code>first&lt;/code>、&lt;code>rest&lt;/code>和&lt;code>cons&lt;/code>的函数，所以现在它在&lt;code>array&lt;/code>上工作。所以，如果你能实现&lt;code>first&lt;/code>、&lt;code>rest&lt;/code>和&lt;code>cons&lt;/code>，你就能免费得到&lt;code>map&lt;/code>和前面提到的大量其他函数。&lt;/p>
&lt;h3 id="通过中间层抽象">通过中间层抽象&lt;/h3>
&lt;p>在这一点上，你可能会反对我只是在踢皮球，因为我们仍然面临着像&lt;code>first&lt;/code>这样的函数如何能够与不同的数据结构一起工作的问题。Clojure 使用两种形式的指示来实现这一目标。在编程中，&lt;em>中间层&lt;/em>是一个通用术语，指的是一种语言所采用的机制，这样一个名字可以有多种相关的含义。在这个例子中，&amp;ldquo;first &amp;ldquo;这个名字有多种数据结构的含义。方向性是使抽象化成为可能的原因。&lt;/p>
&lt;p>&lt;em>多态&lt;/em>是 Clojure 提供中间层的一种方式。我不想在细节上迷失方向，但基本上，多态函数根据提供的参数类型分配给不同的函数体。(这与多态函数根据你提供的参数数量派发到不同的函数体并无太大区别）。&lt;/p>
&lt;p>注意 Clojure 有两种结构来定义多态分发：主机平台的接口结构和平台独立的协议。但在你刚开始的时候，没有必要了解这些东西是如何工作的。我将在第 13 章介绍协议。&lt;/p>
&lt;p>当涉及到序列时，Clojure 也通过做一种轻量级的类型转换来创造中间层，产生一种数据结构，与抽象的函数一起工作。每当 Clojure 期望一个序列&amp;ndash;例如，当你调用&lt;code>map&lt;/code>、&lt;code>first&lt;/code>、&lt;code>rest&lt;/code>或&lt;code>cons&lt;/code>时，它就会调用相关数据结构上的&lt;code>seq&lt;/code>函数，以获得一个允许&lt;code>first&lt;/code>、&lt;code>rest&lt;/code>和&lt;code>cons&lt;/code>的数据结构。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(seq &amp;#39;(1 2 3))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (1 2 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(seq [1 2 3])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (1 2 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(seq #{1 2 3})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (1 2 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(seq {:name &amp;#34;Bill Compton&amp;#34; :occupation &amp;#34;Dead mopey guy&amp;#34;})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; ([:name &amp;#34;Bill Compton&amp;#34;] [:occupation &amp;#34;Dead mopey guy&amp;#34;])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里有两个值得注意的细节。首先，&lt;code>seq&lt;/code>总是返回一个看起来像列表的值；你会把这个值称为&lt;em>sequence&lt;/em>或&lt;em>seq&lt;/em>。第二，Map 的 seq 由两个元素的键值 Vector 组成。这就是为什么&lt;code>map&lt;/code>把你的 Map 当作 Vector 列表的原因! 你可以在 &amp;ldquo;Bill Compton &amp;ldquo;的例子中看到这一点。我想特别指出这个例子，因为它可能是令人惊讶和困惑的。在我刚开始使用 Clojure 的时候就是这样。了解这些底层机制将使你不至于像试图保留人性的男性吸血鬼那样，经常表现出挫折感和普遍的拖沓感。&lt;/p>
&lt;p>你可以通过使用&lt;code>into&lt;/code>将 seq 转换回 Map，将结果粘到一个空的 Map 中（后面你会仔细看&lt;code>into&lt;/code>）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(into {} (seq {:a 1 :b 2 :c 3})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:a 1, :c 3, :b 2}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>所以，Clojure 的序列函数在其参数上使用&lt;code>seq&lt;/code>。序列函数是根据序列抽象定义的，使用&lt;code>first&lt;/code>、&lt;code>rest&lt;/code>和&lt;code>cons&lt;/code>。只要一个数据结构实现了序列抽象，它就可以使用广泛的 seq 库，其中包括诸如&lt;code>reduce&lt;/code>、&lt;code>filter&lt;/code>、&lt;code>distinct&lt;/code>、&lt;code>group-by&lt;/code>等超级明星函数。&lt;/p>
&lt;p>这里的启示是，把注意力集中在我们能对一个数据结构做什么，并尽可能地忽略它的实现，是非常有力的。实现本身并不重要。它们只是达到目的的一种手段。一般来说，抽象编程可以让你在不同的数据结构上使用函数库，不管这些数据结构是如何实现的。&lt;/p>
&lt;h2 id="seq-函数的例子">Seq 函数的例子&lt;/h2>
&lt;p>Clojure 的 seq 库中有很多有用的函数，你会经常用到。现在你已经对 Clojure 的序列抽象有了更深的了解，让我们来详细看看这些函数。如果你是 Lisp 和函数式编程的新手，这些例子将是令人惊讶和愉快的。&lt;/p>
&lt;h3 id="map">Map&lt;/h3>
&lt;p>你现在已经看过很多&lt;code>map&lt;/code>的例子了，但是这一节展示了&lt;code>map&lt;/code>做了两个新的任务：把多个集合作为参数，以及把一个函数集合作为参数。它还强调了一个常见的&lt;code>map&lt;/code>模式：使用关键字作为 Map 函数。&lt;/p>
&lt;p>到目前为止，你只看到了&lt;code>map&lt;/code>在一个集合上操作的例子。在下面的代码中，这个集合是 Vector&lt;code>[1 2 3]&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(map inc [1 2 3])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (2 3 4)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然而，你也可以给&lt;code>map&lt;/code>多个集合。下面是一个简单的例子来说明这个方法的作用。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(map str [&amp;#34;a&amp;#34; &amp;#34;b&amp;#34; &amp;#34;c&amp;#34;] [&amp;#34;A&amp;#34; &amp;#34;B&amp;#34; &amp;#34;C&amp;#34;] )
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (&amp;#34;aA&amp;#34; &amp;#34;bB&amp;#34; &amp;#34;cC&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就好像&lt;code>map&lt;/code>做了以下的事情。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(list (str &amp;#34;a&amp;#34; &amp;#34;A&amp;#34;) (str &amp;#34;b&amp;#34; &amp;#34;B&amp;#34;) (str &amp;#34;c&amp;#34; &amp;#34;C&amp;#34;))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/core-functions-in-depth/vampire-diary.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>当你传递给&lt;code>map&lt;/code>多个集合时，第一个集合的元素（&lt;code>[&amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot;]&lt;/code>）将作为 Map 函数（&lt;code>str&lt;/code>）的第一个参数传递，第二个集合的元素（&lt;code>[&amp;quot;A&amp;quot; &amp;quot;B&amp;quot; &amp;quot;C&amp;quot;&lt;/code>）将作为第二个参数传递，以此类推。只要确保你的 Map 函数可以接受的参数数量与你传递给&lt;code>map&lt;/code>的集合数量相等。&lt;/p>
&lt;p>下面的例子显示了如果你是一个试图抑制人类消费的吸血鬼，你可以如何使用这种能力。你有两个 Vector，一个代表人类摄入的升数，另一个代表过去四天的小动物摄入量。&lt;code>unify-diet-data&lt;/code> 函数获取人类和动物的单日数据，并将两者统一为一张 Map。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def human-consumption [8.1 7.3 6.6 5.0])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def critter-consumption [0.0 0.2 0.3 1.1])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn unify-diet-data
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [human critter]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:human human
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :critter critter})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(map unify-diet-data human-consumption critter-consumption)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; ({:human 8.1, :critter 0.0}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:human 7.3, :critter 0.2}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:human 6.6, :critter 0.3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:human 5.0, :critter 1.1})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>好样的，把人裁掉了!&lt;/p>
&lt;p>你可以用&lt;code>map&lt;/code>做的另一件有趣的事是把一个函数集合传给它。如果你想对不同的数字集合进行一系列的计算，你可以使用这个方法，就像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def sum #(reduce + %))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def avg #(/ (sum %) (count %)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn stats
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [numbers]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (map #(% numbers) [sum count avg]))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(stats [3 4 10])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (17 3 17/3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(stats [80 1 44 13 6])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (144 5 144/5)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子中，&lt;code>stats&lt;/code>函数遍历了一个函数的 Vector，将每个函数应用于&lt;code>numbers&lt;/code>。&lt;/p>
&lt;p>此外，Clojurists 经常使用&lt;code>map&lt;/code>从 map 数据结构的集合中检索与一个关键词相关的值。因为关键字可以作为函数使用，你可以简洁地做到这一点。下面是一个例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def identities
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [{:alias &amp;#34;Batman&amp;#34; :real &amp;#34;Bruce Wayne&amp;#34;}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:alias &amp;#34;Spider-Man&amp;#34; :real &amp;#34;Peter Parker&amp;#34;}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:alias &amp;#34;Santa&amp;#34; :real &amp;#34;Your mom&amp;#34;}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:alias &amp;#34;Easter Bunny&amp;#34; :real &amp;#34;Your dad&amp;#34;}])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(map :real identities)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (&amp;#34;Bruce Wayne&amp;#34; &amp;#34;Peter Parker&amp;#34; &amp;#34;Your mom&amp;#34; &amp;#34;Your dad&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>(如果你是五岁，那么我深表歉意）。&lt;/p>
&lt;h3 id="reduce">reduce&lt;/h3>
&lt;p>第 3 章展示了&lt;code>reduce&lt;/code>如何处理序列中的每个元素来生成一个结果。本节展示了其他一些可能不经常使用的使用方法。&lt;/p>
&lt;p>第一种用法是转换一个 Map 的值，产生一个新的 Map，其键值相同，但数值更新。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(reduce (fn [new-map [key val]]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (assoc new-map key (inc val)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:max 30 :min 10})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:max 31, :min 11}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子中，&lt;code>reduce&lt;/code>将参数&lt;code>{:max 30 :min 10}&lt;/code>视为一个 Vector 序列，如&lt;code>([:max 30] [:min 10])&lt;/code>。然后，它从一个空 Map（第二个参数）开始，用第一个参数，一个匿名函数来建立它。就像&lt;code>reduce&lt;/code>这样做：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(assoc (assoc {} :max (inc 30))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :min (inc 10))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>函数&lt;code>assoc&lt;/code>需要三个参数：一个 Map，一个键，和一个值。它通过&lt;em>关联&lt;/em>给定的键和给定的值，从你给它的 Map 中派生出一个新的 Map。例如，&lt;code>(assoc {:a 1} :b 2)&lt;/code>将返回&lt;code>{:a 1 :b 2}&lt;/code>。&lt;/p>
&lt;p>&lt;code>reduce&lt;/code> 的另一个用途是根据键值从 Map 中过滤出来。在下面的例子中，匿名函数检查一个键值对的值是否大于 4，如果不是，那么这个键值对就被过滤掉了。在 Map&lt;code>{:human 4.1 :critter 3.9}&lt;/code>中，3.9 小于 4，所以&lt;code>:critter&lt;/code>键和它的 3.9 值被过滤掉了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(reduce (fn [new-map [key val]]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if (&amp;gt; val 4)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (assoc new-map key val)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> new-map))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:human 4.1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :critter 3.9})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:human 4.1}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里的启示是，&lt;code>reduce&lt;/code>是一个比最初看起来更灵活的函数。每当你想从一个序列中得到一个新的值时，&lt;code>reduce&lt;/code>通常能够满足你的需要。如果你想做一个真正能让你的头发倒竖的练习，试着用&lt;code>reduce&lt;/code>实现&lt;code>map&lt;/code>，然后在本章后面的内容中对&lt;code>filter&lt;/code>和&lt;code>some&lt;/code>做同样的练习。&lt;/p>
&lt;h3 id="take-drop-take-while-and-drop-while">take, drop, take-while, and drop-while&lt;/h3>
&lt;p>&lt;code>take&lt;/code>和&lt;code>drop&lt;/code>都接受两个参数：一个数字和一个序列。&lt;code>take&lt;/code>返回序列的前 n 个元素，而&lt;code>drop&lt;/code>返回除去前 n 个元素的序列。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(take 3 [1 2 3 4 5 6 7 8 9 10])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (1 2 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(drop 3 [1 2 3 4 5 6 7 8 9 10])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (4 5 6 7 8 9 10)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>它们的表亲&lt;code>take-while&lt;/code>和&lt;code>drop-while&lt;/code>更有趣一些。每一个都需要一个&lt;em>谓词函数&lt;/em>（一个其返回值为真或假的函数）来决定它何时应该停止取舍。例如，假设你有一个 Vector，代表你 &amp;ldquo;食物 &amp;ldquo;日记中的条目。每个条目都有月份和日期，以及你吃了什么。为了保留空间，我们将只包括几个条目。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def food-journal
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [{:month 1 :day 1 :human 5.3 :critter 2.3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 1 :day 2 :human 5.1 :critter 2.0}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 2 :day 1 :human 4.9 :critter 2.1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 2 :day 2 :human 5.0 :critter 2.5}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 3 :day 1 :human 4.2 :critter 3.3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 3 :day 2 :human 4.0 :critter 3.8}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 4 :day 1 :human 3.7 :critter 3.9}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 4 :day 2 :human 3.7 :critter 3.6}])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>使用&lt;code>take-while&lt;/code>，你可以只检索一月和二月的数据。&lt;code>take-while&lt;/code>遍历给定的序列（在本例中是&lt;code>food-journal&lt;/code>），对每个元素应用谓词函数。&lt;/p>
&lt;p>这个例子使用匿名函数&lt;code>#(&amp;lt; (:month %) 3)&lt;/code>来测试日记条目的月份是否超出范围。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(take-while #(&amp;lt; (:month %) 3) food-journal)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; ({:month 1 :day 1 :human 5.3 :critter 2.3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 1 :day 2 :human 5.1 :critter 2.0}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 2 :day 1 :human 4.9 :critter 2.1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 2 :day 2 :human 5.0 :critter 2.5})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当&lt;code>take-while&lt;/code>到达第一个 March 条目时，匿名函数返回&lt;code>false&lt;/code>，而&lt;code>take-while&lt;/code>返回它在这之前测试的每个元素的序列。&lt;/p>
&lt;p>同样的想法也适用于&lt;code>drop-while&lt;/code>，只是它一直在丢弃元素，直到有一个测试为真。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(drop-while #(&amp;lt; (:month %) 3) food-journal)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; ({:month 3 :day 1 :human 4.2 :critter 3.3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 3 :day 2 :human 4.0 :critter 3.8}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 4 :day 1 :human 3.7 :critter 3.9}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 4 :day 2 :human 3.7 :critter 3.6})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通过同时使用&lt;code>take-while&lt;/code>和&lt;code>drop-while&lt;/code>，你可以只获得 2 月和 3 月的数据。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(take-while #(&amp;lt; (:month %) 4)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (drop-while #(&amp;lt; (:month %) 2) food-journal))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; ({:month 2 :day 1 :human 4.9 :critter 2.1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 2 :day 2 :human 5.0 :critter 2.5}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 3 :day 1 :human 4.2 :critter 3.3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 3 :day 2 :human 4.0 :critter 3.8})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个例子使用 &amp;ldquo;drop-while &amp;ldquo;去掉 1 月份的条目，然后对结果使用 &amp;ldquo;take-while &amp;ldquo;继续取条目，直到到达 4 月份的第一个条目。&lt;/p>
&lt;h3 id="filter-和-some">Filter 和 Some&lt;/h3>
&lt;p>使用&lt;code>filter&lt;/code>来返回一个序列中对一个谓词函数为真的所有元素。这里是人类消费少于 5 升的日记条目：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(filter #(&amp;lt; (:human %) 5) food-journal)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; ({:month 2 :day 1 :human 4.9 :critter 2.1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 3 :day 1 :human 4.2 :critter 3.3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 3 :day 2 :human 4.0 :critter 3.8}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 4 :day 1 :human 3.7 :critter 3.9}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 4 :day 2 :human 3.7 :critter 3.6})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可能想知道为什么我们不在前面的 &amp;ldquo;take-while &amp;ldquo;和 &amp;ldquo;drop-while &amp;ldquo;例子中使用&lt;code>filter&lt;/code>。事实上，&lt;code>filter&lt;/code>也可以用于此。这里我们要抓取 1 月和 2 月的数据，就像在&lt;code>take-while&lt;/code>例子中一样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(filter #(&amp;lt; (:month %) 3) food-journal)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; ({:month 1 :day 1 :human 5.3 :critter 2.3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 1 :day 2 :human 5.1 :critter 2.0}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 2 :day 1 :human 4.9 :critter 2.1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:month 2 :day 2 :human 5.0 :critter 2.5})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这种用法完全没有问题，但是&lt;code>filter&lt;/code>最终会处理你的所有数据，这并不总是必要的。因为食物日记已经按日期排序，我们知道&lt;code>take-while&lt;/code>会返回我们想要的数据，而不需要检查任何我们不需要的数据。因此，&lt;code>take-while&lt;/code>可以更有效率。&lt;/p>
&lt;p>通常情况下，你想知道一个集合是否包含对一个谓词函数测试为真的任何值。&lt;code>some&lt;/code>函数就是这样做的，它返回由一个谓词函数返回的第一个真值（任何不是&lt;code>false&lt;/code>或&lt;code>nil&lt;/code>的值）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(some #(&amp;gt; (:critter %) 5) food-journal)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; nil
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(some #(&amp;gt; (:critter %) 3) food-journal)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你没有任何食物日记条目显示你从小动物来源中消耗了超过 5 升的食物，但是你至少有一条显示你消耗了超过 3 升的食物。请注意，第二个例子中的返回值是&lt;code>true&lt;/code>，而不是产生真值的实际条目。原因是匿名函数&lt;code>#(&amp;gt; (:critter %) 3)&lt;/code>返回&lt;code>true&lt;/code>或&lt;code>false&lt;/code>。下面是你如何返回该条目。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(some #(and (&amp;gt; (:critter %) 3) %) food-journal)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:month 3 :day 1 :human 4.2 :critter 3.3}。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里，一个稍有不同的匿名函数使用&lt;code>and&lt;/code>首先检查条件&lt;code>(&amp;gt; (:critter %) 3)&lt;/code>是否为真，然后在条件确实为真时返回条目。&lt;/p>
&lt;h3 id="sort-and-sort-by">sort and sort-by&lt;/h3>
&lt;p>你可以用&lt;code>sort&lt;/code>将元素按升序排序。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(sort [3 1 2])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (1 2 3)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果你的排序需求更复杂，你可以使用&lt;code>sort-by&lt;/code>，它允许你将一个函数（有时称为&lt;em>键函数&lt;/em>）应用于一个序列的元素，并使用它返回的值来决定排序顺序。在下面的例子中，取自*&lt;a class="link" href="http://clojuredocs.org/" target="_blank" rel="noopener"
>http://clojuredocs.org/&lt;/a>*，&lt;code>count&lt;/code>是关键函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(sort-by count [&amp;#34;aaa&amp;#34; &amp;#34;c&amp;#34; &amp;#34;bb&amp;#34;] )
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (&amp;#34;c&amp;#34; &amp;#34;bb&amp;#34; &amp;#34;aaa&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果你使用&lt;code>sort&lt;/code>进行排序，元素将按字母顺序进行排序，返回&lt;code>(&amp;quot;aaa&amp;quot; &amp;quot;bb&amp;quot; &amp;quot;c&amp;quot;)&lt;/code>。相反，结果是&lt;code>(&amp;quot;c&amp;quot; &amp;quot;bb&amp;quot; &amp;quot;aaa&amp;quot;)&lt;/code>，因为你是按&lt;code>count&lt;/code>排序，而&lt;code>&amp;quot;c &amp;quot;的计数是1，&lt;/code>&amp;ldquo;bb &amp;ldquo;是 2，`&amp;ldquo;aaa &amp;ldquo;是 3。&lt;/p>
&lt;h3 id="concat">Concat&lt;/h3>
&lt;p>最后, &lt;code>concat&lt;/code>简单地将一个序列的成员附加到另一个序列的末尾:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(concat [1 2] [3 4])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (1 2 3 4)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="惰性序列">惰性序列&lt;/h2>
&lt;p>正如你之前看到的，&lt;code>map&lt;/code>首先在你传递给它的集合上调用&lt;code>seq&lt;/code>。但这并不是故事的全部。许多函数，包括&lt;code>map&lt;/code>和&lt;code>filter&lt;/code>，都返回一个&lt;em>惰性序列&lt;/em>。惰性序列 是一个 seq，它的成员在你试图访问它们时才被计算。计算一个 seq 的成员被称为&lt;em>实现&lt;/em>seq。将计算推迟到需要的时候，可以使你的程序更有效率，而且它还有一个令人惊讶的好处，就是允许你构建无穷的序列。&lt;/p>
&lt;h3 id="演示惰性序列的效率">演示惰性序列的效率&lt;/h3>
&lt;p>为了看到惰性序列的作用，假装你是一个现代任务组的成员，其目的是为了识别吸血鬼。你的情报人员告诉你，在你的城市里只有一个活跃的吸血鬼，而且他们已经帮助你把嫌疑人的名单缩小到一百万人。你的老板给了你一份一百万个社会安全号码的名单，并喊道：&amp;ldquo;搞定它，麦克菲斯维奇！&amp;rdquo;&lt;/p>
&lt;p>值得庆幸的是，你拥有一台 Vampmatic 3000 计算机，这是用于识别吸血鬼的最先进的设备。由于这种猎杀吸血鬼的技术的源代码是专有的，我把它存根出来，模拟执行这项任务所需的时间。这里是一个吸血鬼数据库的子集。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def vampire-database
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {0 {:makes-blood-puns? false, :has-pulse? true :name &amp;#34;McFishwich&amp;#34;}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 1 {:makes-blood-puns? false, :has-pulse? true :name &amp;#34;McMackson&amp;#34;}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2 {:makes-blood-puns? true, :has-pulse? false :name &amp;#34;Damon Salvatore&amp;#34;}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 3 {:makes-blood-puns? true, :has-pulse? true :name &amp;#34;Mickey Mouse&amp;#34;}})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn vampire-related-details
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [social-security-number]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (Thread/sleep 1000)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (get vampire-database social-security-number))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn vampire?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [record]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (and (:makes-blood-puns? record)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (not (:has-pulse? record))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> record))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn identify-vampire
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [social-security-numbers]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (first (filter vampire?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (map vampire-related-details social-security-numbers))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你有一个函数，&lt;code>vampire-related-details&lt;/code>，它需要一秒钟从数据库中查找一个条目。接下来，你有一个函数，&lt;code>vampire?&lt;/code>，如果它通过了吸血鬼测试，就返回一条记录；否则，就返回&lt;code>false&lt;/code>。最后，&lt;code>identify-vampire&lt;/code>将社会安全号码 Map 到数据库记录，然后返回第一条表明有吸血鬼的记录。&lt;/p>
&lt;p>为了显示运行这些函数需要多少时间，你可以使用&lt;code>time&lt;/code>操作。当你使用&lt;code>time&lt;/code>时，你的代码的行为与你不使用&lt;code>time&lt;/code>时完全一样，但有一个例外：会打印出一份经过时间的报告。下面是一个例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(time (vampire-related-details 0))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Elapsed time: 1001.042 msecs&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:name &amp;#34;McFishwich&amp;#34;, :makes-blood-puns? false, :has-pulse? true}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>第一个打印行报告了给定操作所花费的时间&amp;ndash;本例是 1,001.042 毫秒。第二行是返回值，在本例中是你的数据库记录。返回值与没有使用&lt;code>time&lt;/code>的情况下完全相同。&lt;/p>
&lt;p>一个不笨的&lt;code>map&lt;/code>的实现首先要对&lt;code>social-security-numbers&lt;/code>的每个成员应用&lt;code>vampire-&lt;/code>related-details&lt;code>，然后再把结果传给&lt;/code>filter`。因为你有一百万个嫌疑人，这将需要一百万秒，也就是 12 天，到那时你的一半城市都会死掉！&amp;quot;。当然，如果结果是唯一的吸血鬼是记录中的最后一个嫌疑人，用懒人版本还是会花那么多时间，但至少有一个很好的机会，它不会。&lt;/p>
&lt;p>因为&lt;code>map&lt;/code>是惰性的，在你试图访问 Map 的元素之前，它实际上并没有将&lt;code>吸血鬼相关的细节&lt;/code>应用于社会安全号码。事实上，&lt;code>map&lt;/code>几乎立刻就会返回一个值。&lt;/p>
&lt;p>第一个打印行报告了给定操作所花费的时间&amp;ndash;本例中是 1,001.042 毫秒。第二行是返回值，在这个例子中是你的数据库记录。返回值与没有使用&lt;code>time&lt;/code>的情况下完全相同。&lt;/p>
&lt;p>一个不笨的&lt;code>map&lt;/code>的实现首先要对&lt;code>social-security-numbers&lt;/code>的每个成员应用&lt;code>vampire-&lt;/code>related-details&lt;code>，然后再把结果传给&lt;/code>filter`。因为你有一百万个嫌疑人，这将需要一百万秒，也就是 12 天，到那时你的一半城市都会死掉！&amp;quot;。当然，如果结果是唯一的吸血鬼是记录中的最后一个嫌疑人，用懒人版本还是会花那么多时间，但至少有一个很好的机会，它不会。&lt;/p>
&lt;p>因为&lt;code>map&lt;/code>是惰性的，在你试图访问 Map 的元素之前，它实际上并没有将&lt;code>吸血鬼相关的细节&lt;/code>应用于社会安全号码。事实上，&lt;code>map&lt;/code>几乎马上就会返回一个值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(time (def mapped-details (map vampire-related-details (range 0 1000000))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Elapsed time: 0.049 msecs&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #&amp;#39;user/mapped-details
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子中，&lt;code>range&lt;/code>返回一个由 0 到 999,999 的整数组成的惰性序列。然后，&lt;code>map&lt;/code>返回一个与名称&lt;code>mapped-details&lt;/code>相关的惰性序列。因为&lt;code>map&lt;/code>实际上没有对&lt;code>range&lt;/code>返回的任何元素应用&lt;code>vampire-related-details&lt;/code>，整个操作几乎没有花费任何时间，当然，少于 12 天。&lt;/p>
&lt;p>你可以认为懒人序列是由两部分组成的：一个关于如何实现序列元素的配方和到目前为止已经实现的元素。当你使用&lt;code>map&lt;/code>时，它返回的懒人序列不包括任何已实现的元素，但它确实有生成其元素的配方。每当你试图访问一个未实现的元素时，懒人序列将使用它的配方来生成所请求的元素。&lt;/p>
&lt;p>在前面的例子中，&lt;code>mapped-details&lt;/code>是未实现的。一旦你试图访问&lt;code>mapped-details&lt;/code>的一个成员，它将使用它的配方来生成你所请求的元素，你将产生每秒钟的数据库查询费用。&lt;/p>
&lt;p>在这个例子中，&lt;code>range&lt;/code>返回一个由 0 到 999,999 的整数组成的惰性序列。然后，&lt;code>map&lt;/code>返回一个与&lt;code>mapped-details&lt;/code>名称相关的惰性序列。因为&lt;code>map&lt;/code>实际上没有对&lt;code>range&lt;/code>返回的任何元素应用&lt;code>vampire-related-details&lt;/code>，整个操作几乎没有花费任何时间，当然，少于 12 天。&lt;/p>
&lt;p>你可以认为懒人序列由两部分组成：一个关于如何实现序列元素的配方和到目前为止已经实现的元素。当你使用&lt;code>map&lt;/code>时，它返回的惰性序列不包括任何已实现的元素，但它确实有生成其元素的配方。每当你试图访问一个未实现的元素时，懒人序列将使用它的配方来生成所请求的元素。&lt;/p>
&lt;p>在前面的例子中，&lt;code>mapped-details&lt;/code>是未实现的。一旦你试图访问&lt;code>mapped-details&lt;/code>的一个成员，它将使用它的配方来生成你所请求的元素，你将产生每秒钟的数据库查询费用。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(time (first mapped-details))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Elapsed time: 32030.767 msecs&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:name &amp;#34;McFishwich&amp;#34;, :makes-blood-puns? false, :has-pulse? true}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个操作花了大约 32 秒。这比一百万秒好得多，但还是比我们预期的多了 31 秒。毕竟，你只是试图访问第一个元素，所以它应该只花一秒钟。&lt;/p>
&lt;p>花了 32 秒的原因是 Clojure&lt;em>chunks&lt;/em>它的惰性序列，这只是意味着每当 Clojure 要实现一个元素时，它也会预先实现一些下一个元素的实现。在这个例子中，你只想要&lt;code>mapped-details&lt;/code>的第一个元素，但 Clojure 继续前进，也准备了后面的 31 个元素。Clojure 这样做是因为它几乎总是能带来更好的性能。&lt;/p>
&lt;p>值得庆幸的是，惰性的 seq 元素只需要实现一次。再次访问&lt;code>mapped-details&lt;/code>的第一个元素几乎不需要时间。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(time (first mapped-details))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Elapsed time: 0.022 msecs&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:name &amp;#34;McFishwich&amp;#34;, :makes-blood-puns? false, :has-pulse? true}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>有了这些新发现的知识，你就可以有效地挖掘吸血鬼数据库，找到带獠牙的罪魁祸首。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(time (identify-vampire (range 0 1000000)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;#34;Elapsed time: 32019.912 msecs&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:name &amp;#34;Damon Salvatore&amp;#34;, :makes-blood-puns? true, :has-pulse? false}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>哦！这就是为什么达蒙会做出那些令人毛骨悚然的双关语的原因。&lt;/p>
&lt;h3 id="无穷序列">无穷序列&lt;/h3>
&lt;p>惰性序列 给你的一个很酷、很有用的能力是构建无穷序列的能力。到目前为止，你只处理过从 Vector 或列表中生成的惰性序列，这些序列是终止的。然而，Clojure 自带了一些函数来创建无穷序列。创建无穷序列的一个简单方法是使用&lt;code>repeat&lt;/code>，它创建一个序列，其每个成员都是你传递的参数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(concat (take 8 (repeat &amp;#34;na&amp;#34;)) [&amp;#34;Batman!&amp;#34;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (&amp;#34;na&amp;#34; &amp;#34;na&amp;#34; &amp;#34;na&amp;#34; &amp;#34;na&amp;#34; &amp;#34;na&amp;#34; &amp;#34;na&amp;#34; &amp;#34;na&amp;#34; &amp;#34;na&amp;#34; &amp;#34;Batman!&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这种情况下，你创建了一个无穷的序列，其中每个元素都是字符串 &amp;ldquo;na&amp;rdquo;，然后用它来构建一个可能引起或不引起怀旧情绪的序列。&lt;/p>
&lt;p>你也可以使用&lt;code>repeatedly&lt;/code>，它将调用提供的函数来生成序列中的每个元素。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(take 3 (repeatedly (fn [] (rand-int 10))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (1 4 0)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里，由&lt;code>repeatedly&lt;/code>返回的惰性序列通过调用匿名函数&lt;code>(fn [] (rand-int 10))&lt;/code>生成每个新元素，该函数返回一个 0 到 9 之间的随机整数。如果你在你的 REPL 中运行这个，你的结果很可能与此不同。&lt;/p>
&lt;p>惰性序列 的配方不需要指定一个端点。像&lt;code>first&lt;/code>和&lt;code>take&lt;/code>这样的函数实现了惰性序列，它们没有办法知道序列的下一步是什么，如果序列一直提供元素，那么它们就会一直取走它们。如果你构建你自己的无穷序列，你就可以看到这一点。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn even-numbers
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([] (even-numbers 0))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([n] (cons n (lazy-seq (even-numbers (+ n 2))))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(take 10 (even-numbers))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (0 2 4 6 8 10 12 14 16 18)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个例子有点令人费解，因为它使用了递归。记住&lt;code>cons&lt;/code>返回一个新的列表，并将一个元素追加到给定的列表中，会有所帮助。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(cons 0 &amp;#39;(2 4 6))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (0 2 4 6)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>(顺便说一下，Lisp 程序员在使用&lt;code>cons&lt;/code>函数时称它为&lt;em>consing&lt;/em>)。&lt;/p>
&lt;p>在 &amp;ldquo;偶数 &amp;ldquo;中，你是在对一个惰性列表进行 consing，其中包括一个关于下一个元素的配方（一个函数）（而不是对一个完全实现的列表进行 consing）。&lt;/p>
&lt;p>这就涵盖了惰性序列! 现在你知道了关于序列抽象的所有知识，我们可以转向集合抽象了。&lt;/p>
&lt;h2 id="集合抽象">集合抽象&lt;/h2>
&lt;p>集合的抽象与序列的抽象密切相关。所有 Clojure 的核心数据结构&amp;ndash;Vector、Map、列表和集合&amp;ndash;都参与了这两个抽象。&lt;/p>
&lt;p>序列抽象是关于对成员的单独操作，而集合抽象是关于数据结构的整体。例如，集合函数 &lt;code>count&lt;/code>, &lt;code>empty?&lt;/code>, 和 &lt;code>every?&lt;/code> 不是关于任何单独的元素；它们是关于整体的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(empty?[])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(empty? [&amp;#34;no!&amp;#34;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; false
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>实际上，你很少会有意识的说：&amp;ldquo;好的，自己！&amp;quot;。你现在是在和整个集合一起工作。从集合抽象的角度来考虑！&amp;rdquo; 尽管如此，了解这些作为你所使用的函数和数据结构基础的概念还是很有用的。&lt;/p>
&lt;p>现在我们来研究两个常见的集合函数&amp;ndash;&lt;code>into&lt;/code>和&lt;code>conj&lt;/code>，它们的相似性可能会让人有点困惑。&lt;/p>
&lt;h3 id="into">into&lt;/h3>
&lt;p>最重要的集合函数之一是&lt;code>into&lt;/code>。正如你现在所知，许多 seq 函数返回一个 seq，而不是原始数据结构。你可能想把返回值转换成原始值, &lt;code>into&lt;/code>让你做到这一点:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(map identity {:sunlight-reaction &amp;#34;Glitter!&amp;#34;})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; ([:sunlight-reaction &amp;#34;Glitter!&amp;#34;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(into {} (map identity {:sunlight-reaction &amp;#34;Glitter!&amp;#34;}))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:sunlight-reaction &amp;#34;Glitter!&amp;#34;}.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这里，&lt;code>map&lt;/code>函数在得到一个 map 数据结构后返回一个顺序数据结构，并将 seq 转换回 map。&lt;/p>
&lt;p>这也适用于其他数据结构。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(map identity [:garlic :sesame-oil :fried-eggs])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (:garlic :sesame-oil :fried-eggs)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(into [] (map identity [:garlic :sesame-oil :fried-eggs]))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [:garlic :sesame-oil :fried-eggs]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里，在第一行，&lt;code>map&lt;/code>返回一个序列，我们在第二行使用&lt;code>into&lt;/code>将结果转换为一个 Vector。&lt;/p>
&lt;p>在下面的例子中，我们从一个有两个相同条目的 Vector 开始，&lt;code>map&lt;/code>把它转换为一个列表，然后我们用&lt;code>into&lt;/code>把值粘到一个集合中。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(map identity [:garlic-clove :garlic-clove])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (:garlic-clove :garlic-clove)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(into #{} (map identity [:garlic-clove :garlic-clove]))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #{:garlic-clove}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>因为集合只包含唯一的值，所以集合中最终只有一个值。&lt;/p>
&lt;p>&lt;code>into&lt;/code>的第一个参数不一定是空的。这里，第一个例子显示了如何使用&lt;code>into&lt;/code>向 Map 添加元素，第二个例子显示了如何向 Vector 添加元素。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(into {:favorite-emotion &amp;#34;gloomy&amp;#34;} [[:sunlight-reaction &amp;#34;Glitter!&amp;#34;]])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:favorite-emotion &amp;#34;gloomy&amp;#34; :sunlight-reaction &amp;#34;Glitter!&amp;#34;}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(into [&amp;#34;cherry&amp;#34;] &amp;#39;(&amp;#34;pine&amp;#34; &amp;#34;spruce&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [&amp;#34;cherry&amp;#34; &amp;#34;pine&amp;#34; &amp;#34;spruce&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当然，两个参数也可以是同一类型。在下一个例子中，两个参数都是 Map，而之前所有的例子都有不同类型的参数。它的工作原理和你所期望的一样，返回一个新的 Map，将第二个 Map 的元素添加到第一个 Map 中。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(into {:favorite-animal &amp;#34;kitty&amp;#34;} {:least-favorite-smell &amp;#34;dog&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :relationship-with-teenager &amp;#34;creepy&amp;#34;})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:favorite-animal &amp;#34;kitty&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :relationship-with-teenager &amp;#34;creepy&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :least-favorite-smell &amp;#34;dog&amp;#34;}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果&lt;code>into&lt;/code>在求职面试中被要求描述它的优势，它会说：&amp;ldquo;我很擅长处理两个集合，并将第二个集合中的所有元素添加到第一个集合中。&amp;rdquo;&lt;/p>
&lt;h3 id="conj">conj&lt;/h3>
&lt;p>&lt;code>conj&lt;/code>也是向一个集合添加元素，但它的方式略有不同。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(conj [0] [1])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [0 [1]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>呜呜呜! 看起来它把整个 Vector&lt;code>[1]&lt;/code>添加到&lt;code>[0]&lt;/code>。与&lt;code>into&lt;/code>比较。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(into [0] [1])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [0 1]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下面是我们如何用&lt;code>conj&lt;/code>做同样的事情。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(conj [0] 1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [0 1]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，数字 1 是作为标量（单数，非集合）值传递的，而&lt;code>into&lt;/code>的第二个参数必须是一个集合。&lt;/p>
&lt;p>你可以提供尽可能多的元素与&lt;code>conj&lt;/code>一起添加，你也可以添加到其他集合中，如 map。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(conj [0] 1 2 3 4)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [0 1 2 3 4]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(conj {:time &amp;#34;midnight&amp;#34;} [:place &amp;#34;ye olde cemetarium&amp;#34;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:place &amp;#34;ye olde cemetarium&amp;#34; :time &amp;#34;midnight&amp;#34;}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>conj&lt;/code>和&lt;code>into&lt;/code>如此相似，你甚至可以用&lt;code>into&lt;/code>来定义&lt;code>conj&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn my-conj
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [target &amp;amp; additions]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (into target additions))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(my-conj [0] 1 2 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [0 1 2 3]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="功能函数">功能函数&lt;/h2>
&lt;p>学习利用 Clojure 的接受函数作为参数和返回函数作为值的能力是非常有趣的，即使它需要一些适应。&lt;/p>
&lt;p>Clojure 的两个函数，&lt;code>apply&lt;/code>和&lt;code>partial&lt;/code>，可能看起来特别奇怪，因为它们都&lt;em>接受&lt;/em>和&lt;em>返回&lt;/em>函数。让我们来解开它们的疑惑。&lt;/p>
&lt;h3 id="apply">Apply&lt;/h3>
&lt;p>&lt;code>apply&lt;/code> 会展开一个序列，所以它可以被传递给一个期望有其余参数的函数。例如，&lt;code>max&lt;/code>接受任何数量的参数，并返回所有参数中最大的一个。这里是你如何找到最大的数字。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(max 0 1 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但如果你想找到一个 Vector 的最大元素，怎么办？你不能只把 Vector 传给&lt;code>max&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(max [0 1 2])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [0 1 2]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这不会返回 Vector 中最大的元素，因为&lt;code>max&lt;/code>返回所有传递给它的参数中最大的，在这种情况下，你只是传递给它一个包含所有你想比较的数字的 Vector，而不是把数字作为单独的参数传递进去。&lt;code>apply&lt;/code>是这种情况的完美选择。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(apply max [0 1 2])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通过使用&lt;code>apply&lt;/code>，就像你调用&lt;code>(max 0 1 2)&lt;/code>一样。你经常会像这样使用&lt;code>apply&lt;/code>，对一个集合的元素进行分解，使它们作为单独的参数被传递给一个函数。&lt;/p>
&lt;p>还记得我们之前是如何用 &amp;ldquo;into &amp;ldquo;来定义 &amp;ldquo;conj &amp;ldquo;的吗？那么，我们也可以通过使用&lt;code>apply&lt;/code>在&lt;code>conj&lt;/code>的基础上定义&lt;code>into&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn my-into
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [target additions]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (apply conj target additions))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(my-into [0] [1 2 3])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [0 1 2 3]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>对&lt;code>my-into&lt;/code>的调用相当于调用&lt;code>(conj [0] 1 2 3)&lt;/code>。&lt;/p>
&lt;h3 id="partial">Partial&lt;/h3>
&lt;p>&lt;code>partial&lt;/code>接收一个函数和任意数量的参数。然后它返回一个新的函数。当你调用返回的函数时，它用你提供的原参数和新参数一起调用原函数。&lt;/p>
&lt;p>这里有一个例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def add10 (partial + 10))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(add10 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 13
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(add10 5)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 15
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def add-missing-elements
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (partial conj [&amp;#34;water&amp;#34; &amp;#34;earth&amp;#34; &amp;#34;air&amp;#34;]))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(add-missing-elements &amp;#34;unobtainium&amp;#34; &amp;#34;adamantium&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [&amp;#34;water&amp;#34; &amp;#34;earth&amp;#34; &amp;#34;air&amp;#34; &amp;#34;unobtainium&amp;#34; &amp;#34;adamantium&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>所以当你调用&lt;code>add10&lt;/code>时，它会调用原始函数和参数&lt;code>（+ 10）&lt;/code>，并附加你调用&lt;code>add10&lt;/code>的任何参数。为了帮助澄清&lt;code>partial&lt;/code>的工作原理，下面演示了如何定义：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn my-partial
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [partialized-fn &amp;amp; args]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (fn [&amp;amp; more-args]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (apply partialized-fn (into args more-args))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def add20 (my-partial + 20))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(add20 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 23
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子中，&lt;code>add20&lt;/code>的值是由&lt;code>my-partial&lt;/code>返回的匿名函数。这个匿名函数是这样定义的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(fn [&amp;amp; more-args]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (apply + (into [20] more-args)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>一般来说，当你发现你在许多不同的情况下重复相同的函数和参数组合时，你会想使用 partial。这个玩具例子显示了你如何使用&lt;code>partial&lt;/code>来专门化一个记录器，创建一个&lt;code>warn&lt;/code>函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn lousy-logger
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [log-level message]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (condp = log-level
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :warn (clojure.string/lower-case message)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :emergency (clojure.string/upper-case message)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def warn (partial lousy-logger :warn))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(warn &amp;#34;Red light ahead&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;red light ahead&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这里调用&lt;code>(warning &amp;quot;Red light ahead&amp;quot;)&lt;/code>与调用&lt;code>(lousy-logger :warning &amp;quot;Red light ahead&amp;quot;)&lt;/code>是相同的。&lt;/p>
&lt;h3 id="complement">Complement&lt;/h3>
&lt;p>早些时候，你创建了&lt;code>识别吸血鬼&lt;/code>函数，以便在一百万人中找到一个吸血鬼。如果你想创建一个函数来寻找所有的人类呢？也许你想给他们发送感谢卡，因为他们没有成为不死的掠夺者。这里是你可以做的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn identify-humans
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [social-security-numbers]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (filter #(not (vampire? %))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (map vampire-related-details social-security-numbers)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看看&lt;code>filter&lt;/code>的第一个参数，&lt;code>#(not (vampire? %))&lt;/code>。想要得到一个布尔函数的&lt;em>complement&lt;/em>（否定）是很常见的，所以有一个函数，&lt;code>complement&lt;/code>，用于此。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def not-vampire? (complement vampire?))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn identify-humans
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [social-security-numbers]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (filter not-vampire?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (map vampire-related-details social-security-numbers)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下面是你如何实现 &amp;ldquo;complement&amp;quot;的方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn my-complement
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [fun]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (fn [&amp;amp; args]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (not (apply fun args))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def my-pos? (complement neg?))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(my-pos? 1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(my-pos? -1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; false
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>正如你所看到的，&lt;code>complement&lt;/code>是一个不起眼的函数。它只做一件小事，而且做得很好。&lt;code>complement&lt;/code>使创建一个&lt;code>不吸血&lt;/code>的函数变得微不足道，而且任何阅读代码的人都能理解代码的意图。&lt;/p>
&lt;p>这不会为你提供数兆字节的数据的 MapReduce 或类似的东西，但它确实证明了高阶函数的力量。它们允许你以一种在某些语言中不可能实现的方式建立起实用函数库。总的来说，这些实用函数使你的生活变得更加轻松。&lt;/p>
&lt;h2 id="为华盛顿州福克斯警察局fwpd编写一个复杂的吸血鬼数据分析程序">为华盛顿州福克斯警察局（FWPD）编写一个复杂的吸血鬼数据分析程序&lt;/h2>
&lt;p>为了把所有的事情联系起来，让我们为华盛顿州福克斯警察局（FWPD）编写一个复杂的吸血鬼数据分析程序的雏形。&lt;/p>
&lt;p>FWPD 有一个花哨的新数据库技术，叫做&lt;em>CSV&lt;/em> &lt;em>（逗号-**分隔的&lt;/em>值）&lt;em>。你的工作是解析这个最先进的 CSV，并分析它是否有潜在的吸血鬼。我们将通过过滤每个嫌疑人的&lt;/em>闪光指数*来做到这一点，这是一个由某个少女开发的对嫌疑人的吸血鬼性的 0-10 预测。继续并为你的工具创建一个新的 Leiningen 项目。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">lein new app fwpd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在新的&lt;em>fwpd&lt;/em>目录下，创建一个名为&lt;em>suspects.csv&lt;/em>的文件，输入如下内容。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Edward Cullen,10
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Bella Swan,0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Charlie Swan,0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Jacob Black,3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Carlisle Cullen,6
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在是时候通过建立&lt;em>fwpd/src/fwpd/core.clj&lt;/em>文件来弄脏你的手了。我建议你启动一个新的 REPL 会话，这样你就可以边走边试。在 Emacs 中，你可以通过打开&lt;em>fwpd/**src/fwpd/core.clj&lt;/em>并运行&lt;strong>M-x&lt;/strong> cider-restart 来实现。一旦 REPL 启动，删除&lt;em>core.clj&lt;/em>的内容，然后加入以下内容。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(ns fwpd.core)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def filename &amp;#34;suspects.csv&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>第一行建立了命名空间，第二行只是使你创建的 CSV 更容易被引用。你可以通过编译你的文件（Emacs 中的&lt;strong>C-c C-k&lt;/strong>）并运行以下程序，在你的 REPL 中做一个快速的理智检查。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(slurp filename)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Edward Cullen,10\nBella Swan,0\nCharlie Swan,0\nJacob Black, 3\nCarlisle Cullen, 6&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果&lt;code>slurp&lt;/code>函数没有返回前面的字符串，试着在&lt;em>core.clj&lt;/em>打开的情况下重新启动你的 REPL 会话。&lt;/p>
&lt;p>接下来，在&lt;em>core.clj&lt;/em>中添加这个内容。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">➊ (def vamp-keys [:name :glitter-index])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➋ (defn str-&amp;gt;int
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [str]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (Integer. str))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➌ (def conversions {:name identity
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :glitter-index str-&amp;gt;int})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➍ (defn convert
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [vamp-key value]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ((get conversions vamp-key) value))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最终，你会得到一串看起来像&lt;code>{:name &amp;quot;Edward Cullen&amp;quot; :glitter-index 10}&lt;/code>的 Map，前面的定义可以帮助你达到目的。首先，&lt;code>vamp-keys&lt;/code>➊是一个键的 Vector，你很快会用它来创建吸血鬼 Map。接下来，函数&lt;code>str-&amp;gt;int&lt;/code>➋将一个字符串转换为一个整数。Map&lt;code>conversions&lt;/code>➌将一个转换函数与每个吸血鬼键相关联。你根本不需要转换名字，所以它的转换函数是&lt;code>identity&lt;/code>，它只是返回传递给它的参数。熠熠生辉的索引被转换为一个整数，所以它的转换函数是&lt;code>str-&amp;gt;int&lt;/code>。最后，&lt;code>convert&lt;/code>函数➍接收一个 vamp 键和一个值，并返回转换后的值。下面是一个例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(convert :glitter-index &amp;#34;3&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在把这个添加到你的文件中。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn parse
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Convert a CSV into rows of columns&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [string]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (map #(clojure.string/split % #&amp;#34;,&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (clojure.string/split string #&amp;#34;\n&amp;#34;)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>parse&lt;/code>函数接收一个字符串，首先在换行符上进行分割，创建一个字符串的序列。接下来，它对字符串序列进行 Map，在逗号字符上分割每一个字符串。试着在你的 CSV 上运行&lt;code>parse&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(parse (slurp filename))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; ([&amp;#34;Edward Cullen&amp;#34; &amp;#34;10&amp;#34;] [&amp;#34;Bella Swan&amp;#34; &amp;#34;0&amp;#34;] [&amp;#34;Charlie Swan&amp;#34; &amp;#34;0&amp;#34;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [&amp;#34;Jacob Black&amp;#34; &amp;#34;3&amp;#34;] [&amp;#34;Carlisle Cullen&amp;#34; &amp;#34;6&amp;#34;])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来的代码将 Vector 序列与你的吸血鬼钥匙结合起来，创建 Map。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn mapify
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Return a seq of maps like {:name \&amp;#34;Edward Cullen\&amp;#34; :glitter-index 10}&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [rows]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (map (fn [unmapped-row]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (reduce (fn [row-map [vamp-key value]]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (assoc row-map vamp-key (convert vamp-key value)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (map vector vamp-keys unmapped-row)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> rows))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个函数中，&lt;code>map&lt;/code>通过使用&lt;code>reduce&lt;/code>将每一行 Vector 如&lt;code>[&amp;quot;Bella Swan&amp;quot; 0]&lt;/code>转化为一个 Map，其方式与上面&amp;rdquo;&lt;code>reduce&lt;/code>&amp;ldquo;中的第一个例子相似。首先，&lt;code>map&lt;/code>创建一个键值对序列，如&lt;code>([:name &amp;quot;Bella Swan&amp;quot;] [:glitter-index 0])&lt;/code>。然后，&amp;ldquo;reduce &amp;ldquo;通过将一个 vamp 键和一个转换后的 vamp 值关联到 &amp;ldquo;row-map &amp;ldquo;来建立一个 Map。下面是第一行的 Map。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(first (mapify (parse (slurp filename))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:glitter-index 10, :name &amp;#34;Edward Cullen&amp;#34; }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后，添加这个&lt;code>glitter-filter&lt;/code>函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn glitter-filter
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [minimum-glitter records]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (filter #(&amp;gt;= (:glitter-index %) minimum-glitter) records))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这需要完全 Map 的吸血鬼记录，并过滤掉那些&lt;code>:glitter-index&lt;/code>小于所提供的&lt;code>minimum-glitter&lt;/code>的记录。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(glitter-filter 3 (mapify (parse (slurp filename))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">({:name &amp;#34;Edward Cullen&amp;#34;, :glitter-index 10}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;Jacob Black&amp;#34;, :glitter-index 3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;Carlisle Cullen&amp;#34;, :glitter-index 6})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Et voilà! 你现在离实现你的梦想又近了一步，即成为一名猎杀超自然生物的义务警员。你最好去围捕那些粗略的人物!&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>在本章中，你了解到 Clojure 强调对抽象的编程。序列抽象处理的是对序列中各个元素的操作，而 seq 函数通常将其参数转换为 seq，并返回一个惰性的 seq。惰性求值通过将计算推迟到需要时再进行，从而提高性能。你所学到的另一个抽象，即集合抽象，处理的是整个数据结构。最后，你学到的最重要的东西是，你不应该相信那些在阳光下闪光的人。&lt;/p>
&lt;h2 id="练习">练习&lt;/h2>
&lt;p>你现在拥有的吸血鬼分析程序已经领先于市场上的任何其他程序几十年了。但你怎样才能使它变得更好呢？我建议尝试以下几点。&lt;/p>
&lt;ol>
&lt;li>把你的闪光过滤器的结果变成一个名字的列表。&lt;/li>
&lt;li>写一个函数，&lt;code>append&lt;/code>，它将把一个新的嫌疑人追加到你的嫌疑人列表中。&lt;/li>
&lt;li>写一个函数，&lt;code>validate&lt;/code>，它将在你&lt;code>append&lt;/code>时检查&lt;code>:name&lt;/code>和&lt;code>:glitter-index&lt;/code>是否存在。&lt;code>validate&lt;/code>函数应该接受两个参数：一个类似于&lt;code>conversions&lt;/code>的验证函数的关键词 Map，以及要验证的记录。&lt;/li>
&lt;li>编写一个函数，将你的 Map 列表转换为 CSV 字符串。你需要使用&lt;code>clojure.string/join&lt;/code>函数。&lt;/li>
&lt;/ol>
&lt;p>祝你好运，McFishwich!&lt;/p></description></item><item><title>Chapter3 速成班</title><link>https://example.com/p/chapter3-%E9%80%9F%E6%88%90%E7%8F%AD/</link><pubDate>Thu, 13 Jan 2022 11:12:19 +0800</pubDate><guid>https://example.com/p/chapter3-%E9%80%9F%E6%88%90%E7%8F%AD/</guid><description>&lt;h1 id="做事情clojure-速成班">做事情：Clojure 速成班&lt;/h1>
&lt;p>是时候学习如何用 Clojure 真正地&lt;em>做事&lt;/em>了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。&lt;/p>
&lt;p>在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!&lt;/p>
&lt;p>当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!&lt;/p>
&lt;h2 id="语法">语法&lt;/h2>
&lt;p>Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。&lt;/p>
&lt;h3 id="form">Form&lt;/h3>
&lt;p>所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。&lt;/p>
&lt;ul>
&lt;li>数据结构的字面表示（如数字、字符串、Map 和 Vector）&lt;/li>
&lt;li>操作&lt;/li>
&lt;/ul>
&lt;p>我们使用术语&lt;em>form&lt;/em>来指代有效的代码。我有时也会用&lt;em>表达式&lt;/em>来指代 Clojure Form。但不要太纠结于术语。Clojure &lt;em>求值&lt;/em>每一个 Form，以产生一个值。这些字面意义的表达都是有效的 Form。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;#34;a string&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">[&amp;#34;a&amp;#34; &amp;#34;vector&amp;#34; &amp;#34;of&amp;#34; &amp;#34;strings&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当然，你的代码很少包含自由浮动的字符，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你&lt;em>做事情&lt;/em>的方式。所有操作的 Form 都是：&lt;em>开括号&lt;/em>，&lt;em>操作符&lt;/em>，&lt;em>操作数&lt;/em>，&lt;em>闭括号&lt;/em>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(operator operand1 operand2 ... operandn)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(+ 1 2 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 6
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(str &amp;#34;It was the panda &amp;#34; &amp;#34;in the library &amp;#34; &amp;#34;with a dust buster&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;It was the panda in the library with a dust buster&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/do-things/panda.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>在第一个操作中，运算符&lt;code>+&lt;/code>将操作数&lt;code>1&lt;/code>、&lt;code>2&lt;/code>和&lt;code>3&lt;/code>相加。在第二个操作中，运算符&lt;code>str&lt;/code>将三个字符串连接起来，形成一个新的字符串。这两种 Form 都是有效的。这里有一个不是 Form 的东西，因为它没有一个结束的小括号。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(+
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Clojure 的结构统一性可能与你所习惯的不同。在其他语言中，不同的操作可能有不同的结构，这取决于操作符和操作数。例如，JavaScript 采用的是 中缀符号、点运算符和小括号的大杂烩。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">1 + 2 + 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;#34;It was the panda &amp;#34;.concat(&amp;#34;in the library &amp;#34;, &amp;#34;with a dust buster&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>相比之下，Clojure 的结构是非常简单和一致的。无论你使用哪种运算符，或对哪种数据进行操作，其结构都是一样的。&lt;/p>
&lt;h3 id="控制流">控制流&lt;/h3>
&lt;p>让我们来看看三个基本的控制流操作符。&lt;code>if&lt;/code>, &lt;code>do&lt;/code>, 和&lt;code>when&lt;/code>。在本书中，你会遇到更多的操作，但这些操作可以让你开始。&lt;/p>
&lt;h4 id="if">if&lt;/h4>
&lt;p>这是一个 &lt;code>if&lt;/code> 表达式的一般结构。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(if boolean-form
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> then-form
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> optional-else-form)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>布尔 Form 只是一个求值为真或假的 Form。你会在下一节中了解到逻辑真和逻辑假。下面是几个&lt;code>if&lt;/code>的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(if true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;By Zeus&amp;#39;s hammer!&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;By Aquaman&amp;#39;s trident!&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;By Zeus&amp;#39;s hammer!&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(if false
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;By Zeus&amp;#39;s hammer!&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;By Aquaman&amp;#39;s trident!&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;By Aquaman&amp;#39;s trident!&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>第一个例子返回 &amp;ldquo;By Zeus&amp;rsquo;s hammer!&amp;quot;，因为其布尔 Form 求值为 &lt;code>true&lt;/code>，是一个真值；第二个例子返回 &amp;ldquo;By Aquaman&amp;rsquo;s trident!&amp;quot;，因为其布尔 Form &amp;ldquo;false&amp;rdquo;，求值为一个假值。&lt;/p>
&lt;p>你也可以省略&lt;code>else&lt;/code>分支。如果你这样做，并且布尔表达式是假的，Clojure 会返回&lt;code>nil&lt;/code>，就像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(if false
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;By Odin&amp;#39;s Elbow!&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; nil
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意&lt;code>if&lt;/code>使用操作数位置将操作数与&lt;code>then&lt;/code>和&lt;code>else&lt;/code>分支联系起来：第一个操作数是&lt;code>then&lt;/code>分支，第二个操作数是（可选）&lt;code>else&lt;/code>分支。因此，每个分支只能有一种 Form。这与大多数语言不同。例如，你可以在 Ruby 中这样写。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">if true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> doer.do_thing(1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> doer.do_thing(2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">else
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> other_doer.do_thing(1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> other_doer.do_thing(2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">end
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>为了绕过这个明显的限制，你可以使用&lt;code>do&lt;/code>操作符。&lt;/p>
&lt;h4 id="do">do&lt;/h4>
&lt;p>&lt;code>do&lt;/code>操作符可以让你在括号中&lt;em>包裹&lt;/em>起多个 Form，并运行其中的每一个。在你的 REPL 中尝试以下操作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(if true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (do (println &amp;#34;Success!&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;By Zeus&amp;#39;s hammer!&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (do (println &amp;#34;Failure!&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;By Aquaman&amp;#39;s trident!&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Success!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;By Zeus&amp;#39;s hammer!&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个操作符让你在&lt;code>if&lt;/code>表达式的每个分支中做多件事情。在这种情况下，会发生两件事。&lt;code>Success!&lt;/code>被打印在 REPL 中，&lt;code>By Zeus's hammer!&lt;/code>被作为整个&lt;code>if&lt;/code>表达式的值返回。&lt;/p>
&lt;h4 id="when">when&lt;/h4>
&lt;p>&lt;code>when&lt;/code>操作符就像&lt;code>if&lt;/code>和&lt;code>do&lt;/code>的组合，但没有&lt;code>else&lt;/code>分支。下面是一个例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(when true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println &amp;#34;Success!&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;abra cadabra&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Success!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;abra cadabra&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果你想在某个条件为真时做多件事，而你总是想在条件为假时返回&lt;code>nil&lt;/code>，请使用&lt;code>when&lt;/code>。&lt;/p>
&lt;h4 id="nil-true-false-truthiness-equality-and-boolean-expressions">nil, true, false, Truthiness, Equality, and Boolean Expressions&lt;/h4>
&lt;p>Clojure 有&lt;code>true&lt;/code>和&lt;code>false&lt;/code>。&lt;code>nil&lt;/code>在 Clojure 中用来表示&lt;em>没有值&lt;/em>。你可以用&lt;code>nil?&lt;/code>函数来检查一个值是否为&lt;code>nil&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(nil? 1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; false
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(nil? nil)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>nil&lt;/code>和&lt;code>false&lt;/code>都是用来表示逻辑上的虚假性，而所有其他的值都是逻辑上的真实性。&lt;em>Truthy&lt;/em>和&lt;em>falsey&lt;/em>指的是在布尔表达式中如何处理一个值，比如传递给&lt;code>if&lt;/code>的第一个表达式。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(if &amp;#34;bears eat beets&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;bears beets Battlestar Galactica&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;bears beets Battlestar Galactica&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(if nil
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;This won&amp;#39;t be the result because nil is falsey&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;nil is falsey&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;nil is falsey&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在第一个例子中，字符串&lt;code>bears eat beets&lt;/code>被认为是&lt;code>true&lt;/code>，所以&lt;code>if&lt;/code>表达式求值为 bears beets Battlestar Galactica`。第二个例子显示一个 nil 是假的。&lt;/p>
&lt;p>Clojure 的等于运算符是&lt;code>=&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(= 1 1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(= nil nil)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(= 1 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; false
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其他一些语言要求你在比较不同类型的值时使用不同的运算符。例如，你可能不得不使用某种专门为字符串制作的特殊字符串等于运算符。但在使用 Clojure 的内置数据结构时，你不需要像这样奇怪或繁琐的东西来测试等于。&lt;/p>
&lt;p>Clojure 使用布尔运算符&lt;code>or&lt;/code>和&lt;code>and&lt;/code>。&lt;code>or&lt;/code>返回第一个真值或最后一个值。&lt;code>and&lt;/code>返回第一个 false 的值，如果没有 false 的值，则返回最后一个 true 的值。让我们先看一下&lt;code>or&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(or false nil :large_I_mean_venti :why_cant_I_just_say_large)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; :large_I_mean_venti
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(or (= 0 1) (= &amp;#34;yes&amp;#34; &amp;#34;no&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; false
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(or nil)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; nil
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在第一个例子中，返回值是&lt;code>:large_I_mean_venti&lt;/code>，因为它是第一个真值。第二个例子没有真值，所以&lt;code>or&lt;/code>返回最后一个值，即&lt;code>false&lt;/code>。在最后一个例子中，同样没有真值存在，&lt;code>or&lt;/code>返回最后一个值，即&lt;code>nil&lt;/code>。现在我们来看看&lt;code>and&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(and :free_wifi :hot_coffee)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; :hot_coffee
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(and :feelin_super_cool nil false)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; nil
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在第一个例子中，&lt;code>and&lt;/code>返回最后一个真值，&lt;code>:hot_coffee&lt;/code>。在第二个例子中, &lt;code>and&lt;/code>返回&lt;code>nil&lt;/code>, 这是第一个 false 的值.&lt;/p>
&lt;h3 id="用-def-命名">用 def 命名&lt;/h3>
&lt;p>在 Clojure 中, 你可以使用&lt;code>def&lt;/code>将一个名字与一个值绑定起来:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def failed-protagonist-names
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [&amp;#34;Larry Potter&amp;#34; &amp;#34;Doreen the Explorer&amp;#34; &amp;#34;The Incredible Bulk&amp;#34;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">failed-protagonist-names
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [&amp;#34;Larry Potter&amp;#34; &amp;#34;Doreen the Explorer&amp;#34; &amp;#34;The Incredible Bulk&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/do-things/larry-potter.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>在这个例子中，你把名字&lt;code>failed-protagonist-names&lt;/code>绑定到一个包含三个字符串的 Vector（你将在&lt;a class="link" href="https://www.braveclojure.com/do-things/#Anchor-3" target="_blank" rel="noopener"
>&amp;ldquo;Vector &amp;ldquo;第 45 页&lt;/a>中了解 Vector）。&lt;/p>
&lt;p>请注意，我使用的是 &amp;ldquo;绑定&amp;quot;一词，而在其他语言中，你会说你是在给一个&lt;em>变量&lt;/em>赋值。那些其他语言通常鼓励你对同一个变量进行多次赋值。&lt;/p>
&lt;p>例如，在 Ruby 中，你可以对一个变量进行多次赋值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">severity = :mild
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">error_message = &amp;#34;OH GOD! IT&amp;#39;S A DISASTER! WE&amp;#39;RE &amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">if severity == :mild
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> error_message = error_message + &amp;#34;MILDLY INCONVENIENCED!&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">else
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> error_message = error_message + &amp;#34;DOOOOOOOMED!&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">end
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可能想在 Clojure 中做类似的事情。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def severity :mild)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def error-message &amp;#34;OH GOD! IT&amp;#39;S A DISASTER! WE&amp;#39;RE &amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(if (= severity :mild)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (def error-message (str error-message &amp;#34;MILDLY INCONVENIENCED!&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (def error-message (str error-message &amp;#34;DOOOOOOOMED!&amp;#34;)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然而，像这样改变与名字相关的值会使你更难理解你的程序的行为，因为更难知道哪个值是与名字相关的，或者为什么这个值可能已经改变了。Clojure 有一套处理变化的工具，你会在第 10 章中了解到。随着你对 Clojure 的学习，你会发现你很少需要改变一个名字/值的关联。下面是你写前面代码的一种方式。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn error-message
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [severity]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str &amp;#34;OH GOD! IT&amp;#39;S A DISASTER! WE&amp;#39;RE &amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if (= severity :mild)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;MILDLY INCONVENIENCED!&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;DOOOOOOOMED!&amp;#34;)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(error-message :mild)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;OH GOD! IT&amp;#39;S A DISASTER! WE&amp;#39;RE MILDLY INCONVENIENCED!&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里，你创建了一个函数，&lt;code>error-message&lt;/code>，它接受一个参数，&lt;code>severity&lt;/code>，并使用它来决定返回哪个字符串。然后你用&lt;code>:mild&lt;/code>作为严重程度来调用这个函数。你将在&lt;a class="link" href="https://www.braveclojure.com/do-things/#Anchor-4" target="_blank" rel="noopener"
>&amp;ldquo;函数 &amp;ldquo;第 48 页&lt;/a>中学习所有关于创建函数的知识；与此同时，你应该把&lt;code>def&lt;/code>当作定义常量。在接下来的几章中，你将学习如何通过接受函数式编程范式来处理这个明显的限制。&lt;/p>
&lt;h2 id="数据结构">数据结构&lt;/h2>
&lt;p>Clojure 带有少量的数据结构，你在大多数时候都会用到。如果你来自面向对象的背景，你会惊讶于你可以用这里介绍的看似基本的类型做很多事情。&lt;/p>
&lt;p>Clojure 的所有数据结构都是不可改变的，这意味着你不能在原地改变它们。例如，在 Ruby 中，你可以做以下事情来重新分配索引为 0 的失败主角的名字。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">failed_protagonist_names = [
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Larry Potter&amp;#34;,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Doreen the Explorer&amp;#34;,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;The Incredible Bulk&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">failed_protagonist_names[0] = &amp;#34;Gary Potter&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">failed_protagonist_names
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># =&amp;gt; [
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># &amp;#34;Gary Potter&amp;#34;,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># &amp;#34;Doreen the Explorer&amp;#34;,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># &amp;#34;The Incredible Bulk&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># ]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Clojure 没有与之对应的东西。你会在第 10 章中了解到更多关于 Clojure 这样实现的原因，但现在只学习如何做事情，而不考虑所有的哲学问题，这很有趣。不多说了，让我们来看看 Clojure 中的数字。&lt;/p>
&lt;h3 id="number">Number&lt;/h3>
&lt;p>Clojure 有相当复杂的 Number 支持。我不会花太多时间纠缠于无聊的技术细节（比如强制和传染），因为那会妨碍&lt;em>做事情&lt;/em>。如果你对这些枯燥的细节感兴趣，请查看*&lt;a class="link" href="http://clojure.org/data_structures#Data%20Structures-Numbers" target="_blank" rel="noopener"
>http://clojure.org/data_structures#Data%20Structures-Numbers&lt;/a>*的文档。可以说，Clojure 会很高兴地处理你扔给它的所有东西。&lt;/p>
&lt;p>在此期间，我们将使用整数和浮点数。我们还将使用分数，Clojure 可以直接表示这些分数。下面分别是一个整数、一个浮点数和一个分数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">93
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1.2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1/5
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="字符串">字符串&lt;/h3>
&lt;p>字符串代表文本。这个名字来自于古代腓尼基人，他们在一次涉及纱线的事故后，有一天发明了字母表。下面是一些字符串字面的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">&amp;#34;Lord Voldemort&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;#34;\&amp;#34;He who must not be named\&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;#34;\&amp;#34;Great cow of Moscow!\&amp;#34; - Hermes Conrad&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/do-things/wookie.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>注意，Clojure 只允许用双引号来划分字符串。例如，&amp;lsquo;Lord Voldemort&amp;rsquo; 就不是一个有效的字符串。还要注意，Clojure 没有字符串插值。它只允许通过&lt;code>str&lt;/code>函数进行拼接。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def name &amp;#34;Chewbacca&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(str &amp;#34;\&amp;#34;Uggllglglglglglll\&amp;#34; - &amp;#34; name)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Uggllglglglglglll&amp;#34; - Chewbacca
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="map">Map&lt;/h3>
&lt;p>Map 类似于其他语言中的字典或哈希值。它们是一种将一些值与另一些值联系起来的方式。Clojure 中的两种 Map 是哈希 Map 和排序 Map。我将只介绍更基本的哈希 Map。让我们来看看 Map 字面的一些例子。这里有一个空 Map。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">{}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子中，&lt;code>:first-name&lt;/code>和&lt;code>:last-name&lt;/code>是关键字（我将在下一节介绍这些）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">{:first-name &amp;#34;Charlie&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :last-name &amp;#34;McFishwich&amp;#34;}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里我们把&lt;code>&amp;quot;string-key&amp;quot;&lt;/code>和&lt;code>+&lt;/code>函数联系起来。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">{&amp;#34;string-key&amp;#34; +}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Map 可以被嵌套。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">{:name {:first &amp;#34;John&amp;#34; :middle &amp;#34;Jacob&amp;#34; :last &amp;#34;Jingleheimerschmidt&amp;#34;}}.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，Map 的值可以是任何类型&amp;ndash;字符串、数字、Map、Vector，甚至函数。Clojure 并不关心这个问题。&lt;/p>
&lt;p>除了使用 map 字面，你还可以使用&lt;code>hash-map&lt;/code>函数来创建一个 map。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(hash-map :a 1 :b 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:a 1 :b 2}.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以用&lt;code>get&lt;/code>函数在 Map 中查询数值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(get {:a 0 :b 1} :b)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(get {:a 0 :b {:c &amp;#34;ho hum&amp;#34;}} :b)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:c &amp;#34;ho hum&amp;#34;}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这两个例子中，我们向&lt;code>get&lt;/code>询问给定 Map 中&lt;code>:b&lt;/code>键的值&amp;ndash;在第一个例子中，它返回&lt;code>1&lt;/code>，而在第二个例子中，它返回嵌套 Map&lt;code>{:c &amp;quot;ho hum&amp;quot;}&lt;/code>。&lt;/p>
&lt;p>如果没有找到你的键，&lt;code>get&lt;/code>将返回&lt;code>nil&lt;/code>，或者你可以给它一个默认值，例如&lt;code>&amp;quot;unicorns？&amp;quot;&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(get {:a 0 :b 1} :c)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; nil
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(get {:a 0 :b 1} :c &amp;#34;unicorns?&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;unicorns?&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>get-in&lt;/code>函数可以让你在嵌套 Map 中查询数值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(get-in {:a 0 :b {:c &amp;#34;ho hum&amp;#34;}} [:b :c])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;ho hum&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>另一种在 Map 中查询数值的方法是把 Map 当作一个以键为参数的函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">({:name &amp;#34;The Human Coffeepot&amp;#34;} :name)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;The Human Coffeepot&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以用 Map 做的另一件很酷的事情是把 Keywords 作为函数来查询它们的值，这就引出了下一个主题，Keywords。&lt;/p>
&lt;h3 id="keywords">Keywords&lt;/h3>
&lt;p>了解 Clojure 关键字的最好方法是看它们是如何被使用的。正如你在上一节中所看到的，它们主要是作为 Map 中的键来使用。下面是一些 Keywords 的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">:a
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:rumplestiltsken
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:34
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:_?
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Keywords 可以作为函数使用，在数据结构中查找相应的值。例如，你可以在一个 Map 中查找&lt;code>:a&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(:a {:a 1 :b 2 :c 3})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这相当于。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(get {:a 1 :b 2 :c 3} :a)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以提供一个默认值，和&lt;code>get&lt;/code>一样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(:d {:a 1 :b 2 :c 3} &amp;#34;No gnome knows homes like Noah knows&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;No gnome knows homes like Noah knows&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>使用关键字作为一个函数是令人愉快的简洁，Real Clojurists 一直在这样做。你也应该这样做!&lt;/p>
&lt;h3 id="vector">Vector&lt;/h3>
&lt;p>Vector 类似于数组, 它是一个以 0 为索引的 Set。例如, 下面是一个 Vector 的字面意思:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[3 2 1]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里我们要返回一个 Vector 的第 0 个元素。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(get [3 2 1] 0)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下面是另一个按索引获取的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(get [&amp;#34;a&amp;#34; {:name &amp;#34;Pugsley Winterbottom&amp;#34;} &amp;#34;c&amp;#34;] 1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; {:name &amp;#34;Pugsley Winterbottom&amp;#34;}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以看到，Vector 元素可以是任何类型，而且你可以混合类型。还注意到我们使用的&lt;code>get&lt;/code>函数与我们在 Map 中查找数值时使用的相同。&lt;/p>
&lt;p>你可以用&lt;code>vector&lt;/code>函数来创建 Vector。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(vector &amp;#34;creepy&amp;#34; &amp;#34;full&amp;#34; &amp;#34;moon&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [&amp;#34;creepy&amp;#34; &amp;#34;full&amp;#34; &amp;#34;moon&amp;#34;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以使用&lt;code>conj&lt;/code>函数来添加额外的元素到 Vector 中。元素被添加到 Vector 的&lt;em>尾部&lt;/em>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(conj [1 2 3] 4)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [1 2 3 4]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Vector 不是存储序列的唯一方法；Clojure 还有&lt;em>列表&lt;/em>。&lt;/p>
&lt;h3 id="列表">列表&lt;/h3>
&lt;p>列表 与 Vector 类似，它们都是数值的线性 Set。但也有一些区别。例如，你不能用&lt;code>get&lt;/code>检索列表元素。要写一个列表的字面意思, 只需将元素插入括号内, 并在开头使用单引号:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">&amp;#39;(1 2 3 4)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (1 2 3 4)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，当 REPL 打印出列表时，它不包括单引号。我们将在后面的第 7 章中再来讨论为什么会这样。如果你想从一个列表中检索一个元素，你可以使用 &lt;code>nth&lt;/code> 函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(nth &amp;#39;(:a :b :c) 0)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; :a
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(nth &amp;#39;(:a :b :c) 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; :c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我在本书中没有详细介绍性能，因为我认为只有你熟悉一种语言之后再关注它才是有用的。然而，知道使用&lt;code>nth&lt;/code>从列表中检索一个元素比使用&lt;code>get&lt;/code>从 Vector 中检索一个元素要慢一些是很好的。这是因为 Clojure 必须遍历一个列表中的所有&lt;em>n&lt;/em>个元素才能到达&lt;em>n&lt;/em>个，而通过索引访问一个 Vector 元素最多只需要几跳。&lt;/p>
&lt;p>列表值可以有任何类型，你可以用&lt;code>list&lt;/code>函数创建列表。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(list 1 &amp;#34;two&amp;#34; {3 4})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (1 &amp;#34;二&amp;#34; {3 4})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>元素被添加到一个列表的&lt;em>开头&lt;/em>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(conj &amp;#39;(1 2 3) 4)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (4 1 2 3)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>什么时候应该使用列表，什么时候应该使用 Vector？一个好的经验法则是，如果你需要很容易地把项目添加到一个序列的开头，或者你正在写一个宏，你应该使用一个列表。否则，你应该使用 Vector。随着你学习的深入，你会对何时使用哪种方法有很好的感觉。&lt;/p>
&lt;h3 id="set">Set&lt;/h3>
&lt;p>Set 是唯一值的集合。Clojure 有两种类型的 Set：哈希 Set 和排序 Set。我将专注于哈希 Set，因为它们更经常被使用。下面是一个哈希 Set 的文字符号。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">#{&amp;#34;kurt vonnegut&amp;#34; 20 :icicle}.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你也可以用&lt;code>hash-set&lt;/code>来创建一个 Set:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(hash-set 1 1 2 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #{1 2}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，一个值的多个实例在 Set 中成为一个唯一的值，所以我们只剩下一个&lt;code>1&lt;/code>和一个&lt;code>2&lt;/code>。如果你试图将一个值添加到一个已经包含该值的 Set 中（比如下面代码中的&lt;code>:b&lt;/code>），它仍然只有一个该值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">( conj #{:a :b} :b)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #{:a :b}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你也可以通过使用&lt;code>set&lt;/code>函数从现有的 Vector 和列表中创建 Set。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(set [3 3 3 4 4])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #{3 4}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以使用&lt;code>contains?&lt;/code>函数来检查 Set 的成员资格，通过使用&lt;code>get&lt;/code>，或通过使用关键字作为函数，以 Set 为参数。&lt;code>contains?&lt;/code>返回&lt;code>true&lt;/code>或&lt;code>false&lt;/code>，而&lt;code>get&lt;/code>和关键字查找将返回存在的值，如果不存在，则返回&lt;code>nil&lt;/code>。&lt;/p>
&lt;p>下面是你如何使用&lt;code>contains?&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(contains? #{:a :b} :a)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(contains? #{:a :b} 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; false
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(contains? #{nil} nil)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; true
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下面是你如何使用关键字。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(:a #{:a :b})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; :a
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里是你如何使用&lt;code>get&lt;/code>的方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(get #{:a :b} :a)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; :a
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(get #{:a nil} nil)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; nil
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(get #{:a :b} &amp;#34;kurt vonnegut&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; nil
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，使用&lt;code>get&lt;/code>来测试一个 Set 是否包含&lt;code>nil&lt;/code>，将总是返回&lt;code>nil&lt;/code>，这令人困惑。当你专门测试 Set 成员时，&lt;code>contains?&lt;/code>可能是更好的选择。&lt;/p>
&lt;h3 id="简单性">简单性&lt;/h3>
&lt;p>你可能已经注意到，到目前为止，对数据结构的处理并不包括对如何创建新类型或类的描述。原因是 Clojure 对简单性的强调鼓励你首先去接触内置的数据结构。&lt;/p>
&lt;p>如果你来自面向对象的背景，你可能会认为这种方法很奇怪而且落后。然而，你会发现，你的数据不一定非要和一个类紧密地捆绑在一起，才是有用和可理解的。这里有一个被 Clojurists 喜爱的寓言故事，暗示了 Clojure 的哲学。&lt;/p>
&lt;blockquote>
&lt;p>让 100 个函数操作一个数据结构比让 10 个函数操作 10 个数据结构要好。
-Alan Perlis&lt;/p>
&lt;/blockquote>
&lt;p>在接下来的章节中，你会了解到更多关于 Clojure 哲学的这个方面。现在，请留意你通过坚持使用基本数据结构来获得代码重用性的方法。&lt;/p>
&lt;p>我们的 Clojure 数据结构入门课程到此结束。现在，是时候深入到函数中去，学习如何使用这些数据结构了&lt;/p>
&lt;h2 id="函数">函数&lt;/h2>
&lt;p>人们为 Lisp 疯狂的原因之一是，这些语言可以让你建立起行为复杂的程序，但主要的构件&amp;ndash;函数&amp;ndash;却是如此简单。本节通过解释以下内容，让你开始了解 Lisp 函数的美丽和优雅。&lt;/p>
&lt;ul>
&lt;li>调用函数&lt;/li>
&lt;li>函数与宏和特殊 Form 有什么不同&lt;/li>
&lt;li>定义函数&lt;/li>
&lt;li>匿名函数&lt;/li>
&lt;li>返回函数&lt;/li>
&lt;/ul>
&lt;h3 id="调用函数">调用函数&lt;/h3>
&lt;p>现在你已经看到了许多函数调用的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(+ 1 2 3 4)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(* 1 2 3 4)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(first [1 2 3 4])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>请记住，所有的 Clojure 操作都有相同的语法：开括号、操作符、操作数、闭括号。&lt;em>函数**调用&lt;/em>只是操作的另一个术语，其中运算符是一个函数或一个&lt;em>函数**表达式&lt;/em>（一个返回函数的表达式）。&lt;/p>
&lt;p>这可以让你写出一些相当有趣的代码。下面是一个函数表达式，它返回&lt;code>+&lt;/code>（加法）函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(or + -)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; #&amp;lt;core$_PLUS_ clojure.core$_PLUS_@76dace31&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>该返回值是加法函数的字符串表示。因为&lt;code>or&lt;/code>的返回值是第一个真值，而这里的加法函数是真值，所以返回的是加法函数。你也可以在另一个表达式中使用这个表达式作为运算符。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">((or + -) 1 2 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 6
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>因为&lt;code>(or + -)&lt;/code>返回&lt;code>+&lt;/code>，这个表达式被求值为&lt;code>1&lt;/code>、&lt;code>2&lt;/code>和&lt;code>3&lt;/code>之和，返回&lt;code>6&lt;/code>。&lt;/p>
&lt;p>下面是几个有效的函数调用，它们都返回&lt;code>6&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">((and (= 1 1) +) 1 2 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 6
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">((first [+ 0]) 1 2 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 6
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在第一个例子中，&lt;code>and&lt;/code>的返回值是第一个假值或最后一个真值。在这个例子中，&lt;code>+&lt;/code>被返回，因为它是最后一个真值，然后被应用于参数&lt;code>1 2 3&lt;/code>，返回&lt;code>6&lt;/code>。在第二个例子中，&lt;code>first&lt;/code>的返回值是一个序列中的第一个元素，在这个例子中是&lt;code>+&lt;/code>。&lt;/p>
&lt;p>然而，这些都不是有效的函数调用，因为数字和字符串都不是函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(1 2 3 4)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(&amp;#34;test&amp;#34; 1 2 3)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果你在 REPL 中运行这些，你会得到这样的结果。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ClassCastException java.lang.String cannot be cast to clojure.lang.IFn
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">user/eval728 (NO_SOURCE_FILE:1)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当你继续使用 Clojure 时，你可能会多次看到这个错误：&lt;em>&lt;!-- raw HTML omitted --> cannot be cast to clojure.lang.IFn&lt;/em> 。只是意味着你试图将某个东西作为一个函数使用，而它并不是。&lt;/p>
&lt;p>函数的灵活性并没有随着函数表达式的出现而结束! 在语法上，函数可以接受任何表达式作为参数&amp;ndash;包括&lt;em>其他函数&lt;/em>。可以接受一个函数作为参数或返回一个函数的函数被称为&lt;em>高阶函数&lt;/em>。具有高阶函数的编程语言被称为支持&lt;em>函数一等公民&lt;/em>，因为你可以像对待数字和 Vector 等更熟悉的数据类型一样，将函数作为值来处理。&lt;/p>
&lt;p>以&lt;code>map&lt;/code>函数（不要与 map 数据结构混淆）为例。&lt;code>map&lt;/code>通过对一个集合的每个成员应用一个函数来创建一个新的列表。这里，&lt;code>inc&lt;/code>函数将一个数字增加 1。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(inc 1.1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 2.1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(map inc [0 1 2 3])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (1 2 3 4)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>(注意&lt;code>map&lt;/code>并不返回一个 Vector，尽管我们提供了一个 Vector 作为参数。你将在第四章中了解原因。现在，请相信这是好的，也是预期的）。&lt;/p>
&lt;p>Clojure 对一等公民函数的支持使你能够建立比没有一等公民函数的语言更强大的抽象概念。那些不熟悉这种编程方式的人认为函数允许你对数据实例进行泛化操作。例如，&lt;code>+&lt;/code>函数对任何特定数字的加法进行了抽象。&lt;/p>
&lt;p>相比之下，Clojure（以及所有 Lisp）允许你创建泛化进程的函数。&lt;code>map&lt;/code>允许你通过在任何集合上应用一个函数&amp;ndash;任何函数&amp;ndash;来概括转换一个集合的过程。&lt;/p>
&lt;p>你需要知道的关于函数调用的最后一个细节是，Clojure 在将所有函数参数传递给函数之前，会递归地求值这些参数。下面是 Clojure 如何求值一个参数也是函数调用的函数调用。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(+ (inc 199) (/ 100 (- 7 2)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(+ 200 (/ 100 (- 7 2))) ; evaluated &amp;#34;(inc 199)&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(+ 200 (/ 100 5)) ; evaluated (- 7 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(+ 200 20) ; evaluated (/ 100 5)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">220 ; final evaluation
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>函数调用启动了求值过程，在应用&lt;code>+&lt;/code>函数之前，所有的子 Form 都被求值了。&lt;/p>
&lt;h3 id="函数调用宏调用和特殊-form">函数调用、宏调用和特殊 Form&lt;/h3>
&lt;p>在上一节中，你了解到函数调用是以函数表达式为操作符的表达式。另外两种表达式是&lt;em>宏调用&lt;/em>和&lt;em>特殊 Form&lt;/em>。你已经看到了几种特殊 Form：&lt;code>def&lt;/code> 和&lt;code>if&lt;/code>表达式。&lt;/p>
&lt;p>你将在第 7 章中学习关于宏调用和特殊 Form 的所有知识。现在，使特殊 Form &amp;ldquo;特殊&amp;quot;的主要特征是，与函数调用不同，它们不求值所有的操作数。&lt;/p>
&lt;p>以 &amp;ldquo;if &amp;ldquo;为例。这是它的一般结构。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(if boolean-form
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> then-form
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> optional-else-form)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在想象一下你有一个这样的&lt;code>if&lt;/code>语句。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(if good-mood
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (tweet walking-on-sunshine-lyrics)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (tweet mopey-country-song-lyrics))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>显然，在这样的&lt;code>if&lt;/code>表达中，我们希望 Clojure 只求值两个分支中的一个。如果 Clojure 同时求值两个&lt;code>tweet&lt;/code>函数调用，你的 Twitter 粉丝们最终会非常困惑。&lt;/p>
&lt;p>另一个区别于特殊 Form 的特征是，你不能把它们作为函数的参数。一般来说，特殊 Form 实现了 Clojure 的核心功能，只是不能用函数实现。Clojure 只有少量的特殊 Form，而如此丰富的语言是用如此小的一组构建块来实现的，这是很令人惊讶的。&lt;/p>
&lt;p>宏与特殊 Form 类似，它们对操作数的求值与函数调用不同，而且它们也不能作为参数传递给函数。但这段弯路已经走得够长了；现在是学习如何定义函数的时候了!&lt;/p>
&lt;h3 id="定义函数">定义函数&lt;/h3>
&lt;p>函数的定义由五个主要部分组成。&lt;/p>
&lt;ul>
&lt;li>&lt;code>defn&lt;/code>&lt;/li>
&lt;li>函数名&lt;/li>
&lt;li>描述该函数的 docstring(可选)&lt;/li>
&lt;li>括号中列出的参数&lt;/li>
&lt;li>函数体&lt;/li>
&lt;/ul>
&lt;p>下面是一个函数定义的例子和函数的调用示例。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">➊ (defn too-enthusiastic
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➋ &amp;#34;Return a cheer that might be a bit too enthusiastic&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➌ [name]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➍ (str &amp;#34;OH. MY. GOD! &amp;#34; name &amp;#34; YOU ARE MOST DEFINITELY LIKE THE BEST &amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;MAN SLASH WOMAN EVER I LOVE YOU AND WE SHOULD RUN AWAY SOMEWHERE&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(too-enthusiastic &amp;#34;Zelda&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;OH. MY. GOD! Zelda YOU ARE MOST DEFINITELY LIKE THE BEST MAN SLASH WOMAN EVER I LOVE YOU AND WE SHOULD RUN AWAY SOMEWHERE&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在➊处，&lt;code>too-enthusiastic&lt;/code>是函数的名称，在➋处有一个描述性的 docstring。参数 &amp;ldquo;name &amp;ldquo;在➌处给出，函数体在➍处接受参数，并做了它所描述的事情&amp;ndash;返回一个可能有点过于热情的欢呼。&lt;/p>
&lt;p>让我们更深入地了解 docstring、参数和函数体。&lt;/p>
&lt;h4 id="docstring">docstring&lt;/h4>
&lt;p>docstring*是一种描述和记录你的代码的有用方法。你可以在 REPL 中用 &lt;code>(doc&lt;/code>fn-name&lt;code>)&lt;/code>查看一个函数的 docstring，例如 &lt;code>(doc map)&lt;/code>。如果你使用一个工具为你的代码生成文档，那么 docstring 也会发挥作用。&lt;/p>
&lt;h4 id="参数和-arity">参数和 Arity&lt;/h4>
&lt;p>Clojure 函数可以用零个或多个参数来定义。你传递给函数的值被称为&lt;em>arguments&lt;/em>，参数可以是任何类型。参数的数量就是函数的特性。下面是一些具有不同性质的函数定义。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn no-params
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> []
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;I take no parameters!&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn one-param
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [x]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str &amp;#34;I take one parameter: &amp;#34; x))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn two-params
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [x y]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str &amp;#34;Two parameters! That&amp;#39;s nothing! Pah! I will smoosh them &amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;together to spite you! &amp;#34; x y))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这些例子中，&lt;code>no-params&lt;/code>是一个 0-arity 函数，&lt;code>one-param&lt;/code>是 1-arity，&lt;code>two-params&lt;/code>是 2-arity。&lt;/p>
&lt;p>函数也支持 &lt;em>参数重载&lt;/em>。这意味着你可以定义一个函数，使不同的函数体根据不同的参数来运行。下面是一个多义性函数定义的一般方式。请注意，每个数位定义都被括在括号里，并且有一个参数列表。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn multi-arity
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ;; 3-arity arguments and body
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([first-arg second-arg third-arg]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (do-things first-arg second-arg third-arg))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ;; 2-arity arguments and body
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([first-arg second-arg]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (do-things first-arg second-arg))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ;; 1-arity arguments and body
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([first-arg]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (do-things first-arg)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>函数参数重载是为参数提供默认值的一种方法。在下面的例子中，&lt;code>&amp;quot;karate&amp;quot;&lt;/code>是&lt;code>chop-type&lt;/code>参数的默认参数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn x-chop
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Describe the kind of chop you&amp;#39;re inflicting on someone&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([name chop-type]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str &amp;#34;I &amp;#34; chop-type &amp;#34; chop &amp;#34; name &amp;#34;! Take that!&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([name]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (x-chop name &amp;#34;karate&amp;#34;)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果你用两个参数调用&lt;code>x-chop&lt;/code>，该函数的工作原理和它不是一个多义性函数时一样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(x-chop &amp;#34;Kanye West&amp;#34; &amp;#34;slap&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;I slap chop Kanye West! Take that!&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/do-things/kanye.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>如果你调用&lt;code>x-chop&lt;/code>时只有一个参数，&lt;code>x-chop&lt;/code>实际上会在提供第二个参数&lt;code>karate&lt;/code>时调用自己。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(x-chop &amp;#34;Kanye East&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;I karate chop Kanye East! Take that!&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>像这样用函数本身来定义一个函数，可能显得不寻常。如果是这样，那就好了! 你正在学习一种新的方法来做事!&lt;/p>
&lt;p>你也可以让每种函数做一些完全不相关的事情。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn weird-arity
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Destiny dressed you this morning, my friend, and now Fear is
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> trying to pull off your pants. If you give up, if you give in,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> you&amp;#39;re gonna end up naked with Fear just standing there laughing
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at your dangling unmentionables! - the Tick&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ([number]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (inc number)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>0-arity 主体返回一个明智的引号，1-arity 主体增加一个数字。最有可能的是，你不会想写一个这样的函数，因为有两个完全不相关的函数体会让人困惑。&lt;/p>
&lt;p>Clojure 还允许你通过包括一个&lt;em>可变参数&lt;/em>来定义函数，就像 &amp;ldquo;把这些参数的其余部分放在一个列表中，名称如下&amp;rdquo;。可变参数用安培号（&lt;code>&amp;amp;&lt;/code>）表示，如➊所示。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/do-things/old-man.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn codger-communication
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [whippersnapper]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str &amp;#34;Get off my lawn, &amp;#34; whippersnapper &amp;#34;!!!&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn codger
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➊ [&amp;amp; whippersnappers]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (map codger-communication whippersnappers))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(codger &amp;#34;Billy&amp;#34; &amp;#34;Anne-Marie&amp;#34; &amp;#34;The Incredible Bulk&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (&amp;#34;Get off my lawn, Billy!!!&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Get off my lawn, Anne-Marie!!!&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Get off my lawn, The Incredible Bulk!!!&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>正如你所看到的，当你为变量性质的函数提供参数时，参数被当作一个列表来处理。你可以把可变参数和普通参数混在一起，但可变参数必须放在最后。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn favorite-things
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [name &amp;amp; things]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (str &amp;#34;Hi, &amp;#34; name &amp;#34;, here are my favorite things: &amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (clojure.string/join &amp;#34;, &amp;#34; things)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(favorite-things &amp;#34;Doreen&amp;#34; &amp;#34;gum&amp;#34; &amp;#34;shoes&amp;#34; &amp;#34;kara-te&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Hi, Doreen, here are my favorite things: gum, shoes, kara-te&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后，Clojure 有一种更复杂的定义参数的方法，叫做&lt;em>解构&lt;/em>，这值得有自己的小节。&lt;/p>
&lt;h4 id="解构">解构&lt;/h4>
&lt;p>解构的基本思想是，它可以让你在一个集合中简洁地将名字与值绑定。让我们看看一个基本的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">;; Return the first element of a collection
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn my-first
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [[first-thing]] ; Notice that first-thing is within a vector
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> first-thing)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(my-first [&amp;#34;oven&amp;#34; &amp;#34;bike&amp;#34; &amp;#34;war-axe&amp;#34;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;oven&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里，&lt;code>my-first&lt;/code>函数将符号&lt;code>first-thing&lt;/code>与作为参数传入的 Vector 中的第一个元素联系起来。你告诉&lt;code>my-first&lt;/code>这样做，就是把符号&lt;code>first-thing&lt;/code>放在一个 Vector 中。&lt;/p>
&lt;p>Vector 就像一个巨大的牌子，对 Clojure 说：&amp;ldquo;嘿！这个函数将收到一个列表或 Vector 作为参数。让我的生活更轻松，为我拆开参数的结构，并将有意义的名字与参数的不同部分联系起来！&amp;rdquo; 当对一个 Vector 或列表进行解构时，你可以随意命名你想要的元素，也可以使用其他参数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn chooser
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [[first-choice second-choice &amp;amp; unimportant-choices]]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (str &amp;#34;Your first choice is: &amp;#34; first-choice))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (str &amp;#34;Your second choice is: &amp;#34; second-choice))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (str &amp;#34;We&amp;#39;re ignoring the rest of your choices. &amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Here they are in case you need to cry over them: &amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (clojure.string/join &amp;#34;, &amp;#34; unimportant-choices))))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(chooser [&amp;#34;Marmalade&amp;#34;, &amp;#34;Handsome Jack&amp;#34;, &amp;#34;Pigpen&amp;#34;, &amp;#34;Aquaman&amp;#34;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Your first choice is: Marmalade
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Your second choice is: Handsome Jack
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; We&amp;#39;re ignoring the rest of your choices. Here they are in case \
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> you need to cry over them: Pigpen, Aquaman
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里，其余的参数&lt;code>unimportant``-choices&lt;/code>处理用户在第一和第二选择之后的任何数量的额外选择。&lt;/p>
&lt;p>你也可以对 Map 进行去结构化。就像你告诉 Clojure 通过提供一个 Vector 作为参数来解除 Vector 或列表的结构一样，你可以通过提供一个 Map 作为参数来解除 Map 的结构。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn announce-treasure-location
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">➊ [{lat :lat lng :lng}]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (str &amp;#34;Treasure lat: &amp;#34; lat))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (str &amp;#34;Treasure lng: &amp;#34; lng)))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(announce-treasure-location {:lat 28.22 :lng 81.33})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Treasure lat: 28.22
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; Treasure lng: 81.33
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>让我们更详细地看看➊的那一行。这就像告诉 Clojure，&amp;ldquo;哟！Clojure! 为我做一件事，把&lt;code>lat&lt;/code>这个名字与键&lt;code>:lat&lt;/code>对应的值联系起来。对&lt;code>lng&lt;/code>和&lt;code>:lng&lt;/code>做同样的事情，好吗？&amp;rdquo;&lt;/p>
&lt;p>我们经常想直接把关键词从 Map 中分离出来，所以有一个更短的语法。这和前面的例子有相同的结果。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn announce-treasure-location
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [{:keys [lat lng]}] 。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (str &amp;#34;Treasure lat: &amp;#34; lat))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (str &amp;#34;Treasure lng: &amp;#34; lng)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以通过使用&lt;code>:as&lt;/code>关键字保留对原始 Map 参数的访问。在下面的例子中，原始 Map 是用&lt;code>treasure-location&lt;/code>来访问的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn receive-treasure-location
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [{:keys [lat lng] :as treasure-location}]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (str &amp;#34;Treasure lat: &amp;#34; lat))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (println (str &amp;#34;Treasure lng: &amp;#34; lng))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ;; One would assume that this would put in new coordinates for your ship
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (steer-ship! treasure-location))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>一般来说，你可以把解构看作是指示 Clojure 如何将名字与列表、Map、集合或 Vector 中的值联系起来。现在，我们来看看函数中真正起作用的部分：函数体!&lt;/p>
&lt;h4 id="函数体">函数体&lt;/h4>
&lt;p>函数主体可以包含任何 Form 的 Form。Clojure 会自动返回最后求值的 Form。这个函数体只包含三种 Form，当你调用这个函数时，它会吐出最后一种 Form，&lt;code>&amp;quot;joe&amp;quot;&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn illustrative-function
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> []
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (+ 1 304)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 30
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;joe&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(exstrative-function)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;joe&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下面是另一个函数体，它使用一个&lt;code>if&lt;/code>表达式。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn number-comment
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [x]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if (&amp;gt; x 6)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Oh my gosh! What a big number!&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;That number&amp;#39;s OK, I guess&amp;#34;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(number-comment 5)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;That number&amp;#39;s OK, I guess&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(number-comment 7)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;Oh my gosh! What a big number!&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="所有函数都是平等的">所有函数都是平等的&lt;/h4>
&lt;p>最后说明一下：Clojure 没有特权函数。&lt;code>+&lt;/code>只是一个函数，&lt;code>-&lt;/code>只是一个函数，而&lt;code>inc&lt;/code>和&lt;code>map&lt;/code>也只是函数。它们并不比你自己定义的函数好。所以，不要让他们给你任何口实!&lt;/p>
&lt;p>更重要的是，这个事实有助于证明 Clojure 的底层简单性。在某种程度上，Clojure 是非常愚蠢的。当你进行函数调用时，Clojure 只是说，&amp;quot;&lt;code>map&lt;/code>？当然，不管怎样! 我只是应用这个并继续前进&amp;rdquo;。它并不关心这个函数是什么，或者它来自哪里；它对所有的函数都一视同仁。在它的核心，Clojure 并不关心加法、乘法或 Map 的问题。它只关心函数的应用。&lt;/p>
&lt;p>当你继续用 Clojure 编程时，你会发现这种简单性是很理想的。你不必为处理不同的函数而担心特殊的规则或语法。它们的工作原理都是一样的!&lt;/p>
&lt;h3 id="匿名函数">匿名函数&lt;/h3>
&lt;p>在 Clojure 中，函数不需要有名字。事实上，你会一直使用&lt;em>匿名函数&lt;/em>。多么神秘啊! 你可以通过两种方式创建匿名函数。第一种是使用&lt;code>fn&lt;/code>Form。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(fn [param-list]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> function body)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看起来很像&lt;code>defn&lt;/code>，不是吗？让我们试一试几个例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(map (fn [name] (str &amp;#34;Hi, &amp;#34; name))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [&amp;#34;Darth Vader&amp;#34; &amp;#34;Mr. Magoo&amp;#34;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (&amp;#34;Hi, Darth Vader&amp;#34; &amp;#34;Hi, Mr. Magoo&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">((fn [x] (* x 3)) 8)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 24
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以用处理&lt;code>fn&lt;/code>的方式来处理&lt;code>defn&lt;/code>，这几乎是相同的。参数列表和函数体的工作原理完全相同。你可以使用参数解构，可变参数，等等。你甚至可以将你的匿名函数与一个名字联系起来，这不应该是一个惊喜（如果这确实是一个惊喜，那么 &amp;hellip; &amp;hellip; 惊喜！）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def my-special-multiplier (fn [x] (* x 3))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(my-special-multiplier 12)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 36
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Clojure 还提供了另一种更紧凑的方式来创建匿名函数。下面是一个匿名函数的样子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">#(* % 3)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>哇，这看起来很奇怪。来吧，应用这个看起来很奇怪的函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(#(* % 3) 8)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 24
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下面是一个将匿名函数作为参数传递给 map 的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(map #(str &amp;#34;Hi, &amp;#34; %)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [&amp;#34;Darth Vader&amp;#34; &amp;#34;Mr. Magoo&amp;#34;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (&amp;#34;Hi, Darth Vader&amp;#34; &amp;#34;Hi, Mr. Magoo&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这种看起来很奇怪的匿名函数的编写方式是由一个叫做&lt;em>reader**macros&lt;/em>的函数实现的。你会在第 7 章中了解到这些。现在，只学习如何使用这些匿名函数就可以了。&lt;/p>
&lt;p>你可以看到，这种语法肯定更紧凑，但也有点奇怪。让我们把它分解一下。这种匿名函数看起来很像函数调用，只是它前面有一个哈希标记，&lt;code>#&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">;; Function call
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(* 8 3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">;; Anonymous function
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#(* % 3)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这种相似性使你能更快地看到应用这个匿名函数时将发生什么。&amp;ldquo;哦，&amp;ldquo;你可以对自己说，&amp;ldquo;这是要把它的参数乘以 3&amp;rdquo;。&lt;/p>
&lt;p>现在你可能已经猜到了，百分号&lt;code>%&lt;/code>，表示传递给函数的参数。如果你的匿名函数需要多个参数，你可以像这样区分它们。&lt;code>%1&lt;/code>, &lt;code>%2&lt;/code>, &lt;code>%3&lt;/code>, 以此类推。&lt;code>%&lt;/code>相当于&lt;code>%1&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(#(str %1 &amp;#34; and &amp;#34; %2) &amp;#34;cornbread&amp;#34; &amp;#34;butter beans&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; &amp;#34;cornbread and butter beans&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你也可以用&lt;code>%&amp;amp;&lt;/code>传递其余参数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(#(identity %&amp;amp;) 1 &amp;#34;blarg&amp;#34; :yip)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (1 &amp;#34;blarg&amp;#34; :yip)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这种情况下，你将身份函数应用于其余参数。Identity 返回它所给的参数而不改变它。可变参数是以列表 Form 存储的，所以函数应用返回所有参数的列表。&lt;/p>
&lt;p>如果你需要写一个简单的匿名函数，使用这种风格是最好的，因为它在视觉上很紧凑。另一方面，如果你要写一个更长、更复杂的函数，它很容易变得不可读。如果是这种情况，请使用&lt;code>fn&lt;/code>。&lt;/p>
&lt;h3 id="返回函数">返回函数&lt;/h3>
&lt;p>现在你已经看到，函数可以返回其他函数。返回的函数是&lt;em>closures&lt;/em>，这意味着它们可以访问函数创建时的作用域内的所有变量。下面是一个标准的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn inc-maker
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Create a custom incrementor&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [inc-by]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> #(+ % inc-by))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def inc3 (inc-maker 3))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(inc3 7)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 10
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里，&lt;code>inc-by&lt;/code>在作用域内，所以即使返回的函数在&lt;code>inc-maker&lt;/code>之外使用，也可以访问它。&lt;/p>
&lt;h2 id="把这一切放到一起">把这一切放到一起&lt;/h2>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/do-things/model-hobbit.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>好了! 是时候把你新发现的知识用于一个崇高的目的了：打倒霍比特人! 要打一个霍比特人，你首先要建立它的身体部位模型。每个身体部位都将包括其相对大小，以表明该部位被击中的可能性有多大。为了避免重复，霍比特人的模型将只包括&lt;em>左脚&lt;/em>，&lt;em>左耳&lt;/em>的条目，以此类推。因此，你需要一个函数来完全对称该模型，创建&lt;em>右脚&lt;/em>，&lt;em>右耳&lt;/em>，等等。最后，你将创建一个函数，迭代身体各部分，并随机选择击中的部分。在这一过程中，你将了解到一些新的 Clojure 工具。&lt;code>let&lt;/code>表达式，循环，和正则表达式。有趣!&lt;/p>
&lt;h3 id="夏尔的下一个顶级模型">夏尔的下一个顶级模型&lt;/h3>
&lt;p>对于我们的霍比特人模型，我们将避开霍比特人的特征，如活泼和调皮，只关注霍比特人的小身板。下面是霍比特人的模型。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def asym-hobbit-body-parts [{:name &amp;#34;head&amp;#34; :size 3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-eye&amp;#34; :size 1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-ear&amp;#34; :size 1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;mouth&amp;#34; :size 1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;nose&amp;#34; :size 1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;neck&amp;#34; :size 2}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-shoulder&amp;#34; :size 3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-upper-arm&amp;#34; :size 3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;chest&amp;#34; :size 10}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;back&amp;#34; :size 10}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-forearm&amp;#34; :size 3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;abdomen&amp;#34; :size 6}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-kidney&amp;#34; :size 1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-hand&amp;#34; :size 2}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-knee&amp;#34; :size 2}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-thigh&amp;#34; :size 4}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-lower-leg&amp;#34; :size 3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-achilles&amp;#34; :size 1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-foot&amp;#34; :size 2}])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这是一个 Map 的 Vector。每个 Map 都有身体部位的名称和身体部位的相对大小。(我知道只有动漫人物的眼睛是头部的三分之一大小，但就这样吧，好吗？)&lt;/p>
&lt;p>明显缺少的是霍比特人的右侧。让我们来解决这个问题。清单 3-1 是到目前为止你看到的最复杂的代码，它引入了一些新的想法。但是不要担心，因为我们将详细地研究它。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(defn matching-part
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [part]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name (clojure.string/replace (:name part) #&amp;#34;^left-&amp;#34; &amp;#34;right-&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :size (:size part)})
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(defn symmetrize-body-parts
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;Expects a seq of maps that have a :name and :size&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [asym-body-parts]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (loop [remaining-asym-parts asym-body-parts
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> final-body-parts []]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (if (empty? remaining-asym-parts)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> final-body-parts
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (let [[part &amp;amp; remaining] remaining-asym-parts]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (recur remaining
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (into final-body-parts
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (set [part (matching-part part)])))))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol>
&lt;li>3-1. 匹配-部分和对称-身体-部分的函数&lt;/li>
&lt;/ol>
&lt;p>当我们对&lt;code>asym-hobbit-body-parts&lt;/code>调用函数&lt;code>symmetriz-body-parts&lt;/code>时，我们得到一个完全对称的霍比特人。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(symmetrize-body-parts asym-hobbit-body-parts)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [{:name &amp;#34;head&amp;#34;, :size 3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-eye&amp;#34;, :size 1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;right-eye&amp;#34;, :size 1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-ear&amp;#34;, :size 1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;right-ear&amp;#34;, :size 1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;mouth&amp;#34;, :size 1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;nose&amp;#34;, :size 1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;neck&amp;#34;, :size 2}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-shoulder&amp;#34;, :size 3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;right-shoulder&amp;#34;, :size 3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-upper-arm&amp;#34;, :size 3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;right-upper-arm&amp;#34;, :size 3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;chest&amp;#34;, :size 10}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;back&amp;#34;, :size 10}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-forearm&amp;#34;, :size 3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;right-forearm&amp;#34;, :size 3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;abdomen&amp;#34;, :size 6}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-kidney&amp;#34;, :size 1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;right-kidney&amp;#34;, :size 1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-hand&amp;#34;, :size 2}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;right-hand&amp;#34;, :size 2}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-knee&amp;#34;, :size 2}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;right-knee&amp;#34;, :size 2}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-thigh&amp;#34;, :size 4}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;right-thigh&amp;#34;, :size 4}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-lower-leg&amp;#34;, :size 3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;right-lower-leg&amp;#34;, :size 3}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-achilles&amp;#34;, :size 1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;right-achilles&amp;#34;, :size 1}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;left-foot&amp;#34;, :size 2}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {:name &amp;#34;right-foot&amp;#34;, :size 2}]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>让我们来分析一下这段代码!&lt;/p>
&lt;h3 id="let">let&lt;/h3>
&lt;p>在清单 3-1 的大量疯狂中，你可以看到结构&lt;code>(let ...)&lt;/code>的 Form。让我们通过一个例子来建立对&lt;code>let&lt;/code>的理解，当我们熟悉了所有的部分后，再来检查程序中的完整例子。&lt;/p>
&lt;p>&lt;code>let&lt;/code>将名字与值绑定。你可以认为&lt;code>let&lt;/code>是&lt;em>let&lt;/em> &lt;em>it&lt;/em> &lt;em>be&lt;/em>的缩写，这也是披头士乐队关于编程的一首优美的歌曲。这里有一个例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [x 3]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> x)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(def dalmatian-list
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [&amp;#34;Pongo&amp;#34; &amp;#34;Perdita&amp;#34; &amp;#34;Puppy 1&amp;#34; &amp;#34;Puppy 2&amp;#34;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(let [dalmatians (take 2 dalmatian-list)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> dalmatians)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; (&amp;#34;Pongo&amp;#34; &amp;#34;Perdita&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在第一个例子中，你将名字&lt;code>x&lt;/code>与值&lt;code>3&lt;/code>绑定。在第二个例子中，你把名字&lt;code>dalmatians&lt;/code>绑定到表达式&lt;code>(取2&lt;/code>dalmatian&lt;code>-list)&lt;/code>的结果，也就是列表&lt;code>(&amp;quot;Pongo&amp;quot; &amp;quot;Perdita&amp;quot;)&lt;/code>。&lt;code>let&lt;/code>还引入了一个新的作用域。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def x 0)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(let [x 1] x)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里，你首先使用&lt;code>def&lt;/code>将名字&lt;code>x&lt;/code>绑定到值&lt;code>0&lt;/code>上。然后，&lt;code>let&lt;/code>创建了一个新的作用域，在这个作用域中，名字&lt;code>x&lt;/code>被绑定到值&lt;code>1&lt;/code>上。我认为作用域取决于上下文。例如，在 &amp;ldquo;请清理这些烟头 &amp;ldquo;这句话中，&lt;em>烟头&lt;/em>的含义是不同的，这取决于你是在产科病房工作还是在香烟制造商大会的监管人员工作。在这个代码片段中，你在说：&amp;ldquo;我希望&lt;code>x&lt;/code>在全局上下文中是&lt;code>0&lt;/code>，但在这个&lt;code>let&lt;/code>表达式的上下文中，它应该是&lt;code>1&lt;/code>。&amp;rdquo;&lt;/p>
&lt;p>你可以在你的&lt;code>let&lt;/code>绑定中引用现有的绑定。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(def x 0)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(let [x (inc x)] x)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子中，&lt;code>(inc x)&lt;/code>中的&lt;code>x&lt;/code>是指由&lt;code>(def x 0)&lt;/code>创建的绑定。结果是&lt;code>1&lt;/code>，然后在&lt;code>let&lt;/code>创建的新作用域中与名称&lt;code>x&lt;/code>绑定。在&lt;code>let&lt;/code>Form 的作用域内，&lt;code>x&lt;/code>指的是&lt;code>1&lt;/code>，而不是&lt;code>0&lt;/code>。&lt;/p>
&lt;p>你也可以在&lt;code>let&lt;/code>中使用可变参数，就像你在函数中一样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [[Pongo &amp;amp; dalmatians] dalmatian-list] [Pongo dalmatians])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> [Pongo dalmatians])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [&amp;#34;Pongo&amp;#34; (&amp;#34;Perdita&amp;#34; &amp;#34;Puppy 1&amp;#34; &amp;#34;Puppy 2&amp;#34;) ]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意，&lt;code>let&lt;/code>Form 的值是其主体中最后被求值的 Form。&lt;code>let&lt;/code>Form 遵循所有在&lt;a class="link" href="https://www.braveclojure.com/do-things/#Anchor" target="_blank" rel="noopener"
>&amp;ldquo;调用函数&amp;quot;第 48 页&lt;/a>中介绍的析构规则。在这个例子中，&lt;code>[pongo &amp;amp; dalmatians]&lt;/code>解构了&lt;code>dalmatian-list&lt;/code>，将字符串&lt;code>&amp;quot;Pongo &amp;quot;绑定到名称&lt;/code>pongo&lt;code>上，将其余的dalmatians列表绑定到&lt;/code>dalmatians&lt;code>上。Vector&lt;/code>[pongo dalmatians]&lt;code>是&lt;/code>let&lt;code>的最后一个表达式，所以它是&lt;/code>let`Form 的值。&lt;/p>
&lt;p>&lt;code>let&lt;/code>Form 有两个主要用途。首先，它们通过允许你对事物进行命名。其次，它们允许你只求值一个表达式，并重复使用其结果。当你需要重复使用一个昂贵的函数调用的结果时，这一点特别重要，比如网络 API 调用。当表达式有副作用时，这也很重要。&lt;/p>
&lt;p>让我们再看一下我们的对称函数中的&lt;code>let&lt;/code>Form，这样我们就能明白到底发生了什么。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(let [[part &amp;amp; remaining] remaining-asym-parts])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (recur remaining
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (in into final-body-parts
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (set [part (matching-part part part)]))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段代码告诉 Clojure，&amp;ldquo;创建一个新的作用域。在它里面，将&lt;code>part&lt;/code>与&lt;code>remaining-asym-parts&lt;/code>的第一个元素相关联。将&lt;code>remaining&lt;/code>与&lt;code>remaining-asym-parts&lt;/code>中的其他元素联系起来&amp;rdquo;。&lt;/p>
&lt;p>至于&lt;code>let&lt;/code>表达式的主体，你将在下一节中了解到&lt;code>recur&lt;/code>的含义。函数调用&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(in into final-body-parts
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (set [part (matching-part part part)] ))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>首先告诉 Clojure, &amp;ldquo;使用&lt;code>set&lt;/code>函数创建一个由&lt;code>part&lt;/code>和它的匹配部分组成的集合。然后使用函数&lt;code>into&lt;/code>将该集合的元素添加到 Vector&lt;code>final-body-parts&lt;/code>中&amp;rdquo;。你在这里创建一个集合，以确保你向&lt;code>final-body-parts&lt;/code>添加唯一的元素，因为&lt;code>part&lt;/code>和&lt;code>(matching-part part)&lt;/code>有时是同一个东西，正如你将在接下来的正则表达式部分看到的。下面是一个简化的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(into [] (set [:a :a]))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">; =&amp;gt; [:a]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>首先，&lt;code>(set [:a :a])&lt;/code>返回集合&lt;code>#{:a}&lt;/code>，因为集合不包含重复的元素。然后&lt;code>(into [] #{:a})&lt;/code>返回 Vector&lt;code>[:a]&lt;/code>。&lt;/p>
&lt;p>回到&lt;code>let&lt;/code>：注意&lt;code>part&lt;/code>在&lt;code>let&lt;/code>的主体中被多次使用。如果我们使用原来的表达式，而不是使用&lt;code>part&lt;/code>和&lt;code>remaining&lt;/code>的名字，那将是一个混乱的局面! 下面是一个例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(recur (rest remaining-asym-parts)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (in into final-body-parts
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> (set [(first remaining-asym-parts) (matching-part (first remaining-asym-parts)) ]))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>所以，&lt;code>let&lt;/code>是一种方便的方法，可以为值引入本地名称，这有助于简化代码。&lt;/p>
&lt;h3 id="循环">循环&lt;/h3>
&lt;p>在我们的&lt;code>symmetrize-body-parts&lt;/code>函数中，我们使用了&lt;code>loop&lt;/code>，它提供了另一种在 Clojure 中进行递归的方法。让我们看看一个简单的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="k">loop &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">iteration&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">println &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">str &lt;/span>&lt;span class="s">&amp;#34;Iteration &amp;#34;&lt;/span> &lt;span class="nv">iteration&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">if &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">&amp;gt; &lt;/span>&lt;span class="nv">iteration&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">println &lt;/span>&lt;span class="s">&amp;#34;Goodbye!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">recur&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">inc &lt;/span>&lt;span class="nv">iteration&lt;/span>&lt;span class="p">))))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; Iteration 0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; Iteration 1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; Iteration 2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; Iteration 3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; Iteration 4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; Goodbye!&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>第一行，&lt;code>loop [iteration 0]&lt;/code>，开始了循环并引入了一个初始值的绑定。在循环的第一次传递中，&lt;code>iteration&lt;/code>的值为 0.接下来，它打印一个短消息。然后，它检查&lt;code>iteration&lt;/code>的值。如果该值大于 3，那么是时候说再见了。否则，我们就 &amp;ldquo;重来&amp;rdquo;。这就好比&lt;code>loop&lt;/code>创建了一个匿名函数，其参数名为&lt;code>iteration&lt;/code>，而&lt;code>recur&lt;/code>允许你从其内部调用该函数，传递参数&lt;code>(inc iteration)&lt;/code>。&lt;/p>
&lt;p>事实上，你可以通过使用一个普通的函数定义来完成同样的事情。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">recursive-printer&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">([]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">recursive-printer&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">([&lt;/span>&lt;span class="nv">iteration&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">println &lt;/span>&lt;span class="nv">iteration&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">if &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">&amp;gt; &lt;/span>&lt;span class="nv">iteration&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">println &lt;/span>&lt;span class="s">&amp;#34;Goodbye!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">recursive-printer&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">inc &lt;/span>&lt;span class="nv">iteration&lt;/span>&lt;span class="p">)))))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">recursive-printer&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; Iteration 0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; Iteration 1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; Iteration 2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; Iteration 3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; Iteration 4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; Goodbye!&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但正如你所看到的，这是个比较啰嗦的方法。而且，&lt;code>loop&lt;/code>有更好的性能。在我们的对称化函数中，我们将使用&lt;code>loop&lt;/code>遍历不对称的身体部位列表中的每个元素。&lt;/p>
&lt;h3 id="正则表达式">正则表达式&lt;/h3>
&lt;p>&lt;em>正则表达式&lt;/em>是对文本进行模式匹配的工具。正则表达式的文字符号是将表达式放在哈希标记后的引号中。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">#&amp;#34;regular-expression&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在清单 3-1 中的函数&lt;code>matching-part&lt;/code>中，&lt;code>clojure.string/replace&lt;/code>使用正则表达式&lt;code>#&amp;quot;^left-&amp;quot;&lt;/code>来匹配以&lt;code>&amp;quot;left-&amp;quot;&lt;/code>开头的字符串，以便用&lt;code>&amp;quot;right-&amp;quot;&lt;/code>替换&lt;code>&amp;quot;left-&amp;quot;&lt;/code>。卡特，&lt;code>^&lt;/code>，是正则表达式发出的信号，即只有当文本&lt;code>&amp;quot;left-&amp;quot;&lt;/code>位于字符串的开头时，它才会匹配，这就确保了像&lt;code>&amp;quot;cleft-chin&amp;quot;&lt;/code>这样的字符串不会匹配。你可以用&lt;code>re-find&lt;/code>来测试，它检查一个字符串是否与正则表达式描述的模式相匹配，如果不匹配，则返回匹配的文本或&lt;code>nil&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">re-find &lt;/span>&lt;span class="o">#&lt;/span>&lt;span class="s">&amp;#34;^left-&amp;#34;&lt;/span> &lt;span class="s">&amp;#34;left-eye&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; &amp;#34;left-&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">re-find &lt;/span>&lt;span class="o">#&lt;/span>&lt;span class="s">&amp;#34;^left-&amp;#34;&lt;/span> &lt;span class="s">&amp;#34;cleft-chin&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; nil&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">re-find &lt;/span>&lt;span class="o">#&lt;/span>&lt;span class="s">&amp;#34;^left-&amp;#34;&lt;/span> &lt;span class="s">&amp;#34;wongleblart&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; nil&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下面是几个&lt;code>matching-part&lt;/code>的例子，使用一个重词将&lt;code>&amp;quot;left-&amp;quot;&lt;/code>替换为&lt;code>&amp;quot;right-&amp;quot;&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">matching-part&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">part&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">clojure.string/replace&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="nv">part&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">#&lt;/span>&lt;span class="s">&amp;#34;^left-&amp;#34;&lt;/span> &lt;span class="s">&amp;#34;right-&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="ss">:size&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="ss">:size&lt;/span> &lt;span class="nv">part&lt;/span>&lt;span class="p">)})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">matching-part&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;left-eye&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; {:name &amp;#34;right-eye&amp;#34; :size 1}]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">matching-part&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;head&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; {:name &amp;#34;head&amp;#34; :size 3}]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>请注意，名称 &amp;ldquo;head&amp;rdquo; 是原样返回的。&lt;/p>
&lt;h3 id="对称器">对称器&lt;/h3>
&lt;p>现在让我们回到完整的对称器，对其进行更详细的分析。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="k">def &lt;/span>&lt;span class="nv">asym-hobbit-body-parts&lt;/span> &lt;span class="p">[{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;head&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;left-eye&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;left-ear&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;mouth&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;nose&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;neck&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;left-shoulder&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;left-upper-arm&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;chest&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;back&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;left-forearm&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;abdomen&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;left-kidney&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;left-hand&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;left-knee&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;left-thigh&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;left-lower-leg&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;left-achilles&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="s">&amp;#34;left-foot&amp;#34;&lt;/span> &lt;span class="ss">:size&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">}])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">matching-part&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">part&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">clojure.string/replace&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="ss">:name&lt;/span> &lt;span class="nv">part&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">#&lt;/span>&lt;span class="s">&amp;#34;^left-&amp;#34;&lt;/span> &lt;span class="s">&amp;#34;right-&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="ss">:size&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="ss">:size&lt;/span> &lt;span class="nv">part&lt;/span>&lt;span class="p">)})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">➊&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">symmetrize-body-parts&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Expects a seq of maps that have a :name and :size&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">asym-body-parts&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">➋&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">loop &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">remaining-asym-parts&lt;/span> &lt;span class="nv">asym-body-parts&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">final-body-parts&lt;/span> &lt;span class="p">[]]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">➌&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">if &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">empty?&lt;/span> &lt;span class="nv">remaining-asym-parts&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">final-body-parts&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">➍&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">let &lt;/span>&lt;span class="p">[[&lt;/span>&lt;span class="nv">part&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="nv">remaining&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="nv">remaining-asym-parts&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">➎&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">recur&lt;/span> &lt;span class="nv">remaining&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">into &lt;/span>&lt;span class="nv">final-body-parts&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">set &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">part&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">matching-part&lt;/span> &lt;span class="nv">part&lt;/span>&lt;span class="p">)])))))))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>symmetriz-body-parts&lt;/code>函数（从➊开始）采用了函数式编程中常见的一般策略。给定一个序列（在本例中，是一个身体部位及其尺寸的 Vector），该函数连续地将该序列分割成&lt;em>head&lt;/em>和&lt;em>tail&lt;/em>。然后，它处理头部，将其添加到某个结果中，并使用递归来继续处理尾部的过程。&lt;/p>
&lt;p>我们在➋处开始循环处理主体部分。序列的尾部将被绑定到&lt;code>remaining-asym-parts&lt;/code>。最初，它被绑定到传递给函数的完整序列：&lt;code>asym-body-parts&lt;/code>。我们还创建了一个结果序列，&lt;code>final-body-parts&lt;/code>；它的初始值是一个空 Vector。&lt;/p>
&lt;p>如果&lt;code>remaining-asym-parts&lt;/code>在➌处是空的，这意味着我们已经处理了整个序列，可以返回结果，&lt;code>final-body-parts&lt;/code>。否则，在➍，我们将列表分成&lt;code>head&lt;/code>，&lt;code>part&lt;/code>，和&lt;code>tail&lt;/code>，&lt;code>remaining&lt;/code>。&lt;/p>
&lt;p>在➎处，我们用&lt;code>remaining&lt;/code>进行循环，这个列表在循环的每一次迭代中都会缩短一个元素，还有&lt;code>(in)&lt;/code>表达式，它建立了对称的身体部分的 Vector。&lt;/p>
&lt;p>如果你是这种编程的新手，这段代码可能需要一些时间来解决。请坚持下去! 一旦你理解了正在发生的事情，你会觉得自己像个百万富翁!&lt;/p>
&lt;h3 id="用-reduce-来编写更好的对称器">用 reduce 来编写更好的对称器&lt;/h3>
&lt;p>处理序列的每个元素并返回一个结果的模式非常普遍，以至于有一个内置的函数叫做&lt;code>reduce&lt;/code>。下面是一个简单的例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">;; sum with reduce&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">reduce + &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; 10&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就像告诉 Clojure 这样做。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>reduce&lt;/code>函数按照以下步骤工作。&lt;/p>
&lt;ol>
&lt;li>将给定的函数应用于一个序列的前两个元素。这就是&lt;code>(+ 1 2)&lt;/code>的由来。&lt;/li>
&lt;li>将给定的函数应用于结果和序列的下一个元素。在本例中，步骤 1 的结果是&lt;code>3&lt;/code>，序列的下一个元素也是&lt;code>3&lt;/code>。所以最后的结果是&lt;code>(+3 3)&lt;/code>。&lt;/li>
&lt;li>对序列中剩下的每个元素重复第 2 步。&lt;/li>
&lt;/ol>
&lt;p>&lt;code>reduce&lt;/code>也需要一个可选的初始值。这里的初始值是&lt;code>15&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">reduce + &lt;/span>&lt;span class="mi">15&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果你提供了一个初始值，&lt;code>reduce&lt;/code>就会开始对初始值和序列的第一个元素应用给定的函数，而不是序列的前两个元素。&lt;/p>
&lt;p>需要注意的一个细节是，在这些例子中，&lt;code>reduce&lt;/code>接收一个元素的集合，&lt;code>[1 2 3 4]&lt;/code>，并返回一个单一的数字。虽然程序员经常这样使用&lt;code>reduce&lt;/code>，但你也可以使用&lt;code>reduce&lt;/code>来返回一个比你开始时更大的集合，就像我们在&lt;code>symmetrize&lt;/code>-body-parts&lt;code>中尝试做的那样。&lt;/code>reduce&lt;code>抽象了 &amp;quot;处理一个集合并建立一个结果 &amp;quot;的任务，它对返回的结果类型是不确定的。为了进一步了解&lt;/code>reduce`的工作原理，这里有一种方法可以实现它。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">my-reduce&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">([&lt;/span>&lt;span class="nv">f&lt;/span> &lt;span class="nv">initial&lt;/span> &lt;span class="nv">coll&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">loop &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">result&lt;/span> &lt;span class="nv">initial&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">remaining&lt;/span> &lt;span class="nv">coll&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">if &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">empty?&lt;/span> &lt;span class="nv">remaining&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">result&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">recur&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">f&lt;/span> &lt;span class="nv">result&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">first &lt;/span>&lt;span class="nv">remaining&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">rest &lt;/span>&lt;span class="nv">remaining&lt;/span>&lt;span class="p">)))))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">([&lt;/span>&lt;span class="nv">f&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nv">head&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="nv">tail&lt;/span>&lt;span class="p">]]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">my-reduce&lt;/span> &lt;span class="nv">f&lt;/span> &lt;span class="nv">head&lt;/span> &lt;span class="nv">tail&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们可以重新实现我们的对称器，如下所示。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">better-symmetrize-body-parts&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;Expects a seq of maps that have a :name and :size&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">asym-body-parts&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">reduce &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">fn &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">final-body-parts&lt;/span> &lt;span class="nv">part&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">into &lt;/span>&lt;span class="nv">final-body-parts&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">set &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">part&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">matching-part&lt;/span> &lt;span class="nv">part&lt;/span>&lt;span class="p">)])))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">asym-body-parts&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>真棒! 使用&lt;code>reduce&lt;/code>的一个显而易见的好处是，你写的代码总体上更少。你传递给&lt;code>reduce&lt;/code>的匿名函数只专注于处理一个元素和建立一个结果。原因是&lt;code>reduce&lt;/code>处理了底层的机制，即跟踪哪些元素已经被处理，并决定是否返回一个最终结果或递归。&lt;/p>
&lt;p>使用&lt;code>reduce&lt;/code>也更有表现力。如果你的代码的读者遇到 &amp;ldquo;loop&amp;rdquo;，如果不阅读所有的代码，他们将不能确定这个循环到底在做什么。但是如果他们看到&lt;code>reduce&lt;/code>，他们会立即知道代码的目的是处理一个集合的元素以建立一个结果。&lt;/p>
&lt;p>最后，通过将 &amp;ldquo;reduce &amp;ldquo;过程抽象为一个以另一个函数为参数的函数，你的程序变得更有可塑性。例如，你可以将&lt;code>reduce&lt;/code>函数作为一个参数传递给其他函数。你还可以创建一个更通用的 &amp;ldquo;对称体-部件 &amp;ldquo;版本，例如 &amp;ldquo;扩展体-部件&amp;rdquo;。除了身体部位的列表外，它还可以接受一个&lt;em>扩展器&lt;/em>函数，并让你的模型不仅仅是霍比特人。例如，你可以有一个蜘蛛扩展器，可以增加眼睛和腿的数量。我会让你自己来写，因为我是邪恶的。&lt;/p>
&lt;h3 id="霍比特人的暴力">霍比特人的暴力&lt;/h3>
&lt;p>我的话，这真是为勇敢和真实的人准备的 Clojure! 为了给你的工作画上句号，这里有一个函数可以确定霍比特人的哪个部分被击中。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">hit&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="nv">asym-body-parts&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">let &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nv">sym-parts&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="err">➊&lt;/span>&lt;span class="nv">better-symmetrize-body-parts&lt;/span> &lt;span class="nv">asym-body-parts&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">➋&lt;/span>&lt;span class="nv">body-part-size-sum&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">reduce + &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">map &lt;/span>&lt;span class="ss">:size&lt;/span> &lt;span class="nv">sym-parts&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">target&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">rand &lt;/span>&lt;span class="nv">body-part-size-sum&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">➌&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">loop &lt;/span>&lt;span class="p">[[&lt;/span>&lt;span class="nv">part&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="nv">remaining&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="nv">sym-parts&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">accumulated-size&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="ss">:size&lt;/span> &lt;span class="nv">part&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="k">if &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">&amp;gt; &lt;/span>&lt;span class="nv">accumulated-size&lt;/span> &lt;span class="nv">target&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">part&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">recur&lt;/span> &lt;span class="nv">remaining&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="nv">accumulated-size&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="ss">:size&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">first &lt;/span>&lt;span class="nv">remaining&lt;/span>&lt;span class="p">))))))))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>hit&lt;/code>的工作原理是取一个不对称的身体部位的 Vector，在➊处对称，然后在➋处将各部位的大小相加。一旦我们将这些尺寸相加，就好像从 1 到&lt;code>身体部位尺寸之和&lt;/code>的每个数字都对应于一个身体部位；1 可能对应于左眼，而 2、3、4 可能对应于头部。这使得当你击中一个身体部位时（通过在这个范围内选择一个随机数字），特定身体部位被击中的可能性将取决于身体部位的大小。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/do-things/hobbit-hit-line.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>图 3-1：身体部位与数字的范围相对应，如果目标在这个范围内，就会被击中。&lt;/p>
&lt;p>最后，这些数字中的一个被随机选择，然后我们在➌处使用&lt;code>loop&lt;/code>来寻找并返回与该数字对应的身体部位。循环是通过跟踪我们已经检查过的部分的累计大小，并检查累计大小是否大于目标值来实现的。我把这个过程想象成用一排编号的槽来排列身体部位。在我排完一个身体部位后，我问自己：&amp;ldquo;我已经达到目标了吗？&amp;rdquo; 如果我达到了，这意味着我刚刚排好的身体部位就是被击中的那个部位。否则，我就继续排查这些部位。&lt;/p>
&lt;p>例如，假设你的零件清单是&lt;em>头&lt;/em>、&lt;em>左眼&lt;/em>和&lt;em>左手&lt;/em>，如图 3-1。在取完第一个部分，即头部后，累计大小为 3。当累计大小超过目标时，身体部分就被击中，所以如果目标小于 3，那么头部就被击中了。否则，你取下下一个部分，即左眼，并将累积大小增加到 4，如果目标大于或等于 3 且小于 4，则产生一个命中。&lt;/p>
&lt;p>下面是一些&lt;code>hit&lt;/code>函数的运行样本。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">hit&lt;/span> &lt;span class="nv">asym-hobbit-body-parts&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; {:name &amp;#34;right-upper-arm&amp;#34;, :size 3}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">hit&lt;/span> &lt;span class="nv">asym-hobbit-body-parts&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; {:name &amp;#34;chest&amp;#34;, :size 10}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">hit&lt;/span> &lt;span class="nv">asym-hobbit-body-parts&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; {:name &amp;#34;left-eye&amp;#34;, :size 1}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>哦，我的上帝，那个可怜的霍比特人！你这个怪物！&amp;quot;。你这个怪物!&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本章让你对如何在 Clojure 中&lt;em>做事&lt;/em>有了一个旋风式的了解。你现在知道了如何用字符串、数字、Map、关键字、Vector、列表和 Set 来表示信息，以及如何用&lt;code>def&lt;/code>和&lt;code>let&lt;/code>来命名这些表达式。你已经了解了函数的灵活性以及如何创建你自己的函数。此外，你还了解了 Clojure 的简单哲学，包括其统一的语法和强调在原始数据类型上使用大型函数库。&lt;/p>
&lt;p>第 4 章将带你详细探究 Clojure 的核心函数，第 5 章解释了函数式编程的思维模式。本章向你展示了如何编写 Clojure 代码&amp;ndash;接下来的两章将向你展示如何更好的编写 Clojure。&lt;/p>
&lt;p>在这一点上，我建议你开始写代码，我的每一根纤维都是这样。没有比这更好的方法来巩固你的 Clojure 知识了。Clojure Cheat Sheet（&lt;em>&lt;a class="link" href="http://clojure.org/api/cheatsheet" target="_blank" rel="noopener"
>http://clojure.org/api/cheatsheet&lt;/a>&lt;/em>）是一个很好的参考资料，它列出了所有在本章中涉及的数据结构上操作的内置函数。&lt;/p>
&lt;p>下面的练习会让你的大脑非常兴奋。如果你想更多地测试你的新技能，可以在*&lt;a class="link" href="http://www.projecteuler.net/" target="_blank" rel="noopener"
>http://www.projecteuler.net/&lt;/a>&lt;em>尝试一些 Project Euler 挑战。你还可以看看 4Clojure（&lt;/em>&lt;a class="link" href="http://www.4clojure.com/problems/" target="_blank" rel="noopener"
>http://www.4clojure.com/problems/&lt;/a>*），这是一套在线的 Clojure 问题，旨在测试你的知识。写点什么吧!&lt;/p>
&lt;h2 id="练习">练习&lt;/h2>
&lt;p>这些练习是为了测试你的 Clojure 知识和学习更多的 Clojure 函数，是一种有趣的方式。前三个可以只用本章介绍的信息来完成，但后三个需要你使用到目前为止还没有涉及的函数。如果你真的很想写更多的代码并探索 Clojure 的标准库，那么就去解决后三个问题。如果你觉得这些练习太难了，可以在读完第 4 章和第 5 章后再来看看，你会发现它们要容易得多。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>使用&lt;code>str&lt;/code>, &lt;code>vector&lt;/code>, &lt;code>list&lt;/code>, &lt;code>hash-map&lt;/code>, 和&lt;code>hash-set&lt;/code>函数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>编写一个函数，接收一个数字，并向其添加 100。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>写一个函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">dec-maker&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>，其工作原理与函数&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">inc-maker&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>除了用减法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="k">def &lt;/span>&lt;span class="nv">dec9&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">dec-maker&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">dec9&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; 1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>写一个函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">mapset&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>，它的工作原理是&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">map
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>除了返回值是一个集合。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">mapset&lt;/span> &lt;span class="nb">inc &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; #{2 3}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>创建一个类似于&lt;code>symmetriz-body-parts&lt;/code>的函数，只是它必须与具有径向对称性的奇怪的太空外星人一起工作。他们没有两只眼睛、胳膊、腿等等，而是有五只。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>创建一个函数，将&lt;code>symmetriz-body-parts&lt;/code>和你在练习 5 中创建的函数通用化。这个新的函数应该接受一个身体部位的集合，以及要增加的匹配身体部位的数量。如果你对 Lisp 语言和函数式编程是完全陌生的，那么如何做到这一点可能并不明显。如果你被卡住了，只需转到下一章，以后再重温这个问题。&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Chapter2 如何使用 Emacs</title><link>https://example.com/p/chapter2-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-emacs/</link><pubDate>Thu, 13 Jan 2022 10:43:56 +0800</pubDate><guid>https://example.com/p/chapter2-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-emacs/</guid><description>&lt;h1 id="如何使用-emacs一个优秀的-clojure-编辑器">如何使用 Emacs，一个优秀的 Clojure 编辑器&lt;/h1>
&lt;p>在你掌握 Clojure 的过程中，你的编辑器将是你最亲密的盟友。我强烈建议使用 Emacs，但你当然也可以使用任何你想要的编辑器。如果你不遵循本章中关于 Emacs 的详尽说明，或者你选择使用一个不同的编辑器，那么至少值得投入一些时间来设置你的编辑器，以便与 REPL 一起工作。我推荐的两个在社区中受到好评的替代品是&lt;a class="link" href="https://cursive-ide.com/" target="_blank" rel="noopener"
>Cursive&lt;/a>和&lt;a class="link" href="https://sekao.net/nightcode/" target="_blank" rel="noopener"
>Nightcode&lt;/a>。&lt;/p>
&lt;p>我推荐 Emacs 的原因是，它提供了与 Clojure REPL 的紧密集成，这使你可以在写作时立即尝试你的代码。这种紧密的反馈回路在学习 Clojure 和以后编写真正的 Clojure 程序时都很有用。Emacs 也很适合与任何 Lisp 方言一起工作；事实上，Emacs 是用一种叫做 Emacs Lisp（elisp）的 Lisp 方言编写的。&lt;/p>
&lt;p>在本章结束时，你的 Emacs 设置将看起来像图 2-1。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/basic-emacs/emacs-final.png"
loading="lazy"
>&lt;/p>
&lt;p>图 2-1: 使用 Clojure 的典型 Emacs 设置：一边是代码，另一边是 REPL。&lt;/p>
&lt;p>为了达到这个目的，你将从安装 Emacs 开始，设置一个适合新人的 Emacs 配置。然后你将学习基础知识：如何打开、编辑和保存文件，以及如何使用基本的键绑定与 Emacs 进行交互。最后，你将学习如何实际编辑 Clojure 代码并与 REPL 进行交互。&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;p>你应该使用 Emacs 的最新主要版本，即 Emacs 24，用于你工作的平台。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>OS X&lt;/strong>从*&lt;a class="link" href="http://emacsformacosx.com/" target="_blank" rel="noopener"
>http://emacsformacosx.com&lt;/a>*安装 vanilla Emacs 作为一个 Mac 应用程序。其他选项，如 Aquamacs，应该是为了使 Emacs 更 &amp;ldquo;像 Mac&amp;rdquo;，但从长远来看是有问题的，因为它们的设置与标准 Emacs 有很大的不同，以至于很难使用 Emacs 手册或跟随教程。&lt;/li>
&lt;li>&lt;strong>Ubuntu&lt;/strong>按照*&lt;a class="link" href="https://launchpad.net/~cassou/&amp;#43;archive/emacs" target="_blank" rel="noopener"
>https://launchpad.net/~cassou/+archive/emacs&lt;/a>*上的说明。&lt;/li>
&lt;li>&lt;strong>Windows&lt;/strong>你可以在*&lt;a class="link" href="http://ftp.gnu.org/gnu/emacs/windows/" target="_blank" rel="noopener"
>Index of /gnu/emacs/windows&lt;/a>&lt;em>找到一个二进制文件。在你下载并解压最新版本后，你可以在&lt;/em>bin\runemacs.exe*下运行 Emacs 可执行文件。&lt;/li>
&lt;/ul>
&lt;p>安装完 Emacs 后，打开它。你应该看到类似图 2-2 的东西。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/basic-emacs/emacs-fresh.png"
loading="lazy"
>&lt;/p>
&lt;p>图 2-2：当你第一次打开 Emacs 时显示的屏幕&lt;/p>
&lt;p>欢迎来到 Emacs 的崇拜！你已经使 Richard Stallman 成为了 Emacs 的一员。你让 Richard Stallman 感到骄傲!&lt;/p>
&lt;h2 id="配置">配置&lt;/h2>
&lt;p>我创建了一个库，里面有为 Clojure 配置 Emacs 所需的所有文件，可在&lt;a class="link" href="https://github.com/flyingmachine/emacs-for-clojure/archive/book1.zip" target="_blank" rel="noopener"
>https://github.com/flyingmachine/emacs-for-clojure/archive/book1.zip&lt;/a>。&lt;/p>
&lt;p>注意：这些工具一直在更新，所以如果下面的说明对你不起作用，或者你想使用最新的配置，请阅读&lt;a class="link" href="https://github.com/flyingmachine/emacs-for-clojure/" target="_blank" rel="noopener"
>GitHub - flyingmachine/emacs-for-clojure&lt;/a>上的说明。&lt;/p>
&lt;p>按以下步骤删除你现有的 Emacs 配置并安装对 Clojure 友好的配置。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>关闭 Emacs。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>删除*~/.emacs&lt;em>或&lt;/em>~/.emacs.d*，如果它们存在的话。(Windows 用户，你的 Emacs 文件可能在&lt;em>C:\Users\your_user_name\AppData\Roaming*。因此，举例来说，你可以删除&lt;/em>C:\Users\jason\AppData\Roaming.emacs.d*）。这是 Emacs 寻找配置文件的地方，删除这些文件和目录将确保你从一个干净的地方开始。&lt;/p>
&lt;/li>
&lt;li>
&lt;ol start="3">
&lt;li>下载上面列出的 Emacs 配置压缩文件并解压。其内容应该是一个文件夹，&lt;em>emacs-for-clojure-book1&lt;/em>。运行 mv path/to/emacs-for-clojure-book1 ~/.emacs.d。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>打开 Emacs。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>当你打开 Emacs 时，你可能会看到大量的活动，因为 Emacs 正在下载一堆有用的软件包。一旦这些活动停止，继续前进，退出 Emacs，然后再打开它。(如果你没有看到任何活动，那也没关系！退出并重新启动 Emacs。退出并重新启动 Emacs 只是为了好玩）。在你这样做之后，你应该看到一个像图 2-3 那样的窗口。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/basic-emacs/emacs-configged.png"
loading="lazy"
>&lt;/p>
&lt;p>图 2-3：Emacs 在安装了你可爱的新配置后的样子&lt;/p>
&lt;p>现在我们已经设置好了一切，让我们来学习如何使用 Emacs!&lt;/p>
&lt;h2 id="emacs-逃逸舱口">Emacs 逃逸舱口&lt;/h2>
&lt;p>在我们进入有趣的东西之前，你需要知道一个重要的 Emacs 键绑定：ctrl-G。这个键绑定可以退出你试图运行的任何 Emacs 命令。所以，如果事情进展不顺利，按住 ctrl，按 G，然后再试一次。它不会关闭 Emacs，也不会使你失去任何工作；它只是取消你当前的行动。&lt;/p>
&lt;h2 id="emacs-缓冲区">Emacs 缓冲区&lt;/h2>
&lt;p>所有的编辑都发生在 Emacs 的*缓冲区中。当你第一次启动 Emacs 时，一个名为 &amp;ldquo;&lt;em>scratch&lt;/em>&amp;ldquo;的缓冲区被打开。Emacs 总是在窗口的底部显示当前缓冲区的名称，如图 2-4 所示。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/basic-emacs/emacs-buffer-name.png"
loading="lazy"
>&lt;/p>
&lt;p>图 2-4：Emacs 会一直显示当前缓冲区的名称。&lt;/p>
&lt;p>默认情况下，&lt;code>*scratch*&lt;/code>缓冲区处理括号和缩进的方式对 Lisp 开发来说是最理想的，但对编写纯文本却很不方便。让我们创建一个新的缓冲区，这样我们就可以在不发生意外的情况下进行游戏。要创建一个缓冲区，请这样做。&lt;/p>
&lt;ol>
&lt;li>按住 ctrl 键并按下 X 键。&lt;/li>
&lt;li>2.松开 ctrl 键。&lt;/li>
&lt;li>按 B 键。&lt;/li>
&lt;/ol>
&lt;p>我们可以用一个更紧凑的格式来表达同样的序列。 &lt;strong>C-x b&lt;/strong>。&lt;/p>
&lt;p>执行这个按键序列后，你会在应用程序的底部看到一个提示，如图 2-5 所示。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/basic-emacs/emacs-buffer-prompt.png"
loading="lazy"
>&lt;/p>
&lt;p>图 2-5: 迷你缓冲区是 Emacs 提示你输入的地方。&lt;/p>
&lt;p>这个区域被称为&lt;em>minibuffer&lt;/em>，它是 Emacs 提示你输入的地方。现在它正在提示我们输入一个缓冲区的名称。你可以输入一个已经打开的缓冲区的名称，也可以输入一个新的缓冲区名称。输入 emacs-fun-times，然后按回车键。现在你应该看到一个完全空白的缓冲区，可以直接开始输入。你会发现，按键的工作方式与你所期望的差不多。字符在你输入时出现。上、下、左、右方向键会像你所期望的那样移动你，而回车键会创建一个新行。&lt;/p>
&lt;p>你还会注意到，你不会突然长出浓密的 Unix 胡须或穿上 Birkenstocks（除非你一开始就有）。这应该有助于缓解你对使用 Emacs 的任何恐惧感。当你玩够了之后，继续前进，通过输入&lt;strong>C-x k enter&lt;/strong>来杀死**的缓冲区。(这可能会让人吃惊，但 Emacs 实际上是很暴力的，它充分使用了&lt;em>杀&lt;/em>这个词）。&lt;/p>
&lt;p>现在你已经杀死了&lt;code>emacs-fun-times&lt;/code>缓冲区，你应该回到&lt;code>*scratch*&lt;/code>缓冲区。一般来说，你可以用&lt;strong>C-x b&lt;/strong>创建任意多的新缓冲区。你也可以用同样的命令在缓冲区之间快速切换。当你以这种方式创建一个新的缓冲区时，它只存在于内存中，直到你把它保存为一个文件；缓冲区不一定有文件支持，创建一个缓冲区也不一定会创建一个文件。让我们来学习一下关于文件的工作。&lt;/p>
&lt;h2 id="与文件一起工作">与文件一起工作&lt;/h2>
&lt;p>在 Emacs 中打开文件的键位是&lt;strong>C-x C-f&lt;/strong>。注意，当你按下 X 和 F 时，你需要按住 ctrl。导航到*~/.emacs.d/customizations/ui.el*，它可以自定义 Emacs 的外观和你与它的互动方式。Emacs 在一个与文件名相同的新缓冲区中打开文件。让我们转到第 37 行，去掉前面的分号，取消注释。它将看起来像这样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">setq&lt;/span> &lt;span class="nv">initial-frame-alist&lt;/span> &lt;span class="o">&amp;#39;&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nf">top&lt;/span> &lt;span class="k">. &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">left &lt;/span>&lt;span class="k">. &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">width&lt;/span> &lt;span class="k">. &lt;/span>&lt;span class="mi">120&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">height&lt;/span> &lt;span class="k">. &lt;/span>&lt;span class="mi">80&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后改变 &amp;ldquo;width &amp;ldquo;和 &amp;ldquo;height &amp;ldquo;的值，它们为活动窗口设置&lt;em>字符&lt;/em>的尺寸。通过改变这些值，你可以设置 Emacs 窗口在每次启动时以某种尺寸打开。一开始可以试试小一点的，比如 80 和 20。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nf">setq&lt;/span> &lt;span class="nv">initial-frame-alist&lt;/span> &lt;span class="o">&amp;#39;&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nf">top&lt;/span> &lt;span class="k">. &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">left &lt;/span>&lt;span class="k">. &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">width&lt;/span> &lt;span class="k">. &lt;/span>&lt;span class="mi">80&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">height&lt;/span> &lt;span class="k">. &lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在用下面的键绑定来保存你的文件。 &lt;strong>C-x C-s&lt;/strong>。你应该在 Emacs 的底部得到一个信息，如&lt;code>写了/Users/snuffleupagus/&lt;/code>.emacs.d/customizations/ui.el`。你也可以尝试使用你在其他应用程序中使用的键绑定来保存你的缓冲区（例如，ctrl-S 或 cmd-S）。你下载的 Emacs 配置应该允许这样做，但如果不允许，也没什么大不了的。&lt;/p>
&lt;p>保存文件后，退出 Emacs 并再次启动它。我敢打赌，它非常小! 请看我在图 2-6 中的例子。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/basic-emacs/tinemacs.png"
loading="lazy"
>&lt;/p>
&lt;p>图 2-6：你可以配置 Emacs，使其在每次打开时都设置高度和宽度。&lt;/p>
&lt;p>同样的过程要进行几次，直到 Emacs 以你喜欢的尺寸开始。或者再把这几行注释掉就可以了（在这种情况下，Emacs 将以其默认的宽度和高度打开）。如果你完成了对&lt;em>ui.el&lt;/em>的编辑，你可以用&lt;strong>C-x k&lt;/strong>关闭其缓冲区。无论如何，你已经完成了在 Emacs 中保存第一个文件的工作 如果发生了一些疯狂的事情，你可以按照&lt;a class="link" href="https://www.braveclojure.com/basic-emacs/#Anchor" target="_blank" rel="noopener"
>第 13 页的 &amp;ldquo;配置&amp;rdquo;&lt;/a>中的指示来使 Emacs 重新工作。&lt;/p>
&lt;p>如果你想创建一个新的文件，只需使用&lt;strong>C-x C-f&lt;/strong>并在迷你缓冲区中输入新文件的路径。一旦你保存了缓冲区，Emacs 就会按照你输入的路径用缓冲区的内容创建一个文件。&lt;/p>
&lt;p>让我们来回顾一下。&lt;/p>
&lt;ol>
&lt;li>在 Emacs 中，编辑是在缓冲区*.*中进行的。&lt;/li>
&lt;li>要切换到一个缓冲区，使用&lt;strong>C-x b&lt;/strong>并在 minibuffer*.*中输入缓冲区的名称。&lt;/li>
&lt;li>要创建一个新的缓冲区，使用&lt;strong>C-x b&lt;/strong>并输入一个新的缓冲区名称。&lt;/li>
&lt;li>要打开一个文件，使用&lt;strong>C-x C-f&lt;/strong>并导航到该文件。&lt;/li>
&lt;li>
&lt;ol start="5">
&lt;li>要将缓冲区保存到文件中，使用&lt;strong>C-x C-s&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>要创建一个新的文件，使用&lt;strong>C-x C-f&lt;/strong>并输入新文件的路径。当你保存缓冲区时，Emacs 将在文件系统中创建文件。&lt;/li>
&lt;/ol>
&lt;h2 id="键绑定和模式">键绑定和模式&lt;/h2>
&lt;p>你已经走了很长一段路了! 你现在可以像一个非常基本的编辑器一样使用 Emacs。如果你需要在服务器上使用 Emacs，或者被迫与 Emacs 书呆子配对，这应该能帮助你度过难关。&lt;/p>
&lt;p>然而，要想真正有成效，了解一些关于键绑定的*关键细节对你来说是很有用的（哈哈！）。然后我将介绍 Emacs 模式。之后，我将介绍一些核心术语，并介绍一些超级有用的键绑定。&lt;/p>
&lt;h3 id="emacs-是一个-lisp-解释器">Emacs 是一个 Lisp 解释器&lt;/h3>
&lt;p>术语&lt;em>键绑定&lt;/em>源于这样一个事实：Emacs 将&lt;em>键击打&lt;/em>绑定到&lt;em>命令&lt;/em>上，而这些命令只是 elisp 函数（我将交替使用&lt;em>命令&lt;/em>和&lt;em>函数&lt;/em>）。例如，&lt;strong>C-x b&lt;/strong>被绑定到函数&lt;code>switch-to-buffer&lt;/code>。同样地，&lt;strong>C-x C-s&lt;/strong>与&lt;code>save-file&lt;/code>绑定。&lt;/p>
&lt;p>但 Emacs 甚至比这更进一步。甚至像&lt;strong>f&lt;/strong>和&lt;strong>a&lt;/strong>这样简单的按键也被绑定到一个函数上，在这个例子中是 &amp;ldquo;self-insert-command&amp;rdquo;，是向你正在编辑的缓冲区添加字符的命令。&lt;/p>
&lt;p>从 Emacs 的角度来看，所有的函数都是平等的，你可以重新定义所有的函数，甚至像&lt;code>save-file&lt;/code>这样的核心函数。你可能不会&lt;em>想要&lt;/em>重新定义核心函数，但你可以。&lt;/p>
&lt;p>你可以重新定义函数，因为就其核心而言，Emacs 只是一个 Lisp 解释器，恰好加载了代码编辑功能。Emacs 的大部分内容都是用 elisp 编写的，所以从 Emacs 的角度来看，&lt;code>save-file&lt;/code>只是一个函数，就像&lt;code>switch-to-buffer&lt;/code>和你能运行的几乎所有其他命令一样。不仅如此，你创建的任何函数都被当作内置函数来对待。你甚至可以用 Emacs 来执行 elisp，在它运行时修改 Emacs。&lt;/p>
&lt;p>使用强大的编程语言修改 Emacs 的自由是 Emacs 如此灵活的原因，也是为什么像我这样的人对它如此疯狂。是的，它有很多表面上的复杂性，可能需要花时间去学习。但 Emacs 的底层是 Lisp 的优雅简洁，以及随之而来的无限的可修补性。这种可修补性并不局限于创建和重新定义函数。你还可以创建、重新定义和删除键绑定。从概念上讲，按键绑定只是一个查询表中的条目，它将按键与函数联系起来，而这个查询表是完全可修改的。&lt;/p>
&lt;p>你也可以使用&lt;strong>M-x&lt;/strong>函数名称来运行命令，而不需要特定的键绑定（例如，&lt;strong>M-x&lt;/strong> save-buffer）。 &lt;em>M&lt;/em>代表&lt;em>meta&lt;/em>，这是一个现代键盘不具备的键，但在 Windows 和 Linux 上被 Map 到 alt，在 Mac 上则是 option。 &lt;strong>M-x&lt;/strong>运行&lt;code>smex&lt;/code>命令，它提示你要运行的另一个命令的名称。&lt;/p>
&lt;p>现在你已经了解了键的绑定和功能，你将能够理解什么是模式以及它们是如何工作的。&lt;/p>
&lt;h3 id="模式">模式&lt;/h3>
&lt;p>Emacs 的&lt;em>模式&lt;/em>是一个键绑定和功能的集合，它被打包在一起，帮助你在编辑不同类型的文件时提高工作效率。(模式也可以做一些事情，比如告诉 Emacs 如何做语法高亮，但这是次要的，我不会在这里介绍。)&lt;/p>
&lt;p>例如，当你在编辑一个 Clojure 文件时，你会想加载 Clojure 模式。现在我正在写一个 Markdown 文件并使用 Markdown 模式，它有很多专门用于 Markdown 工作的有用的键绑定。在编辑 Clojure 时，最好有一套 Clojure 专用的键绑定，比如&lt;strong>C-c C-k&lt;/strong>将当前的缓冲区加载到 REPL 中并进行编译。&lt;/p>
&lt;p>模式有两种类型。 &lt;em>主要&lt;/em>模式和&lt;em>次要&lt;/em>模式。Markdown 模式和 Clojure 模式是主要模式。主要模式通常在你打开文件时由 Emacs 设置，但你也可以通过运行相关的 Emacs 命令明确地设置模式，例如用&lt;strong>M-x&lt;/strong> clojure-mode 或&lt;strong>M-x&lt;/strong> major-mode。每次只有一种主要模式是激活的。&lt;/p>
&lt;p>主要模式是针对某种文件类型或语言的 Emacs，而次要模式通常提供对各种文件类型都有用的功能。例如，abbrev 模式 &amp;ldquo;根据预先定义的缩写定义自动展开文本&amp;rdquo;（根据 Emacs 手册&lt;a class="link" href="https://www.braveclojure.com/basic-emacs/#footnote-5680-1" target="_blank" rel="noopener"
>1.&lt;/a>）。你可以同时激活多个次要模式。&lt;/p>
&lt;p>你可以在*模式行中看到哪些模式处于活动状态，如图 2-7 所示。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/basic-emacs/emacs-mode-line.png"
loading="lazy"
>&lt;/p>
&lt;p>图 2-7：模式行显示哪些模式是活动的。&lt;/p>
&lt;p>如果你打开一个文件，而 Emacs 没有为它加载一个主要模式，那么这个模式很有可能存在。你只需要下载它的软件包。说到这个 &amp;hellip; .&lt;/p>
&lt;h3 id="安装软件包">安装软件包&lt;/h3>
&lt;p>许多模式都是以&lt;em>包&lt;/em>的形式发布的，这只是存储在包仓库中的 elisp 文件的捆绑。你在本章开始时安装的 Emacs 24，使浏览和安装软件包变得非常容易。 &lt;strong>M-x&lt;/strong> package-list-packages 会显示几乎所有可用的软件包；只要确保你先运行&lt;strong>M-x&lt;/strong> package-refresh-contents 就能得到最新的列表。你可以用&lt;strong>M-x&lt;/strong> package-install 来安装软件包。&lt;/p>
&lt;p>你也可以通过加载你自己的 elisp 文件或你在网上找到的文件来定制 Emacs。Emacs 初学者指南》（见*&lt;a class="link" href="http://www.masteringemacs.org/articles/2010/10/04/beginners-guide-to-emacs/" target="_blank" rel="noopener"
>http://www.masteringemacs.org/articles/2010/10/04/beginners-guide-to-emacs/&lt;/a>*）在文章底部的 &amp;ldquo;加载新包 &amp;ldquo;一节中对如何加载自定义文件有很好的描述。&lt;/p>
&lt;h2 id="核心编辑术语和键绑定">核心编辑术语和键绑定&lt;/h2>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/basic-emacs/pirate.png"
loading="lazy"
>&lt;/p>
&lt;p>如果你只想把 Emacs 当做一个文本编辑器来使用，你可以完全跳过这一节！但你将会错过很多东西。但你将会错过一些好东西。在这一节中，我们将介绍 Emacs 的关键术语；如何选择、剪切、复制和粘贴文本；如何选择、剪切、复制和粘贴文本（看到我做了什么吗？ 哈哈哈！）；以及如何有效地在缓冲区内移动。&lt;/p>
&lt;p>要想开始，请在 Emacs 中打开一个新的缓冲区，并将其命名为&lt;em>jack-handy&lt;/em>。然后输入以下杰克-汉迪的语录。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">If&lt;/span> &lt;span class="nv">you&lt;/span> &lt;span class="nv">were&lt;/span> &lt;span class="nv">a&lt;/span> &lt;span class="nv">pirate&lt;/span>, &lt;span class="nv">you&lt;/span> &lt;span class="nv">know&lt;/span> &lt;span class="nv">what&lt;/span> &lt;span class="nv">would&lt;/span> &lt;span class="nv">be&lt;/span> &lt;span class="nv">the&lt;/span> &lt;span class="nv">one&lt;/span> &lt;span class="nv">thing&lt;/span> &lt;span class="nv">that&lt;/span> &lt;span class="nv">would&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">really&lt;/span> &lt;span class="nv">make&lt;/span> &lt;span class="nv">you&lt;/span> &lt;span class="nv">mad?&lt;/span> &lt;span class="nv">Treasure&lt;/span> &lt;span class="nv">chests&lt;/span> &lt;span class="nv">with&lt;/span> &lt;span class="nv">no&lt;/span> &lt;span class="nv">handles.&lt;/span> &lt;span class="nv">How&lt;/span> &lt;span class="nv">the&lt;/span> &lt;span class="nv">hell&lt;/span> &lt;span class="nv">are&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">you&lt;/span> &lt;span class="nv">supposed&lt;/span> &lt;span class="nv">to&lt;/span> &lt;span class="nv">carry&lt;/span> &lt;span class="nv">it?!&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">The&lt;/span> &lt;span class="nv">face&lt;/span> &lt;span class="nv">of&lt;/span> &lt;span class="nv">a&lt;/span> &lt;span class="nv">child&lt;/span> &lt;span class="nv">can&lt;/span> &lt;span class="nv">say&lt;/span> &lt;span class="nv">it&lt;/span> &lt;span class="nv">all&lt;/span>, &lt;span class="nv">especially&lt;/span> &lt;span class="nv">the&lt;/span> &lt;span class="nv">mouth&lt;/span> &lt;span class="nv">part&lt;/span> &lt;span class="nv">of&lt;/span> &lt;span class="nv">the&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">face.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">To&lt;/span> &lt;span class="nv">me&lt;/span>, &lt;span class="nv">boxing&lt;/span> &lt;span class="nv">is&lt;/span> &lt;span class="nv">like&lt;/span> &lt;span class="nv">a&lt;/span> &lt;span class="nv">ballet&lt;/span>, &lt;span class="nv">except&lt;/span> &lt;span class="nv">there&lt;/span>&lt;span class="ss">&amp;#39;s&lt;/span> &lt;span class="nv">no&lt;/span> &lt;span class="nv">music&lt;/span>, &lt;span class="nv">no&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">choreography&lt;/span>, &lt;span class="nb">and &lt;/span>&lt;span class="nv">the&lt;/span> &lt;span class="nv">dancers&lt;/span> &lt;span class="nv">hit&lt;/span> &lt;span class="nv">each&lt;/span> &lt;span class="nv">other.&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>用这个例子来试验本节中的导航和编辑。&lt;/p>
&lt;h3 id="点">点&lt;/h3>
&lt;p>如果你一直在关注，你应该在你的 Emacs 缓冲区看到一个橘红色的矩形。这就是&lt;em>游标&lt;/em>，它是&lt;em>点&lt;/em>的图形表示。点是所有魔法发生的地方：你在点上插入文本，大多数编辑命令都是与点有关的。即使你的光标看起来是在一个字符的上面，但点实际上是位于该字符和前一个字符之间。&lt;/p>
&lt;p>例如，把你的光标放在&lt;em>If you were a pirate&lt;/em>中的&lt;em>f&lt;/em>上。点就位于&lt;em>I&lt;/em>和&lt;em>f&lt;/em>之间。现在，如果你使用&lt;strong>C-k&lt;/strong>，从字母&lt;em>f&lt;/em>开始的所有文字将消失。 &lt;strong>C-k&lt;/strong>运行命令&lt;code>kill-line&lt;/code>，它*杀了当前行中从点开始的所有文字（我将在后面讲到更多的杀戮）。用**C-/**撤销这一改变。另外，尝试用正常的操作系统的键绑定来撤消；这也应该是有效的。&lt;/p>
&lt;h2 id="移动">移动&lt;/h2>
&lt;p>你可以像其他编辑器一样用方向键来移动点，但许多键的绑定可以让你更有效地进行导航，如表 2-1 所示。&lt;/p>
&lt;ol>
&lt;li>表 2-1: 文本导航的键位绑定&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>关键字&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>C-a&lt;/strong>&lt;/td>
&lt;td>移动到行首。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>M-m&lt;/strong>&lt;/td>
&lt;td>移动到该行的第一个非空格字符。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>C-e&lt;/strong>&lt;/td>
&lt;td>移动到行尾。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>C-f&lt;/strong>&lt;/td>
&lt;td>向前移动一个字符。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>*&lt;em>C-b&lt;/em> *向后移动一个字符。&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>M-f&lt;/strong>&lt;/td>
&lt;td>向前移动一个字（我经常用这个）。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>M-b&lt;/strong>&lt;/td>
&lt;td>向后移动一个字（我也经常用这个）。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>C-s&lt;/strong>&lt;/td>
&lt;td>Regex 搜索当前缓冲区内的文本，并移动到它。再按一次&lt;strong>C-s&lt;/strong>，移到下一个匹配。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>C-r&lt;/strong>&lt;/td>
&lt;td>与&lt;strong>C-s&lt;/strong>相同，但以反向方式搜索。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>M-&amp;lt;&lt;/strong>&lt;/td>
&lt;td>移到缓冲区的开头。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>M-&amp;gt;&lt;/strong>&lt;/td>
&lt;td>移动到缓冲区的末端。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>M-g g&lt;/strong>&lt;/td>
&lt;td>转到该行。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>来吧，在你的***缓冲区里试试这些键的绑定!&lt;/p>
&lt;h3 id="带区域的选择">带区域的选择&lt;/h3>
&lt;p>在 Emacs 中，我们并不&lt;em>选择&lt;/em>文本。我们创建&lt;em>区域&lt;/em>，并通过用&lt;strong>C-spc&lt;/strong>（ctrl-spacebar）设置*标记来实现。然后，当你移动点时，标记和点之间的所有东西都是区域。这与 shift 选择文本的基本目的非常相似。&lt;/p>
&lt;p>例如，在你的****缓冲区里做以下事情。&lt;/p>
&lt;ol>
&lt;li>转到文件的开头。&lt;/li>
&lt;li>使用&lt;strong>C-spc&lt;/strong>。&lt;/li>
&lt;li>使用&lt;strong>M-f&lt;/strong>两次。你应该看到一个高亮的区域，包括&lt;em>If you&lt;/em>。&lt;/li>
&lt;li>
&lt;ol start="4">
&lt;li>按退格键。这将会删除&lt;em>如果你&lt;/em>。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>使用标记而不是 Shift 选择文本的一个很酷的事情是，你可以在设置标记后自由使用 Emacs 的所有移动命令。例如，你可以设置一个标记，然后用&lt;strong>C-s&lt;/strong>来搜索缓冲区内几百行的一些文本。这样做将创建一个非常大的区域，而你就不必紧张地按住 Shift 键了。&lt;/p>
&lt;p>区域还可以让你把一个操作限制在缓冲区的有限区域内。试试这个。&lt;/p>
&lt;ol>
&lt;li>创建一个区域，包括&lt;em>孩子的脸可以说明一切&lt;/em>。&lt;/li>
&lt;li>
&lt;ol start="2">
&lt;li>使用&lt;strong>M-x&lt;/strong>替换字符串，用&lt;em>head&lt;/em>替换&lt;em>face&lt;/em>。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>这将在当前区域内进行替换，而不是在点之后的整个缓冲区内进行替换，这是默认行为。&lt;/p>
&lt;h3 id="杀戮和杀戮环">杀戮和杀戮环&lt;/h3>
&lt;p>在大多数应用程序中，我们可以&lt;em>切割&lt;/em>文本，这只是轻微的暴力。我们还可以&lt;em>复制&lt;/em>和&lt;em>粘贴&lt;/em>。剪切和复制将选择的内容添加到剪贴板上，而粘贴则将剪贴板上的内容复制到当前的应用程序中。在 Emacs 中，我们采取杀人的方法，&lt;em>杀&lt;/em>区域，把它们加入到&lt;em>杀圈&lt;/em>。当你知道你正在浪费数千字节的文本时，你不觉得&lt;em>勇敢&lt;/em>和&lt;em>坚强&lt;/em>吗？然后我们可以&lt;em>yank&lt;/em>，在点上插入最近杀死的文本。我们还可以&lt;em>复制&lt;/em>文本到杀戮环，而不需要真正杀死它。&lt;/p>
&lt;p>为什么要用这些病态的术语呢？嗯，首先，当你听到有人在 Emacs 中谈论杀死东西时，你不会感到害怕。但更重要的是，Emacs 允许你做一些典型的剪切/复制/粘贴剪贴板功能集所不能做的工作。&lt;/p>
&lt;p>Emacs 在杀戮环上存储了多个文本块，你可以循环使用它们。这很酷，因为你可以通过循环来找回你很久之前杀死的文本。让我们来看看这个功能的实际应用。&lt;/p>
&lt;ol>
&lt;li>在第一行的&lt;em>Treasure&lt;/em>这个词上创建一个区域。&lt;/li>
&lt;li>2.使用&lt;strong>M-w&lt;/strong>，它与 &amp;ldquo;杀死-循环-保存 &amp;ldquo;命令绑定。一般来说，&lt;strong>M-w&lt;/strong>就像复制一样。它将该区域添加到杀戮环中，而不从你的缓冲区中删除它。&lt;/li>
&lt;li>将指针移到最后一行的&lt;em>choreography&lt;/em>字样上。&lt;/li>
&lt;li>使用&lt;strong>M-d&lt;/strong>，它与&lt;code>kill-word&lt;/code>命令绑定。这将把&lt;em>choreogra**phy&lt;/em>添加到杀戮环中，并将其从你的缓冲区中删除。&lt;/li>
&lt;li>使用&lt;strong>C-y&lt;/strong>。这将把你刚刚杀死的文字&lt;em>choreogra&lt;/em>phy*，插入到点的位置。&lt;/li>
&lt;li>使用&lt;strong>M-y&lt;/strong>。这将删除&lt;em>choreography&lt;/em>，并拉出杀戮环上的下一个项目，&lt;em>Treasure&lt;/em>。&lt;/li>
&lt;/ol>
&lt;p>你可以在表 2-2 中看到一些有用的杀戮/拉扯键的绑定。&lt;/p>
&lt;ol>
&lt;li>表 2-2：杀戮和拉扯的键位绑定 文本&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>关键字&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>C-w&lt;/strong>&lt;/td>
&lt;td>杀戮区域。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>M-w&lt;/strong>&lt;/td>
&lt;td>复制区域到杀戮环。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>C-y&lt;/strong>&lt;/td>
&lt;td>绞刑。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>M-y&lt;/strong>&lt;/td>
&lt;td>在拉动后循环使用杀伤环。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>M-d&lt;/strong>&lt;/td>
&lt;td>杀字。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>C-k&lt;/strong>&lt;/td>
&lt;td>杀行。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="编辑和帮助">编辑和帮助&lt;/h3>
&lt;p>表 2-3 显示了一些额外的、有用的编辑键绑定，你应该知道如何处理间距和扩展文本。&lt;/p>
&lt;ol>
&lt;li>表 2-3：其他有用的编辑键绑定方式&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>关键字&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>*&lt;em>Tab&lt;/em>&lt;/td>
&lt;td>缩进行。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>C-j&lt;/strong>&lt;/td>
&lt;td>新行和缩进，相当于回车后的 tab。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>M-/&lt;/strong>&lt;/td>
&lt;td>嬉皮士扩展；循环浏览点之前的文本可能的扩展方式。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>*&lt;em>M-*&lt;/em>&lt;/td>
&lt;td>删除点周围的所有空格和制表符。(我经常使用这个。)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Emacs 也有很好的内置帮助。表 2-4 中显示的两个键绑定将为你提供良好的服务。&lt;/p>
&lt;ol>
&lt;li>表 2-4：内置帮助的键位绑定&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>关键字&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>C-h k&lt;/strong> &lt;strong>键绑定&lt;/strong> 说明与该键绑定的功能。为了使其发挥作用，你在输入&lt;strong>C-h k&lt;/strong>后实际执行按键序列。&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>C-h f&lt;/strong> *描述功能。&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>帮助文本出现在一个新的*窗口中，这个概念我将在本章后面介绍。现在，你可以通过按&lt;strong>C-x o q&lt;/strong>关闭帮助窗口。&lt;/p>
&lt;h2 id="使用-emacs-与-clojure">使用 Emacs 与 Clojure&lt;/h2>
&lt;p>接下来，我将解释如何使用 Emacs 来有效地开发一个 Clojure 应用程序。你将学习如何启动一个与 Emacs 相连的 REPL 进程，以及如何与 Emacs 窗口一起工作。然后，我将介绍大量有用的键绑定，用于求值表达式、编译文件和执行其他方便的任务。最后，我将向你展示如何处理 Clojure 的错误，并介绍 Paredit 的一些功能，这是一种可选的次要模式，对编写和编辑 Lisp 风格语言的代码很有用。&lt;/p>
&lt;p>如果你想开始钻研 Clojure 代码，请务必跳过前面的内容！你可以在以后再回来。你可以稍后再回来。&lt;/p>
&lt;h3 id="开启你的-repl">开启你的 REPL&lt;/h3>
&lt;p>正如你在第 1 章中所学到的，REPL 允许你交互地编写和运行 Clojure 代码。REPL 是一个正在运行的 Clojure 程序，它给你一个提示，然后读取你的输入，求值它，打印结果，并循环返回到提示。在第 1 章中，你在终端窗口用&lt;code>lein repl&lt;/code>启动了 REPL。在本节中，你将直接在 Clojure 中启动一个 REPL。&lt;/p>
&lt;p>为了将 Emacs 连接到 REPL，你将使用 Emacs 软件包 CIDER，可在*[GitHub - clojure-emacs/cider: The Clojure Interactive Development Environment that Rocks for Emacs]（&lt;a class="link" href="https://github.com/clojure-emacs/cider/" target="_blank" rel="noopener"
>https://github.com/clojure-emacs/cider/&lt;/a>）*。如果你按照本章前面的配置说明，你应该已经安装了它，但你也可以通过运行&lt;strong>M-x&lt;/strong>包-安装，输入 cider，然后按回车键来安装它。&lt;/p>
&lt;p>CIDER 允许你在 Emacs 中启动一个 REPL，并为你提供键绑定，使你能更有效地与 REPL 进行交互。现在就去启动一个 REPL 会话吧。使用 Emacs，打开&lt;em>clojure-noob/**src/clojure_noob/core.clj&lt;/em>文件，该文件是你在第一章中创建的。接下来，使用&lt;strong>M-x&lt;/strong> cider-jack-in。这将启动 REPL 并创建一个新的缓冲区，在那里你可以与它进行交互。经过短暂的等待（应该不到一分钟），你应该看到类似图 2-8 的东西。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/basic-emacs/cider-jack-in.png"
loading="lazy"
>&lt;/p>
&lt;p>图 2-8：运行 M-x cider-jack-in 后你的 Emacs 应该是这样的&lt;/p>
&lt;p>现在我们有两个窗口：我们的&lt;em>core.clj&lt;/em>文件在左边打开，REPL 在右边运行。如果你从来没有见过 Emacs 像这样分成两半，不要担心！我将讲述 Emacs 是如何做到的。我一会儿会讲到 Emacs 是如何分割窗口的。同时，在 REPL 中尝试求值一些代码。键入以下加粗的行。当你按下回车键时，你应该看到打印在 REPL 中的结果，显示在每一行代码的后面。这时不要担心代码，我将在下一章中介绍所有这些功能。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; 10&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">map inc &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; (2 3 4 5)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">reduce + &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">5&lt;/span> &lt;span class="mi">6&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; 111&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>相当漂亮! 你可以像在第一章中使用&lt;code>lein repl&lt;/code>那样使用这个 REPL。你还可以做更多的事情，但在这之前，我将解释如何在分屏 Emacs 中工作。&lt;/p>
&lt;p>###插曲。Emacs 的窗口和框架&lt;/p>
&lt;p>让我们绕道来谈谈 Emacs 是如何处理框架和窗口的，并讨论一些与窗口有关的有用的键绑定方法。如果你已经熟悉了 Emacs 的窗口，请随意跳过这一部分。&lt;/p>
&lt;p>Emacs 是在 1802 年左右发明的，所以它使用的术语与你习惯的略有不同。你通常所说的&lt;em>窗口&lt;/em>，Emacs 称之为&lt;em>框架&lt;/em>，而框架可以分割成多个&lt;em>窗口&lt;/em>。分割成多个窗口允许你一次查看多个缓冲区。你在运行&lt;code>cider-jack-in&lt;/code>时已经看到了这种情况（见图 2-9）。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/basic-emacs/emacs-windows.png"
loading="lazy"
>&lt;/p>
&lt;p>图 2-9：在 Emacs 中，一个框架包含有窗口。&lt;/p>
&lt;p>表 2-5 显示了用于处理框架和窗口的几个键的绑定情况。&lt;/p>
&lt;ol>
&lt;li>表 2-5: Emacs 窗口的键位绑定&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>关键字&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>C-x o&lt;/strong>&lt;/td>
&lt;td>将光标切换到另一个窗口。现在试试这个，在你的 Clojure 文件和 REPL 之间切换。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>C-x 1&lt;/strong>&lt;/td>
&lt;td>删除所有其他窗口，框架中只留下当前窗口。这不会关闭你的缓冲区，也不会导致你失去任何工作。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>C-x 2&lt;/strong>&lt;/td>
&lt;td>分割框架的上方和下方。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>C-x 3&lt;/strong>&lt;/td>
&lt;td>并排分割框架。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>C-x 0&lt;/strong>&lt;/td>
&lt;td>删除当前窗口。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>我鼓励你试试 Emacs 的窗口键绑定。例如，把你的光标放在左边的窗口，也就是有 Clojure 文件的那个，然后使用&lt;strong>C-x 1&lt;/strong>。另一个窗口应该消失，而你应该只看到 Clojure 代码。然后做以下工作。&lt;/p>
&lt;ul>
&lt;li>使用&lt;strong>C-x 3&lt;/strong>将窗口再次并排分开。&lt;/li>
&lt;li>使用&lt;strong>C-x o&lt;/strong>来切换到右边的窗口。&lt;/li>
&lt;li>使用&lt;strong>C-x b&lt;/strong> &lt;em>cider-repl&lt;/em>来切换到右边窗口的 CIDER 缓冲区。&lt;/li>
&lt;/ul>
&lt;p>一旦你做了一些实验，设置 Emacs，使它包含两个并排的窗口，左边是 Clojure 代码，右边是 CIDER 缓冲区，就像前面的图片一样。如果你有兴趣了解更多关于窗口和框架的知识，Emacs 手册中有大量的信息：见*&lt;a class="link" href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Windows.html#Windows" target="_blank" rel="noopener"
>http://www.gnu.org/software/emacs/manual/html_node/elisp/Windows.html#Windows&lt;/a>*。&lt;/p>
&lt;p>现在你可以浏览 Emacs 窗口了，是时候学习一些 Clojure 开发的键绑定了&lt;/p>
&lt;p>###有用的键绑定的丰富内容&lt;/p>
&lt;p>现在你已经准备好学习一些按键绑定，它们将揭示在 Clojure 项目中使用 Emacs 的真正力量。这些命令将使你只需按下几个简单的键就能求值、调整、编译和运行代码。让我们先来看看如何快速求值一个表达式。&lt;/p>
&lt;p>在&lt;em>core.clj&lt;/em>的底部，添加以下内容。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">println &lt;/span>&lt;span class="s">&amp;#34;Cleanliness is next to godliness&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在使用&lt;strong>C-e&lt;/strong>导航到行尾，然后使用&lt;strong>C-x C-e&lt;/strong>.文本&lt;code>Cleanliness is next to godliness&lt;/code>应该出现在 CIDER 缓冲区，如图 2-10 所示。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/basic-emacs/cider-eval-last-expression.png"
loading="lazy"
>&lt;/p>
&lt;p>图 2-10：在 REPL 中从另一个缓冲区即时求值代码&lt;/p>
&lt;p>绑定键&lt;strong>C-x C-e&lt;/strong>运行&lt;code>cider-eval-last-expression&lt;/code>命令。顾名思义，该命令将紧接在点之前的表达式发送到 REPL，然后由 REPL 求值该表达式。你也可以试试&lt;strong>C-u C-x C-e&lt;/strong>，它打印出点之后的求值结果。&lt;/p>
&lt;p>现在让我们试着运行我们在第一章中写的&lt;code>-main&lt;/code>函数，这样我们就可以让全世界都知道我们是小茶壶。&lt;/p>
&lt;p>在&lt;em>core.clj&lt;/em>的缓冲区中，使用&lt;strong>C-c M-n M-n&lt;/strong>。这个键绑定将命名空间设置为你当前文件顶部列出的命名空间，所以右边窗口的提示现在应该是&lt;code>clojure-noob.core&amp;gt;&lt;/code>。我还没有详细介绍命名空间，但现在只要知道命名空间是一种组织机制，使我们能够避免命名冲突就足够了。接下来，在提示符下输入（-main）。REPL 应该打印出 &amp;ldquo;I&amp;rsquo;m a little teapot!&amp;ldquo;多么令人激动啊&lt;/p>
&lt;p>现在让我们创建一个新函数并运行它。在&lt;em>core.clj&lt;/em>的底部，添加以下内容。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">train&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">println &lt;/span>&lt;span class="s">&amp;#34;Choo choo!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>完成后，保存你的文件并使用&lt;strong>C-c C-k&lt;/strong>在 REPL 会话中编译你的当前文件。(现在，如果你在 REPL 中运行 &lt;code>(train)&lt;/code>，它将回显 &lt;code>Choo choo!&lt;/code>。&lt;/p>
&lt;p>当你还在 REPL 中时，试试&lt;strong>C-↑&lt;/strong>（ctrl 加向上箭头键）。 &lt;strong>C-↑&lt;/strong>和&lt;strong>C-↓&lt;/strong>循环浏览你的 REPL 历史，其中包括你要求 REPL 求值的所有 Clojure 表达式。&lt;/p>
&lt;p>Mac 用户注意：默认情况下，OS X 将&lt;strong>C-↑&lt;/strong>、&lt;strong>C-↓&lt;/strong>、&lt;strong>C-←&lt;/strong>和&lt;strong>C-→&lt;/strong>Map 为任务控制命令。你可以通过打开系统偏好设置，然后进入 Keyboard4Shortcuts4Mission Control 来改变你的 Mac 键绑定。&lt;/p>
&lt;p>最后，试试这个。&lt;/p>
&lt;ol>
&lt;li>在 REPL 提示符下输入（-main）。注意没有结尾的括号。&lt;/li>
&lt;li>按&lt;strong>C-enter&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>CIDER 应该关闭小括号并求值表达式。这只是 CIDER 为处理这么多小括号而提供的一个很好的小便利。&lt;/p>
&lt;p>CIDER 还有一些键的绑定，在你学习 Clojure 的时候非常好。按&lt;strong>C-c C-d C-d&lt;/strong>将显示该符号下的文档，这可以大大节省时间。当你看完文档后，按&lt;strong>q&lt;/strong>来关闭文档缓冲区。绑定的键**M-.&lt;strong>将导航到点下符号的源代码，而&lt;/strong>M-,**将使你回到原来的缓冲区和位置。最后，&lt;strong>C-c C-d C-a&lt;/strong>可以让你在函数名和文档中搜索任意的文本。当你不能完全记住一个函数的名字时，这是一个很好的方法来寻找它。&lt;/p>
&lt;p>CIDER README（&lt;em>&lt;a class="link" href="https://github.com/clojure-emacs/cider/" target="_blank" rel="noopener"
>GitHub - clojure-emacs/cider: The Clojure Interactive Development Environment that Rocks for Emacs&lt;/a>&lt;/em>)有一个全面的键绑定列表，你可以慢慢学习，但现在，表 2-6 和 2-7 包含了我们刚刚经历的键绑定的总结。&lt;/p>
&lt;ol>
&lt;li>表 2-6：Clojure 缓冲区的键绑定情况&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>C-c M-n M-n&lt;/strong>&lt;/td>
&lt;td>切换到当前缓冲区的命名空间。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>C-x C-e&lt;/strong>&lt;/td>
&lt;td>求值紧邻点的表达式。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>C-c C-k&lt;/strong>&lt;/td>
&lt;td>编译当前缓冲区。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>C-c C-d C-d&lt;/strong>&lt;/td>
&lt;td>显示点下符号的文档。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>M-. 和 M-,&lt;/strong>&lt;/td>
&lt;td>浏览到该点下的符号的源代码，并返回到原来的缓冲区。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>C-c C-d C-a&lt;/strong>&lt;/td>
&lt;td>Apropros 搜索；在函数名和文档中查找任意文本。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ol>
&lt;li>表 2-7: CIDER 缓冲区的键绑定方式&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>关键字&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>**C-&lt;strong>&lt;strong>↑&lt;/strong>&lt;/strong>, C-**&lt;strong>↓&lt;/strong>&lt;/td>
&lt;td>循环浏览 REPL 历史。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>C-enter&lt;/strong>&lt;/td>
&lt;td>关闭圆括号并求值。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="如何处理错误">如何处理错误&lt;/h3>
&lt;p>在这一节中，你将写一些有错误的代码，这样你就可以看到 Emacs 是如何反应的，以及你如何从错误中恢复并继续你的快乐之路。你将在 REPL 缓冲区和 &lt;em>core.clj&lt;/em> 缓冲区中进行这项工作。让我们从 REPL 开始。在提示符下，输入(map)并按回车。你应该看到类似图 2-11 的东西。&lt;/p>
&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/basic-emacs/cider-error.png"
loading="lazy"
>&lt;/p>
&lt;p>图 2-11：这就是在 REPL 中运行坏代码时发生的情况。&lt;/p>
&lt;p>正如你所看到的，在没有参数的情况下调用&lt;code>map&lt;/code>会使 Clojure 失去理智&amp;ndash;它在你的 REPL 缓冲区中显示一个`ArityException&amp;rsquo;错误信息，并在你的左边窗口中填满文本，看起来像一个疯子的呓语。这些呓语就是&lt;em>堆栈跟踪&lt;/em>，它显示了实际抛出异常的函数，以及哪个函数调用了&lt;em>那个&lt;/em>函数，沿着函数调用的堆栈。&lt;/p>
&lt;p>Clojure 的堆栈跟踪在你刚开始的时候可能很难解读，但经过一段时间后，你会学会从其中获得有用的信息。CIDER 通过允许你过滤堆栈痕迹来帮你一把，这可以减少噪音，这样你就可以将异常的原因锁定。&lt;code>*cider-error*&lt;/code>缓冲区的第 2 行有 Clojure、Java、REPL、Tooling、Duplicates 和 All 等过滤器。你可以点击每个选项来激活该过滤器。你也可以点击每个堆栈跟踪行来跳到相应的源代码。&lt;/p>
&lt;p>下面是如何关闭左边窗口中的堆栈跟踪。&lt;/p>
&lt;ol>
&lt;li>使用&lt;strong>C-x o&lt;/strong>来切换到窗口。&lt;/li>
&lt;li>按&lt;strong>q&lt;/strong>关闭堆栈跟踪，回到 CIDER。&lt;/li>
&lt;/ol>
&lt;p>如果你想再次查看错误，你可以切换到&lt;code>*cider-error*&lt;/code>缓冲区。你也可以在尝试编译文件时得到错误信息。要看这个，请到&lt;em>core.clj&lt;/em>缓冲区，写一些有错误的代码，然后进行编译。&lt;/p>
&lt;ol>
&lt;li>在结尾处添加&lt;code>(map)&lt;/code>。&lt;/li>
&lt;li>使用&lt;strong>C-c C-k&lt;/strong>进行编译。&lt;/li>
&lt;/ol>
&lt;p>你应该看到一个&lt;code>*cider-error*&lt;/code>缓冲区，类似于你之前看到的那个。同样，按&lt;strong>q&lt;/strong>关闭堆栈跟踪。&lt;/p>
&lt;h3 id="paredit">Paredit&lt;/h3>
&lt;p>在 Clojure 缓冲区中写代码时，你可能已经注意到了一些意外的事情发生。例如，每当你输入一个左括号，一个右括号就会立即被插入。&lt;/p>
&lt;p>这要归功于&lt;em>paredit-mode&lt;/em>，这是一种次要的模式，它将 Lisp 的大量小括号从一种责任变成了一种资产。Paredit 确保所有的小括号、双引号和大括号都是封闭的，从而减轻了你那可恶的负担。&lt;/p>
&lt;p>Paredit 还提供了键绑定功能，以轻松浏览和改变所有这些括号所创建的结构。在下一节中，我将介绍最有用的键绑定，但你也可以在*&lt;a class="link" href="https://github.com/georgek/paredit-cheatsheet/blob/master/paredit-cheatsheet.pdf" target="_blank" rel="noopener"
>https://github.com/georgek/paredit-cheatsheet/blob/master/paredit-cheatsheet.pdf&lt;/a>*（在骗局中，红色管子代表点）查看全面的骗局表。&lt;/p>
&lt;p>然而，如果你不习惯，paredit 有时会很烦人。我认为花点时间来学习它是非常值得的，但你可以随时用&lt;strong>M-x&lt;/strong> paredit-mode 来禁用它，它可以切换该模式的开启和关闭。&lt;/p>
&lt;p>下面的部分向你展示了最有用的键绑定。&lt;/p>
&lt;h4 id="wrapping-和-slurping">Wrapping 和 Slurping&lt;/h4>
&lt;p>&lt;em>Wrapping&lt;/em>用小括号包围点之后的表达式。 &lt;em>Slurping&lt;/em>将结束的小括号移到右边包括下一个表达式。例如，假设我们用这个开始。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而我们想得到这个结果。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">* &lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们可以把&lt;code>2&lt;/code>包起来，加一个星号，然后再把&lt;code>3&lt;/code>溜走。首先，放置点，这里表示为一个垂直的管道，&lt;code>|&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="err">|&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后输入&lt;strong>M-(&lt;/strong>，与&lt;em>paredit-wrap-round&lt;/em>绑定，得到这个结果。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="err">|&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>加上星号和空格。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">* &lt;/span>&lt;span class="err">|&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>要在 &amp;ldquo;3 &amp;ldquo;上啧啧称奇，请按&lt;strong>C-→&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">* &lt;/span>&lt;span class="err">|&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这样就可以很容易地增加和扩展括号，而不必浪费宝贵的时间按住方向键来移动点。&lt;/p>
&lt;h4 id="barfing">Barfing&lt;/h4>
&lt;p>假设在前面的例子中，你不小心吐了四条。要解开它（也被称为&lt;em>barfing&lt;/em>），将你的光标（&lt;code>|&lt;/code>）放在括号内的任何地方。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="err">|&lt;/span>&lt;span class="nb">* &lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后使用&lt;strong>C-←&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="err">|&lt;/span>&lt;span class="nb">* &lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Ta-da! 现在你知道如何随意扩展和收缩括号了。&lt;/p>
&lt;h4 id="导航">导航&lt;/h4>
&lt;p>在用 Lisp 方言写作时，你经常会遇到这样的表达式。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="nb">map &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">comp &lt;/span>&lt;span class="nv">record&lt;/span> &lt;span class="nv">first&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">d/q&lt;/span> &lt;span class="o">&amp;#39;&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="ss">:find&lt;/span> &lt;span class="nv">?post&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="ss">:in&lt;/span> &lt;span class="nv">$&lt;/span> &lt;span class="nv">?search&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="ss">:where&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[(&lt;/span>&lt;span class="nf">fulltext&lt;/span> &lt;span class="nv">$&lt;/span> &lt;span class="ss">:post/content&lt;/span> &lt;span class="nv">?search&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[[&lt;/span>&lt;span class="nv">?post&lt;/span> &lt;span class="nv">?content&lt;/span>&lt;span class="p">]]]]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">db/db&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="ss">:q&lt;/span> &lt;span class="nv">params&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>对于这种表达式，快速从一个子表达式跳到下一个子表达式是很有用的。如果你把 point 放在开头的小括号之前，&lt;strong>C-M-f&lt;/strong>会把你带到结束的小括号。同样，如果 point 紧跟在闭合小括号之后，&lt;strong>C-M-b&lt;/strong>将带你到开头小括号。&lt;/p>
&lt;p>表 2-8 总结了你刚刚学到的 Paredit 键的绑定。&lt;/p>
&lt;ol>
&lt;li>表 2-8：Paredit 键的绑定方式&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>关键字&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>M-x&lt;/strong> paredit-mode&lt;/td>
&lt;td>切换 paredit 模式。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>M-(&lt;/strong>&lt;/td>
&lt;td>括号内点后的表达式(paredit-wrap-round)。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>**C-**→&lt;/td>
&lt;td>Slurp;将结束的小括号向右移动，以包括下一个表达式。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>**C-**←&lt;/td>
&lt;td>Barf；将括号向左移动，排除最后一个表达式。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>*&lt;em>C-M-f&lt;/em>,*&lt;em>C-M-b&lt;/em>&lt;/td>
&lt;td>移动到开头/结尾小括号。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="继续学习">继续学习&lt;/h2>
&lt;p>Emacs 是历史最悠久的编辑器之一，它的追随者对它的热情往往接近狂热。一开始使用它可能会很别扭，但坚持下去，你会在一生中得到充分的回报。&lt;/p>
&lt;p>每当我打开 Emacs 时，我都会感到受到鼓舞。就像一个工匠进入他的工作室一样，我感到一个可能性的领域在我面前打开。我感到这个环境的舒适，它随着时间的推移已经发展到完全适合我&amp;ndash;各种各样的包和键绑定，帮助我日复一日地把想法变成现实。&lt;/p>
&lt;p>在你继续你的 Emacs 之旅时，这些资源将帮助你。&lt;/p>
&lt;ul>
&lt;li>Emacs 手册&lt;em>提供了优秀、全面的指导。每天早上花点时间看看它吧! 下载 PDF，在旅途中阅读。&lt;/em>&lt;a class="link" href="http://www.gnu.org/software/emacs/manual/html_node/emacs/index.html#Top" target="_blank" rel="noopener"
>http://www.gnu.org/software/emacs/manual/html_node/emacs/index.html#Top&lt;/a>*。&lt;/li>
&lt;li>*《Emacs 参考卡》*是一个方便的小抄。 &lt;em>&lt;a class="link" href="http://www.ic.unicamp.br/~helio/disciplinas/MC102/Emacs_Reference_Card.pdf" target="_blank" rel="noopener"
>http://www.ic.unicamp.br/~helio/disciplinas/MC102/Emacs_Reference_Card.pdf&lt;/a>&lt;/em>。&lt;/li>
&lt;li>Mickey Petersen 的&lt;em>Mastering Emacs&lt;/em>是最好的 Emacs 资源之一。从阅读指南开始。 &lt;em>&lt;a class="link" href="http://www.masteringemacs.org/reading-guide/" target="_blank" rel="noopener"
>阅读指南-掌握 Emacs&lt;/a>&lt;/em> 。&lt;/li>
&lt;li>对于更注重视觉效果的人，我推荐手绘的《如何学习 Emacs》。Emacs 24 或更高版本的初学者指南&amp;rdquo;，作者 Sacha Chua。 &lt;em>&lt;a class="link" href="http://sachachua.com/blog/wp-content/uploads/2013/05/How-to-Learn-Emacs8.png" target="_blank" rel="noopener"
>http://sachachua.com/blog/wp-content/uploads/2013/05/How-to-Learn-Emacs8.png&lt;/a>&lt;/em>。&lt;/li>
&lt;li>只要按&lt;strong>C-h t&lt;/strong>就可以看到内置的教程。&lt;/li>
&lt;/ul>
&lt;h2 id="摘要">摘要&lt;/h2>
&lt;p>呜呼! 你已经覆盖了很多地方。你现在知道了 Emacs 作为一个 Lisp 解释器的真正性质。绑定键是执行 elisp 函数的快捷方式，而模式是绑定键和函数的集合。你学会了如何以自己的方式与 Emacs 互动，并掌握了缓冲区、窗口、区域、杀戮和拉动。最后，你学会了如何使用 CIDER 和 paredit 轻松地与 Clojure 工作。&lt;/p>
&lt;p>有了这些来之不易的 Emacs 知识，现在是时候开始认真学习 Clojure 了&lt;/p>
&lt;p>&lt;a class="link" href="https://www.braveclojure.com/basic-emacs/#footnote-5680-1-backlink" target="_blank" rel="noopener"
>1&lt;/a> &lt;em>&lt;a class="link" href="http://www.gnu.org/software/emacs/manual/html_node/emacs/Minor-Modes.html" target="_blank" rel="noopener"
>http://www.gnu.org/software/emacs/manual/html_node/emacs/Minor-Modes.html&lt;/a>&lt;/em>。&lt;/p></description></item><item><title>Chapter1 构建、运行和 REPL</title><link>https://example.com/p/chapter1-%E6%9E%84%E5%BB%BA%E8%BF%90%E8%A1%8C%E5%92%8C-repl/</link><pubDate>Thu, 13 Jan 2022 10:26:48 +0800</pubDate><guid>https://example.com/p/chapter1-%E6%9E%84%E5%BB%BA%E8%BF%90%E8%A1%8C%E5%92%8C-repl/</guid><description>&lt;h1 id="构建运行和-repl">构建、运行和 REPL&lt;/h1>
&lt;p>在本章中，你将预先投入少量时间来熟悉建立和运行 Clojure 程序的快速、傻瓜式方法。让一个真正的程序运行起来感觉很好。达到了这个里程碑，你就可以自由地进行实验，分享你的工作，并向那些仍在使用上个世纪的语言的同事幸灾乐祸。这将有助于保持你的积极性!&lt;/p>
&lt;p>你还将学习如何使用*Read-Eval-Print Loop（REPL）*在一个正在运行的 Clojure 进程中即时运行代码，这使你能够快速测试你对语言的理解并更有效地学习。&lt;/p>
&lt;p>但首先，我将简要地介绍 Clojure。接下来，我将介绍 Leiningen，这是 Clojure 事实上的标准构建工具。在本章结束时，你将知道如何做以下事情。&lt;/p>
&lt;ul>
&lt;li>用 Leiningen 创建一个新的 Clojure 项目&lt;/li>
&lt;li>构建该项目以创建一个可执行的 JAR 文件&lt;/li>
&lt;li>执行 JAR 文件&lt;/li>
&lt;li>在 Clojure REPL 中执行代码&lt;/li>
&lt;/ul>
&lt;h2 id="第一重要的事-什么是-clojure">第一重要的事: 什么是 Clojure&lt;/h2>
&lt;p>Clojure 是由 Rich Hickey 在一座神话般的火山中铸造的。他使用 Lisp、函数式编程和他自己的一绺史诗般的头发的合金，创造了一种令人愉快而强大的语言。它的 Lisp 遗产使你有能力写出比大多数非 Lisp 语言更有表现力的代码，而它对函数式编程的独特理解将使你作为一个程序员的思维更敏锐。此外，Clojure 为你提供了更好的工具来处理复杂的领域（如并发编程），这些领域在传统上被认为会使开发人员陷入多年的治疗中。&lt;/p>
&lt;p>不过，在谈论 Clojure 时，重要的是要牢记 Clojure 语言和 Clojure 编译器之间的区别。Clojure 语言是一种强调函数的 Lisp 方言，其语法和语义与任何实现都无关。编译器是一个可执行的 JAR 文件，&lt;em>clojure.jar&lt;/em>，它接收用 Clojure 语言编写的代码并将其编译为 Java 虚拟机（JVM）字节码。你会看到&lt;em>Clojure&lt;/em>被用来指代语言和编译器，如果你不知道它们是独立的东西，就会感到困惑。但现在你意识到了，你就会好起来。&lt;/p>
&lt;p>这种区分是必要的，因为与大多数编程语言如 Ruby、Python、C 和其他许多语言不同，Clojure 是一种&lt;em>托管语言&lt;/em>。Clojure 程序在 JVM 中执行，并依赖 JVM 的核心功能，如线程和垃圾收集。Clojure 还针对 JavaScript 和微软的通用语言运行时（CLR），但本书只关注 JVM 的实现。&lt;/p>
&lt;p>稍后我们将更多地探讨 Clojure 和 JVM 之间的关系，但现在你需要了解的主要概念是这些。&lt;/p>
&lt;ul>
&lt;li>JVM 进程执行 Java 字节码。&lt;/li>
&lt;li>通常情况下，Java 编译器从 Java 源代码中产生 Java 字节码。&lt;/li>
&lt;li>JAR 文件是 Java 字节码的集合。&lt;/li>
&lt;li>Java 程序通常以 JAR 文件分发。&lt;/li>
&lt;li>Java 程序&lt;em>clojure.jar&lt;/em> 读取 Clojure 源代码并产生 Java 字节码。&lt;/li>
&lt;li>然后，该 Java 字节码由已经运行&lt;em>clojure.jar&lt;/em>的 JVM 进程执行。&lt;/li>
&lt;/ul>
&lt;p>Clojure 持续在发展。截至目前，Clojure 的版本为 1.9.0，开发工作仍在进行中。如果你在遥远的未来读到这本书，并且 Clojure 有更高的版本号，不要担心！这本书涵盖了 Clojure 的所有内容。本书涵盖了 Clojure 的基础知识，这些知识在不同的版本中应该不会改变。没有必要让你的机器人管家把这本书退回给书店。&lt;/p>
&lt;p>现在你知道什么是 Clojure 了，让我们来实际构建一个该死的 Clojure 程序吧!&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">lein&lt;/span> &lt;span class="k">new &lt;/span>&lt;span class="nv">app&lt;/span> &lt;span class="nv">clojure-noob&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个命令应该创建一个与此相似的目录结构（如果有一些差异也没关系）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="err">|&lt;/span> &lt;span class="nv">.gitignore&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">|&lt;/span> &lt;span class="nv">doc&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">|&lt;/span> &lt;span class="err">|&lt;/span> &lt;span class="nv">intro.md&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">➊&lt;/span> &lt;span class="err">|&lt;/span> &lt;span class="nv">project.clj&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">|&lt;/span> &lt;span class="nv">README.md&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">➋&lt;/span> &lt;span class="err">|&lt;/span> &lt;span class="nv">resources&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">|&lt;/span> &lt;span class="nv">src&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">|&lt;/span> &lt;span class="err">|&lt;/span> &lt;span class="nv">clojure_noob&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">➌&lt;/span> &lt;span class="err">|&lt;/span> &lt;span class="err">|&lt;/span> &lt;span class="err">|&lt;/span> &lt;span class="nv">core.clj&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">➍&lt;/span> &lt;span class="err">|&lt;/span> &lt;span class="nv">test&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">|&lt;/span> &lt;span class="err">|&lt;/span> &lt;span class="nv">clojure_noob&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">|&lt;/span> &lt;span class="err">|&lt;/span> &lt;span class="err">|&lt;/span> &lt;span class="nv">core_test.clj&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个项目骨架本身并不特别，也不像 Clojure 那样。它只是 Leiningen 使用的一种惯例。你将使用 Leiningen 来构建和运行 Clojure 应用程序，Leiningen 希望你的应用程序有这种结构。第一个需要注意的文件是位于➊的&lt;em>project.clj&lt;/em>，它是 Leiningen 的一个配置文件。它可以帮助 Leiningen 回答这样的问题：&amp;ldquo;这个项目有什么依赖？&amp;ldquo;和 &amp;ldquo;当这个 Clojure 程序运行时，什么函数应该先运行？&amp;rdquo; 一般来说，你会把你的源代码保存在&lt;em>src/&amp;lt;project_name&amp;gt;&lt;/em>。在这种情况下，位于➌的&lt;em>src/clojure_noob/core.clj&lt;/em>文件就是你要写一段时间的 Clojure 代码的地方。位于➍的&lt;em>test&lt;/em>目录显然包含了测试，而位于➋的&lt;em>resources&lt;/em>是你存储图片等资产的地方。&lt;/p>
&lt;h3 id="运行-clojure-项目">运行 Clojure 项目&lt;/h3>
&lt;p>现在让我们来实际运行这个项目。在你喜欢的编辑器中打开&lt;em>src/clojure_noob/core.clj&lt;/em>。你应该看到这个。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="err">➊&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kd">ns &lt;/span>&lt;span class="nv">clojure-noob.core&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="ss">:gen-class&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">➋&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kd">defn &lt;/span>&lt;span class="nv">-main&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;I don&amp;#39;t do a whole lot...yet.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="nv">args&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">➌&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">println &lt;/span>&lt;span class="s">&amp;#34;Hello, World!&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>➊处的行声明了一个命名空间，你现在不需要担心这个问题。➋处的&lt;code>-main'函数是你的程序的*入口，这个话题将在附录A中介绍。现在，将➌处的&lt;/code>&amp;ldquo;Hello, World!&amp;quot;&lt;code>改为&lt;/code>&amp;ldquo;I&amp;rsquo;m a little teapot!&amp;quot;&lt;code>。全行应该是&lt;/code>(println &amp;ldquo;I&amp;rsquo;m a little teapot!&amp;rdquo;))`。&lt;/p>
&lt;p>接下来，在你的终端导航到&lt;em>clojure_noob&lt;/em>目录，然后输入。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">lein&lt;/span> &lt;span class="nv">run&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://www.braveclojure.com/assets/images/cftbat/getting-started/teapot.png"
loading="lazy"
>&lt;/p>
&lt;p>你应该看到输出&lt;code>&amp;quot;I'm a little teapot!&amp;quot;&lt;/code>恭喜你，小茶壶，你编写并执行了一个程序！&amp;quot;。&lt;/p>
&lt;p>当你阅读本书时，你会了解到更多关于程序中实际发生的事情，但现在你需要知道的是，你创建了一个函数，&lt;code>-main&lt;/code>，当你在命令行执行&lt;code>lein run&lt;/code>时，这个函数就会运行。&lt;/p>
&lt;h3 id="构建-clojure-项目">构建 Clojure 项目&lt;/h3>
&lt;p>使用&lt;code>lein run&lt;/code>对于尝试你的代码是很好的，但是如果你想与没有安装 Leiningen 的人分享你的工作，该怎么办？要做到这一点，你可以创建一个独立的文件，任何安装了 Java 的人（基本上就是所有人）都可以执行。要创建这个文件，请运行以下程序。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">lein&lt;/span> &lt;span class="nv">uberjar&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个命令创建了&lt;em>target/uberjar/clojure-noob-0.1.0**-SNAPSHOT-standalone.jar&lt;/em>文件。你可以通过运行这个命令使 Java 执行它。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">java&lt;/span> &lt;span class="nv">-jar&lt;/span> &lt;span class="nv">target/uberjar/clojure-noob-0.1.0-SNAPSHOT-standalone.jar&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>看看这个! 文件&lt;em>target/uberjar/clojure-noob-0.1.0-SNAPSHOT**-standalone.jar&lt;/em>是你的 Clojure 程序，你可以在几乎任何平台上发布和运行。&lt;/p>
&lt;p>现在你已经掌握了构建、运行和分发（非常）基本的 Clojure 程序所需的所有基本细节。在后面的章节中，你会了解到更多的细节，当你运行前面的命令时，Leiningen 在做什么，对 Clojure 与 JVM 的关系以及你如何运行生产代码有了完整的了解。&lt;/p>
&lt;p>在我们进入第二章，讨论 Emacs 的神奇和荣耀之前，让我们来看看另一个重要的工具：REPL。&lt;/p>
&lt;h3 id="使用-repl">使用 REPL&lt;/h3>
&lt;p>REPL 是一个用于试验代码的工具。它允许你与正在运行的程序进行交互，并快速尝试各种想法。它通过向你提供一个提示，让你输入代码来实现这一目的。然后，它&lt;em>读取&lt;/em>你的输入，&lt;em>求值&lt;/em>它，&lt;em>打印&lt;/em>结果，并&lt;em>循环&lt;/em>，再次向你提供提示。&lt;/p>
&lt;p>这个过程实现了一个快速的反馈循环，这在大多数其他语言中是不可能的。我强烈建议你经常使用它，因为你能够在学习过程中快速检查你对 Clojure 的理解。除此之外，REPL 开发是 Lisp 体验的一个重要部分，如果你不使用它，你就真的错过了。&lt;/p>
&lt;p>要启动一个 REPL，请运行以下程序。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">lein&lt;/span> &lt;span class="nv">repl&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>输出应该是这样的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">nREPL&lt;/span> &lt;span class="nv">server&lt;/span> &lt;span class="nv">started&lt;/span> &lt;span class="nv">on&lt;/span> &lt;span class="nv">port&lt;/span> &lt;span class="mi">28925&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">REPL-y&lt;/span> &lt;span class="mf">0.1&lt;/span>&lt;span class="nv">.10&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">Clojure&lt;/span> &lt;span class="mf">1.9&lt;/span>&lt;span class="nv">.0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">Exit&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="nv">Control+D&lt;/span> &lt;span class="nb">or &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">exit&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nb">or &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">quit&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">Commands&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">user/help&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">Docs&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">doc &lt;/span>&lt;span class="nv">function-name-here&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">find-doc &lt;/span>&lt;span class="s">&amp;#34;part-of-name-here&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">Source&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">source&lt;/span> &lt;span class="nv">function-name-here&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">user/sourcery&lt;/span> &lt;span class="nv">function-name-here&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">Javadoc&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">javadoc&lt;/span> &lt;span class="nv">java-object-or-class-here&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">Examples&lt;/span> &lt;span class="nv">from&lt;/span> &lt;span class="nv">clojuredocs.org&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nv">clojuredocs&lt;/span> &lt;span class="nb">or &lt;/span>&lt;span class="nv">cdoc&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">user/clojuredocs&lt;/span> &lt;span class="nv">name-here&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">user/clojuredocs&lt;/span> &lt;span class="s">&amp;#34;ns-here&amp;#34;&lt;/span> &lt;span class="s">&amp;#34;name-here&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">clojure-noob.core=&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后一行，&lt;code>clojure-noob.core=&amp;gt;&lt;/code>，告诉你，你在&lt;code>clojure -noob.core&lt;/code>命名空间中。你将在后面学习命名空间，但现在注意到命名空间基本上与你的&lt;em>src/&lt;strong>clojure_noob&lt;/strong>/core.clj&lt;/em>文件的名称一致。另外，注意到 REPL 显示的版本是&lt;em>Clojure 1.9.0&lt;/em>，但如前所述，无论你使用哪个版本，一切都可以正常工作。&lt;/p>
&lt;p>该提示还表明你的代码在 REPL 中被加载，你可以执行被定义的函数。现在只有一个函数，&lt;code>-main&lt;/code>，被定义了。现在就去执行它吧。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">clojure-noob.core=&amp;gt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">-main&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">I&lt;/span>&lt;span class="ss">&amp;#39;m&lt;/span> &lt;span class="nv">a&lt;/span> &lt;span class="nv">little&lt;/span> &lt;span class="nv">teapot!&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">nil&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>干得好! 你刚刚使用 REPL 求值了一个函数调用。试试几个更基本的 Clojure 函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">clojure-noob.core=&amp;gt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">10&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">clojure-noob.core=&amp;gt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">* &lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">24&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">clojure-noob.core=&amp;gt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">first &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>真棒! 你加了一些数字，乘了一些数字，并从一个 Vector 中取出了第一个元素。你还第一次接触到了奇怪的 Lisp 语法! 所有的 Lisp，包括 Clojure，都采用&lt;em>前缀符号&lt;/em>，这意味着运算符在表达式中总是排在第一位。如果你不确定这意味着什么，不要担心。你很快就会了解到 Clojure 的所有语法。&lt;/p>
&lt;p>从概念上讲，REPL 类似于 SSH。就像你可以使用 SSH 与远程服务器交互一样，Clojure REPL 允许你与正在运行的 Clojure 进程交互。这项功能可以非常强大，因为你甚至可以将 REPL 附加到一个实时生产的应用程序，并在它运行时修改你的程序。不过现在，你将使用 REPL 来建立你对 Clojure 语法和语义的了解。&lt;/p>
&lt;p>还有一点要注意：今后，本书将介绍没有 REPL 提示的代码，但请尝试一下这些代码! 下面是一个例子。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-clojure" data-lang="clojure">&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span>&lt;span class="k">do &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">println &lt;/span>&lt;span class="s">&amp;#34;no prompt here!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nb">+ &lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; no prompt here!&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">; =&amp;gt; 4&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当你看到这样的代码片段时，以&lt;code>；=&amp;gt;&lt;/code>开头的行表示正在运行的代码的输出。在这种情况下，应该打印出&lt;code>这里没有提示'的文字，代码的返回值是&lt;/code>4&amp;rsquo;。&lt;/p>
&lt;h2 id="clojure-编辑器">Clojure 编辑器&lt;/h2>
&lt;p>到此为止，你应该已经具备了开始学习 Clojure 语言所需的基本知识，而不需要对编辑器或集成开发环境（IDE）大费周章。但如果你确实想要一个关于强大编辑器的好教程，第 2 章涉及 Emacs，这是 Clojurists 中最受欢迎的编辑器。你绝对不需要在 Clojure 开发中使用 Emacs，但 Emacs 提供了与 Clojure REPL 的紧密集成，非常适合编写 Lisp 代码。然而，最重要的是，你要使用适合你的东西。&lt;/p>
&lt;p>如果 Emacs 不是你的那杯茶，这里有一些为 Clojure 开发设置其他文本编辑器和 IDE 的资源。&lt;/p>
&lt;ul>
&lt;li>这个 YouTube 视频将告诉你如何为 Clojure 开发设置 Sublime Text 2。  &lt;em>&lt;a class="link" href="http://www.youtube.com/watch?v=wBl0rYXQdGg/" target="_blank" rel="noopener"
>- YouTube&lt;/a>&lt;/em>。&lt;/li>
&lt;li>Vim 有很好的工具用于 Clojure 开发。这篇文章是一个很好的起点。 &lt;em>&lt;a class="link" href="http://mybuddymichael.com/writings/writing-clojure-with-vim-in-2013.html" target="_blank" rel="noopener"
>Writing Clojure With Vim In 2013 - mybuddymichael.com&lt;/a>&lt;/em>。&lt;/li>
&lt;li>Counterclockwise 是一个强烈推荐的 Eclipse 插件。&lt;em>&lt;a class="link" href="https://github.com/laurentpetit/ccw/wiki/GoogleCodeHome" target="_blank" rel="noopener"
>GoogleCodeHome - ccw-ide/ccw Wiki - GitHub&lt;/a>&lt;/em>。&lt;/li>
&lt;li>Cursive Clojure 是推荐给那些使用 IntelliJ 的 IDE： &lt;em>&lt;a class="link" href="https://cursiveclojure.com/" target="_blank" rel="noopener"
>https://cursiveclojure.com/&lt;/a>&lt;/em>。&lt;/li>
&lt;li>Nightcode 是一个用 Clojure 编写的简单、免费的 IDE。 &lt;em>&lt;a class="link" href="https://github.com/oakes/Nightcode/" target="_blank" rel="noopener"
>GitHub - oakes/Nightcode: An IDE for Clojure&lt;/a>&lt;/em>。&lt;/li>
&lt;/ul>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>我真为你感到骄傲，小茶壶。你已经运行了你的第一个 Clojure 程序! 不仅如此，你还熟悉了 REPL，这是开发 Clojure 软件的最重要工具之一。太神奇了! 这让我想起了我个人英雄之一的《Long Live》中的不朽名句。&lt;/p>
&lt;blockquote>
&lt;p>You held your head like a hero&lt;br>
On a history book page&lt;br>
It was the end of a decade&lt;br>
But the start of an age&lt;br>
—Taylor Swift&lt;/p>
&lt;/blockquote>
&lt;p>好样的!&lt;/p></description></item><item><title>Introduction 简介</title><link>https://example.com/p/introduction-%E7%AE%80%E4%BB%8B/</link><pubDate>Thu, 13 Jan 2022 10:11:25 +0800</pubDate><guid>https://example.com/p/introduction-%E7%AE%80%E4%BB%8B/</guid><description>&lt;h1 id="简介">简介&lt;/h1>
&lt;p>在你的内心深处，你一直都知道你注定要学习 Clojure。 每当你高举着键盘，为一个难以理解的类层次结构而痛苦地哭泣时；每当你晚上躺在床上，为一个突变引起的海森堡虫而哭泣扰乱你的亲人时；每当一个竞赛条件使你拔掉更多你不断减少的头发时，你的某个秘密部分已经知道&lt;em>一定有一个更好的办法&lt;/em>。&lt;/p>
&lt;p>现在，终于，你面前的教学材料将使你与你渴望已久的编程语言结合起来。&lt;/p>
&lt;h2 id="学习一种新的编程语言穿越四个迷宫的旅程">学习一种新的编程语言：穿越四个迷宫的旅程&lt;/h2>
&lt;p>为了最大限度地发挥 Clojure 的作用，你需要在每个学习新语言的程序员面临的四个迷宫中找到自己的路。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>工具之林&lt;/strong> 友好而高效的编程环境使你能够轻松地尝试你的想法。你将学习如何设置你的环境。&lt;/li>
&lt;li>&lt;strong>语言之山&lt;/strong> 随着你的攀登，你将获得 Clojure 的语法、语义和数据结构方面的知识。你将学习如何使用最强大的编程工具之一&amp;ndash;宏，并学习如何利用 Clojure 的并发结构来简化你的生活。&lt;/li>
&lt;li>&lt;strong>神器之洞&lt;/strong> 在它的深处，你将学会构建、运行和发布你自己的程序，以及如何使用代码库。你还将学习 Clojure 与 Java 虚拟机（JVM）的关系。&lt;/li>
&lt;li>&lt;strong>心态云堡&lt;/strong> 在其稀薄的空气中，你将了解 Lisp 和函数式编程的原因和方法。你将了解渗透在 Clojure 中的简单哲学，以及如何像 Clojurist 一样解决问题。&lt;/li>
&lt;/ul>
&lt;p>别搞错了，你要工作。但这本书会让你感觉到工作是令人振奋的，而不是疲惫的。这是因为本书遵循三个准则。&lt;/p>
&lt;ul>
&lt;li>它采取了甜点优先的方法，给你提供了你需要的开发工具和语言细节，以便立即开始玩真正的程序。&lt;/li>
&lt;li>它假定你对 JVM、函数式编程或 Lisp 没有经验。它详细地涵盖了这些主题，所以当你构建和运行 Clojure 程序时，你会对你正在做的事情感到自信。&lt;/li>
&lt;li>它避开了 &lt;em>真实世界&lt;/em> 的例子，而选择了更有趣的练习，如 &lt;em>攻击霍比特人&lt;/em> 和 &lt;em>追踪闪亮的吸血鬼&lt;/em> 。&lt;/li>
&lt;/ul>
&lt;p>到最后，你将能够使用 Clojure&amp;ndash;现存的最令人兴奋和最有趣的编程语言之一!&lt;/p>
&lt;h2 id="本书是如何组织的">本书是如何组织的&lt;/h2>
&lt;p>本书分为三个部分，以便更好地指导你完成你的勇敢探索，勇敢的初出茅庐的 Clojurist。&lt;/p>
&lt;h3 id="第一部分环境设置">第一部分：环境设置&lt;/h3>
&lt;p>为了保持动力和高效学习，你需要实际写代码和构建可执行文件。这些章节将带领你快速浏览你所需要的工具，以便轻松地编写程序。这样，你就可以专注于学习 Clojure，而不是摆弄你的环境。&lt;/p>
&lt;p>第 1 章：构建、运行和 REPL&lt;/p>
&lt;p>让一个真正的程序运行起来，有一种强大的激励作用。一旦你能做到这一点，你就可以自由地进行实验，而且你可以真正地分享你的工作&lt;/p>
&lt;p>在这短短的一章中，你将投入少量时间来熟悉建立和运行 Clojure 程序的快速方法。你将学习如何在一个正在运行的 Clojure 进程中使用 read-eval-print 循环（REPL）来实验代码。这将收紧你的反馈回路，帮助你更有效地学习。&lt;/p>
&lt;p>第二章：如何使用 Emacs，一个优秀的 Clojure 编辑器&lt;/p>
&lt;p>快速的反馈回路对学习至关重要。在这一章中，我从头开始介绍 Emacs，以保证你有一个高效的 Emacs/Clojure 工作流程。&lt;/p>
&lt;h3 id="第二部分语言基础">第二部分：语言基础&lt;/h3>
&lt;p>这些章节为你继续学习 Clojure 奠定了坚实的基础。你将从学习 Clojure 的基础知识（语法、语义和数据结构）开始，这样你就可以&lt;em>做事情。然后，你将退一步详细研究 Clojure 最常用的函数，并学习如何使用&lt;/em>函数式编程*的思维方式来解决这些问题。&lt;/p>
&lt;p>第三章：做事情：Clojure 速成班&lt;/p>
&lt;p>在这里，你将开始真正深入了解 Clojure。这也是你需要关闭窗户的地方，因为你会开始大喊：&amp;quot;&lt;em>HOLY MOLEY THAT&amp;rsquo;S SPIFFY!&lt;/em>&amp;quot;，而且直到你读完本书的索引才会停止。&lt;/p>
&lt;p>毫无疑问，你已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp。你将探索这个 Lisp 核心，它由两部分组成：函数和数据。&lt;/p>
&lt;p>第 4 章：深入探讨核心函数&lt;/p>
&lt;p>在这一章中，你将了解 Clojure 的几个基本概念。这将为你提供所需的基础，使你能够阅读你以前没有使用过的函数的文档，并理解当你尝试它们时发生了什么。&lt;/p>
&lt;p>你还会看到你最需要的函数的使用例子。这将为你编写自己的代码以及阅读和学习其他人的项目打下坚实的基础。还记得我是如何提到追踪闪闪发光的吸血鬼的吗？你会在这一章中做到这一点（除非你已经在业余时间做到了）。&lt;/p>
&lt;p>第五章：函数式编程&lt;/p>
&lt;p>在这一章中，你将把你在函数和数据结构方面的具体经验与一种新的思维方式结合起来：函数式编程思维方式。你将通过构建席卷全国的最热门的新游戏来炫耀你的知识。Peg Thing!&lt;/p>
&lt;p>第 6 章：组织你的项目：一个图书管理员的故事&lt;/p>
&lt;p>本章解释了什么是命名空间，以及如何使用它们来组织你的代码。我不想透露太多，但它也涉及到一个国际奶酪大盗。&lt;/p>
&lt;p>第 7 章：Clojure 炼金术：读取、求值和宏&lt;/p>
&lt;p>在这一章中，我们将退一步描述 Clojure 如何运行你的代码。这将给你一个概念性的结构，你需要真正理解 Clojure 是如何工作的，以及它与其他非 Lisp 语言有什么不同。有了这个结构，我将介绍宏，这是现有的最强大的工具之一。&lt;/p>
&lt;p>第 8 章：编写宏&lt;/p>
&lt;p>这一章彻底研究了如何编写宏，从基本的例子开始，并在复杂程度上有所提高。最后，你将戴上你的假想帽，假装你经营一家网上药水店，并使用宏来验证客户的订单。&lt;/p>
&lt;h3 id="第三部分高级主题">第三部分：高级主题&lt;/h3>
&lt;p>这些章节涵盖了 Clojure 的额外有趣的主题：并发、Java 互操作和抽象。尽管你可以在不了解这些工具和概念的情况下编写程序，但它们在智力上是有价值的，并能给你作为一个程序员带来巨大的力量。人们说学习 Clojure 会让你成为一个更好的程序员，原因之一就是它让这些章节中涉及的概念变得易于理解和实际使用。&lt;/p>
&lt;p>第 9 章：并发和并行编程的神圣艺术&lt;/p>
&lt;p>在这一章中，你将了解什么是并发和并行，以及它们为什么重要。你将了解在编写并行程序时面临的挑战，以及 Clojure 的设计如何帮助缓解这些挑战。你将使用期货、延迟和承诺来安全地编写并行程序。&lt;/p>
&lt;p>第 10 章：Clojure 形而上学：原子、Refs、Vars 和拥抱僵尸&lt;/p>
&lt;p>本章详细介绍了 Clojure 管理状态的方法以及如何简化并发编程。你将学习如何使用原子、参考数和变量这三种管理状态的结构，并学习如何用&lt;code>pmap&lt;/code>进行无状态的并行计算。还会有抱抱的僵尸。&lt;/p>
&lt;p>第 11 章：用 core.async 掌握并发&lt;/p>
&lt;p>在这一章中，你将思考宇宙中的一切是一台热狗售卖机的想法。我的意思是，你将学习如何为独立运行的进程系统建模，这些进程通过使用 core.async 库的通道相互通信。&lt;/p>
&lt;p>第 12 章：与 JVM 一起工作&lt;/p>
&lt;p>这一章就像一本短语书和 Java 大陆的文化介绍之间的交叉。它向你概述了什么是 JVM，它如何运行程序，以及如何为它编译程序。它还向你简要介绍了常用的 Java 类和方法，并解释了如何在 Clojure 中与它们进行交互。不仅如此，它还向你展示了如何思考和理解 Java，以便你能将任何 Java 库纳入你的 Clojure 程序中。&lt;/p>
&lt;p>第 13 章：用多重方法、协议和记录创建和扩展抽象概念&lt;/p>
&lt;p>在第 4 章中，你了解到 Clojure 是以抽象的方式编写的。本章是对创建和实现你自己的抽象的世界的介绍。你将学习多重方法、协议和记录的基础知识。&lt;/p>
&lt;p>附录 A：用 Leiningen 构建和开发&lt;/p>
&lt;p>本附录阐明了使用 Leiningen 的一些细微之处，比如什么是 Maven，如何计算出 Java 库的版本号，以便你能使用它们。&lt;/p>
&lt;p>附录 B：Boot，花哨的 Clojure 构建框架&lt;/p>
&lt;p>Boot 是 Leiningen 的一个替代品，它提供了相同的功能，但有一个额外的好处，即它更容易扩展和编写可组合的任务。本附录解释了 Boot 的基本概念，并指导你编写你的第一个任务。&lt;/p>
&lt;h2 id="代码">代码&lt;/h2>
&lt;p>你可以在*&lt;a class="link" href="http://www.nostarch.com/clojure/" target="_blank" rel="noopener"
>http://www.nostarch.com/clojure/&lt;/a>*下载该书的所有源代码。这些代码是按章节组织的。&lt;/p>
&lt;p>第 1 章描述了运行 Clojure 代码的不同方式，包括如何使用 REPL。我建议当你遇到大多数例子时，在 REPL 中运行它们，特别是第 3 章到第 8 章。这将有助于你习惯于编写和理解 Lisp 代码，并能帮助你保留你所学的一切。但是对于那些很长的例子，最好把你的代码写到一个文件中，然后在 REPL 中运行你写的代码。&lt;/p>
&lt;h2 id="旅程开始了">旅程开始了&lt;/h2>
&lt;p>你准备好了吗，勇敢的读者？你准备好迎接你真正的命运了吗？带上你最好的一对小括号：你即将踏上一生的旅程!&lt;/p></description></item><item><title>Acknowledgments 致谢</title><link>https://example.com/p/acknowledgments-%E8%87%B4%E8%B0%A2/</link><pubDate>Thu, 13 Jan 2022 10:06:10 +0800</pubDate><guid>https://example.com/p/acknowledgments-%E8%87%B4%E8%B0%A2/</guid><description>&lt;h1 id="致谢">致谢&lt;/h1>
&lt;p>有很多人帮助我诞生了这个奇怪的婴儿，我对他们的支持感到感激。&lt;/p>
&lt;p>首先，感谢我的妻子杰西，她为这本书绘制了插图，使它具有我所希望的视觉特性。也感谢你的支持，感谢你在我处于疯狂的作家模式时容忍我。(附注：通过一本编程书的封面感谢我的妻子，感觉很奇怪。）&lt;/p>
&lt;p>感谢我在麦肯锡的朋友和同事，他们阅读了早期的修订稿并鼓励我继续写作。其中最重要的是 Pat Shaughnessy、Alex Rothenberg、Thomas Newton、Jalil Fanaian、Chris Parker、Mark Daggett、Christian Lilley，以及 Mike Morreale。你们都太伟大了；请搬到 Durham。&lt;/p>
&lt;p>感谢我的朋友布里奇特-希勒（Bridget Hillyer）一直以来的支持。我总是觉得你是我的后盾，这对我来说意义重大。也感谢我的朋友乔-杰克逊，感谢他阅读、听我喋喋不休、并为我提供反馈，并感谢他在我面前对其他人大谈这本书，让我感觉很酷。Alan Dipert，朋友，技术评论员，现在的同事，我向你表示万分感谢，感谢你出色的技术编辑，感谢你首先将我引入 Clojure。&lt;/p>
&lt;p>我不知道是否每个作家都会不断地问自己：&amp;ldquo;我到底为什么要这样做？是否有人会读它？&amp;ldquo;但我肯定会这样做。因此，我想感谢所有在这本书的最初网络版本编写过程中写信给我并建议进行编辑的友好人士。这些积极的反馈使我感到有信心，我正在做一件有意义的事情。同样地，感谢所有购买 Leanpub 版本的人&lt;/p>
&lt;p>非常感谢 Clojure 社区领导人 Eric Normand、David Nolen 和 Alex Miller 对本书的积极宣传。在下一届 Conj 大会上见!&lt;/p>
&lt;p>最后，要感谢 No Starch 出版社的各位同仁，感谢你们对本书的帮助，使之成为我无比自豪的作品。感谢你们的高标准。感谢你们不断地促使本书更加清晰，甚至提出笑话。(Seph 的 &amp;ldquo;蜡球 &amp;ldquo;编辑仍然让我开怀大笑。) Seph Kramer, Riley Hoffman, Hayley Baker, Alison Law, Tyler Ortman, Anne Marie Walker: 谢谢你们!&lt;/p></description></item><item><title>Foreword 前言</title><link>https://example.com/p/foreword-%E5%89%8D%E8%A8%80/</link><pubDate>Thu, 13 Jan 2022 10:04:46 +0800</pubDate><guid>https://example.com/p/foreword-%E5%89%8D%E8%A8%80/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>当你阅读这本搞笑的书时，你会在某个时刻经历一个非常严肃的时刻。在了解了一些 Clojure 之后，编程变得更加有趣。这也是你在这本书上的投资，包括金钱和时间，得到回报的时刻&amp;ndash;有趣。&lt;/p>
&lt;p>幽默与严肃性有一定的关系。对严肃的事情开玩笑是合适的，但只有在适当的时间过去之后。例如，当我想起我最喜欢的叔叔的最后一句话时，我花了很多年才能够破涕为笑。&amp;ldquo;拿着我的啤酒&amp;rdquo;。&lt;/p>
&lt;p>这本书的工作方式正好相反。它在严肃事件发生之前，甚至在严肃事件发生期间，适时地指出了真正有趣的事情&amp;ndash;那一刻你意识到你因为 Clojure 而更喜欢编程。它在做到这一点的同时，并没有掩盖你将要学习的 Clojure 编程的深层技术层面。&lt;/p>
&lt;p>这种方法令人耳目一新，因为我读过的大多数编程书籍都比骆驼的屁还干。我们很幸运，丹尼尔是一位出色的程序员和作家，他的妻子杰斯是一位同样出色的插图画家。我们特别幸运的是，他们两个都疯了，决定在完全相同的时间写一本书。&lt;/p>
&lt;p>Clojure 是本书的主题，但在某种程度上它&amp;ndash;或者说它的创造者 Rich Hickey&amp;ndash;也是作者之一，因为 Clojure 是有史以来最优雅的编程语言。就像早午餐的概念一样，Clojure 是如此的优雅，以至于如果不以某种方式提高他们的水平，就很难告诉别人关于它的任何事情。&lt;/p>
&lt;p>优雅是编程语言家族中许多 Lisp 方言经常被赋予的品质，Clojure 就是其中之一。所有的 Lisp 都是由数学家 John McCarthy 在 1958 年做出的一系列简单而美丽的发现演变而来。&lt;/p>
&lt;p>自 1958 年以来，出现了许多 Lisp 方言 和 Lisp 书籍。还有更多的 Lisp 方言 和书籍即将问世。作为过去和未来的神器，每一种都适合它们的作者在各自的时代所面临的独特的约束和欲望的组合。&lt;/p>
&lt;p>我发现 Clojure，以及这本关于它的特殊书籍，特别适合现在。我希望你也会这样。&lt;/p>
&lt;p>Alan Dipert&lt;/p></description></item></channel></rss>