<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>clojure on Awesome Fenix</title>
    <link>https://zhenfeng-zhu.github.io/tags/clojure/</link>
    <description>Recent content in clojure on Awesome Fenix</description>
    <image>
      <url>https://zhenfeng-zhu.github.io/papermod-cover.png</url>
      <link>https://zhenfeng-zhu.github.io/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 15 Jan 2022 12:30:14 +0800</lastBuildDate><atom:link href="https://zhenfeng-zhu.github.io/tags/clojure/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Chapter9</title>
      <link>https://zhenfeng-zhu.github.io/posts/chapter9/</link>
      <pubDate>Sat, 15 Jan 2022 12:30:14 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/posts/chapter9/</guid>
      <description>并发和并行编程的神圣艺术 如果我是一个庄园的主人，而你是我的继承人，我会在你的第 13 个命名日让你坐下来，告诉你：&amp;ldquo;计算的世界正在改变，小姑娘，你必须为多核处理器的新世界做好准备，以免你被它践踏。
&amp;ldquo;好好听着。近年来，CPU 的时钟速度几乎没有增加，但双核和四核计算机已经变得很普遍。物理定律是残酷而绝对的，它们要求提高时钟速度需要成倍的功率。领域内最好的工程师不太可能很快克服这一限制，如果有的话。因此，你可以预期单台机器上的内核不断增加的趋势将继续下去&amp;ndash;作为一个程序员，你将知道如何充分利用现代硬件的期望也是如此。
&amp;ldquo;在这种新模式下学习编程将是有趣和迷人的，真的。但请注意：它也充满了危险。你必须学习并发和并行编程*，这是一门神圣的艺术，使你的应用结构安全地管理多个同时执行的任务。
&amp;ldquo;你从对并发和并行概念的概述开始学习这门艺术。然后，你将学习困扰每个从业者的三个小妖精：参考单元、互斥和矮人狂战士。你还将学习三种有助于你的工具：期货、许诺和延迟&amp;rdquo;。
然后我会用键盘拍拍你的肩膀，示意你可以开始了。
＃＃并发和并行的概念 并发和并行编程在程序执行的各个层面都涉及到很多混乱的细节，从硬件到操作系统，到编程语言库，再到从你的内心涌出的、落在编辑器中的代码。但在你为这些细节烦恼之前，在这一节中，我将介绍围绕并发和并行的高级概念。
管理多个任务与同时执行任务 并发指的是在同一时间管理一个以上的任务。 任务只是意味着 &amp;ldquo;需要完成的事情&amp;rdquo;，它并不意味着任何有关硬件或软件的实现。我们可以用 Lady Gaga 的歌曲《电话》来说明并发性。Gaga 唱道
 我不能给你发短信，手里拿着饮料，嗯
 这里，她在解释她只能管理一个任务（喝酒）。她断然拒绝了她可以处理一个以上的任务的建议。然而，如果她决定同时处理任务，她会唱歌。
 我将放下这杯酒给你发短信，然后把我的手机拿开，继续喝酒，嗯？
 在这个假设的宇宙中，Lady Gaga 正在处理两个任务：喝酒和发短信。然而，她并没有同时执行这两项任务。相反，她在这两个任务之间进行切换，或者说是交错。请注意，在交错过程中，你不必在切换之前完全完成一项任务：Gaga 可以打一个字，放下手机，拿起饮料喝一口，然后换回手机，再打一个字。
平行性指的是同时执行一个以上的任务。如果加加夫人平行地执行她的两项任务，她会唱歌。
 我可以用一只手给你发短信，而我用另一只手喝酒，嗯？
 平行性是并发性的一个子类：在你同时执行多个任务之前，你首先要管理多个任务。
Clojure 有很多功能，可以让你轻松实现并行化。虽然 Lady Gaga 系统是通过在多只手上同时执行任务来实现并行的，但计算机系统一般是通过在多个处理器上同时执行任务来实现并行的。
将并行性与分布式区分开来是很重要的。分布式计算是并行计算的一个特殊版本，处理器在不同的计算机中，任务通过网络分布到计算机上。这就像 Lady Gaga 问 Beyoncé，&amp;ldquo;请在我喝酒时给这家伙发短信&amp;rdquo;。尽管你可以借助库在 Clojure 中进行分布式编程，但本书只涉及并行编程，在这里我用parallel只指同居的处理器。如果你对分布式编程感兴趣，可以去看看 Kyle Kingsbury 的Call Me Maybe系列，网址是https://aphyr.com/*。
阻塞和异步任务 并发编程的主要用例之一是用于阻塞操作。阻塞实际上是指等待一个操作的完成。你最常听到的是与 I/O 操作有关的，比如读取文件或等待 HTTP 请求的完成。让我们用 Lady Gaga 并发的例子来研究这个问题。
如果 Lady Gaga 给她的对话者发短信，然后拿着手机站在那里，盯着屏幕等待回应，而不喝水，那么你会说读下一条短信操作是阻塞的，这些任务是*同步执行的。
相反，如果她把手机收起来，这样她就可以喝酒了，直到手机发出哔哔声或振动来提醒她，那么阅读下一条短信任务就不是阻塞的，你会说她是在*异步地处理这个任务。
并发编程和并行编程 并发编程和并行编程指的是将一个任务分解成可以并行执行的子任务的技术，以及管理程序同时执行多个任务时产生的风险。在本章的其余部分，我将交替使用这两个术语，因为两者的风险几乎是一样的。
为了更好地理解这些风险以及 Clojure 如何帮助你避免这些风险，让我们来看看 Clojure 中是如何实现并发和并行的。</description>
    </item>
    
    <item>
      <title>Chapter8</title>
      <link>https://zhenfeng-zhu.github.io/posts/chapter8/</link>
      <pubDate>Sat, 15 Jan 2022 12:22:42 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/posts/chapter8/</guid>
      <description>编写宏程序 当我 18 岁时，我在新墨西哥州圣菲的一家酒店找到了一份夜班审计师的工作，每周工作四个晚上，从晚上 11 点到早上 7 点。经过几个月的这种不眠不休的工作，我的情绪有了自己的变化。一天晚上，大约在
凌晨 3 点，我正在看一个信息广告，该产品声称可以恢复男人的头发。当我看到一个曾经秃头的人的故事时，我被真诚的喜悦所淹没。&amp;ldquo;终于来了！&amp;ldquo;我的大脑涌动着。&amp;ldquo;这个人得到了他应得的爱和成功! 多么不可思议的产品，给无望的人以希望！&amp;rdquo;
从那时起，我发现自己一直在想，我是否能以某种方式重新创造因长期睡眠不足而引起的情感放弃和对生命的欣赏。也许是某种药水&amp;ndash;喝上几口，释放我内心的理查德-西蒙斯，但时间不会太长。
就像药水可以让我暂时改变我的基本性质一样，宏允许你以其他语言无法实现的方式修改 Clojure。有了宏，你可以扩展 Clojure 以适应你的问题空间，建立起语言。
在这一章中，你将彻底研究如何编写宏，从基本的例子开始，逐步提高复杂性。最后，你将戴上你的假想帽，用宏来验证你想象中的在线药水店的客户订单。
在本章结束时，你将了解你用来编写宏的所有工具：引号、语法引号、解引号、解引号拼接（又称皮纳塔工具）和 gensym。你还会了解到对毫无戒心的宏作者来说隐藏着的危险：双重评估、变量捕获和宏感染。
宏是必不可少的 在你开始编写宏之前，我想帮助你把它们放在适当的环境中。是的，宏比北极熊的脚趾甲还要酷，但你不应该把宏看成是一些深奥的工具，当你想对你的代码进行额外的花哨处理时，就把它拿出来。事实上，宏允许 Clojure 从一个很小的函数和特殊形式的核心中获得大量的内置功能。以when为例。 when有这样的一般形式。
(when boolean-expression 表达式-1 表达式-2 表达式-3 ... 表达式-x) 你可能认为when是一个像if一样的特殊形式。那么你猜怎么着？它不是! 在大多数其他语言中，你只能使用特殊的关键字来创建条件表达式，而没有办法创建你自己的条件运算符。然而，when实际上是一个宏。
在这个宏扩展中，你可以看到when是用if和do来实现的。
(macroexpand &#39;(when boolean-expression 表达式-1 表达式-2 表达式-3)) ; =&amp;gt; (if boolean-expression (做表达式-1 表达式-2 表达式-3)) 这表明宏是 Clojure 开发中不可或缺的一部分&amp;ndash;它们甚至被用来提供基本操作。宏并不是为奇特的特殊情况而保留的；你应该把写宏看作是你工具包中的另一个工具。当你学会编写自己的宏时，你会发现它们是如何让你进一步扩展语言，使其适合你的特定问题领域的形状。
解剖巨集 巨集定义看起来很像函数定义。它们有一个名称，一个可选的文档字符串，一个参数列表，以及一个主体。主体几乎总是返回一个列表。这是有道理的，因为宏是将数据结构转化为 Clojure 可以评估的形式的一种方式，而 Clojure 使用列表来表示函数调用、特殊形式调用和宏调用。你可以在宏主体中使用任何函数、宏或特殊形式，你调用宏就像调用函数或特殊形式一样。
作为一个例子，这里有我们的老朋友infix宏。
(defmacro infix &amp;quot;当你为你的童年的符号而憔悴时，使用这个宏&amp;quot; [infix] (list (second infixed) (list (second infixed) (first infixed) (last infixed)) 这个宏将一个列表重新排列成正确的 infix 记号顺序。下面是一个例子。</description>
    </item>
    
    <item>
      <title>Chapter7 Clojure 炼金术。阅读、评估和宏</title>
      <link>https://zhenfeng-zhu.github.io/posts/chapter7/</link>
      <pubDate>Sat, 15 Jan 2022 12:14:36 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/posts/chapter7/</guid>
      <description>Clojure 炼金术：阅读、评估和宏 哲学家之石，与生命之药和伟哥一样，是炼金术传说中最著名的标本之一，因其能将铅转化为金而受到追捧。然而，Clojure 提供了一种工具，使哲学家的石头看起来只是一个小饰品：*宏。
宏允许你将任意的表达式转化为有效的 Clojure，因此你可以扩展语言本身以满足你的需求。而且，你甚至不需要是一个穿长袍的老家伙或老太太来使用它们
为了获得这种能力，请考虑这个微不足道的宏。
(defmacro backwards [形式］ (反向形式)) (backwards (&amp;quot; backwards&amp;quot; &amp;quot; am&amp;quot; &amp;quot;I&amp;quot; str)) ; =&amp;gt; &amp;quot;我是倒退的&amp;quot; backwards宏允许 Clojure 成功地评估表达式(&amp;quot; backwards&amp;quot; &amp;quot; am&amp;quot; &amp;quot;I&amp;quot; str)，尽管它没有遵循 Clojure 的内置语法规则，这些规则要求表达式的操作数首先出现（更不用说表达式不能按相反顺序书写的规则）。如果没有 &amp;ldquo;向后&amp;rdquo;，这个表达式会比几千年来的炼金术士用他们的一生来追求不可能实现的长生不老的方法更难失败。有了`向后&#39;，*你就创造了你自己的语法！*你扩展了 Clojure，这样你就可以随心所欲地写代码了 我告诉你，这比把铅变成金子要好得多!
本章为你提供了编写自己的宏所需的概念基础，使你能够疯狂地编写自己的宏。它解释了 Clojure 评估模型的元素：读取器，评估器，和宏扩展器。这就像 Clojure 元素的周期表。想想周期表是如何揭示原子的特性的：同一列的元素行为相似，因为它们有相同的核电荷。如果没有元素周期表及其基础理论，我们就会像过去的炼金术士一样，随意地把东西混在一起，看看什么东西会爆炸。但是，随着对元素的深入了解，你可以看到为什么东西会爆炸，并学会如何有目的地炸毁东西。
A Overview of Clojure&amp;rsquo;s Evaluation Model Clojure（像所有的 Lisps）有一个不同于大多数其他语言的评估模型：它有一个两阶段的系统，它读文本源代码，产生 Clojure 数据结构。然后对这些数据结构进行*评估。Clojure 遍历数据结构，并根据数据结构的类型执行函数应用或 var 查找等操作。例如，当 Clojure 读取文本(+ 1 2)时，结果是一个列表数据结构，其第一个元素是一个+符号，后面是数字 1 和 2。这个数据结构被传递给 Clojure 的评估器，评估器查找+对应的函数，并将该函数应用于 1 和 2。
在源代码、数据和评估之间有这种关系的语言被称为homoiconic（顺便说一句，如果你在浴室的镜子前熄灯说三次homoiconic，约翰-麦卡锡的幽灵就会出现并给你一个小括号）。同源语言使你能够将你的代码作为一组数据结构进行推理，你可以通过程序进行操作。为了说明这一点，让我们在编译的土地上走一圈。
编程语言需要一个编译器或解释器来将你写的代码（由 Unicode 字符组成）翻译成其他东西：机器指令、其他编程语言的代码，等等。在这个过程中，编译器会构建一个抽象语法树（AST），这是一个代表你的程序的数据结构。你可以把 AST 看作是评价器的输入，你可以把它看作是一个遍历该树的函数，以产生机器代码或其他什么作为其输出。</description>
    </item>
    
    <item>
      <title>Chapter6 整理你的项目：一个图书管理员的故事</title>
      <link>https://zhenfeng-zhu.github.io/posts/chapter6/</link>
      <pubDate>Fri, 14 Jan 2022 12:40:41 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/posts/chapter6/</guid>
      <description>整理你的项目：一个图书管理员的故事 在我们每个人心中都住着一个叫 Melvil 的图书管理员，一个以组织艺术为乐的奇异生物。日日夜夜，Melvil 都渴望为你的代码库带来秩序。幸运的是，Clojure 提供了一套工具，专门用来帮助这个侏儒与混乱的力量不断斗争。
这些工具通过将相关的函数和数据分组来帮助你组织你的代码。它们还可以防止名称冲突，这样你就不会意外地覆盖别人的代码，反之亦然。在这个充满悬念和神秘的故事中，请和我一起学习如何使用这些工具，并解决一生中的抢劫案吧 在这个传奇故事的最后，你将了解以下内容。
  `def&amp;rsquo;是做什么的
  什么是命名空间以及如何使用它们
  命名空间和文件系统之间的关系
  如何使用refer、alias、require、use和ns。
  如何使用文件系统来组织 Clojure 项目
  我先来介绍一下 Clojure 的组织系统，它的工作原理很像一个库。Melvil 兴奋地颤抖着!
你的项目是一个库 现实世界中的图书馆存储对象的集合，如书籍、杂志和 DVD。他们使用寻址系统，所以当你得到一个物体的地址时，你可以导航到物理空间并检索到该物体。
当然，没有人能够直接知道一本书或 DVD 的地址是什么。这就是为什么图书馆要记录一个物体的标题和它的地址之间的联系，并提供工具来搜索这些记录。在计算机之前的旧时代，图书馆提供卡片目录，即装满纸质卡片的柜子，其中包含每本书的标题、作者、&amp;ldquo;地址&amp;rdquo;（杜威十进制或国会图书馆编号）和其他信息。
例如，要找到《达芬奇密码》，你可以翻阅书名目录（按书名排序的卡片），直到你找到正确的卡片。在那张卡片上，你会看到地址813.54（如果它使用杜威十进制系统），浏览图书馆，找到达芬奇密码所在的书架，并参与你一生中的文学和/或仇恨阅读冒险。
在 Clojure 中想象一个类似的设置是很有用的。我认为 Clojure 是将对象（如数据结构和函数）存储在一组巨大的编号架上。没有人能够直接知道一个对象被存储在哪个架子上。相反，我们给 Clojure 一个标识符，它用来检索该对象。
为了使之成功，Clojure 必须维护我们的标识符和货架地址之间的关联。它通过使用namespaces来做到这一点。命名空间包含了人类友好的符号和书架地址的引用之间的映射，被称为vars，很像卡片目录。
从技术上讲，命名空间是 &amp;ldquo;clojure.lang.Namespace &amp;ldquo;类型的对象，你可以与它们互动，就像你可以与 Clojure 数据结构互动一样。例如，你可以用*ns*来引用当前的命名空间，你可以用(ns-name *ns*)来获得其名称。
(ns-name *ns*) ; =&amp;gt; user 例如，当你启动 REPL 时，你在user命名空间中（正如你在这里看到的）。提示符显示当前名称空间，使用user=&amp;gt;。
当前名字空间的概念意味着你可以有多个名字空间，事实上 Clojure 允许你创建任意多的名字空间（尽管从技术上讲，你可以创建的名字数量可能有一个上限）。在 Clojure 程序中，你总是在个命名空间中。
至于符号，你一直在使用它们，甚至没有意识到。例如，当你写(map inc [1 2])时，map和inc都是符号。符号是 Clojure 中的数据类型，我将在下一章中彻底解释它们。现在，你需要知道的是，当你给 Clojure 一个像map这样的符号时，它会在当前命名空间中找到相应的 var，得到一个架子上的地址，并为你从那个架子上检索一个对象&amp;ndash;在这里，就是map所指的那个函数。如果你想只使用符号本身，而不是它所指的东西，你必须引用它。引述任何 Clojure 的形式告诉 Clojure 不要评估它，而是把它当作数据。接下来的几个例子显示了当你引用一个表单时会发生什么。</description>
    </item>
    
    <item>
      <title>Chapter5 函数式编程</title>
      <link>https://zhenfeng-zhu.github.io/posts/chapter5/</link>
      <pubDate>Fri, 14 Jan 2022 10:00:07 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/posts/chapter5/</guid>
      <description>函数式编程 到目前为止，你已经专注于熟悉 Clojure 提供的工具：不可变的数据结构、函数、抽象，等等。在这一章中，你将学习如何思考你的编程任务，以最好的方式利用这些工具。你将开始把你的经验整合到一个新的函数式编程思维中。
你将学到的核心概念包括：什么是纯函数，为什么它们很有用；如何使用不可变的数据结构，为什么它们比可变的表亲更有优势；如何将数据和函数分开，给你带来更多的力量和灵活性；以及为什么对一小部分数据抽象进行编程会很强大。一旦你把所有这些知识塞进你的大脑，你就会有一个全新的解决问题的方法
在学习了这些主题之后，你将通过编写一个基于终端的游戏来运用你所学到的一切，这个游戏的灵感来自于美国各地 Cracker Barrel 餐馆中的一种古老而神秘的思维训练装置。Peg Thing!
纯函数：什么和为什么 除了 &amp;ldquo;println &amp;ldquo;和 &amp;ldquo;rand&amp;rdquo;，到目前为止，你所使用的所有函数都是纯函数。是什么使它们成为纯函数，为什么会有这样的问题？如果一个函数符合两个条件，它就是纯函数。
 如果给出相同的参数，它总是返回相同的结果。这被称为引用透明度，你可以把它添加到你的 5 美元编程术语列表中。 它不能引起任何副作用。也就是说，该函数不能做出任何在函数本身之外可以观察到的改变&amp;ndash;例如，通过改变一个外部可访问的可改变对象或写到一个文件。  这些特性使你更容易推理你的程序，因为这些函数是完全隔离的，无法影响你系统的其他部分。当你使用它们时，你不必问自己，&amp;ldquo;我调用这个函数会破坏什么？&amp;rdquo; 它们也是一致的：你永远不需要搞清楚为什么给一个函数传递相同的参数会导致不同的返回值，因为这永远不会发生。
纯函数和算术一样稳定，没有问题（你最后一次为两个数字相加而烦恼是什么时候？） 它们是巨大的函数小砖块，你可以自信地将其作为你程序的基础。让我们更详细地看看引用透明性和无副作用，看看它们到底是什么，以及它们是如何发挥作用的。
纯函数是引用透明的 为了在调用相同参数时返回相同的结果，纯函数只依靠 1）自己的参数和 2）不可变的值来决定其返回值。例如，数学函数是引用透明的。
(+ 1 2) ; =&amp;gt; 3 如果一个函数依赖于一个不可变的值，那么它就是引用透明的。字符串`&amp;rdquo;, Daniel-san &amp;ldquo;是不可变的，所以下面的函数也是引用透明的。
(defn wisdom [words] (str words &amp;#34;, Daniel-san&amp;#34;)) (wisdom &amp;#34;Always bathe on Fridays&amp;#34;) ; =&amp;gt; &amp;#34;Always bathe on Fridays, Daniel-san&amp;#34; 相比之下，下面的函数在相同的参数下不会产生相同的结果；因此，它们在指称上是不透明的。任何依赖随机数生成器的函数都不可能是指称透明的。
(defn year-end-evaluation [] (if (&amp;gt; (rand) 0.5) &amp;#34;You get a raise!&amp;#34; &amp;#34;Better luck next year!</description>
    </item>
    
    <item>
      <title>Chapter4 核心函数的深入研究</title>
      <link>https://zhenfeng-zhu.github.io/posts/chapter4/</link>
      <pubDate>Thu, 13 Jan 2022 17:39:28 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/posts/chapter4/</guid>
      <description>核心函数的深入研究 如果你像我一样是焦虑的、以青少年为中心的准肥皂剧*《吸血鬼日记》的超级粉丝，你一定记得主角埃琳娜开始质疑她苍白的、神秘的暗恋者的行为的那一集。&amp;ldquo;为什么当我的膝盖被刮伤时，他立刻消失得无影无踪？&amp;ldquo;和 &amp;ldquo;为什么当我的手指被划破时，他的脸变成了一个怪异的死亡面具？&amp;ldquo;等等。
如果你已经开始玩 Clojure 的核心函数，你可能也会问自己类似的问题。&amp;ldquo;为什么map&#39;会返回一个列表，而我给它的是一个向量？&amp;quot;和 &amp;quot;为什么reduce&amp;rsquo;会把我的 map 当成一个向量列表？&amp;ldquo;等等。(不过，有了 Clojure，你至少可以免于思考作为一个 17 岁孩子的深刻的存在恐惧，直到永远）。
在这一章中，你将了解到 Clojure 的深邃、黑暗、嗜血、超自然的****，我的意思是，在这一章中，你将了解到 Clojure 的编程到抽象的基本概念以及序列和集合的抽象。你还会了解到疯狂的序列*。这将为你提供所需的基础，使你能够阅读你以前没有使用过的函数的文档，并理解当你试着使用它们时发生了什么。
接下来，你将获得更多关于你最需要使用的函数的经验。你将学习如何用函数map、reduce、into、conj、concat、some、filter、take、drop、sort、sort-by和identity来处理列表、向量、Map 和集合。你还将学习如何用apply、partial和complement创建新的函数。所有这些信息将帮助你了解如何以 Clojure 的方式做事，它将为你编写自己的代码以及阅读和学习他人的项目打下坚实的基础。
最后，你将学会如何解析和查询 CSV 中的吸血鬼数据，以确定在你的家乡潜伏着哪些诺斯费拉图。
从编程到抽象 为了理解对抽象的编程，让我们把 Clojure 与一种没有考虑到这个原则的语言进行比较。Emacs Lisp（elisp）。在 elisp 中，你可以使用mapcar函数来导出一个新的列表，这与你在 Clojure 中使用map的方式相似。然而，如果你想在 elisp 中映射一个哈希图（类似于 Clojure 的 map 数据结构），你需要使用maphash函数，而在 Clojure 中你仍然可以只使用map。换句话说，elisp 使用两个不同的、针对数据结构的函数来实现map操作，而 Clojure 只使用一个。你也可以在 Clojure 中对 map 调用reduce，而 elisp 并没有提供一个函数来减少散列 map。
原因是 Clojure 在*序列抽象方面定义了map和reduce函数，而不是在具体的数据结构方面。只要数据结构响应核心序列操作（函数first&#39;、rest&amp;rsquo;和cons&#39;，我们稍后会仔细研究），它就能与map&#39;、`reduce&amp;rsquo;以及其他大量的序列函数免费工作。这就是 Clojurists 所说的抽象编程，也是 Clojure 哲学的一个核心原则。
我认为抽象是操作的命名集合。如果你能在一个对象上执行一个抽象的所有操作，那么这个对象就是该抽象的一个实例。我甚至在编程之外也是这样想的。例如，电池抽象包括 &amp;ldquo;将导电介质连接到其阳极和阴极 &amp;ldquo;的操作，而该操作的输出是电流。电池是用锂还是用土豆做的并不重要。只要它对定义电池的一系列操作做出反应，它就是一个电池。
同样地，map并不关心列表、向量、集合和 Map 是如何实现的。它只关心它是否能对它们进行序列操作。让我们看看map是如何在序列抽象中定义的，这样你就能理解一般的抽象编程。
把列表、向量、集合和 Map 当作序列对待 如果你把map操作独立于任何编程语言，甚至是编程，它的基本行为是用一个函数ƒ从现有的序列x导出一个新的序列y，这样y1 = ƒ(x1), y2 = ƒ(x2), .</description>
    </item>
    
    <item>
      <title>Chapter3 Clojure 速成班</title>
      <link>https://zhenfeng-zhu.github.io/posts/chapter3/</link>
      <pubDate>Thu, 13 Jan 2022 11:12:19 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/posts/chapter3/</guid>
      <description>做事情：Clojure 速成班 是时候学习如何用 Clojure 真正地做事了! 该死的! 尽管你无疑已经听说过 Clojure 令人敬畏的并发支持和其他了不起的功能，但 Clojure 最突出的特点是它是一种 Lisp 语言。在本章中，你将探索构成这个 Lisp 核心的元素：语法、函数和数据。它们将共同为你在 Clojure 中表示和解决问题打下坚实的基础。
在打下这个基础之后，你将能够编写一些超级重要的代码。在最后一节中，你将通过创建一个霍比特人的模型，并编写一个函数将其打在一个随机的位置上，从而将一切联系起来。超级! 重要的!
当你阅读本章时，我建议你在 REPL 中输入例子并运行它们。用一种新的语言编程是一种技能，就像约德尔舞或花样游泳一样，你必须通过练习来学习它。 请留意它!
语法 Clojure 的语法很简单。像所有的 Lisp 一样，它采用了统一的结构、少量的特殊运算符，以及从藏在麻省理工学院下面的小括号矿井中不断提供的小括号，Lisp 就是在那里诞生的。
形式 所有的 Clojure 代码都是以统一结构编写的。Clojure 可以识别两种结构。
 数据结构的字面表示（如数字、字符串、Map 和向量） 操作  我们使用术语form来指代有效的代码。我有时也会用表达式来指代 Clojure 形式。但不要太纠结于术语。Clojure 评价每一个表单，以产生一个值。这些字面表达都是有效的形式。
1 &amp;quot;a string&amp;quot; [&amp;quot;a&amp;quot; &amp;quot;vector&amp;quot; &amp;quot;of&amp;quot; &amp;quot;strings&amp;quot;] 当然，你的代码很少包含自由浮动的字元，因为它们本身实际上并不做什么。相反，你会在操作中使用字面符号。操作是你做事情的方式。所有操作的形式都是：*开括号，*操作符，*操作数，闭括号。
(operator operand1 operand2 ... operandn) 请注意，这里没有逗号。Clojure 使用空格来分隔操作数，它将逗号视为空格。下面是一些操作的例子。
(+ 1 2 3) ; =&amp;gt; 6 (str &amp;quot;It was the panda &amp;quot; &amp;quot;in the library &amp;quot; &amp;quot;with a dust buster&amp;quot;) ; =&amp;gt; &amp;quot;It was the panda in the library with a dust buster&amp;quot; 在第一个操作中，运算符+将操作数1、2和3相加。在第二个操作中，运算符str将三个字符串连接起来，形成一个新的字符串。这两种形式都是有效的。这里有一个不是形式的东西，因为它没有一个结束的小括号。</description>
    </item>
    
    <item>
      <title>Chapter2 如何使用 Emacs，一个优秀的 Clojure 编辑器</title>
      <link>https://zhenfeng-zhu.github.io/posts/chapter2/</link>
      <pubDate>Thu, 13 Jan 2022 10:43:56 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/posts/chapter2/</guid>
      <description>如何使用 Emacs，一个优秀的 Clojure 编辑器 在你掌握 Clojure 的过程中，你的编辑器将是你最亲密的盟友。我强烈建议使用 Emacs，但你当然也可以使用任何你想要的编辑器。如果你不遵循本章中关于 Emacs 的详尽说明，或者你选择使用一个不同的编辑器，那么至少值得投入一些时间来设置你的编辑器，以便与 REPL 一起工作。我推荐的两个在社区中受到好评的替代品是Cursive和Nightcode。
我推荐 Emacs 的原因是，它提供了与 Clojure REPL 的紧密集成，这使你可以在写作时立即尝试你的代码。这种紧密的反馈回路在学习 Clojure 和以后编写真正的 Clojure 程序时都很有用。Emacs 也很适合与任何 Lisp 方言一起工作；事实上，Emacs 是用一种叫做 Emacs Lisp（elisp）的 Lisp 方言编写的。
在本章结束时，你的 Emacs 设置将看起来像图 2-1。
图 2-1: 使用 Clojure 的典型 Emacs 设置：一边是代码，另一边是 REPL。
为了达到这个目的，你将从安装 Emacs 开始，设置一个适合新人的 Emacs 配置。然后你将学习基础知识：如何打开、编辑和保存文件，以及如何使用基本的键绑定与 Emacs 进行交互。最后，你将学习如何实际编辑 Clojure 代码并与 REPL 进行交互。
安装 你应该使用 Emacs 的最新主要版本，即 Emacs 24，用于你工作的平台。
 OS X从*http://emacsformacosx.com*安装 vanilla Emacs 作为一个 Mac 应用程序。其他选项，如 Aquamacs，应该是为了使 Emacs 更 &amp;ldquo;像 Mac&amp;rdquo;，但从长远来看是有问题的，因为它们的设置与标准 Emacs 有很大的不同，以至于很难使用 Emacs 手册或跟随教程。 Ubuntu按照*https://launchpad.</description>
    </item>
    
    <item>
      <title>Chapter1 构建、运行和 REPL</title>
      <link>https://zhenfeng-zhu.github.io/posts/chapter1/</link>
      <pubDate>Thu, 13 Jan 2022 10:26:48 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/posts/chapter1/</guid>
      <description>构建、运行和 REPL 在本章中，你将预先投入少量时间来熟悉建立和运行 Clojure 程序的快速、傻瓜式方法。让一个真正的程序运行起来感觉很好。达到了这个里程碑，你就可以自由地进行实验，分享你的工作，并向那些仍在使用上个世纪的语言的同事幸灾乐祸。这将有助于保持你的积极性!
你还将学习如何使用*Read-Eval-Print Loop（REPL）*在一个正在运行的 Clojure 进程中即时运行代码，这使你能够快速测试你对语言的理解并更有效地学习。
但首先，我将简要地介绍 Clojure。接下来，我将介绍 Leiningen，这是 Clojure 事实上的标准构建工具。在本章结束时，你将知道如何做以下事情。
 用 Leiningen 创建一个新的 Clojure 项目 构建该项目以创建一个可执行的 JAR 文件 执行 JAR 文件 在 Clojure REPL 中执行代码  First Things First: 什么是 Clojure Clojure 是由 Rich Hickey 在一座神话般的火山中铸造的。他使用 Lisp、函数式编程和他自己的一绺史诗般的头发的合金，创造了一种令人愉快而强大的语言。它的 Lisp 遗产使你有能力写出比大多数非 Lisp 语言更有表现力的代码，而它对函数式编程的独特理解将使你作为一个程序员的思维更敏锐。此外，Clojure 为你提供了更好的工具来处理复杂的领域（如并发编程），这些领域在传统上被认为会使开发人员陷入多年的治疗中。
不过，在谈论 Clojure 时，重要的是要牢记 Clojure 语言和 Clojure 编译器之间的区别。Clojure 语言是一种强调函数的 Lisp 方言，其语法和语义与任何实现都无关。编译器是一个可执行的 JAR 文件，clojure.jar，它接收用 Clojure 语言编写的代码并将其编译为 Java 虚拟机（JVM）字节码。你会看到Clojure被用来指代语言和编译器，如果你不知道它们是独立的东西，就会感到困惑。但现在你意识到了，你就会好起来。
这种区分是必要的，因为与大多数编程语言如 Ruby、Python、C 和其他许多语言不同，Clojure 是一种托管语言。Clojure 程序在 JVM 中执行，并依赖 JVM 的核心功能，如线程和垃圾收集。Clojure 还针对 JavaScript 和微软的通用语言运行时（CLR），但本书只关注 JVM 的实现。</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://zhenfeng-zhu.github.io/posts/introduction/</link>
      <pubDate>Thu, 13 Jan 2022 10:11:25 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/posts/introduction/</guid>
      <description>简介 在你的内心深处，你一直都知道你注定要学习 Clojure。 每当你高举着键盘，为一个难以理解的类层次结构而痛苦地哭泣时；每当你晚上躺在床上，为一个突变引起的海森堡虫而哭泣扰乱你的亲人时；每当一个竞赛条件使你拔掉更多你不断减少的头发时，你的某个秘密部分已经知道一定有一个更好的办法。
现在，终于，你面前的教学材料将使你与你渴望已久的编程语言结合起来。
学习一种新的编程语言：穿越四个迷宫的旅程 为了最大限度地发挥 Clojure 的作用，你需要在每个学习新语言的程序员面临的四个迷宫中找到自己的路。
 工具之林 友好而高效的编程环境使你能够轻松地尝试你的想法。你将学习如何设置你的环境。 语言之山 随着你的攀登，你将获得 Clojure 的语法、语义和数据结构方面的知识。你将学习如何使用最强大的编程工具之一&amp;ndash;宏，并学习如何利用 Clojure 的并发结构来简化你的生活。 神器之洞 在它的深处，你将学会构建、运行和发布你自己的程序，以及如何使用代码库。你还将学习 Clojure 与 Java 虚拟机（JVM）的关系。 心态的云堡 在其稀薄的空气中，你将了解 Lisp 和函数式编程的原因和方法。你将了解渗透在 Clojure 中的简单哲学，以及如何像 Clojurist 一样解决问题。  别搞错了，你要工作。但这本书会让你感觉到工作是令人振奋的，而不是疲惫的。这是因为本书遵循三个准则。
 它采取了甜点优先的方法，给你提供了你需要的开发工具和语言细节，以便立即开始玩真正的程序。 它假定你对 JVM、函数式编程或 Lisp 没有经验。它详细地涵盖了这些主题，所以当你构建和运行 Clojure 程序时，你会对你正在做的事情感到自信。 它避开了 真实世界 的例子，而选择了更有趣的练习，如 攻击霍比特人 和 追踪闪亮的吸血鬼 。  到最后，你将能够使用 Clojure&amp;ndash;现存的最令人兴奋和最有趣的编程语言之一!
本书是如何组织的 本书分为三个部分，以便更好地指导你完成你的勇敢探索，勇敢的初出茅庐的 Clojurist。
第一部分：环境设置 为了保持动力和高效学习，你需要实际写代码和构建可执行文件。这些章节将带领你快速浏览你所需要的工具，以便轻松地编写程序。这样，你就可以专注于学习 Clojure，而不是摆弄你的环境。
第 1 章：构建、运行和 REPL
让一个真正的程序运行起来，有一种强大的激励作用。一旦你能做到这一点，你就可以自由地进行实验，而且你可以真正地分享你的工作
在这短短的一章中，你将投入少量时间来熟悉建立和运行 Clojure 程序的快速方法。你将学习如何在一个正在运行的 Clojure 进程中使用读-评-印循环（REPL）来实验代码。这将收紧你的反馈回路，帮助你更有效地学习。
第二章：如何使用 Emacs，一个优秀的 Clojure 编辑器</description>
    </item>
    
    <item>
      <title>Acknowledgments</title>
      <link>https://zhenfeng-zhu.github.io/posts/acknowledgments/</link>
      <pubDate>Thu, 13 Jan 2022 10:06:10 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/posts/acknowledgments/</guid>
      <description>鸣谢 有很多人帮助我诞生了这个奇怪的婴儿，我对他们的支持感到谦卑和感激。
首先，感谢我的妻子杰西，她为这本书绘制了插图，使它具有我所希望的视觉特性。也感谢你的支持，感谢你在我处于疯狂的作家模式时容忍我。(附注：通过一本编程书的封面感谢我的妻子，感觉很奇怪。）
感谢我在麦肯锡的朋友和同事，他们阅读了早期的修订稿并鼓励我继续写作。其中最重要的是 Pat Shaughnessy、Alex Rothenberg、Thomas Newton、Jalil Fanaian、Chris Parker、Mark Daggett、Christian Lilley，以及 Mike Morreale。你们都太伟大了；请搬到达勒姆。
感谢我的朋友布里奇特-希勒（Bridget Hillyer）一直以来的支持和积极性。我总是觉得你是我的后盾，这对我来说意义重大。也感谢我的朋友乔-杰克逊，感谢他阅读、听我喋喋不休、提供反馈，并感谢他在我面前对其他人大谈这本书，让我感觉很酷。Alan Dipert，朋友，技术评论员，现在的同事，我向你表示万分感谢，感谢你出色的技术编辑，感谢你首先将我引入 Clojure。
我不知道是否每个作家都会不断地问自己：&amp;ldquo;我到底为什么要这样做？是否有人会读它？&amp;ldquo;但我肯定会这样做。因此，我想感谢所有在这本书的最初网络版本编写过程中写信给我并建议进行编辑的友好人士。这些积极的反馈使我感到有信心，我正在做一件有意义的事情。同样地，感谢所有购买 Leanpub 版本的人
非常感谢 Clojure 社区领导人 Eric Normand、David Nolen 和 Alex Miller 对本书的积极宣传。在下一届 Conj 大会上见!
最后，要感谢 No Starch 出版社的各位同仁，感谢你们对本书的帮助，使之成为我无比自豪的作品。感谢你们的高标准。感谢你们不断地促使本书更加清晰，甚至提出笑话。(Seph 的 &amp;ldquo;蜡球 &amp;ldquo;编辑仍然让我开怀大笑。) Seph Kramer, Riley Hoffman, Hayley Baker, Alison Law, Tyler Ortman, Anne Marie Walker: 谢谢你们!</description>
    </item>
    
    <item>
      <title>Foreword</title>
      <link>https://zhenfeng-zhu.github.io/posts/foreword/</link>
      <pubDate>Thu, 13 Jan 2022 10:04:46 +0800</pubDate>
      
      <guid>https://zhenfeng-zhu.github.io/posts/foreword/</guid>
      <description>前言 当你阅读这本搞笑的书时，你会在某个时刻经历一个非常严肃的时刻。这是你向自己承认，在了解了一些 Clojure 之后，编程变得更加有趣的时刻。这也是你在这本书上的投资，包括金钱和时间，得到回报的时刻&amp;ndash;有兴趣。
幽默与严肃性有一定的关系。对严肃的事情开玩笑是合适的，但只有在适当的时间过去之后。例如，当我想起我最喜欢的叔叔的最后一句话时，我花了很多年才能够破涕为笑。&amp;ldquo;拿着我的啤酒&amp;rdquo;。
这本书的工作方式正好相反。它在严肃事件发生之前，甚至在严肃事件发生期间，适时地指出了真正有趣的事情&amp;ndash;那一刻你意识到你因为 Clojure 而更喜欢编程。它在做到这一点的同时，并没有掩盖你将要学习的 Clojure 编程的深层技术层面。
这种方法令人耳目一新，因为我读过的大多数编程书籍都比骆驼的屁还干。我们很幸运，丹尼尔是一位出色的程序员和作家，他的妻子杰斯是一位同样出色的插图画家。我们特别幸运的是，他们两个都疯了，决定在完全相同的时间写一本书。
Clojure 是本书的主题，但在某种程度上它&amp;ndash;或者说它的创造者 Rich Hickey&amp;ndash;也是作者之一，因为 Clojure 是有史以来最优雅的编程语言。就像早午餐的概念一样，Clojure 是如此的优雅，以至于如果不以某种方式提高他们的水平，就很难告诉别人关于它的任何事情。
优雅是编程语言家族中许多方言经常被赋予的品质，这些方言被统称为 Lisp，Clojure 就是其中之一。所有的 Lisp 都是由数学家 John McCarthy 在 1958 年做出的一系列简单而美丽的发现演变而来。
自 1958 年以来，出现了许多 Lisps 和 Lisp 书籍。还有更多的 Lisps 和书籍即将问世。作为过去和未来的人工制品，每一种都适合它们的作者在各自的时代所面临的独特的约束和欲望的组合。
我发现 Clojure，以及这本关于它的特殊书籍，特别适合现在。我希望你也会这样。
Alan Dipert</description>
    </item>
    
  </channel>
</rss>
