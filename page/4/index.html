<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Awesome Fenix</title>
<meta name=description content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod">
<meta name=author content="Fenix">
<link rel=canonical href=https://zhenfeng-zhu.github.io/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<link rel=icon href=https://zhenfeng-zhu.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://zhenfeng-zhu.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://zhenfeng-zhu.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://zhenfeng-zhu.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://zhenfeng-zhu.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.91.2">
<link rel=alternate type=application/rss+xml href=https://zhenfeng-zhu.github.io/index.xml>
<link rel=alternate type=application/json href=https://zhenfeng-zhu.github.io/index.json>
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="Awesome Fenix">
<meta property="og:description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod">
<meta property="og:type" content="website">
<meta property="og:url" content="https://zhenfeng-zhu.github.io/"><meta property="og:image" content="https://zhenfeng-zhu.github.io/papermod-cover.png">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhenfeng-zhu.github.io/papermod-cover.png">
<meta name=twitter:title content="Awesome Fenix">
<meta name=twitter:description content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Awesome Fenix","url":"https://zhenfeng-zhu.github.io","description":"Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod","thumbnailUrl":"https://zhenfeng-zhu.github.io/favicon.ico","sameAs":["https://github.com/zhenfeng-zhu","index.xml"]}</script>
</head>
<body class=list id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhenfeng-zhu.github.io accesskey=h title="Awesome Fenix (Alt + H)">Awesome Fenix</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://zhenfeng-zhu.github.io/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/about title=About>
<span>About</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/search/ title=🔍>
<span>🔍</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-entry>
<header class=entry-header>
<h2>crystal 简介
</h2>
</header>
<section class=entry-content>
<p>关注 crystal 也有一段时间了，看到多线程的 pr 已经提了，今天简单写一下。
Fast as C, Slick as Ruby
语法 crystal 的语法和 Ruby 比较类似。
# A very basic HTTP server require "http/server" server = HTTP::Server.new do |context| context.response.content_type = "text/plain" context.response.print "Hello world, got #{context.request.path}!" end puts "Listening on http://127.0.0.1:8080" server.listen(8080) 类型系统 crystal 的一大卖点就是静态类型系统，但是写起来又和脚本语言类似。
def shout(x) # Notice that both Int32 and String respond_to `to_s` x.to_s.upcase end foo = ENV["FOO"]? || 10 typeof(foo) # => (Int32 | String) typeof(shout(foo)) # => String 空引用检查 crystal 可以在编译的时候检查空引用，避免出现空指针异常。...</p>
</section>
<footer class=entry-footer><span title="2019-08-27 02:14:18.124 +0000 UTC">August 27, 2019</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to crystal 简介" href=https://zhenfeng-zhu.github.io/posts/crystal%E7%AE%80%E4%BB%8B/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>socket
</h2>
</header>
<section class=entry-content>
<p>Socket 网络模型 osi 七层模型 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 对应的 tcpip 就是 应用层 dns http 传输层 icmp tcp udp ip 层 ipv4 ipv6 mac 层 arp vlan 物理层 Ethernet 为什么要分层 因为网络环境过于复杂，不是一个能够集中控制的体系。全球的服务器和设备各有各的体系，但是可以通过同一套网络协议栈切分成多个层次和组合，来满足不同设备之间的通信需求。
二层到四层，即 mac、ip 和传输等层都是 Linux 内核中处理。应用层的如浏览器、Nginx 和 Tomcat 等都是用户态的。
传输层的 tcp 和 udp 里都有端口的概念，不同应用监听不同的段即可。
应用层和内核的互通机制，就是通过 socket 系统调用。其实 socket 哪一层都不属于，它是属于操作系统的概念，而不是网络分层的概念。因为操作系统把二层到四层的处理代码在内核里，应用层的处理代码让应用自己做，两者需要跨内核态和用户态进行通信，这个就是 socket。...</p>
</section>
<footer class=entry-footer><span title="2019-08-26 06:54:14.652 +0000 UTC">August 26, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to socket" href=https://zhenfeng-zhu.github.io/posts/socket/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>go 进阶
</h2>
</header>
<section class=entry-content>
<p>Diagnostics go 提供了一系列诊断逻辑和性能问题的工具。
profiling 分析 tracing 跟踪 debuging 调试 运行时统计信息和事件 Profiling profiling 信息可以在 go test 或者 net/http/pprof 包的时候使用。
runtime/pprof 包有：
cpu 主动消费 cpu 周期所花费的时间，不包括睡眠或者 io 等待 heap 报告内存分配采样； 当前或历史内存使用状况 检测内存泄露 threadcreate 报告创建新的系统线程 goroutine 当前所有协程的堆栈跟踪 block 显示 goroutine 阻塞等待同步原语的位置。 默认不开启，使用 runtime.SetBlockProfileRate 启用 mutex 报告锁竞争。 如果认为自己的程序因为互斥锁导致 cpu 不能充分利用的时候，使用这个。 默认也是不开启，使用 runtime.SetMutexProfileFraction 启用。 其他可用的的性能分析工具...</p>
</section>
<footer class=entry-footer><span title="2019-08-26 06:53:32.176 +0000 UTC">August 26, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to go 进阶" href=https://zhenfeng-zhu.github.io/posts/go%E8%BF%9B%E9%98%B6/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>mysql
</h2>
</header>
<section class=entry-content>
<p>MySQL 基本架构 客户端
server 层
连接器：管理连接，权限验证
查询缓存：命中规则，直接返回结果 8.0 之后全部删除了这个模块
分析器：词法分析，语法分析
优化器：执行计划生成，索引选择
执行器：操作引擎，返回结果
存储引擎：存储数据，提供读写接口
数据库中的长连接指连接成功之后，如果客户端持续有请求，则一直使用同一个连接。短连接是指每次执行完很少的几次查询之后就断开连接，下次再重新建立。
如果全部使用长连接，会导致 mysql 内存涨的很快，可能出现 OOM，因此要定期断开长连接，或者在执行一个比较大的操作之后，执行 mysql_reset_connection 重置一下。
日志系统 redo log 重做日志 redo log 是 innodb 引擎特有的。物理日志，记录的是某个数据页上做了什么修改。循环写入。
WAL 技术：Write-Ahead Logging：关键点就是先写日志，再写磁盘。当一条记录更新时，先把记录写到 redolog 中，更新到内存，这时这个更新操作就成功了。然后 innodb 引擎就会在适当的时候，将这个操作记录更新到磁盘中。因此在数据库异常重启的时候，之前的提交的记录不会丢失。
binlog 归档日志 binlog 是 server 层实现的，所有的引擎都可以使用。binlog 是逻辑日志，记录的是这个语句的原始逻辑。binlog 是写到一定大小后，切换下一个，不会覆盖以前的日志。
因此一个 update 操作就是：
找到该行
判断数据页是否在内存中，如果是返回行数据，否则从磁盘读入到内存中。
将值进行更新，写入新行
新行更新到内存
写入 redolog，处于 prepare 阶段
写入 binlog
提交事务，处于 commit 阶段。...</p>
</section>
<footer class=entry-footer><span title="2018-12-01 15:54:53 +0000 UTC">December 1, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to mysql" href=https://zhenfeng-zhu.github.io/posts/mysql/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>graphql
</h2>
</header>
<section class=entry-content>
<p>graphql 经常被认为是聚焦于前端的技术。
核心概念 SDL：schema definition language（模式定义语言） 如：
type Person{ name: String! age: Int! } 这个类型有两个字段，name 和 age，他们的类型是 String 和 Int。！的意思代表他们是必需的。
type Post{ title: String! author: Person! } 接下来的 Post 也有两个字段，其中 Person 也是可以作为一个类型。
也可以这样，在 Person 中添加一个 post：
type Person{ name: String! age: Int! posts: [Post!]! } 通过 Query 获取数据 基本查询 客户端发送下面的数据给服务器
{ allPersons { name } } allPersons 是根字段（root field），它下面的成为查询的 payload，这里仅包含了一个 name。
服务器返回的结果会是这样的：
{ "allPersons": [ { "name": "Johnny" }, { "name": "Sarah" }, { "name": "Alice" } ] } 可以看到只返回了 name 字段，age 字段是不会返回的。...</p>
</section>
<footer class=entry-footer><span title="2018-11-08 18:28:13 +0000 UTC">November 8, 2018</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to graphql" href=https://zhenfeng-zhu.github.io/posts/graphql/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>go-best-practice
</h2>
</header>
<section class=entry-content>
<p> 短变量名称在声明和上次使用之间的距离很短时效果很好。 长变量名称需要证明自己的合理性; 名称越长，需要提供的价值越高。冗长的名称与页面上的重量相比，信号量较小。 请勿在变量名称中包含类型名称。 常量应该描述它们持有的值，而不是该如何使用。 对于循环和分支使用单字母变量，参数和返回值使用单个字，函数和包级别声明使用多个单词 方法、接口和包使用单个词。 请记住，包的名称是调用者用来引用名称的一部分，因此要好好利用这一点。 变量的名称应描述其内容，而不是内容的类型。
典型错误：
var usersMap map[string]*User 如果users的描述性都不够用，那么usersMap也不会。
声明变量但没有初始化时，请使用 var。
在声明和初始化时，使用:=。
关于变量和常量的注释应描述其内容而非其目的 任何既不明显也不简短的公共功能必须予以注释。 无论长度或复杂程度如何，对库中的任何函数都必须进行注释 在编写函数之前，请编写描述函数的注释。 如果你发现很难写出注释，那么这就表明你将要编写的代码很难理解。
以包所提供的内容来命名，而不是它包含的内容。
避免使用类似base，common或util的包名称 尽早return而不是深度嵌套 使用internal包来减少公共 API 不鼓励使用nil作为参数 首选可变参数函数而非[]T参数 通过消除错误来消除错误处理 使用github.com/pkg/errors包装errors 永远不要启动一个停止不了的 goroutine </p>
</section>
<footer class=entry-footer><span title="2018-11-07 17:16:07 +0000 UTC">November 7, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to go-best-practice" href=https://zhenfeng-zhu.github.io/posts/go-best-practice/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>kubernetes
</h2>
</header>
<section class=entry-content>
<p>docker 利用 Linux 的 cgroups 和 namespace，构建一个沙箱运行环境。
docker 镜像 其实就是一个压缩包，这个压缩包是由一个完整的操作系统的所有文件目录构成，包含了这个应用运行所需要的所有依赖，所以本地开发环境和测试环境是一样的。
解决了应用打包的根本性问题。
容器编排 对 Docker 容器的一系列定义、配置和创建动作的管理
容器本身没有价值，有价值的是“容器编排”。
原理 容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造一个“边界”。
在创建一个容器进程的时候，指定了这个进程所需要启动的一组 Namespace 参数，这样容器就只能看到当前 Namespace 所限定的资源、文件、设备、状态或配置。
Cgroups 主要作用是为一个进程组设置资源上限，如 CPU、内存、磁盘和带宽等。也可以设置进程优先级，审计，挂起，重启等。
因此，一个正在运行的 Docker 容器，其实就是一个启用了多个 Namespace 的应用进程，而这个进程能够使用的资源是由 Cgroups 来限制。
挂载在容器根目录上，用来为容器进程提供隔离后执行环境的文件系统，就是容器镜像，rootfs。
启动 Namespace 配置 设置 Cgroups 参数 切换进程根目录 rootf docker 镜像设计时，引入了层（layer），用户制作镜像的每一步操作都会生成一个层，也就是一个增量的 rootfs。AuFS，所以就有了共享层，镜像不用那么大。
一个进程，可以选择加入到某个进程已有的 Namespace 当中，从而达到进入这个进程所在的容器的目的，这正是 docker exec 的实现原理。
volume 机制，允许你将宿主机上指定的目录或文件，挂载到容器里面进行读取和修改操作。
主要依赖 Linux 依赖三大技术 Namespace Cgroups rootfs 和虚拟机比较 虚拟机是通过硬件虚拟化功能，模拟一套操作系统所需要的各种硬件，如 CPU、内存、IO 设备等，然后安装一个新的操作系统。
docker 是利用 Linux 的 Namespace 原理，帮助用户启动的还是系统的应用进程，只是加了一些参数，限制其能看到的资源。因此相对于虚拟机资源消耗更小，而且轻量级，敏捷高性能。...</p>
</section>
<footer class=entry-footer><span title="2018-10-08 15:29:21 +0000 UTC">October 8, 2018</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to kubernetes" href=https://zhenfeng-zhu.github.io/posts/kubernetes/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>watchdog
</h2>
</header>
<section class=entry-content>
<p>监视器
监视器提供了一个外部世界和函数之间的非托管的通用接口。它的工作是收集从 API 网关来的 HTTP 请求，然后调用程序。监视器是一个小型的 Golang 服务——下图展示了它是如何工作的：
上图：一个小型的 web 服务，可以为每个传入的 HTTP 请求分配所需要的进程。
每个函数都需要嵌入这个二进制文件并将其作为ENTRYPOINT 或 CMD，实际上是把它作为容器的初始化进程。一旦你的进程被创建分支，监视器就会通过stdin 传递 HTTP 请求并从stdout中读取 HTTP 响应。这意味着你的程序无需知道 web 和 HTTP 的任何信息。
轻松创建新函数 从 CLI 创建一个函数
创建函数最简单的方法是使用 FaaS CLI 和模板。CLI 抽象了所有 Docker 的知识，使得你只需要编写所支持语言的 handler 文件即可。
你的第一个使用 OpenFaaS 的无服务器 Python 函数 阅读有关 FaaS CLI 的教程 深入研究 Package your function 打包你的函数
如果你不想使用 CLI 或者现有的二进制文件或镜像，可以使用下面的方法去打包函数：
使用一个现有的或者一个新的 Docker 镜像作为基础镜像 FROM 通过curl 或 ADD https://从 Releases 页面 添加 fwatchdog 二进制文件 为每个你要运行的函数设置 fprocess(函数进程) 环境变量 Expose port 8080 暴露端口 8080 Set the CMD to fwatchdog 设置 CMD为fwatchdog 一个echo函数的示例 Dockerfile：...</p>
</section>
<footer class=entry-footer><span title="2018-09-06 16:23:57 +0000 UTC">September 6, 2018</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to watchdog" href=https://zhenfeng-zhu.github.io/posts/watchdog/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>queue-worker
</h2>
</header>
<section class=entry-content>
<p>queue-worker 源码分析 异步函数和同步函数 在 OpenFaaS 中同步调用函数时，将会连接到网关，直到函数成功返回才会关闭连接。同步调用是阻塞的。
网关的路由是：/function/&lt;function_name> 必须等待 在结束的时候得到结果 明确知道是成功还是失败 异步函数会有一些差异：
网关的路由是：/async-function/&lt;function_name> 客户端获得 202 的即时响应码 从 queue-worker 中调用函数 默认情况下，结果是被丢弃的。 查看 queue-worker 的日志 docker service logs -f func_queue-worker 利用 requestbin 和 X-Callback-Url 获取异步函数的结果 如果需要获得异步函数的结果，有两个方法：
更改代码，将结果返回给端点或者消息系统 利用内置的回调 内置的回调将会允许函数提供一个 url，queue-worker 会报告函数的成功或失败。 requestbin 会创建一个新的 bin，这是互联网的一个 url 地址，可以从这里获取函数的结果。 源码分析 依赖项 github.com/nats-io/go-nats-streaming github.com/nats-io/go-nats github.com/openfaas/faas go-nats 和 go-nats-streaming 是 nats 和 nats-streaming 的 go 版本的客户端。
faas 这个依赖其实是只用到了 queue 包下面的 types.go 文件。这个文件是定义了异步请求的 Request 结构体和一个 CanQueueRequests 接口。如下所示：...</p>
</section>
<footer class=entry-footer><span title="2018-09-06 16:23:12 +0000 UTC">September 6, 2018</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to queue-worker" href=https://zhenfeng-zhu.github.io/posts/queue-worker/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>区块链学习笔记
</h2>
</header>
<section class=entry-content>
<p>本文是阅读http://www.netkiller.cn/blockchain/ch01s10.html 上的一些笔记。
理解区块链的分布式记账 http://www.netkiller.cn/blockchain/ch01s10.html
区块链中提到的账本，记账等词汇是和会计无关的词汇。
我们传统理解的账本是一个二维的表格，记录了某年某月某日的费用：
时间 用途 金额 2018-08-23 借 100 2018-08-22 还 200 2018-08-21 借 50 2018-08-20 还 1000 如果账目比较多，可以拆账，将不同分类的账目放在特定的账本中，而且二维表格还可以设置索引等，快速找到一笔交易。
但是区块链的记账形式是：
可以发现，区块链的这种记账方式是做了行列矩阵转换，节点之间收尾相互连接，成为链式结构，所有的账目都在一条链上。
所谓分布式记账，其实就是上述链状的数据结构保存在所有的节点上，形成分布式集群。
之所以采用区块链来做分布式记账，主要是区块链有如下好处：
去中心化
传统的数据库存储是中心化的，通过暴露 ip 地址和端口号提供服务，后来分布式进群化之后，出现了主主从架构等。
与数据库相比，区块链是多主架构，而且实现更为复杂，节点之间的数据之间不是简单的二进制日志同步，而是要通过加密技术，节点达成共识之后才存储。
可追溯
安全
安全分为很多层，区块链只能做到存储层的安全。
区块链无法解决用户层，应用层，逻辑层等安全问题，他只能保证存储在硬盘上的区块不被修改。
不可篡改
很多人认为区块链数据一旦创建之后就不能修改，所以采用区块链技术很安全。其实不然，数据是可以修改的，但是不能篡改。
撰改是指非法修改区块链数据，而修改则是合法变更数据。
通常撰改区块链数据多指数据存储层面的修改。而修改则是通过合约提供的修改函数变更区块链里面的数据。
多数区块链平台没有用户认证权限管理模块。所以无法控制区块中的哪些数据能被修改，哪些不能修改，哪些用户可以修改等等。即使有些区块链平台具备权限控制，颗粒度也无法达到目前的数据库控制的那么细。
采用区块链作为账本的时候，会面临如下几个问题：
不能建立索引，无法快速搜索出区块中的数据，必须依赖区块链以外的技术，如搜索引擎，数据库等。例如；etherscan....</p>
</section>
<footer class=entry-footer><span title="2018-08-23 15:14:02 +0000 UTC">August 23, 2018</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to 区块链学习笔记" href=https://zhenfeng-zhu.github.io/posts/blockchain/></a>
</article>
<footer class=page-footer>
<nav class=pagination>
<a class=prev href=https://zhenfeng-zhu.github.io/page/3/>« Prev Page</a>
<a class=next href=https://zhenfeng-zhu.github.io/page/5/>Next Page »</a>
</nav>
</footer>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://zhenfeng-zhu.github.io>Awesome Fenix</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>