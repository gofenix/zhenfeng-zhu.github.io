<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Awesome Fenix</title>
<meta name=keywords content>
<meta name=description content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod">
<meta name=author content="Fenix">
<link rel=canonical href=https://zhenfeng-zhu.github.io/>
<link href=/assets/css/stylesheet.min.8d754ccb970fef4a6d8e5b0441e01d76a0d3530c6777067a1b2ca581aa1b4af7.css integrity="sha256-jXVMy5cP70ptjlsEQeAddqDTUwxndwZ6GyylgaobSvc=" rel="preload stylesheet" as=style>
<link rel=icon href=https://zhenfeng-zhu.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://zhenfeng-zhu.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://zhenfeng-zhu.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://zhenfeng-zhu.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://zhenfeng-zhu.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.91.0">
<link rel=alternate type=application/rss+xml href=https://zhenfeng-zhu.github.io/index.xml>
<link rel=alternate type=application/json href=https://zhenfeng-zhu.github.io/index.json>
<meta property="og:title" content="Awesome Fenix">
<meta property="og:description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod">
<meta property="og:type" content="website">
<meta property="og:url" content="https://zhenfeng-zhu.github.io/">
<meta property="og:image" content="https://zhenfeng-zhu.github.io/papermod-cover.png">
<meta property="og:updated_time" content="2021-12-20T09:58:58+08:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhenfeng-zhu.github.io/papermod-cover.png">
<meta name=twitter:title content="Awesome Fenix">
<meta name=twitter:description content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Awesome Fenix","url":"https://zhenfeng-zhu.github.io","description":"Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod","thumbnailUrl":"https://zhenfeng-zhu.github.io/favicon.ico","sameAs":["https://github.com/zhenfeng-zhu","index.xml"]}</script>
</head>
<body class=list id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhenfeng-zhu.github.io accesskey=h title="Awesome Fenix (Alt + H)">Awesome Fenix</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu onscroll=menu_on_scroll()>
<li>
<a href=https://zhenfeng-zhu.github.io/about title=About>
<span>About</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/search/ title=🔍>
<span>🔍</span>
</a>
</li></ul>
</nav>
</header>
<main class=main>
<article class=post-entry>
<header class=entry-header>
<h2>
elasticsearch
</h2>
</header>
<section class=entry-content>
<p>以前没有好好学的东西，现在在工作中慢慢的补回来了。
基础概念 索引 es是将数据存储在一个或者多个索引（index）中。
索引就像是数据库。
文档 文档是es的实体。由字段构成，每个字段包含字段名和一个或者多个字段值。
文档就像数据库中的一条条记录。
类型 每个文档都有一个类型与之相对应。
类型就像数据库中的表。
映射 所有文档在被写入到es中，都会被分析。由用户设置一些参数决定如何分割词条、哪些字应该被过滤掉等等。
节点 单个es服务实例就是一个节点。
集群 多个协同工作的es节点的集合就是集群。
分片 es将数据分散到多个物理的Lucene索引上，这些物理Lucene索引被称为分片。
副本 副本就是每个分片都做冗余处理，一个宕机之后，不影响服务。
快速入门 安装 es的安装很简单，我这里使用的是mac，下载下来zip包，解压即可使用。
[elasticsearch-6.2.4] pwd /Users/zhuzhenfeng/Documents/software/elasticsearch-6.2.4 [elasticsearch-6.2.4] ./bin/elasticsearch Java HotSpot(TM) 64-Bit Server VM warning: Option UseConcMarkSweepGC was deprecated in version 9.0 and will likely be removed in a future release. [2018-05-20T17:18:37,619][INFO ][o.e.n.Node ] [] initializing ....</p>
</section>
<footer class=entry-footer>
May 20, 2018&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix
</footer>
<a class=entry-link aria-label="post link to elasticsearch" href=https://zhenfeng-zhu.github.io/posts/elasticsearch/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>
git常用操作
</h2>
</header>
<section class=entry-content>
<p>整理一下常用的git操作，不用再到处找了。
git放弃本地修改，强制更新 git fetch --all git reset --hard origin/master git修改远程仓库地址 git remote set-url origin url cherry-pick 当你通过一番挣扎终于搞定一个bug,顺手提交到 git 服务器,心里一阵暗爽. 这时发现你当前所在的分支是 master !!!
这个分支不是开发者用来提交代码的,可惜现在剁手也晚了.
先切换到master git checkout master git log 复制提交的commit id
切换到dev, cherry-pick
git checkout dev git cherry-pic ${commit_id} 常用开发流程 git checkout -b feature1
git commit之后，进行rebase
git pull –rebase
gca!
git rvm...</p>
</section>
<footer class=entry-footer>
May 14, 2018&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix
</footer>
<a class=entry-link aria-label="post link to git常用操作" href=https://zhenfeng-zhu.github.io/posts/git/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>
node的cluster
</h2>
</header>
<section class=entry-content>
<p>我们知道js是运行单线程的，也就是说一个node进程只能运行在一个cpu上。那么如果用node来做web server的话，就无法享受到多核运算的好处。
一个问题就是：
如何榨干服务器资源，利用多核CPU的并发优势。 node官方提供的解决方案是cluster。
1 cluster是什么 简单来说：
在服务器上同时启动多个进程。 每个进程都跑的是同一份源码。 这些进程可以同时监听一个端口。 其中：
负责启动其他进程的叫做master进程，不做具体工作，只负责启动其他进程。 其他被启动的叫worker进程。他们接收请求，对外提供服务。 worker进程的数量一般根据服务器的cpu核数来决定，这样就可以完美利用多核资源。 以下是官方文档的一个例子：
const cluster = require('cluster'); const http = require('http'); const numCPUs = require('os').cpus().length; if (cluster.isMaster) { console.log(`主进程 ${process.pid} 正在运行`); // 衍生工作进程。 for (let i = 0; i &lt; numCPUs; i++) { cluster.fork(); } cluster.on('exit', (worker, code, signal) => { console.log(`工作进程 ${worker.process.pid} 已退出`); }); } else { // 工作进程可以共享任何 TCP 连接。 // 在本例子中，共享的是一个 HTTP 服务器。 http....</p>
</section>
<footer class=entry-footer>
May 5, 2018&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix
</footer>
<a class=entry-link aria-label="post link to node的cluster" href=https://zhenfeng-zhu.github.io/posts/node%E7%9A%84cluster/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>
node踩坑
</h2>
</header>
<section class=entry-content>
<p>module 首先第一个就是es6的module。
看到别人写的
import { a } from "./module"; 所以自己也想要这么写，但是每次运行的时候都会报错。
// demo2.js export const a = "hello"; //demo1.js import { a } from "./demo2"; function hello() { console.log(a); } zhuzhenfengdeMacBook-Pro :: node/node-example » node demo1.js /Users/zhuzhenfeng/Documents/github/node/node-example/demo1.js:1 (function (exports, require, module, __filename, __dirname) { import { a } from "./demo2"; ^ SyntaxError: Unexpected token { at new Script (vm.js:74:7) at createScript (vm.js:246:10) at Object.runInThisContext (vm.js:298:10) at Module._compile (internal/modules/cjs/loader.js:646:28) at Object.Module._extensions..js (internal/modules/cjs/loader.js:689:10) at Module....</p>
</section>
<footer class=entry-footer>
May 5, 2018&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix
</footer>
<a class=entry-link aria-label="post link to node踩坑" href=https://zhenfeng-zhu.github.io/posts/node%E8%B8%A9%E5%9D%91/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>
node学习笔记
</h2>
</header>
<section class=entry-content>
<p>写node也有一段时间了，整理一下学习笔记，共同进步
什么是node？ 首先看一下什么是node.js
Node 是一个服务器端 JavaScript Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效 Node.js 的包管理器 npm，是全球最大的开源库生态系统 模块系统是node最基本也是最常用的。一般可以分为四类：
原生模块 文件模块 第三方模块 自定义模块 node社区崇尚DRY文化，即Don’t repeate yourself。这种文化使得node的生态异常繁荣，同样也由于某些包的质量低下引来了一些诟病。
谈谈自定义模块 我们在写node程序的时候，一般都是在写自定义模块。
创建模块
// b.js function FunA(){ return "hello world"; } // 暴露方法FunA module.exports = FunA; 加载模块
// a.js const FunA=require('./b.js'); // 运行FunA const name=FunA(); console.log(name); 在做模块到处的时候有两种方式：
module.exports
module.exports 就 Node....</p>
</section>
<footer class=entry-footer>
April 22, 2018&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Fenix
</footer>
<a class=entry-link aria-label="post link to node学习笔记" href=https://zhenfeng-zhu.github.io/posts/node-learning/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>
node的redis实战
</h2>
</header>
<section class=entry-content>
<p>Node.js Redis客户端模块 为了追新，这里我使用的yarn，毕竟我是HDD（面向热点编程）编程实践者。
模块安装
yarn add redis 模块使用实例
const redis = require('redis') const client = redis.createClient('6379', '127.0.0.1') client.on("error", function (err) { console.log("Error " + err); }); client.set("string key", "string val", redis.print); client.hset("hash key", "hashtest 1", "some value", redis.print); client.hset(["hash key", "hashtest 2", "some other value"], redis.print); client.hkeys("hash key", function (err, replies) { console.log(replies.length + " replies:"); replies.forEach(function (reply, i) { console.log(" " + i + ": " + reply); }); client....</p>
</section>
<footer class=entry-footer>
April 13, 2018&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix
</footer>
<a class=entry-link aria-label="post link to node的redis实战" href=https://zhenfeng-zhu.github.io/posts/node%E7%9A%84redis%E5%AE%9E%E6%88%98/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>
谈谈web框架
</h2>
</header>
<section class=entry-content>
<p>这篇文章打的标签比较多，也基本涵盖了我所了解的一些知识，归纳总结一下自己对web框架的理解。自己了解的也不是很多，也请多多指教。
写程序免不了要做web相关的，现在由于前后端的分离，后端一般只提供rest接口，前端一般使用node来做渲染。在之前使用jsp那一套的时候，基本上都要写html+js的前端的一套，也要写后端java的CRUD。
我理解的web框架中，大致是分为这么两类：
router框架 mvc框架 mvc类框架 mvc，初级程序员面试笔试的时候必考的一个知识点。model-view-controller，即模型-视图-控制器。
m，模型主要用于封装与应用程序相关的数据以及对数据的处理方法。 v，在 View 中一般没有程序上的逻辑。为了实现 View 上的刷新功能，View 需要访问它监视的数据模型（Model），因此应该事先在被它监视的数据那里注册。 c，用于控制应用程序的流程。 我了解比较多的mvc框架是spring mvc。spring、spring mvc和spring boot等，他们并不是一个概念，也不是仅仅用于web开发。但是在这里我就不分那么细，统一用spring来代替。这里所说的spring都是指狭义上的web开发方面。
在做web开发的时候，项目目录一般是这样的：
$ tree [16:23:43] . ├── mvnw ├── mvnw.cmd ├── pom.xml └── src ├── main │ ├── java │ │ └── com │ │ └── example │ │ └── demo │ │ └── DemoApplication.java │ └── resources │ ├── application.properties │ ├── static │ └── templates └── test └── java └── com └── example └── demo └── DemoApplicationTests....</p>
</section>
<footer class=entry-footer>
April 8, 2018&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix
</footer>
<a class=entry-link aria-label="post link to 谈谈web框架" href=https://zhenfeng-zhu.github.io/posts/%E8%B0%88%E8%B0%88web%E6%A1%86%E6%9E%B6/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>
技术栈
</h2>
</header>
<section class=entry-content>
<p>创业公司真的比较锻炼人，接触了很多的东西，视野开阔了，但是在某些时候自己疲于奔命，每个东西都是接触了一点点就被赶鸭子上架开始开发了。
技术栈 Docker docker是一个容器，以前就看过docker相关的东西，但是没有仔细研究，docker的命令会用一些，在工作中使用了，看了一本docker的书，能够编写docker的compose文件。
rancher rancher是一个做容器管理的。我们把主机添加到rancher中，他就可以自动做到LB，服务的发现编排。我们部署的时候只需要编写catalog，他就可以自动发现docker应用，然后拉取镜像，部署到相关的机器上，很是方便。
aws 近期主要是对aws的进行公司服务的部署，搭建一套rancher的环境。aws的服务特别多，ec2是实例主机，就和虚拟机一样，VPC就像机房，ec2依托于VPC而存在，在这基础上又了解了子网、DHCP弹性IP等等。
kotlin 之前自己用kotlin开发过一个博客，对kotlin的感觉是有些东西写的很爽，但是还是觉得java好用一些，对kotlin的态度是用不用都无所谓。
guice 这个我之前都读错了，我读成了盖斯，其实是和果汁的英文发音很像，ju斯。只是一个依赖注入框架，只是单纯的去做DI，比spring更轻量级一些。
需要我们编写AppModule.java去手动配置哪个类注入哪个类。
rxjava rxjava我都没有找到一个系统的教程，不知道该从哪里学习。
vertx vertx+Reactive编程的方式相当考验心智，自己脑子中的编程方式还没转过来。
ES6 node代码中都是用es6来写的，async和await现在也会用了。
express 想到自己大学的时候看过node的书，里面讲的就是express，只是自己当时没想明白，现在看的回调多了，算是熟悉了他这种的编程模式，所以觉得express特别简单易上手。
typescript 还没它去写东西，可能下周会用它来写个机器人。
貌似自己已经完全抛弃了spring+java的那一套东西，没机会用到。
知识面扩展 监控 grafana+Prometheus+graylog去做可视化和日志的监控。
对于业务的数据，需要在代码层面进行埋点，把要监控的数据传给普罗米修斯。
FSM状态机 机器人的框架使用的是FSM状态机来管理，以前做游戏的时候接触过。
网关 网关现在已经是微服务架构中的标配了，用它来做一些限流，LB和日志收集等等。
我们使用的是kong，在这里kong加上一些插件，相当好用。
规则引擎 在规则引擎中，都是一个个规则。
DSL 领域特定语言，在规则引擎和机器人的时候，就用了DSL。我现在的理解就是DSL就是用编程语言实现的一些函数。
Key Transparency 谷歌的一个公钥管理库，保证了无法被篡改。...</p>
</section>
<footer class=entry-footer>
April 5, 2018&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix
</footer>
<a class=entry-link aria-label="post link to 技术栈" href=https://zhenfeng-zhu.github.io/posts/%E6%8A%80%E6%9C%AF%E6%A0%88/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>
同步一个 fork
</h2>
</header>
<section class=entry-content>
<p>具体方法 Configuring a remote for a fork 给 fork 配置一个 remote 主要使用 git remote -v 查看远程状态。 git remote -v # origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) # origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) 添加一个将被同步给 fork 远程的上游仓库 git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git 再次查看状态确认是否配置成功。 git remote -v # origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) # origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) # upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch) # upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push) Syncing a fork 从上游仓库 fetch 分支和提交点，传送到本地，并会被存储在一个本地分支 upstream/master git fetch upstream git fetch upstream # remote: Counting objects: 75, done....</p>
</section>
<footer class=entry-footer>
April 4, 2018&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix
</footer>
<a class=entry-link aria-label="post link to 同步一个 fork" href=https://zhenfeng-zhu.github.io/posts/%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA-fork/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>
Go语言体会
</h2>
</header>
<section class=entry-content>
<p>最近公司要统一技术栈，在kotlin和go之间选。我心里是比较倾向go的，主要有如下几点体会。
语言简单，上手快。 gorotuine 易发布 垃圾回收 约定大于配置 我最早听说协程，是在大三找实习的时候，那个时候面试会问线程和进程的关系，问的深一些就是协程和线程的区别。游戏公司基本都用lua，看了lua的资料后，对协程有了一些自己的了解，随后就是在做Unity相关的开发，在unity中使用了很多的协程，但是在unity中使用的协程好像跟主流的不太一样，在看了go之后，豁然开朗。
goroutine使用的内存比线程更少，go在运行的时候会自动在配置的一组逻辑处理器上调度执行。比如：
func log(msg string){ ... } go log("") 使用关键字go，即可让log函数在一个goroutine里执行了。
并发最难的部分是要确保其他并发运行的进程、线程或者goroutine不会以外的修改数据。go使用了Channel的方式来解决这个问题。对于通道模式，保证同一时刻只会有一个goroutine修改数据。
说起go的语言简单，其实主要是他的类型比较简单。go使用的是组合模式，只需要将一个类型嵌入到另外一个类型就可以复用所有的功能。而且go还具有独特的接口实现机制，允许用户对行为进行建模，在go中不需要声明某个类型实现了某个接口，编译器会自动判断一个实例是使用什么接口。
对于java来说，所有的设计都是围绕着接口展开，于是在设计模式中，就是面向接口编程：
interface User{ void login(); void logout(); } 在java中，继承的类必须显式声明继承了此接口。而在go中接口只是描述一个动作，如果说是实现这个接口，只需要让某个实例实现了这个接口中的所有方法就行了。
type Reader interface{ Read(p []byte))(n int, err error) } 这其实和传统的oop语言的接口有着本质的区别，go中的接口一般只定义一个单一的动作，实际使用的过程中，这更有利于使用组合来复用代码。
约定大于配置这点，go在这方面上做的感觉有点儿吹毛求疵了，但是这样也使得程序可读性更强，没有很多垃圾代码。比如go的文件结构必须是src pkg 和bin 三个包，而且go也不允许你声明一个变量却不使用，导入了一个包却不使用，而且程序的代码也有约定，init方法比main方法更早执行。
go的并发 说到并发，就会想到另外一个概念，并行。可以简单这样的理解：
并发是同时管理多个事情，而并行是同时做很多事情。也就是并发是manage，并行是run。 对于单核处理器来讲，同一时刻只能有一个任务在执行，那么并发就是同时管理多个任务，让他们交替执行。并行是针对于多核处理器的，同一时刻可以把多个任务放在不同的处理器上执行，这样就可以同时执行。
在go里面主要是采用协程来实现并发的，也就是goroutine。与其他语言不同的是，go是在语法层面做到的，即go func();
语法 go f(x, y) go是关键字，后面跟函数。
例子 package main import ( "log" "time" ) func doSomething(id int) { log.Printf("before do job:(%d) \n", id) time....</p>
</section>
<footer class=entry-footer>
April 4, 2018&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix
</footer>
<a class=entry-link aria-label="post link to Go语言体会" href=https://zhenfeng-zhu.github.io/posts/go%E8%AF%AD%E8%A8%80%E4%BD%93%E4%BC%9A/></a>
</article>
<footer class=page-footer>
<nav class=pagination>
<a class=prev href=https://zhenfeng-zhu.github.io/page/6/>« Prev Page</a>
<a class=next href=https://zhenfeng-zhu.github.io/page/8/>Next Page »</a>
</nav>
</footer>
</main><footer class=footer>
<span>&copy; 2021 <a href=https://zhenfeng-zhu.github.io>Awesome Fenix</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>