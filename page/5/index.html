<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Go Data</title>
<meta name=keywords content>
<meta name=description content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod">
<meta name=author content="Lucas">
<link rel=canonical href=https://zhenfeng-zhu.github.io/>
<link href=/assets/css/stylesheet.min.8d754ccb970fef4a6d8e5b0441e01d76a0d3530c6777067a1b2ca581aa1b4af7.css integrity="sha256-jXVMy5cP70ptjlsEQeAddqDTUwxndwZ6GyylgaobSvc=" rel="preload stylesheet" as=style>
<link rel=icon href=https://zhenfeng-zhu.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://zhenfeng-zhu.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://zhenfeng-zhu.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://zhenfeng-zhu.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://zhenfeng-zhu.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.91.0">
<link rel=alternate type=application/rss+xml href=https://zhenfeng-zhu.github.io/index.xml>
<link rel=alternate type=application/json href=https://zhenfeng-zhu.github.io/index.json>
<meta property="og:title" content="Go Data">
<meta property="og:description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod">
<meta property="og:type" content="website">
<meta property="og:url" content="https://zhenfeng-zhu.github.io/">
<meta property="og:image" content="https://zhenfeng-zhu.github.io/papermod-cover.png">
<meta property="og:updated_time" content="2021-12-20T09:58:58+08:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhenfeng-zhu.github.io/papermod-cover.png">
<meta name=twitter:title content="Go Data">
<meta name=twitter:description content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Go Data","url":"https://zhenfeng-zhu.github.io","description":"Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod","thumbnailUrl":"https://zhenfeng-zhu.github.io/favicon.ico","sameAs":["https://github.com/zhenfeng-zhu","index.xml"]}</script>
</head>
<body class=list id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhenfeng-zhu.github.io accesskey=h title="Go Data (Alt + H)">Go Data</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu onscroll=menu_on_scroll()>
<li>
<a href=https://zhenfeng-zhu.github.io/about title=About>
<span>About</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/search/ title=🔍>
<span>🔍</span>
</a>
</li></ul>
</nav>
</header>
<main class=main>
<article class=post-entry>
<header class=entry-header>
<h2>
dive-into-redis
</h2>
</header>
<section class=entry-content>
<p>redis持久化，
机制有两种：
快照：全量备份，二进制序列化，存储紧凑 AOF日志：连续的增量备份，内存数据修改的文本 ...</p>
</section>
<footer class=entry-footer>
August 20, 2018&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Lucas
</footer>
<a class=entry-link aria-label="post link to dive-into-redis" href=https://zhenfeng-zhu.github.io/posts/dive-into-redis/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>
golang踩坑
</h2>
</header>
<section class=entry-content>
<p>一 x509 error when using HTTPS inside a Docker container
因为docker中没有CA证书。
普通的镜像解决办法
FROM ubuntu:14.04.1 RUN apt-get update RUN apt-get install -y ca-certificates CMD curl https://www.google.com 如果是alpine的参考这个：
FROM docker.finogeeks.club/base/alpine MAINTAINER "zhuzhenfeng@finogeeks.club" RUN set -ex \ && apk add --no-cache ca-certificates COPY src/wallet/wallet /opt/wallet ENTRYPOINT /opt/wallet 二 panic: runtime error: invalid memory address or nil pointer dereference [signal 0xb code=0x1 addr=0x38 pc=0x26df]
“An error is returned if caused by client policy (such as CheckRedirect), or if there was an HTTP protocol error....</p>
</section>
<footer class=entry-footer>
August 14, 2018&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Lucas
</footer>
<a class=entry-link aria-label="post link to golang踩坑" href=https://zhenfeng-zhu.github.io/posts/golang%E8%B8%A9%E5%9D%91/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>
以太坊开发总结
</h2>
</header>
<section class=entry-content>
<p>最近因公司项目需要，做为一个打杂工程师，操起键盘和笔记本开始了以太坊的踩坑之旅。以太坊的开发比较新，变化也比较多，还好有@cctanfujun的手把手带领下，半只脚踏入了以太坊的开发的大门。
在这篇文章中，我将会简单介绍一下以太坊的基本概念，以及我现在用到的一些工具，还有具体的一个开发流程。因为我还没有接触到如何上主链，所以这些都是基于测试链讲解。希望能给大家带来一些帮助。
什么是区块链
相信大家对区块链都有自己的理解，不仅仅是互联网公司，传统企业也在“币改转型”。
**简言之，区块链就是数据库。**它是特定数据的数据库，里面的数据不断增长，具有非凡特性：
一旦数据存储于数据库，永远都无法被修改或删除。区块链上的每个记录会被永久保存下来。 没有单独的个人或组织能维护该数据库。必须要上千个人才行，每个人都有数据库的副本。 什么是以太坊？
以太坊（英语：Ethereum）是一个开源的有智能合约功能的公共区块链平台[1][2]。通过其专用加密货币以太币（Ether，又称“以太币”）提供去中心化的虚拟机（称为“以太虚拟机”Ethereum Virtual Machine）来处理点对点合约。
为什么选择以太坊？
智能合约
代币
资料相对完善，相对容易开发
大佬对以太坊比较熟悉
大佬对以太坊比较熟悉
大佬对以太坊比较熟悉
重要的事情说三遍，有一个经验丰富的人带领，做东西肯定事半功倍。
自己动手写区块链
这里提供两个教程，一个是书，一个是视频。其中视频和书是对应的，不清楚是不是同一个作者。
Blockchain Tutorial
私有区块链，我们一起GO
以太坊开发
由于我是专注于后端的开发，现在的技术栈是
node go 正式进入以太坊的开发。这是我这段时间接触到的一些资源：
go-ethereum：也就是geth，官方的go版本的客户端
solidity：智能合约编程语言
truffle：智能合约的编程框架，基于nodejs
Ganache：启动了多个节点本地私链
Rinkeby：以太坊测试链
Etherscan：以太坊区块链浏览器，可以查询交易
MetaMask：chrome的钱包插件...</p>
</section>
<footer class=entry-footer>
August 10, 2018&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Lucas
</footer>
<a class=entry-link aria-label="post link to 以太坊开发总结" href=https://zhenfeng-zhu.github.io/posts/eth-tools/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>
以太坊
</h2>
</header>
<section class=entry-content>
<p>参与了公司的一个项目，上了以太坊，这里简单记录一下踩坑。
首先先把go的依赖下载下来：
go get -u -v github.com/ethereum/go-ethereum 有时候下载的很慢，可以从github上拉下来代码。
账户 以太坊的地址在离线状态下也可以创建到。
创建账户有两种方式：
以公钥和私钥的形式创建 func CreateAccount() (string, error) { key, err := crypto.GenerateKey() if err != nil { log.Fatalln(err) return "", nil } address := crypto.PubkeyToAddress(key.PublicKey).Hex() log.Println("address: ", address) privateKey := hex.EncodeToString(key.D.Bytes()) log.Println("privateKey: ", privateKey) return address, nil } 这种方式一般用的比较少。
以keystore的形式创建 keystore会创建一个文件，这个文件如下所示：
{ "address": "d93688757810e644f0b9c162102d9c598813f0dd", "crypto": { "cipher": "aes-128-ctr", "ciphertext": "71ae7c8144729b2f9e0c51d95c6dfb73e63f14b5332b3594e8a1f325237c27ed", "cipherparams": { "iv": "620c73001081c014a862ce80003a4648" }, "kdf": "scrypt", "kdfparams": { "dklen": 32, "n": 262144, "p": 1, "r": 8, "salt": "bd272aa37271ef9913eb095a4d143be238e348c48fce6459896e1bb1b0236741" }, "mac": "2b3ade771645090a2b34c214906c592a1300d529e459faefb1421ba496b6fe1d" }, "id": "e4dd5384-56a8-4ec7-b6e0-492dcd3742e9", "version": 3 } 在生成这个文件的时候，会让你输一个密码，这个文件加密码其实就是一个私钥。...</p>
</section>
<footer class=entry-footer>
August 7, 2018&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Lucas
</footer>
<a class=entry-link aria-label="post link to 以太坊" href=https://zhenfeng-zhu.github.io/posts/%E4%BB%A5%E5%A4%AA%E5%9D%8A/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>
contract
</h2>
</header>
<section class=entry-content>
<p>类型 Solidity是静态类型的语言。
值类型 bool int/uint fixed/unfixed address balance和transfer send call, callcode和delegatecall byte bytes 和 string 十六进制hex"0012" enum function 引用类型 数组
uint[]
结构体
struct
映射
mapping(key => value)
单元和全局变量 以太币的单位
在数字后面加上 wei、 finney、 szabo 或 ether。默认是wei
时间单位
数字后面带有 seconds、 minutes、 hours、 days、 weeks 和 years。默认是秒。
区块和交易
block.blockhash(uint blockNumber) returns (bytes32)：指定区块的区块哈希。 block.coinbase (address): 挖出当前区块的矿工地址 block....</p>
</section>
<footer class=entry-footer>
August 3, 2018&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Lucas
</footer>
<a class=entry-link aria-label="post link to contract" href=https://zhenfeng-zhu.github.io/posts/contract/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>
faas-provider
</h2>
</header>
<section class=entry-content>
<p>faas-provider是一个模板，只要实现了这个模板的接口，就可以自定义实现自己的provider。
faas-provider OpenFaaS官方提供了两套后台provider：
Docker Swarm Kubernetes 这两者在部署和调用函数的时候流程图如下：
部署一个函数
调用一个函数
provider要提供的一些API有：
List / Create / Delete 一个函数 /system/functions
方法: GET / POST / DELETE
获取一个函数 /system/function/{name:[-a-zA-Z_0-9]+}
方法: GET
伸缩一个函数 /system/scale-function/{name:[-a-zA-Z_0-9]+}
方法: POST
调用一个函数 /function/{name:[-a-zA-Z_0-9]+}
方法: POST
在provider的server.go的serve方法，可以看到这个serve方法创建了几个路由，接受一个FaaSHandler对象。
// Serve load your handlers into the correct OpenFaaS route spec. This function is blocking. func Serve(handlers *types.FaaSHandlers, config *types.FaaSConfig) { r.HandleFunc("/system/functions", handlers.FunctionReader).Methods("GET") r.HandleFunc("/system/functions", handlers....</p>
</section>
<footer class=entry-footer>
August 1, 2018&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Lucas
</footer>
<a class=entry-link aria-label="post link to faas-provider" href=https://zhenfeng-zhu.github.io/posts/faas-provider/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>
gateway-reading
</h2>
</header>
<section class=entry-content>
<p>OpenFaaS的Gateway是一个golang实现的请求转发的网关，在这个网关服务中，主要有以下几个功能：
UI 部署函数 监控 自动伸缩 架构分析 从图中可以发现，当Gateway作为一个入口，当CLI或者web页面发来要部署或者调用一个函数的时候，Gateway会将请求转发给Provider，同时会将监控指标发给Prometheus。AlterManager会根据需求，调用API自动伸缩函数。
源码分析 依赖 github.com/gorilla/mux github.com/nats-io/go-nats-streaming github.com/nats-io/go-nats github.com/openfaas/nats-queue-worker github.com/prometheus/client_golang mux 是一个用来执行http请求的路由和分发的第三方扩展包。
go-nats-streaming，go-nats，nats-queue-worker这三个依赖是异步函数的时候才会用到，在分析queue-worker的时候有说到Gateway也是一个发布者。
client_golang是Prometheus的客户端。
项目结构 ├── Dockerfile ├── Dockerfile.arm64 ├── Dockerfile.armhf ├── Gopkg.lock ├── Gopkg.toml ├── README.md ├── assets ├── build.sh ├── handlers │ ├── alerthandler.go │ ├── alerthandler_test.go │ ├── asyncreport.go │ ├── baseurlresolver_test.go │ ├── basic_auth.go │ ├── basic_auth_test.go │ ├── callid_middleware.go │ ├── cors.go │ ├── cors_test.go │ ├── forwarding_proxy.go │ ├── forwarding_proxy_test....</p>
</section>
<footer class=entry-footer>
August 1, 2018&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Lucas
</footer>
<a class=entry-link aria-label="post link to gateway-reading" href=https://zhenfeng-zhu.github.io/posts/gateway-reading/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>
NATS streaming
</h2>
</header>
<section class=entry-content>
<p>市面上常见到的和Nats功能类似的消息通信系统有：
ActiveMQ（Java编写）、KafKa（Scala编写）、RabbitMq（Ruby编写）、Nats（之前是Ruby编写现已修改为Go）、Redis（C语言编写）、Kestrel（Scala编写不常用）、NSQ（Go语言编写），这些消息通信系统在Broker吞吐量方面的比较：
可以看到NATS的吞吐量特别高， NATS原来是使用Ruby编写，可以实现每秒150k消息，后来使用Go语言重写，能够达到每秒8-11百万个消息，整个程序很小只有3M Docker image，它不支持持久化消息，如果你离线，你就不能获得消息。关于NATS的详细介绍，请参考上篇文章：NATS简介
NATS Streaming NATS Streaming是由NATS驱动的数据流系统，也是由go语言写成的，在保证吞吐量和时延的基础上，解决了Nats消息投递一致性的问题。nats streaming可以和核心nats平台无缝嵌入，扩展和互动。
功能 除了nats平台的一些功能，nats streaming还支持以下的：
增强的消息协议 消息/事件持久化 至少一次投递 发布者速率限制 每个订阅者的速率匹配/限制 可重复消费 持久订阅 使用 首先安装nats-streaming-server服务，有多种方式，这里介绍两种：
homebrew
直接在命令行启动
brew install nats-streaming-server go get
这种方式可以让我们直接运行源码启动
go get github.com/nats-io/nats-streaming-server 启动nats-streaming-server
有三种启动方式
直接启动
nats-streaming-server 开启nats监控的启动
nats-streaming-server -m 8222 源码方式启动
cd $GOPATH/src/github.com/nats-io/nats-streaming-server go run nats-streaming-server.go 客户端 直接下载go的客户端
go get github.com/nats-io/go-nats-streaming 运行发布者...</p>
</section>
<footer class=entry-footer>
July 30, 2018&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Lucas
</footer>
<a class=entry-link aria-label="post link to NATS streaming" href=https://zhenfeng-zhu.github.io/posts/nats-streaming/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>
nats简介
</h2>
</header>
<section class=entry-content>
<p>nats是一个开源的，云原生的消息系统。Apcera，百度，西门子，VMware，HTC和爱立信等公司都有在使用。
核心基于EventMachine开发，原理是基于消息发布订阅机制，每台服务器上的每个模块会根据自己的消息类别向MessageBus发布多个消息主题，而同时也向自己需要交互的模块，按照需要的主题订阅消息。能够达到每秒8-11百万个消息，整个程序很小只有3M Docker image，它不支持持久化消息，如果你离线，你就不能获得消息。使用nats streaming可以做到持久化，缓存等功能。
NATS server nats提供了一个go编写的轻量级服务器。发行版包括二进制和docker镜像
NATS clients
nats官方提供的客户端有Go，Node，Ruby，Java，C，C＃，NGINX等。
NATS 设计目标
核心原则是性能，可伸缩和易用性。
高效 始终在线和可用 非常轻巧 支持多种质量的服务 支持各种消息传递模型和使用场景 NATS 使用场景 nats是一个简单且强大的消息系统，为支持现代云原生架构设计。由于可伸缩性的复杂性，nats旨在容易使用和实现，且能提供多种质量的服务。
一些适用nats的场景有：
高吞吐量的消息分散 —— 少数的生产者需要将数据发送给很多的消费者。 寻址和发现 —— 将数据发送给特定的应用实例，设备或者用户，也可用于发现并连接到基础架构中的实例，设备或用户。 命令和控制（控制面板）—— 向程序或设备发送指令，并从程序/设备中接收状态，如SCADA，卫星遥感，物联网等。 负载均衡 —— 主要应用于程序会生成大量的请求，且可动态伸缩程序实例。 N路可扩展性 —— 通信基础架构能够充分利用go的高效并发/调度机制，以增强水平和垂直的扩展性。 位置透明 —— 程序在各个地理位置上分布者大量实例，且你无法了解到程序之间的端点配置详情，及他们所生产或消费的数据。 容错 使用nats-streaming的附加场景有：
从特定时间或顺序消费 持久性 有保证的消息投递 NATS消息传递模型 发布订阅 请求回复 排队 NATS的特点 nats的独特功能有：
纯净的pub-sub 集群模式的server 订阅者的自动裁剪 基于文本的协议 多种服务质量 最多一次投递 至少一次投递 持久 缓存 ...</p>
</section>
<footer class=entry-footer>
July 30, 2018&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Lucas
</footer>
<a class=entry-link aria-label="post link to nats简介" href=https://zhenfeng-zhu.github.io/posts/nats/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>
overview-of-openfaas
</h2>
</header>
<section class=entry-content>
<p>OpenFaaS概览 无服务器函数变得简单。
函数监视器 你可以通过添加函数监视器 (一个小型的Golang HTTP服务)把任何一个Docker镜像变成无服务器函数。 函数监视器是允许HTTP请求通过STDIN转发到目标进程的入口点。响应会从你应用写入STDOUT返回给调用者。 API网关/UI门户 API网关为你的函数提供外部路由，并通过Prometheus收集云原生指标。 你的API网关将会根据需求更改Docker Swarm 或 Kubernetes API中的服务副本数来实现伸缩性。 UI是允许你在浏览器中调用函数或者根据需要创建新的函数。 API网关是一个RESTful形式的微服务，你可以在这里查看Swagger文档。
命令行 Docker中的任何容器或者进程都可以是FaaS中的一个无服务器函数。使用FaaS CLI ，你可以快速的部署函数。
可以从Node.js, Python, Go 或者更多的语言模板中创建新的函数。如果你无法找到一个合适的模板，甚至可以使用一个Dockerfile。
CLI实际上是API网关的一个RESTful客户端。
在配置好OpenFaaS之后，你可以在这里开始学习CLI开始学习CLI
函数示例 你可以通过 使用FaaS-CLI和其内置的模板创建新函数，也可以在Docker中使用Windows或Linux的二进制文件。
Python示例： import requests def handle(req): r = requests.get(req, timeout = 1) print(req +" => " + str(r.status_code)) handler.py
Node.js示例： "use strict" module.exports = (callback, context) => { callback(null, {"message": "You said: " + context}) } handler....</p>
</section>
<footer class=entry-footer>
July 26, 2018&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Lucas
</footer>
<a class=entry-link aria-label="post link to overview-of-openfaas" href=https://zhenfeng-zhu.github.io/posts/overview-of-openfaas/></a>
</article>
<footer class=page-footer>
<nav class=pagination>
<a class=prev href=https://zhenfeng-zhu.github.io/page/4/>« Prev Page</a>
<a class=next href=https://zhenfeng-zhu.github.io/page/6/>Next Page »</a>
</nav>
</footer>
</main><footer class=footer>
<span>&copy; 2021 <a href=https://zhenfeng-zhu.github.io>Go Data</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>