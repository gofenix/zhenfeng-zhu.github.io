<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Awesome Fenix</title>
<meta name=description content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod">
<meta name=author content="Fenix">
<link rel=canonical href=https://zhenfeng-zhu.github.io/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<link rel=icon href=https://zhenfeng-zhu.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://zhenfeng-zhu.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://zhenfeng-zhu.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://zhenfeng-zhu.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://zhenfeng-zhu.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.91.2">
<link rel=alternate type=application/rss+xml href=https://zhenfeng-zhu.github.io/index.xml>
<link rel=alternate type=application/json href=https://zhenfeng-zhu.github.io/index.json>
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="Awesome Fenix">
<meta property="og:description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod">
<meta property="og:type" content="website">
<meta property="og:url" content="https://zhenfeng-zhu.github.io/"><meta property="og:image" content="https://zhenfeng-zhu.github.io/papermod-cover.png">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhenfeng-zhu.github.io/papermod-cover.png">
<meta name=twitter:title content="Awesome Fenix">
<meta name=twitter:description content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Awesome Fenix","url":"https://zhenfeng-zhu.github.io","description":"Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod","thumbnailUrl":"https://zhenfeng-zhu.github.io/favicon.ico","sameAs":["https://github.com/zhenfeng-zhu","index.xml"]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8502076734034112" crossorigin=anonymous></script>
</head>
<body class=list id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zhenfeng-zhu.github.io accesskey=h title="Awesome Fenix (Alt + H)">Awesome Fenix</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://zhenfeng-zhu.github.io/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/about title=About>
<span>About</span>
</a>
</li>
<li>
<a href=https://zhenfeng-zhu.github.io/search/ title=🔍>
<span>🔍</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-entry>
<header class=entry-header>
<h2>一致性哈希算法
</h2>
</header>
<section class=entry-content>
<p>当我们在做数据库分库分表或者做分布式缓存的时候，不可避免的都会遇到一个问题：
如何将数据均匀的分散到各个节点中，并且尽量的在加减节点的时能使受影响的数据最少。
1 hash 取模 随机放置就不多说了。通常最容易想到的方案是哈希取模了。
可以将传入的 key 按照 $$ index=hash(key) % N $$ 这样来计算出需要存放的节点。
这样可以满足数据的均匀分配，但是这个算法的容错性和扩展性比较差。比如增加或者删除一个节点的时候，所有的 key 都要重新计算，显然这样的成本比较高，为此需要一个算法来满足均匀的同时也要有良好的容错性和扩展性。
2 一致性 hash 算法 一致性 hash 算法是将所有的哈希值构成了一个环，其范围是 0~2^32-1。如图：
之后将各个服务器节点散列到这个环上，可以用节点的 IP，hostname 这样唯一性的字段作为 key 进行 hash。散列之后如下：
之后需要将数据定位到对应的节点上，使用同样的 hash 函数将 key 也映射到这个环上。
这样就按照顺时针方向就可以将 k1 定位到 N1 节点，k2 定位到 N3 节点，k3 定位到 N2 节点。
2.1 容错性 假设 N1 宕机了：
依然根据顺时针方向，k2 和 k3 保持不变，只有 k1 被重新映射到了 N3。这样就很好的保证了容错性，当一个节点宕机时只会影响到少部分数据。
2.2 扩展性 当新增一个节点时：
在 N2 和 N3 之间新增了一个节点 N4，这时受影响的数据只有 k3，其余的数据也是保持不变。...</p>
</section>
<footer class=entry-footer><span title="2018-03-24 19:03:58 +0000 UTC">March 24, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to 一致性哈希算法" href=https://zhenfeng-zhu.github.io/posts/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Spring Boot 启动原理分析
</h2>
</header>
<section class=entry-content>
<p>Spring Boot 启动原理分析 我们在开发 spring boot 应用的时候，一般会遇到如下的启动类：
@SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 从这段代码可以看出，注解@SpringBootApplication 和 SpringApplication.run()是比较重要的两个东西。
1 @SpringApplication 注解 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { ... } 在这段代码里，比较重要的只有三个注解：
@Configuration（@SpringBootConfiguration 点开查看发现里面还是应用了@Configuration） @EnableAutoConfiguration @ComponentScan 其实，我们使用这三个注解来修饰 springboot 的启动类也可以正常运行,如下所示：
@ComponentScan @EnableAutoConfiguration @Configuration public class DemoApplication { public static void main(String[] args) { SpringApplication....</p>
</section>
<footer class=entry-footer><span title="2018-03-24 19:03:22 +0000 UTC">March 24, 2018</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to Spring Boot 启动原理分析" href=https://zhenfeng-zhu.github.io/posts/spring-boot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Spring Data Jpa 实战
</h2>
</header>
<section class=entry-content>
<p>为了解决抽象各个 Java 实体基本的“增删改查”操作，我们通常会以泛型的方式封装一个模板 Dao 来进行抽象简化，但是这样依然不是很方便，我们需要针对每个实体编写一个继承自泛型模板 Dao 的接口，再编写该接口的实现。虽然一些基础的数据访问已经可以得到很好的复用，但是在代码结构上针对每个实体都会有一堆 Dao 的接口和实现。
由于模板 Dao 的实现，使得这些具体实体的 Dao 层已经变的非常“薄”，有一些具体实体的 Dao 实现可能完全就是对模板 Dao 的简单代理，并且往往这样的实现类可能会出现在很多实体上。Spring-data-jpa 的出现正可以让这样一个已经很“薄”的数据访问层变成只是一层接口的编写方式。
1 工程配置 1.1 pom &lt;?xml version="1.0" encoding="UTF-8"?> &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>com.example&lt;/groupId> &lt;artifactId>jpa-demo&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;packaging>jar&lt;/packaging> &lt;name>jpa-demo&lt;/name> &lt;description>Demo project for Spring Boot&lt;/description> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>1.5.9.RELEASE&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;project.reporting.outputEncoding>UTF-8&lt;/project.reporting.outputEncoding> &lt;java.version>1.8&lt;/java.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-jpa&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;scope>runtime&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>org....</p>
</section>
<footer class=entry-footer><span title="2018-03-24 19:02:48 +0000 UTC">March 24, 2018</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to Spring Data Jpa 实战" href=https://zhenfeng-zhu.github.io/posts/spring-data-jpa%E5%AE%9E%E6%88%98/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>spring boot 多数据源配置
</h2>
</header>
<section class=entry-content>
<p>spring boot 多数据源配置 在单数据源的情况下，Spring Boot 的配置非常简单，只需要在 application.properties 文件中配置连接参数即可。但是往往随着业务量发展，我们通常会进行数据库拆分或是引入其他数据库，从而我们需要配置多个数据源。
1 准备 1.1 禁止 DataSourceAutoConfiguration 首先要将 spring boot 自带的DataSourceAutoConfiguration禁掉，因为它会读取application.properties文件的spring.datasource.*属性并自动配置单数据源。在@SpringBootApplication注解中添加exclude属性即可：
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class}) public class DemoApplication { public static void main(String[] args) { SpringApplication.run(JpaDemoApplication.class, args); } } 1.2 配置数据库连接 然后在application.properties中配置多数据源连接信息：
spring.datasource.primary.url=jdbc:mysql://localhost:3306/test spring.datasource.primary.username=root spring.datasource.primary.password=root spring.datasource.primary.driver-class-name=com.mysql.jdbc.Driver spring.datasource.secondary.url=jdbc:mysql://localhost:3306/test1 spring.datasource.secondary.username=root spring.datasource.secondary.password=root spring.datasource.secondary.driver-class-name=com.mysql.jdbc.Driver 1.3 手段创建数据源 由于我们禁掉了自动数据源配置，因些下一步就需要手动将这些数据源创建出来：
@Configuration public class DataSourceConfig { @Bean(name = "primaryDataSource") // @Qualifier(value = "primaryDataSource") @ConfigurationProperties(prefix = "spring.datasource.primary") public DataSource primaryDataSource(){ return DataSourceBuilder.create().build(); } @Bean(name = "secondaryDataSource") // @Qualifier(value = "secondaryDataSource") @ConfigurationProperties(prefix = "spring....</p>
</section>
<footer class=entry-footer><span title="2018-03-24 19:01:37 +0000 UTC">March 24, 2018</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to spring boot 多数据源配置" href=https://zhenfeng-zhu.github.io/posts/spring-boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>spring boot 连接 redis
</h2>
</header>
<section class=entry-content>
<p>Spring-data-redis为 spring-data 模块中对 redis 的支持部分，简称为“SDR”，提供了基于 jedis 客户端 API 的高度封装以及与 spring 容器的整合，
jedis 客户端在编程实施方面存在如下不足：
connection 管理缺乏自动化，connection-pool 的设计缺少必要的容器支持。 数据操作需要关注“序列化”/“反序列化”，因为 jedis 的客户端 API 接受的数据类型为 string 和 byte，对结构化数据(json,xml,pojo 等)操作需要额外的支持。 事务操作纯粹为硬编码 pub/sub 功能，缺乏必要的设计模式支持，对于开发者而言需要关注的太多。 1 spring-data-redis 特性 连接池自动管理，提供了一个高度封装的“RedisTemplate”类 针对 jedis 客户端中大量 api 进行了归类封装,将同一类型操作封装为 operation 接口 ValueOperations：简单 K-V 操作 SetOperations：set 类型数据操作 ZSetOperations：zset 类型数据操作 HashOperations：针对 map 类型的数据操作 ListOperations：针对 list 类型的数据操作 提供了对 key 的“bound”(绑定)便捷化操作 API，可以通过 bound 封装指定的 key，然后进行一系列的操作而无须“显式”的再次指定 Key，即 BoundKeyOperations： BoundValueOperations BoundSetOperations BoundListOperations BoundSetOperations BoundHashOperations 将事务操作封装，有容器控制。 针对数据的“序列化/反序列化”，提供了多种可选择策略(RedisSerializer) JdkSerializationRedisSerializer：POJO 对象的存取场景，使用 JDK 本身序列化机制，将 pojo 类通过 ObjectInputStream/ObjectOutputStream 进行序列化操作，最终 redis-server 中将存储字节序列。是目前最常用的序列化策略。 StringRedisSerializer：Key 或者 value 为字符串的场景，根据指定的 charset 对数据的字节序列编码成 string，是“new String(bytes, charset)”和“string....</p>
</section>
<footer class=entry-footer><span title="2018-03-24 19:00:48 +0000 UTC">March 24, 2018</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to spring boot 连接 redis" href=https://zhenfeng-zhu.github.io/posts/spring-boot%E8%BF%9E%E6%8E%A5redis/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>最终一致性的实现手段
</h2>
</header>
<section class=entry-content>
<p>最终一致性的实现手段 实现最终一致性有三种手段：可靠事件模式、业务补偿模式和 TCC 模式
1 可靠事件模式 可靠事件模式属于事件驱动架构，当某件重要的事情发生时，比如更新一个业务实体，微服务会向消息代理发布一个事件。消息代理会将订阅事件的微服务推送事件。
要实现这种模式需要消息队列实现事件的持久化和 at least once 的可靠事件投递模式。
1.1 本地事件表 本地事件表方法是将事件和业务数据保存在同一个数据库中，使用一个额外的事件恢复服务来恢复事件，由本地事物保证更新业务和发布事件的原子性。
但是业务系统和事件系统耦合比较紧密，额外的事件数据库操作也会给数据库带来额外的压力，可能成为瓶颈。
1.2 外部事件 此方法是将事件持久化到外部的事件系统，事件系统需要提供实时事件服务以接受微服务发布的事件，同时事件系统还需要提供事件恢复服务来确认恢复事件。
1.3 不足 此过程可能出现重复消费的情况。
2 补偿模式 一般来讲，异常一般是由以下两种情况造成的：
业务异常：业务逻辑产生的错误，比如余额不足、库存不足等。
技术异常：非业务逻辑产生的异常，比如网络连接异常、超时等。
补偿模式就是使用一个额外的协调服务来协调各个需要保证一致性的其他服务。协调服务按顺序调用每一个服务，如果某个服务调用异常就取消之前所有已经调用成功的服务。
建议仅用于技术异常的情况。对于业务异常来讲，应该尽可能的去优化业务模式，以避免要求补偿事务。
2.1 常用手段 在实现补偿模式时应该做到两点：
首先要确定失败的步骤和状态，从而确定要补偿的范围。 其次要能提供补偿操作使用的业务数据。 可以通过记录完整的业务流水的方法来实现上面两点要求。但是对于一个通用的补偿框架来说，预先知道微服务需要记录的业务要素是不可能的，那么就需要一种办法来保证业务流水的可扩展性，实践中主要有两种方法：大表和关联表。
大表，顾明思议就是设计时除了必须的字段外，还需要预留大量的备用字段，框架可以提供辅助工具来将业务数据映射到备用字段中。大表对于框架层实现起来比较简单，但是也有一些难点，比如预留多少个字段合适，每个字段又需要预留多长。还有一个难点是如果仅从数据层面来查询数据，很难一眼看出备用字段的业务含义，维护过程不友好。 关联表，分为技术表和业务表。技术表中保存为实现补偿操作所需要的技术数据，业务表中保存业务数据。通过在技术表中增加业务表名和业务表主键来建立和业务数据的关联。关联表更灵活，能支持不同业务类型记录不同的业务要素。但是在框架的实现上难度较高，每次查询都需要复杂的关联动作，性能会受到影响。 2.2 重试 补偿过程作为一个服务，在调用的时候也会出现不成功的情况，这时就要通过重试机制来保证补偿的成功率。因此要求补偿操作具有幂等性。
但是也不是盲目的重试，我们需要根据服务执行失败的原因来选择不同的策略：
因业务因素导致失败，需要停止重试。 罕见的异常，如网络中断，传输过程中数据丢失，应该立即重试。 如果是因为系统繁忙，此时需要等待一段时间再重试。 2.3 不足 在补偿模式中有一个明显的缺陷是隔离性，从第一个服务开始一直到补偿完成，不一致性是对其他服务可见的。另外补偿模式过分依赖协调服务的健壮性，如果协调服务异常，则没办法达到一致性。
3 TCC 模式 TCC，是 Try，Confirm 和 Cancel 的缩写。一个完整的 TCC 业务一般是由一个主业务和若干个从业务组成。
Try 完成所有业务检查 预留必须的业务资源 Confirm 真正执行业务 不做任何业务检查 只使用 Try 阶段预留的业务资源 满足幂等性 Cancel 释放 Try 阶段预留的业务资源 满足幂等性 3....</p>
</section>
<footer class=entry-footer><span title="2018-03-24 18:59:55 +0000 UTC">March 24, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to 最终一致性的实现手段" href=https://zhenfeng-zhu.github.io/posts/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%AE%B5/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Reactive 微服务
</h2>
</header>
<section class=entry-content>
<p>Reactive 微服务 分布式系统构建起来很困难，因为它们容易出问题，运行缓慢，并且被 CAP 和 FLP 理论所限制。换句话说，它们的构建和运维都特别复杂。为了解决这个问题，reactive 便出现了。
Reactive 编程：一种开发模型，其专注于数据流向、对变化的反馈，以及传播他们。
在 reactive 编程中，刺激信号是数据的转移，叫做 streams。其实很像生产者——消费者模式，消费者对值进行订阅并响应。
Reactive 系统：一种架构风格，其基于异步消息来构建响应式的分布式系统。
reactive 系统使用了消息驱动的方法。所有的构建通过异步消息的发送和接收来交互。消息投递的逻辑由底层的实现决定。发送者不会阻塞着等待回复，它们可能会稍后才接收到回复。
reactive 系统会有两个重要的特征：
伸缩性——可以横向伸缩
伸缩性来自消息传递的解耦。消息被发送到一个地址之后，可以被一组消费者按照一种负载均衡方法消费。当 reactive 系统遇到负载高峰时，它可以创造出新的消费者，并在此之后销毁它们。
恢复性——可以处理错误并且恢复
首先，这种消息交互模式允许组件在其本地处理错误，组件不需要等待消息，因此当一个组件发生错误时，其他组件仍然会正常工作。其次，当一个处理消息的组件发生错误后，消息可以可以传递给在相同地址注册的其他组件。
reactive 微服务系统是由 reactive 微服务组成的。这些微服务有下面四个特征：
自治性 异步性 恢复性 伸缩性 Reactive 微服务是可自治的。他们可以根据周围的服务是否可用来调整自己的行为。自治性往往伴随着孤立性；Reactive 微服务可以在本地处理错误、独立地完成任务，并在必要时和其他服务合作。它们使用异步消息传递的机制和其他服务沟通；它们也会接收消息并且对其作出回应。
得益于异步消息机制，reactive 微服务可以处理错误并根据情况调整自己的行为。错误不会被扩散，而是在靠近错误源头的地方被处理掉。当一个微服务挂掉之后，它的消费者微服务要能够处理错误并避免扩散。这一孤立原则是避免错误逐层上浮而毁掉整个系统的关键。可恢复性不只是关于处理错误，它还涉及到自愈性；一个 reactive 微服务应该能够从错误中恢复并且对错误进行补救。
最后，reactive 微服务必须是可伸缩的，这样系统才可以根据负载情况来调整节点数量。这一特性意味着将会有一系列的限制，比如不能有在内存中的状态，要能够在必要时同步状态信息，或者要能够将消息路由到状态信息相同的节点。
Vert.x Vert.x 是一个用于构建 reactive 和分布式系统的工具箱，其使用了异步非阻塞编程模型。当使用 Vert.x 构建微服务的时候，微服务会自然地带上一个核心特征：所有事情都是异步的。
传统编程模式
int res = compute(1, 2); 在这段代码中，是在等待 compute 函数计算出来结果之后再进行剩下的操作。而在异步非阻塞的编程模式中，将会创建一个 handler：
compute(1, 2, res -> { // called with the result }); 在上述代码中，compute 函数不再返回一个结果，而是传一个 handler，当结果准备好时调用就可以了。得益于这种开发模型，可以使用很少的线程去处理高并发工作。在 vert....</p>
</section>
<footer class=entry-footer><span title="2018-03-24 17:57:58 +0000 UTC">March 24, 2018</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to Reactive 微服务" href=https://zhenfeng-zhu.github.io/posts/reactive%E5%BE%AE%E6%9C%8D%E5%8A%A1/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Guice 快速入门
</h2>
</header>
<section class=entry-content>
<p>Guice 快速入门 接手的新项目主要是使用 kotlin+vert.x 来写的，使用 gradle 构建，依赖注入框架使用了 guice。这段时间都是在熟悉代码的过程，恶补一些知识。
guice 是谷歌推出的一个轻量级的依赖注入框架，当然 spring 也可以实现依赖注入，只是 spring 太庞大了。
1 基本使用 引入依赖 使用 gradle 或者 maven，引入 guice。
maven:
&lt;dependency> &lt;groupId>com.google.inject&lt;/groupId> &lt;artifactId>guice&lt;/artifactId> &lt;version>4.1.0&lt;/version> &lt;/dependency> Gradle:
compile "com.google.inject:guice:4.1.0" 项目骨架 首先需要一个业务接口，包含一个方法来执行业务逻辑，它的实现非常简单：
package com.learning.guice; public interface UserService { void process(); } package com.learning.guice; public class UserServiceImpl implements UserService { @Override public void process() { System.out.println("我需要做一些业务逻辑"); } } 然后写一个日志的接口：
package com.learning.guice; public interface LogService { void log(String msg); } package com....</p>
</section>
<footer class=entry-footer><span title="2018-03-24 17:57:15 +0000 UTC">March 24, 2018</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to Guice 快速入门" href=https://zhenfeng-zhu.github.io/posts/guice%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>kotlin 快速入门
</h2>
</header>
<section class=entry-content>
<p>快速浏览一下 Kotlin 的语法。
基本语法 包定义和引用 在源文件头部：
package my.demo import java.util.* 方法定义 带有方法体，并且返回确定类型数据的定义方式，例如接受 Int 类型的参数并返回 Int 类型的值： fun sum(a: Int, b: Int): Int { return a + b } 带有方法体，返回推断类型数据的定义方式，例如： fun sum(a: Int, b: Int) = a + b 返回无意义类型的定义方式： fun printSum(a: Int, b: Int): Unit { println("sum of $aand $bis ${a + b}") } 或者省略 Unit：
fun printSum(a: Int, b: Int) { println("sum of $aand $bis ${a + b}") } 变量定义 只赋值一次（只读）本地变量，val： val a:Int = 1 // 指定初始值 val b = 2 // 类型自推断为 `Int` val c:Int // 当不指定初始值时需要指定类型 c = 3 // 延迟赋值 可变变量， var： var x = 5 // 类型自推断为 `Int` x += 1 顶层变量 val PI = 3....</p>
</section>
<footer class=entry-footer><span title="2018-03-24 17:56:45 +0000 UTC">March 24, 2018</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to kotlin 快速入门" href=https://zhenfeng-zhu.github.io/posts/kotlin%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>RxJava2 快速入门
</h2>
</header>
<section class=entry-content>
<p>RxJava2 快速入门 引入依赖 compile 'io.reactivex.rxjava2:rxjava:2.0.1' 写法 简单版本 private static void helloSimple() { Consumer&lt;String> consumer = new Consumer&lt;String>() { @Override public void accept(String s) throws Exception { System.out.println("consumer accept is " + s); } }; Observable.just("hello world").subscribe(consumer); } 复杂版本 private static void helloComplex() { Observer&lt;String> observer = new Observer&lt;String>() { @Override public void onSubscribe(Disposable d) { System.out.println("onSubscribe: " + d); } @Override public void onNext(String s) { System.out.println("onNext: " + s); } @Override public void onError(Throwable e) { System....</p>
</section>
<footer class=entry-footer><span title="2018-03-24 17:55:56 +0000 UTC">March 24, 2018</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Fenix</footer>
<a class=entry-link aria-label="post link to RxJava2 快速入门" href=https://zhenfeng-zhu.github.io/posts/rxjava2%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/></a>
</article>
<footer class=page-footer>
<nav class=pagination>
<a class=prev href=https://zhenfeng-zhu.github.io/page/8/>« Prev Page</a>
<a class=next href=https://zhenfeng-zhu.github.io/page/10/>Next Page »</a>
</nav>
</footer>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://zhenfeng-zhu.github.io>Awesome Fenix</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>